% Minimal Descriptive Programming System Design
%
% File:         min-design.tex
% Author:       Bob Walton (walton@seas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}
\usepackage{upquote}
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newsavebox{\BRABOX}
\begin{lrbox}{\BRABOX}
\verb|{|
\end{lrbox}
\newcommand{\BRA}{\usebox{\BRABOX}}

\newsavebox{\KETBOX}
\begin{lrbox}{\KETBOX}
\verb|}|
\end{lrbox}
\newcommand{\KET}{\usebox{\KETBOX}}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttnbmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttarmkey}[2]{{\tt ->\bf #1}%
                          \index{#1@{\tt #1}!#2}}
\newcommand{\ttdkey}[1]{{\tt .\bf #1}\index{#1@{\tt #1}}}
\newcommand{\ttdmkey}[2]{{\tt .\bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttbkey}[1]{{\tt [{\bf #1}]}\index{#1@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{{\tt [{\bf #1}]}\index{#1@{\tt [#1]}!#2}}
\newcommand{\ttomkey}[3]{{\tt \bf operator #2}%
                         \index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\minkey}[1]%
           {{\tt \bf min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minnbkey}[1]%
           {{\tt min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmkey}[2]%
           {{\tt \bf min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{{\tt \bf {\tt MUP}::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {{\tt \bf MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttindex{min::#1!#2}\ttindex{#1!#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

% < and > do NOT print right in {\tt \bf <>}, i.e.,
% they have no correct BOLDFACE TT font entries.
% So we use the following to force non-boldface in
% keys.
%
\newcommand{\LT}{{\tt <}}
\newcommand{\GT}{{\tt >}}
\newcommand{\BRACKETED}[1]{{\tt <#1>}}
\newcommand{\NARG}{\BRACKETED{}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{argstack}%
	{\begin{tabular}[t]{@{}l@{}}}
	{\end{tabular}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newcommand{\ARGBREAK}{\\&{\tt ~~~~}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[2]{\ttomkey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTNBKEY}[1]{\ttnbkey{#1}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MINKEY}[1]{{\tt \bf #1}\minindex{#1}}
\newcommand{\MINIKEY}[2]{{\tt \bf #1}\minindex{#2}}
\newcommand{\MINNBKEY}[1]{{\tt #1}\minindex{#1}}
\newcommand{\MUPKEY}[1]{{\tt \bf #1}\MUPindex{#1}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}

\begin{document}
        
\title{Internal Design\\[2ex]of the\\[2ex]
       Minimal\\Descriptive Programming\\System\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton}

\date{April 2, 2011}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the internal design of MIN,
the Minimal Descriptive Programming System.
This document is written for readers who wish to add C++ code
to a MIN implementation, or who wish to maintain an implementation.

A programming system provides run time and compile time support
for programming languages.
A programming system, such as MIN, is
built on top of an underlying programming system provided by the
implementation language, in this case C++.
MIN consists of a data store, of the single-thread execution system
inherited from C++, and of MIN compatible threads.
Other programming language specific
programming systems can be built on top of MIN.

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{center}
\begin{tabular}{ll}
\ttmkey{acc}{abbreviation}	& allocator/collector/compactor
			          (\itemref{ACC-INTERFACE},\itemref{ACC}) \\
\ttmkey{aux}{abbreviation}	& auxiliary (\itemref{AUXILIARY}) \\
\ttmkey{attr}{abbreviation}	& attribute (\itemref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{DISP}{abbreviation}	& displacement (\pagref{MIN::DISP}) \\
\ttmkey{gen}{abbreviation}	& general value (\itemref{GENERAL-VALUES}) \\
\ttmkey{insptr}{abbreviation}	& insertable pointer
				  (read-write, push, pop pointer) \\
\ttmkey{int}{abbreviation}	& signed integer (\pagref{INT}) \\
\ttmkey{lab}{abbreviation}	& label (\itemref{LABELS}) \\
\ttmkey{min}{abbreviation}	& the `{\tt min}' namespace (\pagref{min::}) \\
\ttmkey{MACC}{abbreviation}	& {\tt min::acc} (\pagref{MACC}) \\
\ttmkey{MIN}{abbreviation}	& the {\tt MIN\_} macro preface
				  (\pagref{MIN_}) \\
\ttmkey{MINT}{abbreviation}	& {\tt min::internal} (\pagref{MINT}) \\
\ttmkey{MOS}{abbreviation}	& {\tt min::os} (\pagref{MOS}) \\
\ttmkey{MUP}{abbreviation}	& {\tt min::unprotected} (\pagref{MUP}) \\
\ttmkey{num}{abbreviation}	& number (\pagref{NUMBERS}) \\
\ttmkey{obj}{abbreviation}	& object (\pagref{OBJECTS}) \\
\ttmkey{ptr}{abbreviation}	& pointer (often read-only, see updptr and
                                  insptr) \\
\ttmkey{ref}{abbreviation}	& reference 
    (\pagref{PROTECTED-BODY-REFERENCES-AND-POINTERS}) \\
\ttmkey{str}{abbreviation}	& string (\pagref{STRINGS}) \\
\ttmkey{uns}{abbreviation}	& unsigned integer (\pagref{UNS}) \\
\ttmkey{updptr}{abbreviation}	& updatable pointer
                                  (i.e., read-write pointer) \\
\ttmkey{var}{abbreviation}	& variable (\itemref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{vec}{abbreviation}	& vector (\itemref{OBJECT-VECTOR-LEVEL}) \\
\end{tabular}
\end{center}

\section{Interfaces}
\label{INTERFACES}

The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}
\verb|#include  <min.h>|
\end{center}

External MIN data and functions are placed in the
\ttnbmkey{min}{namespace}\label{min::} namespace.
There are some macros that can be defined to control compilation, and
these have names beginning with \ttnbkey{MIN\_}\label{MIN_}.

MIN has two interfaces:
the \key{protected interface}, which can be used
by C++ code to access MIN while maintaining the integrity
of MIN data, and the \key{unprotected interface}, which provides
more efficient access to MIN data but requires the user to
follow certain protocols to be sure that data are not damaged.

From the syntactic point of view the
only distinction between these interfaces is that the unprotected
interface is in the with \minkey{unprotected} namespace, whereas
the protected interface is in the \ttkey{min} namespace.  User code
that accesses the unprotected interface typically abbreviates the long
`{\tt min::unprotected::}' prefix to
`\ttnbmkey{MUP}{abbreviates {\tt min::unprotected}}{\tt ::}'\label{MUP}
by including the following definition:
\begin{center}
\verb|#define  MUP  min::unprotected|
\end{center}

In this document we will use the abbreviation `\verb|MUP|' for
`\verb|min::unprotected|'.
Note that namespace definitions such as the above are \underline{not}
included in \verb|min.h| or other MIN \verb|.h| files; they must
be included explicitly in \verb|.cc| files.

Most {\tt MUP} functions `produce \key{undefined results}' when their arguments
are out of legal range.
This means that when the arguments are out of range,
function execution may lose control and crash, or may produce result
values that are wrong or out of legal range.
When documentation of a {\tt MUP} function
states that particular argument range checks are not performed,
then the {\tt MUP} function always produces undefined results when its
arguments would not pass these checks,
unless the documentation explicitly says otherwise.

Most, but not all, of the protection provided by the protected interface
is obtained by the functions of that interface using the
{\tt MIN\_ASSERT} macro:

\begin{indpar}
\begin{tabular}{lp{4.0in}}
\TTNBKEY{MIN\_ASSERT}{\tt (}$e${\tt )}
	& By default defined as `{\tt assert(}$e${\tt )}' if
	  {\tt MIN\_PROTECT} is defined to be {\tt 1} (its default),
	  and defined to be a no operation otherwise.  Alternatively
	  may be defined by the compilation before
	  \verb|#include <min.h>|.
\LABEL{MIN_ASSERT}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{lp{4.0in}}
\TTNBKEY{MIN\_PROTECT}	& 1 (the default)
                          if {\tt MIN\_ASSERT} is to be mapped to
			  the C++ \ttkey{assert} macro if {\tt MIN\_ASSERT}
			  not otherwise defined; 0 to map {\tt MIN\_ASSERT}
			  to a no operation if it is not otherwise defined.
\LABEL{MIN_PROTECT} \\
\end{tabular}
\end{indpar}

By setting {\tt MIN\_PROTECT} to {\tt 0}, a compilation can optimize
debugged code, although this will remove the protection
provided by the protected interface.  Alternatively,
a compilation can provide its own definition for the
{\tt MIN\_ASSERT} macro,
such as a definition printing extra information
in case of an assertion failure.

The above macros ({\tt MIN\_ASSERT}, {\tt MIN\_PROTECT})
can be defined independently for each separately compiled
part of a program, but most \verb|MIN_| macros must be defined identically
for all separately compiled parts of a single program.

The following are the most commonly used compiler options that
redefine {\tt MIN\_} macros:

\begin{indpar}
\begin{tabular}{lll}
Macro Name		& Meaning	& Page Reference \\[1ex]
\verb|-DMIN_PROTECT=0|	& delete assert checks
					& \pagref{MIN_PROTECT} \\
\verb|-DMIN_IS_COMPACT=1|
			& make implementation compact
					& \pagref{MIN_IS_COMPACT} \\
\end{tabular}
\end{indpar}

The other compilation parameters involve technical details of
memory management.  For specifics see the file
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

Protected functions are in the \ttmkey{min}{namespace} namespace
and have names beginning with
`\ttmkey{min::}{in function name}', while
unprotected MIN functions are in the \ttmkey{min::unprotected}{namespace}
namespace and have names beginning with
`\ttnbmkey{min::unprotected::}{in function name}'.
The {\tt min} and {\tt min::unprotected} namespaces hold \underline{all}
the stable interfaces of the MIN implementation.

Code in \verb|min.h| that is not meant to be accessed
by users is in the following namespaces:

\begin{indpar}
\begin{tabular}{llp{4.0in}}
	    & Abbre- \\
Namespace   & viation   & Use
\\[1ex]
\tt min::os & \tt MOS	& Operating system independent interface to
			  operating system functions
			  not covered by C++ standards.
			  See Appendix \itemref{MOS}.
\\[1ex]
\tt min::acc & \tt MACC & The part of the interface to the
			  Allocator/\EOL Collector/\EOL Compactor
			  that can be
			  changed when the acc is changed.
			  See Appendix \itemref{ACC}.
\\[1ex]
\tt min::internal & \ttnbkey{MINT}\label{MINT}
		        & Interface to internal MIN code that can
			  be changed without notice at any time.
			  Not described in this document; see
			  {\tt .h} files.
\end{tabular}
\end{indpar}

\section{Data}

In defining MIN data the following number types are used to be sure
the size of each number is clear:
\begin{center}
\begin{tabular}{l@{~~~~~}p{4.5in}}
\minkey{uns8}	& unsigned 8-bit integer \\
\minkey{int8}	& signed 8-bit integer \\
\minkey{uns16}	& unsigned 16-bit integer \\
\minkey{int16}	& signed 16-bit integer \\
\minkey{uns32}	& unsigned 32-bit integer \\
\minkey{int32}	& signed 32-bit integer \\
\minkey{float32}	& 32-bit IEEE floating point number \\
\minkey{uns64}	& unsigned 64-bit integer \\
\minkey{int64}	& signed 64-bit integer \\
\minkey{float64}	& 64-bit IEEE floating point number \\
\minkey{unsptr}	& unsigned integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{intptr}	& signed integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{unsgen}	& unsigned integer of same length as a general value
                  (32 or 64 bits, see \itemref{GENERAL-VALUES})
                  \\
\end{tabular}
\end{center}%
\LABEL{MIN::UNS8}%
\LABEL{MIN::INT8}%
\LABEL{MIN::UNS16}%
\LABEL{MIN::INT16}%
\LABEL{MIN::UNS32}%
\LABEL{MIN::INT32}%
\LABEL{MIN::FLOAT32}%
\LABEL{MIN::UNS64}%
\LABEL{MIN::INT64}%
\LABEL{MIN::FLOAT64}%
\LABEL{MIN::UNSPTR}%
\LABEL{MIN::INTPTR}%
\LABEL{MIN::UNSGEN}%
\label{INT}%
\label{UNS}

Current implementations of MIN assume a compiler that has
direct support for 64 bit integers.  It is possible, but not recommended,
to modify the implementations to use compilers without such support.

MIN depends upon certain undocumentated C++ conventions.

First, it is assumed that classes will not have hidden
padding that is not required to align member offsets.
It is assumed that the compiler will allocate class members
in order without any hidden padding if this will lead to
an allocation in which each member of a number type above or
of any pointer type has an offset in class instances
that is a multiple of the member length.

Second, it is assumed that the contents of a base class are
allocated is if the class contained an unnamed first member
whose type is the base class.

Care is taken to use these first two assumptions when defining
MIN data this may be input or output in binary form.
Some checks on these assumptions are programmed into MIN
initialization routines using C++ `assert' statements.

Third, it is assumed that a class containing just one element
that is a number or pointer is just as efficient in optimized
code as a number or pointer not in a class.  In particular,
such a one-element class used as an argument or return value
should be passed in a register.

All these assumptions seem to be satisfied by the GNU C++
compiler.

\subsection{Stubs and Bodies}

MIN data memory consists of regions that contain stubs and regions
that contain bodies.  A region is a contiguous block
of memory, typically consisting of an integral number of hardware
pages.

\ikey{Stubs}{stub}
are small fixed size units of memory that cannot be relocated:
the usual stub size for MIN is 16 bytes.
Each object has a stub, and the address of the stub is in effect
the internal name of the object.  Some atoms (e.g., numbers, strings)
have stubs, and some (e.g., integers that are not large, and very short
strings) do not.

A stub is divided into an 8 byte \key{stub value}
and an 8 byte \key{stub control}.
The stub value can be a 64-bit IEEE floating point number,
an 8 {\tt char} string, or, as we will soon see, a pointer to a body.
It is also possible for a stub value to hold any other 8 bytes of information.

The stub control holds a 1 byte \key{type code} and other information used,
for example, by the allocator/collector/compactor (acc).

The type name of a stub is `\minkey{stub}', and a pointer to a stub
has type `\verb|min::stub *|'.\LABEL{MIN::STUB}
Protected functions can return `\verb|const min::stub *|' values,
but only unprotected functions can return `\verb|min::stub *|' values.

A \key{body} is a variable sized
\ttmkey{relocatable}{body}\label{RELOCATABLE-BODY}
block of memory
attached to a particular stub.  A stub may have a body attached to
it, in which case the stub value is a pointer to that body.
When certain functions are called,
any body can be moved and its corresponding stub value reset to
point at the new location of the body.
Functions with this property are called
`\key{relocating functions}'\label{RELOCATING-FUNCTIONS}
and are marked by {\REL} in documentation.  Included
are functions that allocate objects.
Obtaining a C++ pointer into a body is an unprotected operation, because
the pointer must be maintained if a relocating function is called.

\ikey{Interrupts}{interrupt!and relocation} can relocate bodies.
Therefore interrupts are only allowed
at specific points in the code.  The inline function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{interrupt\REL}\verb| ( void )|
\LABEL{MIN::INTERRUPT} \\
\end{tabular}\end{indpar}%
\index{interrupt!relocating}

checks an interrupt
flag, and if that is set, calls an out-of-line function to process
the interrupt.  The function returns {\tt true} if and only if
there was actually an interrupt (this should be used only
for optimization).

A body may be \mkey{deallocated}{by moving}
by moving it to unimplemented memory.  When this is done the
stub \mkey{type code}{reset on deallocation}
is reset to the value \minnbkey{DEALLOCATED}\LABEL{MIN::DEALLOCATED},
which indicates the body is deallocated.
The function that deallocates a body is:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{deallocate\REL}\verb| ( const min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\end{tabular}\end{indpar}%
\index{deallocate!relocating}

Deallocation is considered to be a variant of relocation.
Relocating functions, those marked marked by {\REL} in documentation,
may also deallocate objects.

The {\tt min::is\_deallocated} function described on
\pagref{MIN::IS_DEALLOCATED}
can be used to test whether the body of a stub has been deallocated.

Bodies are always some multiple
of 8 bytes long, and are allocated on 8 byte boundaries.

\ikey{Protected functions}{protected function!using {\tt MIN\_ASSERT}}
that take a stub pointer as argument use
\ttnbmkey{MIN\_ASSERT}{in protected function} macros
(\pagref{MIN_ASSERT}) to check
the \mkey{type code}{checked by {\tt MIN\_ASSERT}}
of the stub and various lengths.  Unprotected functions
contain no such checks.

Memory consisting of unrelocatable stubs pointing at relocatable
bodies is called a `\key{stub/\EOL body memory}'.
Thus MIN has a stub/body memory.
The main advantages of stub/body memory are that relocation of bodies
can happen independently of other program activity, and bodies can be
deallocated by program command at any time.\footnote{
Stub/body memories are certainly not new.  For example, Kyoto COMMONLISP
used a stub/body implementation of arrays, and the author has heard about
implementations that go back to the late 1950's or early 60's: see
p33 of the author's thesis, R-CODE, A Very Capable Virtual Computer.}


\subsection{General Values}
\label{GENERAL-VALUES}

A general value can store any of:

\begin{center}
\begin{tabular}{l}
a direct atom value \\
a pointer to a stub \\
an auxiliary pointer \\
an index \\
a control code \\
a special value
\end{tabular}
\end{center}

General values are used as attribute names and values in
objects and as function arguments and return values.

General values that represent numbers or character strings
are called \skey{atom}s, because they have no subcomponents.
There are two kinds of atoms: \skey{direct atom}s that
are stored completely in a general value, and
\skey{indirect atom}s that are stored in a stub or in
a body pointed at by a stub, with the stub being pointed
at by a general value.

Efficiency aside, it does not matter
whether a general value stores a direct atom value or a pointer
to a stub holding an indirect atom value,
as atom values are immutable and cannot be changed.  Of course not all
atom values will fit into a general value, and those that do not must
be stored in stubs or in bodies pointed at by stubs.

An \key{auxiliary pointer} is an integer that is used by a general value
stored inside a body to point at some part, called an
\key{auxiliary},\label{AUXILIARY} of the same body.
There are several subtypes of auxiliary pointers storable in bodies.
See~\pagref{OBJECT-BODY-AUXILIARY-POINTER}.

An \key{index} is an integer that is used to give the index of a variable
that is an element of an object body.
See~\pagref{OBJECTS}.

A \key{control code} is an integer that represents flags and codes
stored in a general value.  Control codes can have different
interpretations in different contexts.
For example, see `Attribute Flags', \pagref{ATTRIBUTE-FLAGS}.

A \key{special value} is a unique value that has some
special meaning.  \verb|min::MISSING()|, for example, is a special
value that may be input or output to indicate that data is missing,
and \verb|min::NONE()| is a special value used only to
indicate that a function argument or result does not exist.
See \itemref{SPECIAL-VALUES}.

The \verb|min::|\MINKEY{gen}\LABEL{MIN::GEN}
type is defined as a C++ class that
consists of a single {\tt private} element of type
\verb|min::|\MINKEY{unsgen}, which is an unsigned integer.
From the point of view of C++ type checking, a {\tt min::\EOL gen}
value is a class, but from the computational point of view it is
an unsigned integer.

Because \verb|min::gen| is a class type, it is not possible to
present {\tt min::\EOL gen} constants to the compiler for use in
optimized code in a completely straightforward way.  To get the
desired effect, {\tt min::\EOL gen} constants are represented by
{\tt inline} functions, which allows the optimizing computer 
to insert the constants directly into instructions.  Thus
we have the constant {\tt min::\EOL MISSING()}, a function call
with no arguments, \underline{instead of} {\tt min::\EOL MISSING}, a datum.

There are two kinds of MIN implementation: `\key{compact}' and
`\key{loose}'.\label{COMPACT}\label{LOOSE}\label{COMPACT-OR-LOOSE}
A compact implementation uses 32-bit general values, while
a loose implementation uses 64-bit general values.
An implementation cannot use both 32-bit and 64-bit general values;
the implementation must use one or the other.

The 64-bit loose implementation formats a {\tt min::\EOL gen}
value as an IEEE floating point number, using the NaN (Not-a-Number)
values to encode non-numeric {\tt min::\EOL gen} values, such as
pointers to stubs.  Thus
in the loose implementation {\tt min::\EOL float64} values are
stored verbatim in {\tt min::\EOL gen} values.

Some functions and constants are defined only for compact implementations,
and some only for loose implementations.  Those defined only for
compact implementations are marked
with the superscript {\COMPACT}\index{C@{\COMPACT}}
in this document.
Those defined only for
loose implementations are similarly marked
with the superscript {\LOOSE}\index{L@{\LOOSE}}.

The value of a compact implementation is that it uses less memory%
\footnote{However, double precision floating point numbers only
use less memory if each is replicated several times.},
but there may be a speed penalty.
The value of a loose implementation is that it may run faster, but
there is a memory penalty.  It is not clear what the speed difference
between the two implementations really is, so both implementations
are offered in order to decide the issue by experiment.

Also compact implementations do not permit more than
about $2^{32}$ objects to exist in memory at one time, whereas
loose implementations permit up to about $2^{44}$ objects.

\subsubsection{General Value Subtypes}
\label{GENERAL-VALUE-SUBTYPES}

A \key{general value} has type \minkey{gen} and
is a 32 or 64 bit aligned value that can be of one of the following
subtypes;

\begin{indpar}[3em]
a pointer to a stub \\
a 64-bit IEEE floating point direct number atom\LOOSE \\
a 28-bit direct integer atom\COMPACT \\
a 0-5 {\tt char} direct string atom\LOOSE \\
a 0-3 {\tt char} direct string atom\COMPACT \\
a VSIZE-bit index \\
a VSIZE-bit control code \\
a VSIZE-bit special value \\
a VSIZE-bit list auxiliary pointer \\
a VSIZE-bit sublist auxiliary pointer \\
a VSIZE-bit indirect auxiliary pointer
\end{indpar}
\hspace*{1in}\begin{minipage}{4.5in}
where \key{VSIZE} equals 24 for a compact implementation
and 40 for a loose implementation
\end{minipage}

Here {\COMPACT} subtypes are only implemented by compact
implementations, and {\LOOSE} subtypes are only implemented by
loose implementations (\pagref{COMPACT-OR-LOOSE}).

Numbers and character strings stored inside a \verb|min::gen| value are
called `\skey{direct atom}s\,'.  Numbers and character strings
stored in stubs or bodies which are pointed at by a
\verb|min::gen| value are called `\skey{indirect atom}s'.  An atom is
always stored in only one way by an implementation.  If a number will fit
into a direct atom, it is stored as a direct atom, and never as an
indirect atom.  Similarly if a character string will fit into a direct atom,
it is stored as a direct atom, and never as an indirect atom.

Analogously indirect atoms are stored in only one place in memory, so
two indirect numbers are equal if and only the \verb|min::gen| values
pointing at them point at the same place, and similarly
two indirect character strings are equal if and only
the \verb|min::gen| values pointing at them point at the same place.

Therefore two atoms are equal if and only if the \verb|min::gen| values
designating them are \verb|==| as 32-bit or 64-bit values.

General values that point at stubs hold stub addresses in a
packed format.  44 bits are available to store a stub address in a
64-bit general value, and 32 bits are available to store a stub address
in a 32-bit general value, but in the latter case the packed address must be
less than $2^{32}-2^{29}$ (the $2^{29}$ other 32 bit values are used to store
direct integers, direct strings,
auxiliary pointers, indices, control codes, and special
values).  There are three
\skey{stub address packing scheme}s,\label{STUB-ADDRESS-PACKING} and the fastest
is selected for each type of general value.  The scheme selection is
controlled by the following `\skey{stub address packing parameter}\,'
macros:

\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTNBKEY{MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum absolute address of any stub as an unsigned integer
	  constant.  See \pagref{MIN_MAX_ABSOLUTE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTNBKEY{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum address of any stub relative to a constant
	  stub base address, as an unsigned integer
	  constant.  See \pagref{MIN_MAX_RELATIVE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}

The fastest scheme is the \key{absolute stub address} scheme,
where the absolute stub
address is stored.  For 64 bit general values this is
just a matter of inserting the stub address into the low order 44 bits
of the value.  For 32 bit general values this is just a matter of
using the stub address as the general value.
This scheme can be used if
{\tt MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The second fastest scheme is the \key{relative stub address}
\label{RELATIVE-STUB-ADDRESS} scheme, where the
stub address relative to a constant \key{stub base}
address is stored.
The relation between the absolute and relative stub addresses is:

\begin{center}
stub absolute address = stub base + stub relative address
\end{center}

where `stub base' is a constant determined when the program is
initialized.
This scheme can be used if
{\tt MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The slowest scheme is the \key{stub index} scheme, where the
relative stub address divided by the stub length is stored.
The stub length is chosen to be a power of 2 so that this
scheme will be efficient.  Again, this scheme can be used
if the relative address of the stub is not too large, but since
the stub length is 16, the relative address can be 16 times larger
for the stub index packing scheme than it is for the stub relative address
packing scheme.
Thus the index scheme can be used if
{\tt MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS/16}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

Note that on machines that have 32 bit addresses (e.g.,
the IA32\footnote{Intel Architecture 32-bit, a.k.a, i386 machines.}
machines), there is little to gain by either the relative stub address
or stub index packing schemes,
so only the absolute stub address scheme should be used on such machines.

A 32-bit general value direct integer consists of a high order 4-bit
subtype code and a low order 28-bit signed integer stored in offset form,
so the true integer can be derived from the {\tt min::gen} value by
subtracting the {\tt min::gen} representation of zero.
The range of such a direct integer is the same as the range of a 28-bit
two's complement integer: $-2^{27}$ to $2^{27}-1$, inclusive.

Other 32-bit general values consist of a high order
8-bit subtype code and a low order 24-bit datum.
For most auxiliary pointer
general values the datum is a 24-bit auxiliary pointer
(see~\pagref{OBJECT-BODY-AUXILIARY-POINTER}
for a definition of auxiliary pointers).
For index and special values the datum is a 24-bit index.
For control code general values the datum is 24-bits that
contains flags and codes that have different interpretations in different
contexts.  And for direct string general values the datum
holds 0 to 3 8-bit {\tt char}'s.

For 64-bit general values that point at stubs, the high order 20 bits
are used as a subtype code.  For other 64-bit general values, the high
order 24 bits are the subtype code and the low order 40 bits are the datum.
The values chosen for these subtype codes make stub pointers, direct strings,
auxiliary pointers, indices, and control codes -- that is, all non-number
{\tt min::gen} values --
into IEEE Nan (Not-a-Number)
values that are never generated by hardware instructions.

For most auxiliary pointer general values the 40-bit datum is used to hold
a 40-bit auxiliary pointer.
For index and special values the datum holds a 40-bit index.
For control code general values the datum is a 40-bit control code;
and for direct string general values the datum holds 0-5 {\tt char}'s.

The {\tt min::gen} type has the alignment
properties of either {\tt min::uns32} or {\tt min::uns64},
and \verb|min::|\EOL \MINKEY{unsgen} is {\tt typedef}'ed to the appropriate one
of these two types.

Many {\tt min::gen} values, which are 32 or 64 bits, are divided into a subtype,
either 8 or 24 bits, and a datum, either 24 or 40 bits.  In this context the
datum is called the `\mkey{value}{part of a {\tt min::gen} value}'.

The following definitions are provided in {\tt min.h} to facilitate coding:

\begin{indpar}
\begin{tabular}{r@{}l}
\verb|typedef |
	& \verb|min::uns32|
	  \verb|min::|\MINKEY{unsgen}\COMPACT
\LABEL{MIN::COMPACT_UNSGEN} \\
\verb|typedef |
	& \verb|min::uns64|
	  \verb|min::|\MINKEY{unsgen}\LOOSE
\LABEL{MIN::LOOSE_UNSGEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_gen}\verb| ( min::unsgen value )|
\LABEL{MUP::NEW_GEN} \\
\verb|min::unsgen MUP::| & \MUPKEY{value\_of}\verb| ( min::gen value )|
\LABEL{MUP::VALUE_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{gen}\verb| ( void )|
\LABEL{MIN::GEN_OF_VOID} \\
\verb|const unsigned min::| & \MINKEY{TSIZE}
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
\LABEL{MIN::VSIZE} \\
\end{tabular}
\end{indpar}

\verb|min::unsgen| is typedef'ed to
{\tt min::uns32}\COMPACT or {\tt min::uns64}\LOOSE.
{\tt MUP::\EOL new\_\EOL gen} and {\tt MUP::\EOL value\_of} are
unprotected converters between {\tt min::\EOL unsgen} and {\tt min::\EOL gen}
values.

{\tt min::\EOL gen (~void~)} is the default constructor that sets
an unassigned {\tt min::\EOL gen} value so it will more likely
trigger a fault if read by mistake.
Note that the existence of this constructor makes it impossible to
include {\tt min::\EOL gen} values in C++ {\tt union}'s, but
{\tt min::\EOL unsgen} values can be included instead and converted
using the unprotected converters.

\verb|TSIZE| is the subtype size in bits;
equal to {\tt 8}\COMPACT or {\tt 24}\LOOSE.
\verb|VSIZE| is the value size in bits;
equal to {\tt 24}\COMPACT or {\tt 40}\LOOSE.

\subsubsection{General Value Compilation}
\label{GENERAL-VALUE-COMPILATION}

The decisions on whether an implementation is
compact or loose (\pagref{COMPACT-OR-LOOSE})
must be made before C++ code is compiled.
Decisions must also be made determining the stub address packing
parameters (\pagref{STUB-ADDRESS-PACKING}).
The following macros, which must be defined identically
for all separately compiled parts of a single program, describe
these decisions.  These macros are in two groups, first the macros
that are set by the programmer, and then the macros which by default
are computed from the settings of the first group of macros.
All these macros are defined in
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

The macros set by the programmer are:

\begin{indpar}\begin{tabular}{p{2.0in}p{3.5in}}
\TTNBKEY{MIN\_IS\_COMPACT}	& 1 if compact implementation; 0 if loose;
				  defaults to 0.
\LABEL{MIN_IS_COMPACT}
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{2.0in}p{3.5in}}
\TTNBKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
				& Maximum number of garbage collector
				  ephemeral levels allowed in
				  \underline{any} execution of the
				  compiled binary; defaults to 2.
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\end{tabular}\end{indpar}

The macros which are normally set to default values computed from
the above macro settings are:
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTNBKEY{MIN\_IS\_LOOSE}	& 1 if loose implementation; 0 if compact;
				  Must equal `\verb|! MIN_IS_COMPACT|\,'.
\LABEL{MIN_IS_LOOSE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTNBKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
				& The maximum number of stubs that can
				  exist in \underline{any} execution
				  of the compiled binary.  Defaults: \\
& \hspace*{1em}\begin{tabular}{ll}
if \verb|MIN_IS_COMPACT| = 1:	& $2^{28} - 2^{25}$ \\
else pointers are 32 bits:	& $2^{28}$ \\
else:				& $2^{40-4e}$ \\
\end{tabular} \\
& where \\
& ~~$e = max(0,\mbox{\tt MIN\_MAX\_EPHEMERAL\_LEVELS}-2)$.
\LABEL{MIN_MAX_NUMBER_OF_STUBS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTNBKEY{MIN\_STUB\_BASE}
	& The value of the `stub base' for relative addressing
          (see \pagref{RELATIVE-STUB-ADDRESS}).  If defined
          this must be a non-negative integer constant.  Defaults to
	  \verb|0| if \verb|MIN_MAX_NUMBER_OF_STUBS| is set by
	  default, and otherwise is left undefined.
\LABEL{MIN_STUB_BASE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.5in}p{3.0in}@{}}
\TTNBKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}
	& The maximum address of any stub relative to the `stub base' (address
	  of the first stub), as an unsigned integer constant.  Default: \\
	& ~~\verb|16*MIN_MAX_NUMBER_OF_STUBS - 1|.
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.5in}p{3.0in}@{}}
\TTNBKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}
	& The maximum absolute address of any stub.  Defaults: \\
	& ~~~~ if \verb|MIN_STUB_BASE| defined: \\
	& ~~~~~~~~ \verb|  MIN_STUB_BASE| \\
	& ~~~~~~~~ \verb|+ MIN_MAX_RELATIVE_STUB_ADDRESS| \\
	& ~~~~ else if \begin{tabular}[t]{@{}l@{}}
	               \verb|MIN_IS_COMPACT| = 1 and \\
		       pointers are 32 bits:
		       \end{tabular} \\
	& ~~~~~~~~ $2^{32}-2^{29}-1$ \\
	& ~~~~ else if pointers are 32 bits: \\
	& ~~~~~~~~ $2^{32}-1$ \\
	& ~~~~ else: \\
	& ~~~~~~~~ $2^{48}-1$
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS}
\end{tabular}
\end{indpar}

\subsubsection{General Value Functions}
\label{GENERAL-VALUE-FUNCTIONS}

The following functions return {\tt true} if a {\tt min::gen} datum is of the
indicated subtype and {\tt false} otherwise:

\begin{indpar}
\verb|bool min::|\MINKEY{is\_stub}\verb| ( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::|\MINKEY{is\_direct\_float\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::|\MINKEY{is\_direct\_int\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::|\MINKEY{is\_direct\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::|\MINKEY{is\_index}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::|\MINKEY{is\_control\_code}\verb| ( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::|\MINKEY{is\_special}\verb| ( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::|\MINKEY{is\_list\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::|\MINKEY{is\_sublist\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::|\MINKEY{is\_indirect\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::|\MINKEY{is\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_AUX}
\end{indpar}

For a 32-bit general value {\tt is\_direct\_float\LOOSE} is unimplemented.
For a 64-bit general value {\tt is\_direct\_int\COMPACT} is unimplemented.
The {\tt min::\EOL is\_\EOL aux} function returns true if the general
value is any auxiliary pointer (i.e., list, sublist, etc.).

The following protected functions return the value appropriate for a given
subtype, after checking the subtype with a {\tt MIN\_ASSERT} statement:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * min::| & \MINKEY{stub\_of}\verb| ( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\
\end{tabular}\end{indpar}

Here the \verb|min::uns64| value returned by \minkey{direct\_str\_of}
should be overlaid by a union with a \verb|char[]| buffer, as in
the code:

\begin{indpar}\begin{verbatim}
union { min::uns64 str; char buf[6]; } u;
min::gen v;
. . . set v to a direct string value . . .
u.str = min::direct_str_of ( v );
cout << u.buf;
\end{verbatim}\end{indpar}

The {\tt min::direct\_str\_of} function merely copies the 3 or
5 {\tt char}'s of the {\tt min::gen} direct string value and
appends a NUL character.
It does this by writing an appropriate value into \verb|u.str|.

The \verb|min::|\ldots\verb|_aux_of|, the \verb|min::index_of| function,
the \verb|min::control_code_of| function,
and the {\tt min::\EOL spec\-ial\_\EOL index\_\EOL of} function all
return a 24-bit\COMPACT or 40-bit\LOOSE unsigned integer as a
{\tt min::unsgen} value.

The following unprotected functions return the value appropriate for a given
subtype, \underline{without} checking the subtype:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::| & \MUPKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{tabular}\end{indpar}

Note that \verb|MUP::stub_of| returns a `\verb|min::stub *|' pointer
whereas \verb|min::stub_of| returns a `\verb|const min::stub *|' pointer.

The {\tt MUP::\EOL aux\_\EOL of} function returns the auxiliary pointer
of any \verb|min::gen| value containing an auxiliary pointer (list,
sublist, or indirect).

New {\tt min::gen} values can be generated by the following protected
functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_stub\_gen}\verb| ( const min::stub * s )|
\LABEL{MIN::NEW_STUB_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE}\verb| ( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen\COMPACT}\verb| ( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_str\_gen}\verb| ( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen}\verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{tabular}\end{indpar}

These protected functions check for argument range errors.  Stubs are
\underline{not} allocated by these functions, so an {\tt int}
argument to {\tt min::new\_direct\_int\_gen\COMPACT} must fit in 28 bits,
and the {\tt const char *} strings must be short enough to
fit into a direct string.  For {\tt min::new\_\EOL direct\_\EOL str\_\EOL gen}
with a second argument \verb|n|, a string longer than \verb|n| characters
is shortened to \verb|n| characters (analogously to \verb|strncpy| and
\verb|strncmp|).
The {\tt min::unsgen} arguments used to make auxiliary pointers, indices,
control codes, and special values must fit within {\tt min::VSIZE} bits.

The subtype codes used for 64-bit {\tt min::gen} direct string, stub pointer,
auxiliary pointer, index, control code, and special values
-- that is, all the non-numeric \verb|min::gen| values --
are chosen to avoid being the same as the high order bits of any
IEEE floating point number normally generated by the compiler,
run-time system, or program execution.  A {\tt min::float64}
input to {\tt min::new\_direct\_\EOL float\_\EOL gen} is assumed not to have
these subtype
codes, and no check is made for such, even by range-checking protected
functions.

The following unprotected functions are analogous but do not check for
range errors.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen MUP::| & \MUPKEY{new\_stub\_gen}\verb| ( min::stub * s )|
\LABEL{MUP::NEW_STUB_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_float\_gen\LOOSE}%
    \verb| ( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_int\_gen\COMPACT}\verb| ( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen}\verb| ( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen}%
    \verb| ( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::| & \MUPKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN}
\end{tabular}\end{indpar}

The following unprotected functions can be used to replace the data
(non-subtype) part of a \verb|min::gen| value that is \underline{not}
a pointer to a stub or a number (direct float or direct integer).
The intended use is for changing the value of an auxiliary pointer
in a general value, or the flags in a condition code.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen}\verb| ( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\
\end{tabular}\end{indpar}

The actual direct atom, stub pointer, auxiliary pointer, index,
and control code
{\tt min::gen} subtype codes
are implementation dependent.  The following constants equal these
subtype codes:

\begin{indpar}
\verb|const unsigned min::|\MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_FLOAT\LOOSE}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_INT\COMPACT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::|\MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_PACKED\_AUX}
\LABEL{MIN::GEN_PACKED_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::|\MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::|\MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::|\MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL}
\end{indpar}

\verb|min::GEN_ILLEGAL| is actually illegal as a subtype code but may
be returned by the following function which be used to retrieve
the subtype code field:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{gen\_subtype\_of}\verb| ( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{tabular}\end{indpar}

For 64-bit \verb|min::gen| values, this retrieves the high order
24 bits of the value, and then zeros any low order bits that are not
part of the subtype code (that is, the 64-bits are right shifted by
40 bits and then bits of the result that are not part of the
subtype, such as bits in a number, are zeroed).
For 32-bit \verb|min::gen| values, this retrieves
the high order 8 bits, and then zeros any low order bits that are not
part of the subtype code (similarly the 32-bits are right shifted by
24 bits, etc.).
\verb|min::GEN_ILLEGAL| is returned by this function if the \verb|min::gen|
value is not a legal general value.

There are also unprotected functions to convert between
{\tt min::\EOL gen} and {\tt min::\EOL unsgen} values:
see \pagref{MUP::NEW_GEN}.

\subsection{Special Values}
\label{SPECIAL-VALUES}

Special general values are \verb|min::gen| values that are unique
and not equal to any value that can be generated during
program execution.  Special general values are C/C++ {\tt const}
values, and must only be used as specified by documentation.
They are used as return or argument values by some functions.

For reasons given below, special values are defined by {\tt inline}
functions of zero arguments.
The special values defined by MIN are:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::gen min::}\MINNBKEY{MISSING()}]~%
	\LABEL{MIN::MISSING}\\
Denotes a missing value or an empty set of values, and may be input
or output and used as an attribute value.
\item[{\tt const min::gen min::}\MINNBKEY{NONE()}]~%
	\LABEL{MIN::NONE}\\
Denotes a non-existent function value or result, and may not be
input or output or used as an attribute value or label.
\item[{\tt const min::gen min::}\MINNBKEY{ANY()}]~%
	\LABEL{MIN::ANY}\\
Denotes any value from a set of values.
\item[{\tt const min::gen min::}\MINNBKEY{MULTI\_VALUED()}]~%
	\LABEL{MIN::MULTI_VALUED}\\
Indicates a set of values has more than one element.
\item[{\tt const min::gen min::}\MINNBKEY{UNDEFINED()}]~%
	\LABEL{MIN::UNDEFINED}\\
A value given to an object variable vector element
(\itemref{TYPED-OBJECTS}) that has no value and can be indirected.
\item[{\tt const min::gen min::}\MINNBKEY{SUCCESS()}]~%
	\LABEL{MIN::SUCCESS}\\
A value returned to indicate a function has succeeded.
\item[{\tt const min::gen min::}\MINNBKEY{FAILURE()}]~%
	\LABEL{MIN::FAILURE}\\
A value returned to indicate a function has failed.
\end{list}
\end{indpar}

Special general values each have a unique \ikey{index}{of special value}
that identifies them relative to other special values.  These
indices are in the range $0$ through $2^{24}-1$.  The last 256 indices of this
range, $2^{24}-256$ through $2^{24}-1$ are reserved for use by the MIN
system.  Other special values can be created by other systems,
and indices near 0 are reserved for non-system users.

For efficiency reasons it is desirable for special values to be
compile time constants.  Because {\tt min::\EOL gen} is a class type,
C++ constants cannot be used to insert special values into optimized
instructions, and {\tt inline} functions are used instead.  The
standard definition of the special value {\tt SPECIAL\_I}
with index {\tt i} is:

\begin{indpar}\begin{verbatim}
inline min::gen SPECIAL_I ( void )
{
    return min::new_special_gen ( i );
}
\end{verbatim}\end{indpar}


\subsection{Stubs}
\label{STUBS}

General values may point at object stubs, which are 16 byte structures
that are \underline{not} relocated during execution.
Some stubs have pointers to object bodies, which can be
relocated during execution, either
because the object is being expanded or contracted, or because
memory is being compacted.

A stub contains an 8 byte stub value and an 8 byte stub control.
The type of a stub is \minkey{stub}.  Only pointers to stubs
are used, and these come in two flavors:
{\tt const min::stub~*} is used by protected functions and
{\tt min::stub~*} without the `{\tt const}' is used
by unprotected functions.

If the stub control is viewed as a 64 bit integer, its high order byte
is the type code.  The high order bit of this type code,
which is the high order
bit of the 64 bit stub control integer, is off if the stub is managed by
the allocator/collector/compactor (acc, of which the garbage collector is
a part).  In this case the stub is said to be `\key{collectible}'.
In the other case, where the bit is on, the stub is
said to be `\key{uncollectable}', and the stub is allocated and freed
by explicit calls to the acc, but is not garbage collected or compacted by the
acc.

If an stub has a body, its stub value is a pointer at that body.
Any pointer into a body is called a `body pointer'.

\subsubsection{Stub Type Codes}
\label{STUB-TYPE-CODES}

The \key{type code} of a stub may be returned by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{type\_of}\verb| ( const min::stub * s )|
\LABEL{MIN::TYPE_OF}
\end{tabular}\end{indpar}

A determination of whether or not a stub is collectible may be made
by applying the function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_collectible}\verb| ( int type )|
\LABEL{MIN::IS_COLLECTIBLE}
\end{tabular}\end{indpar}

to the type code of the stub.  Notice that type codes are \underline{signed}
integers, so that negative type codes are uncollectable and positive type codes
are collectible.

A partial list of stub type codes is:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const int min::NUMBER}]~\\
Stub value is an IEEE 64-bit floating point number.
\item[{\tt const int min::SHORT\_STR}]~\\
Stub value is 0-8 \verb|const char| string, NUL padded.
\item[{\tt const int min::LONG\_STR}]~\\
Stub value is a pointer at a body of type {\tt min::long\_\EOL string}
that contains a \verb|const char| vector and its size. 
\item[{\tt const int min::DEALLOCATED}]~\\
Stub has a deallocated body.
\end{list}
\end{indpar}

A full list of stub type codes complete with page references
is given on \pagref{STUB-TYPE-CODE-LIST}.

\subsubsection{Stub Values}
\label{STUB-VALUES}

A stub contains a 64-bit \key{stub value}.  If the stub is collectible
(as determined by its type), the type of this value
is determined by the stub type code (\itemref{STUB-TYPE-CODES}).
Otherwise the stub is typically attached to an object and the type of the stub
value is determined by how it is attached; in this case the type of the
stub value is most often just \verb|min::gen|.

Many stubs are immutable
and their stub values cannot be written after the stub has been created;
nevertheless we describe unprotected functions
below (\itemref{UNPROTECTED-STUB-FUNCTIONS}) that
write these values.  Unprotected functions are also provided to obtain
body pointers from stubs when these are the stub values of the stubs.
This cannot be done by protected
functions as body pointers are relocatable and require special
programming be sure they are up-to-date (\itemref{BODY-POINTERS}).

\subsubsection{Stub Control}
\label{STUB-CONTROL}

A stub contains a 64-bit \key{stub control}.  The high order 8 bits
of this is the stub type code, and the high order bit of this type
code determines whether the stub is collectible (bit is off)
or uncollectable (bit is on).

If the stub is collectible,
the stub control is used exclusively by the acc,
except for the type code, which is shared between the acc
and the rest of the system.  Such a control word is called
an `\key{acc control}\,'.  A typical (but not required)
organization of an acc control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 12-24 bits:	& acc flags \\
low order 44-32 bits:	& chain pointer \\
\end{tabular}
\end{center}

Here the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING})
that is used to build lists of allocated stubs which
the acc manages.

If a stub is uncollectable, its stub control, which is called
a `\key{non-acc control}\,', can be organized in different
ways according to the type code value.  The standard way of organizing
a non-acc stub control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 8 bits:		& subtype code \\
low order 48 bits:	& chain pointer or unsigned integer value \\
\end{tabular}
\end{center}

Again the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING}),
but now it has enough bits to be packed with the fastest packing scheme.

A non-acc control may also be used outside a stub, say by the acc, and
in this case it may be alternatively organized as:

\begin{center}
\begin{tabular}{ll}
high order 16 bits:	& locator \\
low order 48 bits:	& stub pointer \\
\end{tabular}
\end{center}

The main use of uncollectable stubs is as auxiliary stubs.
An `\key{auxiliary stub}' is an uncollectable stub attached to an object.
When the object is garbage collected, the auxiliary stub is freed.  Auxiliary
stubs are a means of adding memory to an object without relocating the object.
For example, if the object stores 64-bit IEEE floating point numbers,
a chain of auxiliary stubs can be used to add memory to the object
for additional numbers.  Note that the auxiliary stub itself does not
contain information that tells the type of the value it stores;
one has to trace the reference from the object pointing at the
auxiliary stub to determine this type.  Usually auxiliary stub
values are \verb|min::gen| values.  See \itemref{UNPROTECTED-STUB-FUNCTIONS}
for functions that can read and write auxiliary stubs.

\subsection{Body Pointers}
\label{BODY-POINTERS}

Bodies are relocatable
(\pagref{RELOCATABLE-BODY}) and and pointers into bodies,
called \skey{body pointer}s,
require special handling to
ensure that they are up-to-date.  There are two ways of managing
this: the protected way and the unprotected way.

Note also that deallocation of a body is treated as
reallocation of the body to inaccessible virtual memory.

\subsubsection{Protected Body Pointers}
\label{PROTECTED-BODY-POINTERS}

The protected way of handling body pointers
uses special pointer data that is adapted to
the type of datum being pointed at.  For example, the following
code can access any string:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some string
assert ( min::is_str ( x ) );
min::str_ptr xp ( x );
int length = min::strlen ( xp );
for ( int i = 0; i < length; ++ i )
{
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Here the \verb|str_ptr| datum is a \key{protected body pointer}.
For strings that are long enough to have a body, the
\verb|str_ptr| stores a pointer to the stub of the string,
and `\verb|xp[i]|' is an inline function that expands to
code that reads the body pointer from the stub and adds both
an appropriate constant offset and then the index `\verb|i|'
to that pointer in order to get the address of the character.

It might be thought that this is inefficient as the body pointer
is re-read from the stub for every different iteration of the `\verb|for|'
loop.  However, if no out-of-line functions are called in the
loop, an optimizing compiler will typically eliminate
the excess reads and load the body pointer plus constant offset
into a register before the loop begins.  The key here is to
avoid out-of-line function calls, as for each such call the
optimizer must assume that the body pointer in the stub might
change.

Specialized protected pointer types are provided for most types of object
that have bodies.

\subsubsection{Protected Body References and Pointers}
\label{PROTECTED-BODY-REFERENCES-AND-POINTERS}

In addition to specialized pointer types for each type of object,
there are a general body reference and pointer types
that reference any type an element in any body associated with any stub.
The reference types are most frequently used:

\newcommand{\TARG}{\BRACKETED{T}}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::|\MINKEY{ref\TARG}\verb| MUP::| & \MUPKEY{new\_ref}\ARGBREAK
    \verb| ( const min::stub * s,|\ARGBREAK
    \verb|   T const & location )|
\LABEL{MUP::NEW_REF} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * const r| & \TTARMKEY{s}{in {\tt min::ref\TARG}}
\LABEL{MIN::REF_STUB} \\
\verb|const min::unsptr r| & \TTARMKEY{offset}{in {\tt min::ref\TARG}}
\LABEL{MIN::REF_OFFSET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref\TARG}}\ARGBREAK
      \verb|( min::ref<T> const & r, T value )|
\LABEL{MIN::=REF_OF_T} \\
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref\TARG}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  const min::ref<T> & r2 )|
\LABEL{MIN::=REF_OF_REF} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|T |
    & \TTOMKEY{T}{{\tt T}}{of {\tt min::ref\TARG}}
      \verb|( const min::ref<T> & r )|
\LABEL{MIN::REF_TO_T} \\
\verb|T |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::ref\TARG}}
	  \verb| ( const min::ref<T> & r )|
\LABEL{MIN::REF_->} \\
\end{tabular}\end{indpar}

A {\tt min::ref\TARG} type is similar to the `{\tt T \&}' type.
Internally a {\tt min::ref\TARG} value {\tt r}
is a pointer to a location of type {\tt T} that
consists of a {\tt const min::\EOL stub~*} pointer {\tt r->s} to a stub
and an {\tt min::\EOL unsptr} byte offset {\tt r->offset}
of a location in the body
associated with the stub.  Setting a reference type equal to a value
of type {\tt T} stores the value in the location.  Setting a reference
{\tt r} equal to another reference {\tt r2}, as in `{\tt r~=~r2}', does
\underline{not} copy the internal pointers, but instead copies the
value at the {\tt r2} location to the {\tt r} location.

{\tt min::ref\TARG} values are returned by protected functions described
elsewhere:
\begin{center}
\begin{tabular}{ll}
packed stuctures & see {\tt MIN\_REF},
    \pagref{MIN_REF} and \pagref{PACKED_STRUCT_MIN_REF} \\
packed vector headers & see {\tt MIN\_REF},
    \pagref{MIN_REF} and \pagref{PACKED_VEC_MIN_REF} \\
packed vector elements	& see {\tt operator []},
    \pagref{PACKED_VEC_[]_REF} \\
locatable variables	& see {\tt operator min::ref\TARG},
    \pagref{LOCATABLE_VAR_REF} \\
object vector elements	& see TBD pTBD \\
TBD
\end{tabular}
\end{center}

The unprotected {\tt MUP::new\_ref} function is used by these
protected function to construct a {\tt min::\EOL ref\TARG} value
from a pointer {\tt s} to a stub and a {\tt const} location
within the body associated with that stub.  The location is
{\tt const} only to prevent it being written \underline{without}
using the {\tt min::\EOL ref\TARG} reference value returned by
{\tt MUP::\EOL new\_\EOL ref}; the reference value \underline{does}
permit the location to be written by protected code.

A {\tt min::ref\TARG} value is implicitly convertable to the type {\tt T}
value its internal pointer points at.  As this implicit conversion
is not activated by C++ in the case of an expression of the form
`{\tt r->\ldots}', `{\tt operator~->}' of a {\tt min::\EOL ref\TARG}
argument is defined to invoke the conversion explicitly.

Actually there are two kinds of {\tt min::\EOL ref\TARG} types that
differ according to whether or not the type {\tt T} is
`\mkey{locatable}{{\tt min::ref\BRACKETED{T}} reference to}'
\label{LOCATABLE_REF}
({\tt min::\EOL gen}, {\tt const min::\EOL stub~*}, and
classes such as {\tt min:\EOL packed\_\EOL\ldots ptr\BRACKETED{\ldots}}
that encapulate {\tt const min::\EOL stub~*} values are
locatable types: see \pagref{LOCATABLE-TYPE}).
If {\tt T} is locatable, storing a value in a {\tt min::\EOL ref\TARG}
location implicitly calls the
{\tt min::\EOL acc\_\EOL write\_\EOL update} functions of
Section~\itemref{ACC-WRITE-UPDATE-FUNCTIONS} to update the stubs
involved.  If {\tt T} is not locatable, this is not done.

A {\tt min::\EOL ref\TARG} reference value can also designate a location at
an absolute address not in a body associated with a stub.  This is
done by using fake stub whose `body pointer' is zero.  Such reference
values are used to point at locatable variables in static memory or the
stack (see {\tt operator min::ref\TARG}, \pagref{LOCATABLE_VAR_REF}).

Associated with the {\tt min::\EOL ref\TARG} reference type is
the companion {\tt min::\EOL ptr\TARG} pointer type:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{ptr\TARG} \verb| p|
\LABEL{MIN::PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}{of {\tt min::ref\TARG}}
      \verb|( const min::ref<T> & r )|
\LABEL{MIN::=&_OF_REF_OF_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{*}{*}{of {\tt min::ptr\TARG}}
      \verb|( const min::ptr<T> & p )|
\LABEL{MIN::=*_OF_PTR_OF_T} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * const p| & \TTARMKEY{s}{in {\tt min::ptr\TARG}}
\LABEL{MIN::PTR_STUB} \\
\verb|const min::unsptr p| & \TTARMKEY{offset}{in {\tt min::ptr\TARG}}
\LABEL{MIN::PTR_OFFSET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::ref\TARG}}
      \verb|( min::ptr<T> & p, const min::ptr<T> & p2 )|
\LABEL{MIN::=PTR_OF_PTR}
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|T * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::ptr\TARG}}
	  \verb| ( const min::ptr<T> & p )|
\LABEL{MIN::PTR_->} \\
\end{tabular}\end{indpar}

Internally a {\tt min::\EOL ptr\TARG} value is exactly like a
{\tt min::\EOL ref\TARG} value; both point at a location defined by
a stub and an offset within the body of the stub.
The main difference is that {\tt =} for reference values copies the
values of the locations pointed at, while {\tt =} for pointer values
copies the pointer itself; i.e., the pointer to the stub and the offset.

The other difference is the if a {\tt min::\EOL ref\TARG} value {\tt r}
designates a location containing a {\tt T} value {\tt v}, then
{\tt r->\ldots} is equivalent to {\tt v->\ldots}, and designates the value
pointed at by {\tt v}. 
But if a {\tt min::\EOL ptr\TARG} value {\tt p}
designates a location containing a {\tt T} value {\tt v}, then
{\tt p->\ldots} is equivalent to {\tt (\&v)->\ldots},
and designates the value {\tt v} itself.

A {\tt min::\EOL ptr\TARG} value can be created by applying the
{\tt \&} operator to a {\tt min::\EOL ref\TARG} value or to a
locatable variable (see {\tt operator \&} for locatable variables,
\pagref{LOCATABLE_VAR_PTR}).
A {\tt min::\EOL ref\TARG} value can be recovered from a
pointer value by applying the
{\tt *} operator to the {\tt min::\EOL ptr\TARG} value.


\subsubsection{Unprotected Body Pointers}
\label{UNPROTECTED-BODY-POINTERS}

\ikey{Unprotected body pointers}{unprotected body pointer}%
\index{pointer!unprotected body}\index{body pointer!unprotected}
are C/C++ pointers that point directly into a body.
Functions that obtain body unprotected
pointers from stubs are unprotected (\verb|MUP|) functions because
the unprotected body pointers they return are invalidated
if the body pointed at
is relocated.

In order to track possible relocation,
names of functions that might relocate bodies are marked
with the superscript {\REL} in this document.
Relocation can only happen inside such \skey{relocating function}s
(\pagref{RELOCATING-FUNCTIONS}).

The following uses unprotected body pointers to point at a character
string stored in a body:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some long string
assert ( min::is_stub ( x ) );
const min::stub * xstub = min::stub_of ( x );
assert ( min::type_of ( xstub ) == min::LONG_STR );
MUP::long_str * xstr = MUP::long_str_of ( xstub );
const char * xp = MUP::str_of ( xstr );
int length = MUP::length_of ( xstr );
for ( int i = 0; i < length; ++ i )
{
    // Relocating functions must NOT be called in this loop.
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Strings are in fact of three types, `direct' which stores characters
in the general value, `short' which stores up to 8 characters in the stub
value, and `long' which stores more than 8 characters in the body.  The
above code only works for long strings (\pagref{LONG-STRING-STUB}).


When relocation happens inside a relocating function,
the `\key{relocated flag}\,'\label{RELOCATED-FLAG},
which is one of the execution flags
described in~\itemref{EXECUTION-FLAGS}, is set.
Functions that use unprotected pointers must obey the following
protocol:

\begin{indpar}
save the relocated flag \\
\ldots\ldots \\
compute local variables containing unprotected body pointers \\
use these local variables \\
\ldots\ldots \\
to call a relocating function: \\
\hspace*{3em}\begin{tabular}{l}
    clear the relocated flag and call the relocating function \\
    if the relocated flag is now set: \\
    \hspace*{3em}\begin{tabular}{l}
	optionally check that object bodies pointed at \\
	\hspace*{3em}have not been deallocated (see \itemref{DEALLOCATION}) \\
	set the saved relocated flag \\
	recompute all local variables containing unprotected body pointers \\
    \end{tabular} \\
\end{tabular} \\
\ldots\ldots \\
restore the saved relocated flag
\end{indpar}

When a function that calls relocating functions returns to its caller,
it must set the relocated
flag if that flag was set when the function started or if the
flag was set during function execution.

Relocating functions update body pointers that are not stored
in local variables, in particular those stored in stubs.
The local variables must then be recomputed from the pointers stored in
the stubs.

If a body is deallocated by a relocating function,
the stub's type will be changed to
{\tt min::\EOL DEALLOCATED}, and the body will be relocated to inaccessible
virtual memory so references to it will cause program terminating
memory fault.  For many stubs, this is the only possible 
type change.  However some bodies may not only be relocated, but
may be reorganized, causing their stub to change type.  An example
is objects, which can have stub type {\tt min::\EOL SHORT\_\EOL OBJ} or
{\tt min::\EOL LONG\_\EOL OBJ}, and may be reorganized during relocation to
become more compact.  Usually such stubs are marked when they
are in use by a function that calls relocating functions so that
they will not change type (except for deallocation) and their
bodies will not be reorganized.  For example, objects have a state
which indicates if protected object pointers are pointing at the
object.

If the example above is modified to call a relocating function
in its loop, the resulting code would be:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some long string
assert ( min::is_stub ( x ) );
const min::stub * xstub = min::stub_of ( x );
assert ( min::type_of ( xstub ) == min::LONG_STR );
MUP::long_str * xstr = MUP::long_str_of ( xstub );
const char * xp = MUP::str_of ( xstr );
int length = MUP::length_of ( xstr );
bool relocated = min::set_relocated_flag ( false );
for ( int i = 0; i < length; ++ i )
{
    . . . xp[i] . . .
    some_relocating_function ( . . . );
    if ( min::set_relocated_flag( false ) )
    {
        relocated = true;
        assert ( ! is_deallocated ( xstub ) );
        xstr = MUP::long_str_of ( xstub );
        xp = MUP::str_of ( xstr );
    }
    . . . xp[i] . . .
}
min::set_relocated_flag ( relocated );
\end{verbatim}\end{indpar}

The following functions get and set the relocated flag:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{relocated\_flag}\verb| ( void )|
\LABEL{MIN::RELOCATED_FLAG} \\
\verb|bool min::| & \MINKEY{set\_relocated\_flag}\verb| ( bool value )|
\LABEL{MIN::SET_RELOCATED_FLAG}
\end{tabular}\end{indpar}

The function to set the flag returns the flag's previous value.

A function that computes an unprotected pointer into a body does not
check the type code of the stub pointing at the body.  The type
code must be checked separately before the pointer is computed.  If the
pointer is being recomputed after possible relocation, the stub type
code may have to be checked.  For most stub types, the only check
required relates to the possibility that the body has been deallocated.

Code to handle relocating function calls and unprotected body
pointers has the general form:

\begin{indpar}\begin{verbatim}
... some_function ( ... )
{
    bool relocated = min::set_relocated_flag ( false );
    . . . . .
    const min::stub * s = min::stub_of ( ... );
    . . . . .
    assert ( ... == type_of ( s ) );
    MUP::some_body_type * p =
        MUP::some_function_returning_a_body_pointer ( s );
    . . . . . use p . . . . .
    some_relocating_function ( ... );
    if ( min::set_relocated_flag( false ) )
    {
        relocated = true;
        assert ( ! is_deallocated ( s ) );
        p = MUP::some_function_returning_a_body_pointer ( s );
    }
    . . . . . use p . . . . .
    min::set_relocated_flag ( relocated );
    return ...;
}
\end{verbatim}\end{indpar}

To simplify this code, the following is defined:

\begin{indpar}\begin{verbatim}
class min::relocated
{
public:
    bool relocated_flag;
    relocated ( void )
    {
        relocated_flag = min::set_relocated_flag ( false );
    }
    ~ relocated ( void )
    {
        min::set_relocated_flag ( relocated_flag );
    }
    operator bool ()
    {
        if ( min::set_relocated_flag ( false ) )
            return relocated_flag = true;
        else
            return false;
    }
}
\end{verbatim}\end{indpar}\LABEL{MIN::RELOCATED}

which permits the general code given above to be rewritten more conveniently
as:

\begin{indpar}\begin{verbatim}
... some_function ( ... )
{
    // relocated constructor saves the relocated flag.
    min::relocated relocated;
    . . . . .
    const min::stub * s = min::stub_of ( ... );
    . . . . .
    assert ( ... == type_of ( s ) );
    MUP::some_body_type * p =
        MUP::some_function_returning_a_body_pointer ( s );
    . . . . . use p . . . . .
    some_relocating_function ( ... );
    if ( relocated )
    {
        assert ( ! is_deallocated ( s ) );
        p = MUP::some_function_returning_a_body_pointer ( s );
    }
    . . . . . use p . . . . .
    return ...;
    // relocated deconstructor restores relocated flag.
}
\end{verbatim}\end{indpar}

\subsubsection{Deallocation}
\label{DEALLOCATION}

The operation of \ikey{deallocating a body}{deallocate!body}\index{deallocation}
is considered to be a relocation of the body.  The body pointer in the
stub is pointed at a `deallocated body' located in
inaccessible virtual memory, and the type code in the stub
is set to {\tt min::DEALLOCATED} (\pagref{MIN::DEALLOCATED}).

The following function tests whether a stub
has {\tt min::DEALLOCATED} type:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_deallocated}\verb| ( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED}
\end{tabular}\end{indpar}

This function just checks the stub type code to see if it equals
{\tt min::DEALLOCATED} (\pagref{MIN::DEALLOCATED}).

The inaccessible memory to which a {\tt min::DEALLOCATED} stub is
pointed is called the `\key{deallocated body}' of the stub.
Implementations typically provide a single block of inaccessible memory
which is used as the deallocated body of all {\tt min::DEALLOCATED} stubs.
The size of this will be large enough that any access to the body of
a {\tt min::DEALLOCATED} stub that was previously of a
standard stub type will cause a memory fault, because every such access is
checked to see if it does not go beyond the end of the body by using
data in a header at the beginning of the body,
and the size of the deallocated body is larger than the size of the header.

However, when recomputing pointers into a body after a relocating
function has been called the body header may not be reaccessed,
so in this case an explicit check that a body has not been deallocated
is necessary.

\subsection{Allocator/Collector/Compactor Interface}
\label{ACC-INTERFACE}

The garbage collector needs to be able to locate all
\verb|min::gen| and {\tt const min::\EOL stub~*} values
that are in use and that might contain stub pointers.
Values of these types are called \skey{locatable value}s.%
\label{LOCATABLE-VALUE}
These types, and types that are just classes which
encapsulate a {\tt min::\EOL gen} or {\tt const min::\EOL stub~*}
value (such as the {\tt min::packed\_\ldots ptr\BRACKETED{\ldots}} types),
are called \skey{locatable type}s.%
\label{LOCATABLE-TYPE}

Values of a locatable type {\tt T} stored in static memory or the stack
need to be locatable by the garbage collector.  This is done
by storing them in {\tt min::\EOL locatable\_\EOL var\TARG} type
variables, as described in the first subsection of this section.

When you write a value of locatable type {\tt T} into a stub or associated
body, you need to call the {\tt MUP::\EOL acc\_\EOL write\_\EOL update}
function (\itemref{ACC-WRITE-UPDATE-FUNCTIONS}) to update garbage
collection flags associated with stubs.
This is done automatically if a {\tt min::\EOL ref\TARG} reference value is
used to write the value.  Such reference values are created
by functions described in the second subsection of this section.

If you are implementing a new type of stub and maybe bodies
associated with that stub type, or a new class of pointers to stubs,
then you need to use the unprotected
interfaces described in the third and fourth subsections of this section.

\subsubsection{Locatable Variables}
\label{LOCATABLE-VARIABLES}

Values that might contain stub pointers must be locatable
by the garbage collector (the collector part of the acc).  Since
in a compact implementation even double precision numbers are
represented by \verb|min::gen| values pointing at stubs, this means
the just about all general values must be locatable.  However,
in order to benefit loose implementations, a distinction is made
between \verb|min::gen| values known to be numeric and those
that might not be, so loose implementations can encounter less overhead
when dealing with numeric \verb|min::gen| values.

In order to be locatable by the garbage collector, \verb|min::gen|
values in static or stack memory must be stored in locations of type
\verb|min::|\MINKEY{locatable\_\EOL gen}, or, if they a \underline{known}
with certainty to be numbers, in locations of type
\verb|min::|\MINKEY{locatable\_\EOL num\_\EOL gen}:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{locatable\_gen} \verb| var ( void )|
\LABEL{MIN::LOCATABLE_GEN} \\
\verb|min::locatable_gen & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( min::locatable_gen & var,|\ARGBREAK
      \verb|  min::gen value )|
\LABEL{MIN::=LOCATABLE_GEN_OF_GEN} \\
\verb|min::locatable_gen & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( min::locatable_gen & var,|\ARGBREAK
      \verb|  const min::locatable_gen & var2 )|
\LABEL{MIN::=LOCATABLE_GEN_OF_LOCATABLE_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::gen |
    & \TTOMKEY{min::gen}{min::gen}%
              {of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( const min::locatable_gen & var )|
\LABEL{MIN::LOCATABLE_GEN_TO_GEN} \\
\verb|min::ref<min::gen> |
    & \TTOMKEY{min::ref<min::gen>}{min::ref\BRACKETED{min::gen}}%
              {of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( const min::locatable_gen & var )|
\LABEL{MIN::LOCATABLE_GEN_TO_REF_GEN} \\
\verb|min::ptr<min::gen> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( const min::locatable_gen & var )|
\LABEL{MIN::&_LOCATABLE_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
In compact implementation: \\
~~~~\verb|typedef  |
	& \verb|min::locatable_gen  min::|\MINKEY{locatable\_num\_gen} \\
In loose implementation: \\
~~~~\verb|typedef  |
	& \verb|min::gen  min::|\MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\end{tabular}\end{indpar}

If the implemention is loose (\pagref{LOOSE}),
{\tt min::locatable\_\EOL num\_\EOL gen} is equivalent to
{\tt min::gen}.  If the implementation is compact, it is equivalent to
{\tt min::locatable\_\EOL gen}.

The main operations that can be performed on a
{\tt min::locatable\_\EOL gen} location are to copy a {\tt min::gen}
value into it or out of it.  Setting one {\tt min::\EOL locatable\_\EOL gen}
location equal to another copies the {\tt min::gen} value of the locations,
and not the location structure itself.

A {\tt min::\EOL locatable\_\EOL gen} locatable variable
\label{LOCATABLE_VAR_REF}
is implicitly convertable to a
reference
of type {\tt min::\EOL ref<min::gen>}
that references the {\tt min::gen}
value stored in the locatable variable.

Applying the {\tt \&} operator to a
\label{LOCATABLE_VAR_PTR}
{\tt min::\EOL locatable\_\EOL gen} locatable variable
returns a pointer of type {\tt min::\EOL ptr<min::gen>} that points
at the locatable variable.

Due to a technical difficulty with C++, it is not possible to pass a
{\tt min::gen} value to a {\tt min::\EOL locatable\_\EOL gen} constructor.%
%
\footnote{\label{LOCATABLE-VAR-COPY-FOOTNOTE}
More specifically, we need to disable the copy constructor
for {\tt min::\EOL locatable\_\EOL gen} values, as constructing such a
value stores its address in a global location so the garbage collector
can find it, and copying the {\tt min::\EOL locatable\_\EOL gen} value
to another location would be a disaster.  Therefore we disable the
{\tt min::\EOL locatable\_\EOL gen}
copy constructor by making it {\tt private}.
Then the construction `{\tt T~x~=~y}' fails because it works
by compiling `{\tt T~x~(T(y))}' if {\tt y} is not of type {\tt T},
that is, C++ uses the conversion constructor to convert {\tt y}
to type {\tt T}, and then uses the \underline{copy constructor}
to copy the result to its final resting place.  This is not acceptable for
location sensitive values such as
{\tt min::\EOL locatable\_\EOL gen} values.}
%
For example:

\begin{indpar}\begin{verbatim}
min::locatable_gen x = y;    // Does NOT compile!
min::locatable_gen x;        // OK
x = y;                       // OK
\end{verbatim}\end{indpar}

The only available {\tt min::locatable\_gen} constructor takes
no arguments and initializes the value of the locatable variable
to {\tt min::\EOL MISSING}.

An example usage is:

\begin{indpar}\begin{verbatim}
static min::locatable_gen v;
. . . . . . . . . .
void f ( ref<min::gen> r );
. . . . . . . . . .
... some_function ( min::gen x )
{
    min::locatable_gen q;
    q = x;
    min::ptr p = & q;
    . . .
    v = q;     // Copies the min::gen value of q to v.
    * p = x;   // Sets q to x.
    . . .
    f ( v );   // Converts v to min::ref<min::gen>
    ..

    . . .
}
\end{verbatim}\end{indpar}

{\tt const min::\EOL stub~*} values
must also be locatable by the garbage collector.
In particular the {\tt min::\EOL packed\_\EOL \ldots ptr\BRACKETED{\ldots}}
pointers
(see Sections~\itemref{PACKED-STRUCTURES} and \itemref{PACKED-VECTORS})
must be locatable.
When such values are stored in static or stack memory,
this may be done with the code:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|(constructor) min::|
    & \MINKEY{locatable\_var\TARG}\verb| var ( void )|
\LABEL{MIN::LOCATABLE_VAR} \\
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var\TARG}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  T value )|
\LABEL{MIN::=LOCATABLE_VAR} \\
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var\TARG}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  const min::stub * s )|
\LABEL{MIN::=LOCATABLE_VAR_OF_STUB} \\
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var\TARG}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  const min::locatable_var<T> & var2 )|
\LABEL{MIN::=LOCATABLE_VAR_OF_LOCATABLE_VAR} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|const min::stub * |
    & \TTOMKEY{const min::stub *}{const min::stub *}%
              {of {\tt min::locatable\_var\TARG}}\ARGBREAK
      \verb|( const min::locatable_var<T> & var )|
\LABEL{MIN::LOCATABLE_VAR_TO_STUB_PTR} \\
\verb|min::ref<T> |
    & \TTOMKEY{min::ref<T>}{min::ref\TARG}%
              {of {\tt min::locatable\_var\TARG}}\ARGBREAK
      \verb|( const min::locatable_var<T> & var )|
\LABEL{MIN::LOCATABLE_VAR_TO_REF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var\TARG}}\ARGBREAK
      \verb|( const min::locatable_var<T> & var )|
\LABEL{MIN::&_LOCATABLE_VAR} \\
\end{tabular}\end{indpar}

Here {\tt T} must be
`{\tt const min::stub~*}'
or a class like {\tt min::\EOL packed\_\ldots ptr\BRACKETED{\ldots}}
whose only data member is of type {\tt const min::stub~*}.
In either case, a {\tt min::\EOL locatable\_\EOL var\TARG}
value is implicitly convertable to a {\tt const min::\EOL stub~*} value.

In the second case, {\tt T} is the {\tt public} base class of
{\tt min::\EOL locatable\_\EOL var\TARG}, so expressions of
the forms {\tt \ldots=var},
{\tt var->\ldots}, {\tt var[\ldots]}, etc will work for
{\tt min::\EOL locatable\_\EOL var\TARG} value {\tt var} if they
will work for a value of type {\tt T}.

Like a {\tt min::\EOL locatable\_\EOL gen} locatable variable,
a {\tt min::\EOL locatable\_\EOL var\TARG} locatable variable
is implicitly convertable to a
reference of type {\tt min::\EOL ref<T>}, and can be pointed at
by a pointer of type {\tt min::\EOL ptr<T>} obtained by applying
the {\tt \&} operator to the locatable variable.

And as with {\tt min::\EOL locatable\_\EOL gen} locatable variables,
due to a technical difficulty with C++ it is not possible to pass a
type {\tt T} value to a {\tt min::\EOL locatable\_\EOL var\TARG} constructor.%
\footnote{See footnote \itemref{LOCATABLE-VAR-COPY-FOOTNOTE}.}
The only available {\tt min::locatable\_var\TARG} constructor takes
no arguments and initializes the value of the locatable variable
to {\tt min::\EOL NULL\_\EOL STUB}.

An example usage is:

\begin{indpar}\begin{verbatim}

typedef min::packed_vec_insptr<char> bufvec;
min::locatable_var<bufvec> x;
void f ( min::ref<bufvec> p );
... some_function ( ... )
{
    min::locatable_var<bufvec> y;
    y = x;    // Copies the bufvec value of x to y.
    f ( y );  // Converts y to a min::ref<bufvec> reference.
}
\end{verbatim}\end{indpar}

The {\tt min::locatable\_gen} type is actually a specialization
of {\tt min::\EOL locatable\_\EOL var}:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|typedef |
	& \verb|min::locatable_var<min::gen>|\ARGBREAK
	  \verb|min::|\MINKEY{locatable\_gen}
\LABEL{MIN::LOCATABLE_GEN_TYPEDEF} \\
\end{tabular}\end{indpar}

However, this specialization differs from
{\tt min::\EOL locatable\_\EOL var\TARG}in that it is not
implicitly convertable to a {\tt const min::\EOL stub~*} value nor
is {\tt min::gen} a base type of this specialization.

Importantly a \verb|min::gen| or \verb|const min::stub *|
value need \underline{not} be stored
in a locatable variable if it can be located by the garbage collector by some
other means.  For example, if it is stored in one locatable variable,
it need not be stored in another.  Or if a \verb|min::gen|
or {\tt const min::\EOL stub~*} value
$V$ is stored in an object pointed at by another \verb|min::gen|
or {\tt const min::\EOL stub~*}
value $P$, and $P$ is locatable, then $V$ need not
be stored in a locatable variable.

A very important rule is that when a function is called, the caller
must be sure every \verb|min::gen|
or {\tt const min::\EOL stub~*} value passed to the called
function can be located by the garbage collector \underline{without} the called
function needing to store the value in a locatable variable.
For example, the caller can store the value in its own locatable
variable.  This is called the `\key{caller locating convention}'.

Also \verb|min::gen| and {\tt const min::\EOL stub~}
values need only be locatable by
the garbage collector when a relocating function (\pagref{RELOCATING-FUNCTIONS})
is called.  In between such calls \verb|min::gen|
and {\tt const min::\EOL stub*} values can be
stored in other places.  In particular, there is no problem
returning these values from a called function to its caller.

\subsubsection{Locatable Member References}
\label{LOCATABLE-MEMBER-REFERENCES}

Suppose we have some kind of stub/body data type whose body
is the structure {\tt S} defined and used in the following:

\begin{indpar}\begin{verbatim}
struct S;
struct S_ptr
    // Pointer to a datum of type S.
{
    const min::stub * s;
    S * operator -> ( void )
    {
        return (S *) MUP::ptr_of ( s );
            // Return pointer to body.
    }
    operator const min::stub * ( void )
    {
        return s;
            // Return pointer to stub.
    }
};

struct S
{
    // Examples of different member types:
    //
    int x;
    min::gen g;
    S_ptr p;
};

void foo ( S_ptr q )
{
    // Examples of usage of members:
    //
    int x2 = q->x.
    q->x = ...;
    min::gen g2 = q->g;
    q->g = ...;
    MUP::acc_write_update ( q, q->g );
    S_ptr p2 = q->p;
    q->p = ...;
    MUP::acc_write_update ( q, q->p );
}
\end{verbatim}\end{indpar}

Because {\tt min::gen} and {\tt S\_ptr} are locatable types,
{\tt MUP::\EOL acc\_\EOL write\_\EOL update}
(\itemref{ACC-WRITE-UPDATE-FUNCTIONS}) must be called when
members of these types are written into a stub or associated body.  There is
a danger of unintentional omission of these calls.

An alternative is to replace some of the above code by the following:

\begin{indpar}\begin{verbatim}
struct S
{
    int x;
    const min::gen g;    // Added `const'.
    const S_ptr p;       // Added `const'.
};

inline min::ref<min::gen> g_ref ( S_ptr q )
{
    return MUP::new_ref ( q, q->g );
}

inline min::ref<S_ptr> p_ref ( S_ptr q )
{
    return MUP::new_ref ( q, q->p );
}

void foo ( S_ptr q )
{
    int x2 = q->x.
    x = ...;
    min::gen g2 = q->g;
    g_ref(q)= ...;       // q->g replaced by g_ref(q).
    S_ptr p2 = q->p;
    p_ref(q) = ...;      // q->p replaced by p_ref(q).
}
\end{verbatim}\end{indpar}

Here the calls to {\tt MUP::acc\_write\_update} are inside the
{\tt \ldots\_ref(q) =} calls (\pagref{LOCATABLE_REF}).
Writing {\tt q->g = \ldots}
and {\tt q->p = \ldots} is prevented by making the {\tt g} and {\tt p}
members `{\tt const}', so accidently updating locatable members
without calling {\tt MUP::\EOL acc\_\EOL write\_\EOL update}
is prevented.

To make the above easier to code, the {\tt MIN\_REF} macro
is provided which expands as follows:

\begin{indpar}
\TTNBKEY{MIN\_REF}\verb| ( type, name, ctype )|
\LABEL{MIN_REF}
\\[1ex]
expands to \\[1ex]
\verb|inline min::ref<type> name_ref ( ctype container )| \\
\verb|{| \\
\verb|    return MUP::new_ref ( container, container->name );| \\
\verb|}|
\end{indpar}

Here `{\tt type}' is the member type and `{\tt ctype}' is
the `\key{container type}'.

This enables the {\tt inline} function definitions above to be
replaced by

\begin{indpar}\begin{verbatim}
MIN_REF ( min::gen, g, S_ptr )
MIN_REF ( S_ptr, p, S_ptr )
\end{verbatim}\end{indpar}

This methodology and the {\tt MIN\_\EOL REF} macro are frequently
used with packed structures (see \itemref{PACKED-STRUCTURES}) and
packed vectors (see \itemref{PACKED-VECTORS}).

\subsubsection{Unprotected Stub Functions}
\label{UNPROTECTED-STUB-FUNCTIONS}

If you are implementing a new type of stub and maybe bodies
associated with that stub type, or a new class of pointers to stubs,
then you need to use the unprotected
interfaces described in this section.

As described in the first subsection, you need to be able update stubs
using the {\tt MUP::\EOL acc\_\EOL write\_\EOL update} functions
when locatable values are written into stubs or associated bodies.
You need to be able to allocate and free stubs, as described in the
second subsection.  You need to be able to read and write stub values,
as described in the third subsection.  If you are using acc stubs you
need to be able to write the type field in stub controls, and if
you are using auxiliary stubs, you need to be able to read, write,
and manipulate entire stub controls.
This is described in the fourth subsection.

\subsubsubsection{ACC Write Update Functions}
\label{ACC-WRITE-UPDATE-FUNCTIONS}

In addition to needing to locate \verb|min::gen|
and {\tt min::\EOL stub~*} values, the acc
must be notified whenever a pointer to a collectible stub \verb|s2|
is stored in the data of a collectible stub \verb|s1| (i.e., in
the stub \verb|s1| or its body or auxiliary stubs attached to either).
This is done by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::stub * s2 )|
\LABEL{MUP::ACC_WRITE_STUB_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   min::gen g )|
\LABEL{MUP::ACC_WRITE_GEN_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
          \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   min::gen g )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_UPDATE} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::stub * const * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_STUB_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_GEN_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
	  \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_VEC_UPDATE} \\
\end{tabular}\end{indpar}

The first of the above functions updates the stubs {\tt s1} and {\tt s2}
if {\tt s2} is not {\tt NULL}.  The second updates the stub {\tt s1}
and the stub pointed at by {\tt g} if {\tt g} points at a stub.
The third of the above functions equals the second function for a compact
(\pagref{COMPACT}) implementation, and is a no-operation for a loose
implementation.

The last three of the above functions look at all the
values \verb|p[0]|, \ldots, \verb|p[n-1]|, and for each of these
call the corresponding function choosen from the first three
of the above functions.

The {\tt min::\EOL acc\_\EOL write\_\EOL num\_\EOL update}
functions should only be used if all the
\verb|min::gen| values they reference are numeric, as in a loose
implementation these functions do nothing.

These \verb|min::acc_write_update| functions
\underline{must not} be called with any argument that points at a stub
with {\tt min::ACC\_\EOL FREE} type, which can only happen when the
stub has been recently returned by
{\tt min::\EOL new\_\EOL acc\_\EOL stub}.
See \itemref{STUB-ALLOCATION-FUNCTIONS}.


\subsubsubsection{Stub Allocation Functions}
\label{STUB-ALLOCATION-FUNCTIONS}

The following functions are used to allocate stubs:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub}\verb| ( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub}\verb| ( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\end{tabular}\end{indpar}

The \verb|min::new_acc_stub| function returns a garbage collectible (acc)
stub with its type set to \minkey{ACC\_FREE}.  A stub with this type
\underline{must not} be visible to the garbage collector; no pointer
to it can be stored in an acc locatable variable.
The {\tt MUP::acc\_\EOL write\_\EOL update}
function \underline{must not} be called with any
\verb|min::gen| or {\tt min::\EOL stub~*} argument that points at
a stub with {\tt min::ACC\_\EOL FREE} type.  All
\verb|min::gen| or {\tt min::\EOL stub~*} values stored in
the data of a {\tt min::ACC\_\EOL FREE} stub must also be stored
in acc locatable variable, or must themselves point at 
{\tt min::ACC\_\EOL FREE} stubs.

The actions of changing the type of a stub
from {\tt min::ACC\_\EOL FREE}
to another collectible type and storing a
\verb|min::gen| or {\tt min::\EOL stub~*}
value pointing at the stub in an acc
locatable variable must not be separated by any
call to a relocating function.

It is permissible to allocate and build a graph of stubs some of
which have {\tt min::\EOL ACC\_\EOL FREE} type.  No stub locatable
by the garbage collector may contain (in its stub or body or
auxiliary stubs) a pointer to a stub with
{\tt min::\EOL ACC\_\EOL FREE} type.  Any stub with
{\tt min::\EOL ACC\_\EOL FREE} type can contain only pointers
to stubs of this type or stubs that are locatable by the garbage
collector.  After building the graph, the types of all stubs with
{\tt min::\EOL ACC\_\EOL FREE} type should be changed to
normal acc types, and pointers that permit the garbage collector
to locate these stubs should be stored in locatable variables,
all without making any calls to relocating functions.

The \verb|min::new_aux_stub| function returns a non-acc (i.e.,
not garbage collectible)
stub with its type set to \minkey{AUX\_FREE}.  This kind of stub is
is \underline{not} freed by the garbage collector.  It may be
freed only by calling:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::| & \MUPKEY{free\_aux\_stub}\verb| ( min::stub * s )|
\LABEL{MUP::FREE_AUX_STUB} \\
\end{tabular}\end{indpar}

A non-acc stub is most often attached to an acc stub in such a way
that when the acc stub is garbage collected, the non-acc stub is
freed.  Such a non-acc stub is called an \key{auxiliary stub}, and
because most non-acc stubs are of this kind, functions dealing with
non-acc stubs have names containing `\ttkey{aux}' instead of
`\verb|non_acc|'.

\subsubsubsection{Stub Value Read/Write Functions}
\label{STUB-VALUE-READ-WRITE-FUNCTIONS}

The following functions read or write the stub value part of a stub:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::VALUE_OF_STUB} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{ptr\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::PTR_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_value\_of}\verb| ( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of}\verb| ( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of}\verb| ( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_ptr\_of}\verb| ( min::stub * s, void * p )|
\LABEL{MUP::SET_PTR_OF} \\
\end{tabular}\end{indpar}

Thus the stub value can be taken to be of type \verb|min::uns64|,
\verb|min::float64|, \verb|min::gen|, or
of some pointer type.

These functions do \underline{not} check type codes, nor do they check
that values read or written are within legal range for a particular
stub.  For example, a stub value that is not a floating point number can be
read by \verb|MUP::float_of| with undefined results.

\subsubsubsection{Stub Control Functions}
\label{STUB-CONTROL-FUNCTIONS}

If you are using auxiliary stubs, you need to be able to read, write,
and manipulate the stub control part of the stub.  If you are using
acc stubs, you only need to write the type part of the control.

The following
read or write the stub control:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|int min::| & \MINKEY{type\_of}\verb| ( const min::stub * s )| \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( const min::stub * s,| \\
      \verb|   min::uns64 flags )|
      \end{tabular}
\LABEL{MUP::TEST_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_control\_of}\verb| ( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of}\verb| ( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of}\verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of}\verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{tabular}\end{indpar}

The \verb|MUP::control_of| and \verb|MUP::set_control_of| functions
deal with the entire 64 bit stub control value of a stub.  The other
functions deal only with parts.

For acc stubs, only the type part of the control should be read or
written.  The other parts of the control are for use by the
acc, and should not be accessed by non-acc code,
in order to ensure that the acc is independent of other code.

The stub control in a stub is an example of a MIN \key{control value}.
A MIN control value holds a stub address or an unsigned integer
in its low order bits.  It may hold an 8 bit type code in its highest order
bits.  Any bits left over are flag bits, or if there is no 8 bit type
code, the high order 16 bits may be a signed integer field called the
`\mkey{locator}{field of control value}'
which is used only by some acc code.  Control values have type
\verb|min::uns64|.  Control values are used as stub controls, and
may be use in other places, e.g., by the acc to hold pointers from
a block that holds a body back to the stub pointing at the body.

Thus control values contain an address/value low order field, and optional
type code high order field, and flag bits.  There are two kinds of
control values: (ordinary) control values and acc control values:

\begin{indpar}
Ordinary control value with type: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-56 & int8 type \\
55-48 & 8 flag bits \\
47-0 & unsigned integer value or absolute stub address
\end{tabular}

Ordinary control value with locator: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-48 & int16 locator \\
47-0 & unsigned integer value or absolute stub address
\end{tabular}

Acc control value: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-56 & int8 type \\
55-(56-$G$) & $G$ flag bits \\
(55-$G$)-0 & absolute or packed stub address
\end{tabular}

where $8\leq G\leq 24$.
\end{indpar}

The larger G, the more acc flags, which may permit the
garbage collector to be more efficient (e.g., to have more ephemeral
levels).

The packed stub address is an absolute stub address,
relative stub address, or stub index.  The possible packing schemes used for
these are the same as the packing schemes used for general values:
see \pagref{STUB-ADDRESS-PACKING}.  However, the actual packing scheme
used for acc control values may differ from the actual packing scheme
used for general values, because the number of bits available for the
packed stub address may differ in the two cases.

Addresses stored in a control value must be stub addresses, as only they
can be packed into less than 64 bits.

The control values used as stub controls do have a type code field which
can be read by \verb|min::type_of| (which is protected) and
written by \verb|MUP::set_type_of|.  For stub controls,
acc control values are used with
collectible types, and ordinary control values with
uncollectable types.

The flag bits are set, cleared, and tested individually.  They are
defined by constants of type \verb|min::uns64|, such as

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::uns64 MUP::}\MUPKEY{STUB\_ADDRESS}]~%
	\LABEL{MIN::STUB_ADDRESS}\\
Indicates that the address/value field of an ordinary (non-acc)
control holds a stub address.  This flag is only used for
uncollectable stubs whose control address/value field might
be either a stub address or an unsigned integer.
\end{list}
\end{indpar}

These flag constants are defined by expressions of the form

\begin{center}
\verb|( min::uns64(1) << |$K$\verb| )|
\end{center}

The above functions assume that any flag constants select bits
in a control value that are not inside the address/value field
or inside the type code field.

Ordinary (non-acc) control values that have a locator
field cannot have any flag bits.

The flags in the stub control value of a stub can be tested, set, or
cleared by some of the above functions.
The \verb|MUP::test_flags_of| function
returns true if and only if the logical AND of the \verb|flags| arguments
and the flags in the stub's control is non-zero.  The \verb|MUP::set_flags_of|
function sets one or more individual flags by logically ORing its
argument into the stub's control, and the
\verb|MUP::clear_flags_of| function clears flags by logically ANDing
the complement of its argument into the stub's control.

The above functions do \underline{not} check type codes, nor do they check
that values read or written are within legal range for a particular
stub.  Thus a stub control value
can be written by \verb|MUP::set_control_of| even if the written
control datum is incompatible with the garbage collector implementation,
and may produce undefined results when the garbage collector
next executes.  Flag bits must not be inside the address/value field
or inside the type code field.

The high order byte of any control written by \verb|MUP::set_control_of|
is the type code, and the high order bit is clear if the stub is collectible
and set if the stub is uncollectable (\itemref{STUB-CONTROL}).
Changing a stub from collectible to uncollectable or vice versa requires
removing or adding the stub to garbage collector lists that are threaded
through the pointer field of the stub control.  So one cannot simply
change the type code field of a stub from collectible to uncollectable
or vice versa.

Ordinary (non-acc) control values can be manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator}\verb| ( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value}\verb| ( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|int MUP::| & \MUPKEY{locator\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{tabular}\end{indpar}

The `{\tt new}' functions compute a control value,
the `{\tt renew}' functions modify control values
by inserting a new locator, value, or stub address, and
the other functions return the parts of a control value.
Here the 16-bit locator is represented as an \verb|int|
in the range from $-2^{15}$ through $2^{15}-1$.

None of these functions check the ranges of their arguments.

Acc control values can be manipulated by the following similar functions
(this is only done by acc code):

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
\end{tabular}\end{indpar}

Either ordinary or acc control values can be
manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type}\verb| ( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{tabular}\end{indpar}

Here the 8-bit type code is represented as an {\tt int} in
the range from $-128$ through $127$.

\subsubsection{Unprotected Body Functions}
\label{UNPROTECTED-BODY-FUNCTIONS}

If you are implementing a new know of stub, and your stubs have bodies,
you need to be able to allocate, relocate, and deallocate the bodies.
The following functions allocate and deallocate bodies:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void MUP::|
    & \MUPKEY{new\_body}\verb| ( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body}\verb| ( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{tabular}\end{indpar}

Here \verb|n| is the size in bytes of the body to be allocated or deallocated.
The allocator is not required to remember the size of a body,
so when deallocating the body the caller must provide the same size
as was used to allocate the body.  The allocator will likely
run a check that will likely catch a wrong size, but it may not
be able to determine the right size.

Bodies are always aligned on 8 byte boundaries, but the size \verb|n|
need \underline{not} be a multiple of 8.

When a body is deallocated, the stub type is set to
\verb|min::DEALLOCATED| and the stub pointer is set to
point at a block of inaccessible memory.
As a special case, if the body size \verb|n| is zero,
{\tt MUP::\EOL deallocate\_\EOL body} does nothing
(see {\tt MIN::\EOL body\_\EOL size\_\EOL of} below).


The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\end{tabular}\end{indpar}

returns the size of the body, that is, the same size
as that passed to {\tt MUP::new\_\EOL body} when the
body was allocated.  This is necessary as the acc does
\underline{not} keep track of body sizes, and depends upon
this {\tt MUP::body\_\EOL size\_\EOL of} function to
find body sizes.  If the stub is deallocated (of type
\verb|min::DEALLOCATED|) or if the stub has no body,
\verb|0| is returned.  This enables the code
\begin{center}
\verb|MUP::deallocate_body ( s, MUP::body_size_of ( s ) )|
\end{center}

The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void * & MUP::| & \MUPKEY{ptr\_ref\_of}%
	     \verb| ( min::stub * s )| 
\LABEL{MUP::PTR_REF_OF_STUB} \\
\end{tabular}\end{indpar}

returns a pointer to a pointer to the body.
The first pointer points to a location P with a fixed address
(P is the stub value); P holds
a pointer to the body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS}).
Whenever the body is relocated the value of P is changed to
point to the new body location.

In order to change the size of a body, the following
can be used:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\\
    & \verb|    ( min::stub * s,| \\
    & \verb|      min::unsptr new_size, min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_ptr\_ref}%
	     \verb| ( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_PTR_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}%
	     \verb| ( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\verb|void MUP::| & \MUPKEY{retype\_resize\_body}\ARGBREAK
	     \verb| ( MUP::resize_body & rb, int new_type )| 
\LABEL{MUP::RETYPE_RESIZE_BODY} \\
\end{tabular}\end{indpar}

When constructed the \verb|MUP::resize_body| datum allocates
a new body for a stub \verb|s|, and when deconstructed the datum
installs the new body in the stub \verb|s| while deallocating the
old body of \verb|s|.  Stub \verb|s|
is not altered until the {\tt MUP::\EOL resize\_\EOL body}
datum is deconstructed, and the {\tt MUP::\EOL abort\_\EOL resize\_\EOL body}
function can be used to abort the body resizing
and prevent stub \verb|s| from ever being altered.
The sizes of the old and new body of \verb|s| must be passed to
the {\tt MUP::\EOL resize\_\EOL body} constructor.

Given a {\tt MUP::\EOL resize\_\EOL body} datum \verb|rb|,
\begin{center}
\verb|MUP::new_body_ptr_ref ( rb )|
\end{center}
returns a pointer to a pointer to the new body.  The first pointer
points to a location P with a fixed address that exists as long
as the {\tt MUP::\EOL resize\_\EOL body} datum \verb|rb| exists.   P holds
a pointer to the new body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS})
as all bodies
can be, and will be pointed to by a changed value of P if it is
relocated.

After the new body is obtained, information should be copied from
the old body to the new body before the {\tt MUP::\EOL resize\_\EOL body}
datum is deconstructed.  The new body will not be touched by
the garbage collector while the {\tt MUP::\EOL resize\_\EOL body} datum
exists, but it may be relocated.  The existing stub \verb|s|
\underline{must} be protected from garbage collection and
its body protected from reorganization by the user while the
{\tt MUP::\EOL resize\_\EOL body} datum exists, but that body may
also be relocated.  \verb|s| must NOT be deallocated
while the {\tt MUP::\EOL resize\_\EOL body} datum exists, unless
{\tt MUP::\EOL abort\_\EOL resize\_\EOL body} has been called.

Normally the type of stub \verb|s| is not changed, but
if the {\tt MUP::\EOL retype\_\EOL resize\_\EOL body} function is called
with a new stub type value, that value will be installed in stub \verb|s|
if and when the new body is installed in stub \verb|s|.

\subsection{Numbers}
\label{NUMBERS}

A \key{number stub} is collectible, has \minnbkey{NUMBER}\LABEL{MIN::NUMBER}
stub type code, and has
an immutable \verb|min::float64| stub value that can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT}\verb| ( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{tabular}\end{indpar}

Number stubs exist only in compact implementations;
in loose implementations number atoms are stored exclusively
in direct number general values
(\itemref{GENERAL-VALUE-SUBTYPES}).

General values that are numbers can be tested, created, and read
by the following protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_num}\verb| ( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of}\verb| ( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash}\verb| ( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\end{tabular}\end{indpar}

The \verb|min::is_num| function for a loose 64-bit \verb|min::gen| argument
is just another name for the \verb|min::is_direct_float| function of the same
argument.  For a compact 32-bit \verb|min::gen| argument the function returns
true if the argument is a direct integer or a stub pointer
pointing at a number stub.

The \verb|min::new_num_gen| function with \verb|min::float64| argument
and loose 64-bit \verb|min::gen| value
is just another name for {\tt min::new\_\EOL direct\_\EOL gen}, which
simply changes the type of its argument.
The \verb|min::new_num_gen| function with \verb|min::float64| argument
and compact 32-bit \verb|min::gen| value creates a direct integer
if the argument is an integer in the
require range; otherwise the function returns a \verb|min::gen| value
that is a pointer to a number stub.  If a pointer to a number stub is
to be returned and a number stub containing the argument value already exists,
a pointer to the existing stub is returned;
otherwise a new number stub is created and a pointer to it returned.
Therefore two 32-bit \verb|min::gen| values that represent equal numbers are
themselves \verb|==|.

The \verb|min::new_num_gen| function with an \verb|int| or \verb|min::unsptr|
argument does the
same thing as it would with its argument converted to a \verb|min::float64|
value, but is more efficient in the case where \verb|min::gen| values
are 32 bits and the argument is in the range of a direct integer general
value.

The \verb|min::float_of| function for a loose 64-bit \verb|min::gen|
argument is just another name for the \verb|min::direct_float_of| function
of the same argument, which after checking the subtype of the argument,
simply changes the type of the argument.
For a compact 32-bit \verb|min::gen| argument the
function returns any integer stored directly
in the argument converted to a 64-bit IEEE floating point number, or
returns the stub value for any number stub pointed at by the argument.
In this last case the stub type code is checked by a \verb|MIN_ASSERT|
statement to be sure the stub is a number stub.

The \verb|min::int_of| function does the same thing as the
\verb|min::float_of| followed by conversion to an \verb|int| value,
except that \verb|min::int_of| includes a check that the result
is a pure integer, without any fractional part, and is within the
range of the \verb|int| type, and
\verb|min::int_of| is more efficient when given a 32-bit direct integer
\verb|min::gen| argument.

Lastly, the \verb|min::numhash| function
returns the hash value of a \verb|min::gen|
value that is a number.  This value is computed by considering
the \verb|min::float_of| value of the number
to be a \underline{big endian} string of 8 characters and using the algorithm
on \pagref{HASH-ALGORITHM} to compute the hash value of this string.%
\label{NUMBER-HASH-ALGORITHM}

To permit hash values of arbitrary floating point numbers to be computed,
the following function is provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{floathash}\verb| ( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{tabular}\end{indpar}

The above \verb|min::float_of|, \verb|min::int_of|, and \verb|min::numhash|
functions of a \verb|min::gen| argument apply \verb|MIN_ASSERT| to check
that their argument is a number.  The following unprotected function assumes
that its argument is a number without doing any \verb|MIN_ASSERT| check:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN}
\end{tabular}\end{indpar}

\subsection{Strings}
\label{STRINGS}

In MIN all \skey{string}s\index{strings@strings}
are NUL terminated UTF-8 encoded UNICODE character strings.
\key{UTF-8} encodes 32-bit UNICODE characters in 1 to 7 \verb|char|'s.

All ASCII characters are encoded as themselves in
the UTF-8 encoding.  This implies that
all ASCII character strings are UTF-8 encoded character
strings with the same characters as their ASCII representation indicates.%
\footnote{ASCII character codes range from 0 through 127.  UTF-8 extends
this by assigning meaning to codes from 128 to 255.}

It is possible for a string to be miscoded UTF-8.  None
of the functions given below, including the protected functions,
check for this.

A MIN string value cannot store the NUL character as legal UTF-8.
But it is possible to use the `\key{modified UTF-8}' encoding instead of
strict UTF-8.  The difference is that strict UTF-8 encodes the NUL
character in a single byte as an ASCII NUL, whereas modified UTF-8
encodes the NUL character as the `overlong' 2-byte string `\verb|0xC0,0x80|'
(which is not legal in strict UTF-8 because it is not the shortest
possible encoding of NUL in UTF-8).

There are two kinds of string stubs: short strings and long strings.
In addition, a string of up to 3 {\tt char}'s can be stored within a 32-bit
\verb|min::gen| value, and a string of up to 5 {\tt char}'s can be stored
within a 64-bit \verb|min::gen| value,
without using a stub
(see \itemref{GENERAL-VALUE-SUBTYPES} and
\itemref{GENERAL-VALUE-FUNCTIONS}).
Such strings are called \skey{direct string}s, while strings stored in
stubs or bodies which are pointed at by \verb|min::gen| values,
the short and long strings, are called \skey{indirect string}s.
A short string holds up to 8 characters inside the string stub
(there must be more characters than a direct string will hold).
A long string has an string body that holds the string characters
(there must be more than 8)
along with the string length and hash value.

All three kinds of strings, direct, short, and long, are immutable
and have hash values (\pagref{HASH-VALUE}).

\subsubsection{Protected String Functions}
\label{PROTECTED-STRING-FUNCTIONS}

There are protected functions accessing general values that denote
strings of any kind without distinction, and these are described next.
Unprotected functions that apply only to particular
types of string are described later in this section.

The following functions create new general string values:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb| ( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\end{tabular}\end{indpar}

The \verb|min::new_str_gen| functions copy the input string after the
manner of \verb|strcpy| and \verb|strncpy|, respectively.  That is,
they copy from \verb|p|
until a NUL is copied or \verb|n| characters have been copied, whichever
comes first.

When a string general value
is created, if the input string is short enough for the general value
to hold the string itself, a direct string general value is created.
Otherwise \verb|min::new_str_gen| searches to see if any equal string
exists.  If such a string exists, a pointer to the stub of the existing
string is returned in the new \verb|min::gen| value, and no new stub
is created.  Otherwise, if the input string is 8 or fewer {\tt char}'s,
a short string stub is created, and if the input string has more
than 8 {\tt char}'s, a long string stub and body are created.

Thus if two string \verb|min::gen| values are equal as
strings, they have \verb|==| \verb|min::gen| values.

There is also a function to create a new general string value from
a vector of UNICODE characters:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb| ( const min::uns32 * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_UNICODE} \\
\end{tabular}\end{indpar}

Here UNICODE characters are represented as \verb|min::uns32| values.

The following may be used to convert between UNICODE
characters and \key{UTF-8} strings:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 min::|
    & \MINNBKEY{UTF8\_ILLEGAL}
\LABEL{MIN::UTF8_ILLEGAL} \\
\verb|min::uns32 min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb| ( const char * & s )|
\LABEL{MIN::UTF8_TO_UNICODE} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb| ( char * & s, min::uns32 c )|
\LABEL{MIN::UNICODE_TO_UTF8} \\
\end{tabular}\end{indpar}

The {\tt min::uft8\_to\_unicode} function reads a UTF-8 encoded character
from \verb|s|, updating \verb|s| to point after the character, and returns
the character.  {\tt min::\EOL unicode\_\EOL to\_\EOL utf8} writes
a UTF-8 character \verb|c| into \verb|s|, updating \verb|s| to point after the
character, and returns the number of bytes written.

The {\tt min::uft8\_to\_unicode} function will accept
\mkey{overlong}{UTF-8 encoding} UTF-8 encodings as legal,
and also accept 7-byte encodings (first byte {\tt 0xFE})
so that $2^{32}-1$ can be encoded.  If it encounters an
encoding with the wrong number of continuation bytes,
or if it encounters a continuation byte with no preceeding
start byte, it returns \verb|min|::\MINNBKEY{UTF8\_\EOL ILLEGAL},%
\label{UTF8_ILLEGAL}
which is 2368 (hexadecimal), the `\key{smirk}', a.k.a
the APL FUNCTIONAL SYMBOL TILDE DIAERESIS, $\stackrel{..}{\sim}$.
In this case \verb|s| is updated to just after the illegal encoding.
No other checks for illegal UNICODE characters are made.

The {\tt min::unicode\_to\_utf8} function will output
7-byte encodings (first byte {\tt 0xFE}) for
UNICODE character values {\tt => 0x80000000}, and will output
the overlong encoding {\tt 0xC0},{\tt 0x80}
for \ttnbmkey{NUL}{UTF-8 encoding}
(UTF-8 in which this is the \underline{only} permitted overlong encoding
is called `modified UTF-8').  No other overlong encodings are output.

The following functions test a \verb|min::gen| value to see if it
is a string and obtain information from
a string \verb|min::gen| value.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{is\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\[1ex]
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\verb| ( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::|
    & \MINKEY{strncpy}\verb| ( char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\[1ex]
\verb|int min::| & \MINKEY{strcmp}\verb| ( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::|
    & \MINKEY{strncmp} \\
    & \verb|    ( const char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\end{tabular}\end{indpar}

Five of these functions correspond to the standard C/C++
{\tt strlen}, {\tt strcpy}, {\tt strncpy}, {\tt strcmp},
and {\tt strncmp} functions, and differ
from these only in that instead of taking a {\tt char *} source string
argument, these functions take a {\tt min::gen} source argument.

To permit hash values of arbitrary strings to be computed,
without creating {\tt min::gen} values from them first,
the following functions are provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash}\verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{tabular}\end{indpar}

Both \verb|strhash| and \verb|strnhash| accept NUL terminated strings, but
\verb|strnhash| stops reading the string after the first \verb|n| characters
if none of these characters is NUL.

A string hash value is computed according to the following machine
independent algorithm:\label{HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = 0
n = length of string
for i = 1 through n:
    c = i'th char of string as unsigned 8 bit integer
    hash = ( hash * 65599 ) + c
if hash = 0, then hash = 2**32 - 1
\end{verbatim}\end{indpar}

where the final result is truncated to 32 bits.  The constant
is a prime such that multiplication by it may be turned into
shifts and adds by compilers: $65599=2^{16}+2^6-1$.
A hash value is never zero (so zero can be used to denote a missing hash value).

The low order bits of the hash value are random, so it can be
truncated to provide a random hash.

\subsubsection{Protected String Pointers}
\label{PROTECTED-STRING-POINTERS}

A read-only pointer to the characters of a string {\tt min::gen} value can
be obtained using the following functions to create and use
a \key{string pointer}:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MIN::STR_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MIN::STR_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( min::str_ptr & sp, min::gen v )|
\LABEL{MIN::=_STR_PTR_OF_GEN} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( min::str_ptr & sp1, const min::str_ptr & sp2 )|
\LABEL{MIN::=_STR_PTR_OF_STR_PTR} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( min::str_ptr & sp1, const min::stub * s )|
\LABEL{MIN::=_STR_PTR_OF_STUB} \\
\verb|const char & |
    & \TTOMKEY{[ ]}{[ ]}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( const min::str_ptr & sp, int index )|
\LABEL{MUP::[]_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::str_ptr & sp )|
\LABEL{MIN::STRLEN_OF_STR_PTR} \\
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( min::str_ptr & sp )|
\LABEL{MIN::STRHASH_OF_STR_PTR} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\verb| ( char * p, min::str_ptr & sp )|
\LABEL{MIN::STRCPY_OF_STR_PTR} \\
\verb|char * min::|
    & \MINKEY{strncpy}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( char * p,| \\
      \verb|   min::str_ptr & sp, min::unsptr n )| \\[1ex]
      \end{tabular}
\LABEL{MIN::STRNCPY_OF_STR_PTR} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp}\verb| ( const char * p, min::str_ptr & sp )|
\LABEL{MIN::STRCMP_OF_STR_PTR} \\
\verb|int min::|
    & \MINKEY{strncmp}%
      \begin{tabular}[t]{@{}l@{}}
      \verb|( const char * p,| \\
      \verb|  min::str_ptr & sp, min::unsptr n )| \\[1ex]
      \end{tabular}
\LABEL{MIN::STRNCMP_OF_STR_PTR} \\[1ex]
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( min::str_ptr & sp )|
\LABEL{MUP::STR_OF_STR_PTR} \\
\end{tabular}\end{indpar}

The constructors create a string pointer pointing to the {\tt char}'s
of the string specified by the \verb|min::gen| or
`\verb|min::stub *|' argument.  A \verb|min::gen| argument
must be a direct string or a pointer to a short or long string stub,
and a stub pointer must be a pointer to a short or long string stub,
or be {\tt min::\EOL NULL\_\EOL STUB}.
The {\tt =} operator can reset the string
pointer to point at a different \verb|min::gen| value, or at the
value pointed at by another string pointer.
If a constructor is given no argument or 
{\tt min::\EOL NULL\_\EOL STUB},
or the {\tt =} right side is
{\tt min::\EOL NULL\_\EOL STUB}, the string pointer is set to not
point at anything, and using it is undefined (but will probably
cause a memory fault).

The \verb|strlen|, \verb|strhash|, \verb|strcpy|, \verb|strncpy|,
\verb|strcmp|, and \verb|strncmp| functions retrieve the same information
about the string pointed at by a string pointer as they retrieve about
the string value the pointer points at.

The {\tt MUP::str\_of} function returns a standard C++ pointer to the string,
taking care to ensure the vector of {\tt char}'s is NUL-terminated.
The value of {\tt min::str\_of} will become obsolete if the string is
relocated, and in particular, may become obsolete if a relocating
function is called.  This is why this function is unprotected.

The \verb|[ ]| operator can be used to access individual characters
in a string.  If {\tt sp} is a string pointer, `\verb|sp[i]|' is
shorthand for `\verb|MUP::str_of(sp)[i]|'.  There is no protection
against \verb|i| being longer than the string length.

For direct and short strings the string pointer, when it is created,
copies the string {\tt char}'s into a buffer internal to the string pointer,
in order to save the {\tt char}'s in a direct string value, or to
add a missing NUL to the end of the short string {\tt char} vector.
In long string cases no copying is done, and the string pointer
is essentially just a pointer to the string stub, which in turn points
at the string proper inside a relocatable string body.

\subsubsection{Unprotected String Functions}
\label{UNPROTECTED-STRING-FUNCTIONS}

The constructor

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) MUP::| & \MUPKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MUP::STR_PTR_OF_GEN} \\
\verb|(constructor) MUP::| & \MUPKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MUP::STR_PTR_OF_STUB} \\
\verb|(constructor) MUP::| & \MUPKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MUP::STR_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp, min::gen v )|
\LABEL{MUP::=_STR_PTR_OF_GEN} \\
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp1, const min::str_ptr & sp2 )|
\LABEL{MUP::=_STR_PTR_OF_STR_PTR} \\
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp1, const MUP::str_ptr & sp2 )|
\LABEL{MUP::=_STR_PTR_OF_MUP_STR_PTR} \\
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp1, const min::stub * s )|
\LABEL{MUP::=_STR_PTR_OF_STUB} \\
\end{tabular}\end{indpar}

is just like \verb|min::str_ptr| except that it assumes that
\verb|v| or `{\tt min::\EOL stub~*}' is a string
(i.e., that {\tt min::\EOL is\_\EOL str(v)} is
true).  The {\tt =} operator applied to an
unprotected string pointer also makes the same assumption.

The following unprotected functions
may be used to access the internals of short
and long strings.

A \key{short string stub}\label{SHORT-STRING-STUB} is collectible, has
\minnbkey{SHORT\_STR}\LABEL{MIN::SHORT_STR} stub type code, and has
an immutable {\tt min::\EOL uns64} stub value that holds a NUL padded
8 \verb|char| vector and can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::|
    & \MUPKEY{short\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::SHORT_STR_OF}
\end{tabular}\end{indpar}

This function does \underline{not} check the type of the stub \verb|s|.
The \verb|min::uns64| value returned by \MUPkey{short\_str\_of}
should be overlaid by a union with a \verb|char[ ]| buffer, as in

\begin{indpar}\begin{verbatim}
union { min::uns64 str; char buf[9]; } u;
min::stub * s1;
. . . set s1 to point at a short string stub . . .
u.str = MUP::short_str_of ( s1 );
u.buf[8] = 0;	// Be sure result is NUL terminated.
cout << u.buf;
\end{verbatim}\end{indpar}

Short string values are NUL (zero) padded 0 to 8 \verb|char|
strings.  To be sure any value read is NUL terminated, a NUL (zero)
must be stored after the value read, as is done by \verb|u.buf[8] = 0|
in the example.

A \key{long string stub}\label{LONG-STRING-STUB} is collectible, has
\minnbkey{LONG\_STR}\LABEL{MIN::LONG_STR} stub type code, and has
a value that is a pointer to a \MUPkey{long\_str} type body
which holds an arbitrary length NUL terminated \verb|char| string.

The long string body consists of the 32-bit length and 32-bit hash value
of the string, followed by a \verb|char|
vector containing the string proper with the terminating NUL.  The
\verb|char| vector is padded to a multiple of 8 bytes with NUL
bytes, but the terminating NUL and the padding are not included
in the length.

The following are unprotected functions to return a relocatable pointer to the
long string body, a relocatable pointer to the string itself,
and the length and hash of the string.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{tabular}\end{indpar}

These functions are unprotected because \verb|long_str *| pointers
are relocatable.


\subsection{Labels}
\label{LABELS}

Attribute labels are often atoms, i.e., single strings or numbers.
But they may be sequences of atoms.  Such sequences are represented by
\skey{label}s.\footnote{Labels could also be represented by
sublists stored inside objects (\pagref{LIST-LEVEL}), but each label tends to
be reused by many objects, and storing it inside each using object
would be inefficient.  In addition labels are useful as function arguments.}
Labels may also be elements of other labels.

A label is just a vector of name components, where a name
component is an atom or a label.  However, labels are immutable and
have the property that no two distinct label stubs can have equal vectors of
name components.  

Note that a label of one element
is distinct from the element itself and has a different
hash code.  Also note that labels can be elements of labels.  A programming
language may wish to require that the elements of labels be numbers or
strings, that numbers and strings be treated as labels of one element,
and that proper labels with one element not be created.  But the
\verb|min.h| code does not do this.

A \key{label stub}\label{LABEL-STUB} is collectible,
has \minnbkey{LABEL}\LABEL{MIN::LABEL} stub type code,
and has an immutable value.
The label value may be read by using {\tt min::\EOL lab\_\EOL pointer}'s:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MIN::LAB_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( const min::stub * s )|
\LABEL{MIN::LAB_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MIN::LAB_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt min::lab\_ptr}}\ARGBREAK
          \verb| ( const min::lab_ptr & labp )|
\LABEL{MIN::LAB_PTR_TO_MIN_STUB} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb| ( min::lab_ptr & labp, min::gen v )|
\LABEL{MIN::=_LAB_PTR_OF_GEN} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb| ( min::lab_ptr & labp, const min::stub * s )|
\LABEL{MIN::=_LAB_PTR_OF_STUB} \\
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb| ( const min::lab_ptr & labp,|\ARGBREAK
	  \verb|   min::uns32 i )|
\LABEL{MIN::[]_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{length\_of}\ARGBREAK
	  \verb| ( min::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{hash\_of}\ARGBREAK
	  \verb| ( min::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

Here \verb|v| or \verb|s| must point at the stub of a label,
and given a label pointer \verb|labp| pointing at
a label, \verb|labp[i]| is the \verb|i|+1's
element of the label, for
$0\leq$\verb|i|$<$\verb|min::length_of(labp)|,
where the {\tt min::\EOL length\_\EOL of} function
returns the number of elements in the label.
Note that \verb|labp[i]| is read-only, but one can take
its address, as in:
\begin{indpar}\begin{verbatim}
memcpy ( ..., & labp[0], sizeof ( T ) * min::length_of ( labp ) );
\end{verbatim}\end{indpar}

The form of constructor that has no argument creates a label pointer
that is not pointing at any label, and will produce undefined results
if used (typically usage causes a memory fault).  Such a label pointer can also
be created by giving the constructor the argument
{\tt min::\EOL NULL\_\EOL STUB}.  The {\tt =} operator can be used
to change the label a label pointer is pointing at, or by setting the
label pointer to {\tt min::\EOL NULL\_\EOL STUB}, make the pointer
not point at any label.

The length of a label is the number of elements (general values) in the label.
The length of a label may be read from a label pointer, or may be read
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{tabular}\end{indpar}

The hash value of a label may be computed from the label pointer, or
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|const min::uns32 min::| & \MINKEY{labhash\_initial}\verb| = 1009|
\LABEL{MIN::LABHASH_INITIAL} \\
\verb|min::uns32 min::| & \MINKEY{labhash}%
    \verb| ( min::uns32 hash, min::uns32 h )|
\LABEL{MIN::LABHASH_INCREMENTAL} \\
\verb|min::uns32 min::| & \MINKEY{labhash}%
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{tabular}\end{indpar}

The last function computes the hash value for a label that could be created
from the given vector {\tt p} of {\tt n} general values, where each
general value is a name component.  The hash of a label is computed from
the hash of each of its elements using the following
machine independent algorithm:\label{LABEL-HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = min::labhash_initial;
n = length of label
for i = 1 through n:
    h = hash of i'th element of label
    hash = ( hash * ( 65599 ** 10 ) ) + h
    if hash = 0, then hash = 2**32 - 1
\end{verbatim}\end{indpar}

Comparing this with the hash algorithm for strings
on \pagref{HASH-ALGORITHM}, one sees that as long as
label elements are numbers and strings of fewer than 10 characters,
the hash of a label is equivalent to the hash of the
string made by concatenating a prefix and then the label elements, where each
string of fewer than 10 characters is padded to 10 characters
by prefacing it with NUL characters.  Note that
numbers are treated as 8 character strings; see
\pagref{NUMBER-HASH-ALGORITHM}.  The prefix is any 10 character string with
hash value {\tt min::\EOL labhash\_\EOL initial = 1009}.

The two argument \verb|labhash ( hash, h )| function performs the
incremental step in the computation of a label hash, and can be useful
in some lookup situations.  More specifically, the above algorithm
is equivalent to:

\begin{indpar}\begin{verbatim}
hash = min::labhash_initial;
n = length of label
for i = 1 through n:
    hash = labhash ( hash, hash of i'th element of label )
\end{verbatim}\end{indpar}

Although label values are generally read using lab pointers,
a label value may be read by the protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   const min::stub * s )|
	  \end{tabular}
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   min::gen v )|
	  \end{tabular}
\LABEL{MIN::LAB_OF_GEN} \\
\end{tabular}\end{indpar}

These read an initial segment of the label vector into the location
addressed by {\tt p}.  If the label vector has {\tt n} or more elements,
the first {\tt n} elements are read.  Otherwise, as many elements as
the label vector has are read.  The number of elements read is returned
in any case.  The label can be denoted by either its stub address or
by a general value pointing at its stub address.

A label may be created by the following protected function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}%
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\end{tabular}\end{indpar}

Here {\tt p} must point to a vector of {\tt n} \verb|min::gen|
values that becomes the value vector of the label.  Each
\verb|min::gen| value must be a name component.
This function returns any existing label with elements equal to
those given by the function arguments, in preference to creating a new
label.  Thus two \verb|min::gen| label values with equal elements are
\verb|==|.

The following function returns true if and only if its argument is
a label:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_lab}\verb| ( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\end{tabular}\end{indpar}

The following unprotected constructors are just like their
protected versions except that they assume any \verb|min::gen|
value \verb|v| or \verb|min::stub *| value \verb|s| is a label:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MUP::LAB_PTR_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::stub * s )|
\LABEL{MUP::LAB_PTR_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MUP::LAB_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::lab\_ptr}}\ARGBREAK
          \verb| ( const MUP::lab_ptr & labp )|
\LABEL{MUP::LAB_PTR_TO_MIN_STUB} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb| ( MUP::lab_ptr & labp, min::gen v )|
\LABEL{MUP::=_LAB_PTR_OF_GEN} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb| ( MUP::lab_ptr & labp, const min::stub * s )|
\LABEL{MUP::=_LAB_PTR_OF_STUB} \\
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb| ( const MUP::lab_ptr & labp,|\ARGBREAK
	  \verb|   min::uns32 i )|
\LABEL{MUP::[]_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

The {\tt =} operator applied to these unprotected
pointers also makes the same assumption.

\subsection{Names}
\label{NAMES}

A \key{name} is a
number (\itemref{NUMBERS}),
string (\itemref{STRINGS}),
or label (\itemref{LABELS}), i.e., it is an atom or a label.
A name can also be viewed as
a sequence of \skey{name component}s, each of which is a number, string,
or label.
Names and name components are all immutable values which have an associated
hash value.

A number or string is used to represent a 1-component name whose
only component is the number or string.  Other names are represented
by labels whose elements are the components of the names.  A label whose
only component is a number or string is \underline{not}
used to represent a name, in order to ensure that each name has a unique
representation.

The following functions concern names:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_name}\verb| ( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash}\verb| ( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare}\verb| ( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\end{tabular}\end{indpar}

The \verb|min::is_name| function returns true if and only if its argument is
a name (number, string, or label).

The \verb|min::hash| function returns a non-zero
\key{hash value}\label{HASH-VALUE} of its argument, which must be
a name.

The \verb|min::compare| function returns an integer $<0$, $=0$, or $>0$
according to whether its \verb|v1| argument is less than, equal to, or
greater than its \verb|v2| argument.
In this ordering numbers are
before strings, strings are before labels, and labels are before
any non-name values.  Numbers are ordered
numerically, strings are ordered lexicographically as per the
C language \verb|strcmp| function, and labels are ordered lexicographically
using the {\tt min::\EOL compare} function recursively to compare
label elements.  Non-name values are ordered by converting their
\verb|min::gen| values to bit strings and comparing the bit strings.
This means that \verb|min::gen| values that point at stubs are ordered
according to their stub addresses.

It is an error to pass a non-name argument to
either the \verb|min::hash| and \verb|min::compare| function.

\subsection{Packed Structures}
\label{PACKED-STRUCTURES}

\newcommand{\SARG}{\BRACKETED{S}}
\newcommand{\EHARG}{\BRACKETED{E,H}}
\newcommand{\EARGDEFAULT}{\BRACKETED{{E,H = min::packed\_vec\_header}}}
\newcommand{\EARG}{\BRACKETED{{E,H}}}

A \key{packed structure} is a C `struct' stored in a body associated
with a stub that has a \minnbkey{PACKED\_STRUCT}\LABEL{MIN::PACKED_STRUCT}
stub type code.

The C type of a packed structure must be a C \verb|struct|
initializable by setting all bytes to zero and copiable
by \verb|memcpy|.
Its \underline{first} member must be
\begin{center}
\verb|const min::uns32 control;|
\end{center}
This first member holds subtype information and flags.
\verb|min::gen| and \verb|min::stub *| values are permitted as members
of the \verb|struct|.
C++ classes are not permitted, as member types must \underline{not}
have constructors or destructors and must be copyable with
a simple `{\tt =}' operator or with the \verb|memcpy| function.

There are two types of pointers that can be used to
access members of packed structures:
\begin{indpar}\begin{tabular}{l@{~~~~~a.k.a~~~~~}l}
\verb|min::packed_struct_ptr<S>| & \verb|min::packed_struct<S>::ptr| \\
\verb|min::packed_struct_updptr<S>| & \verb|min::packed_struct<S>::updptr|
\end{tabular}\end{indpar}
where \verb|S| is the C type of the structure.
The first \mkey{read-only pointer}{to packed structure} type
permits read-only access to packed structure members,
while the second \mkey{updatable pointer}{to packed structure} type
permits read-write access.
These pointers are like the type `\verb|const min::stub *|' but with with extra
clothes.
Pointers of these types can also be included as members in C packed structures
and packed vector headers and elements (see \itemref{PACKED-VECTORS}).

The C type of a packed structure is described at run-time by a
{\tt min::packed\_\EOL struct\SARG} C++ static object, where
\verb|S| is the C type of the structure.
The {\tt new\_gen} and {\tt new\_stub}
member functions of this C++ static object can be
used to create new packed structures of the described type.

More explicitly, to create a new type of \key{packed structure}
named \verb|pstype| use

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\SARG} \verb|pstype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_with\_base\BRACKETED{S,B}}
		\verb|pstype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE_WITH_BASE} \\
\verb|min::uns32 min::| & \MINNBKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINNBKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen pstype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\verb|const min::stub * pstype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_STUB} \\
\verb|min::uns32 pstype|
    & \TTDMKEY{subtype}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_SUBTYPE} \\
\verb|const char * const pstype.|
    & \TTDMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{gen\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISP} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{stub\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_DISP} \\
\end{tabular}\end{indpar}

where

\begin{itemlist}[0.5in]

\item[{\tt S}]
The C type of the body of packed structures of the type being
declared.  This C type must be a C \verb|struct| whose first
member is
\begin{center}
\verb|const min::uns32 control;|
\end{center}
This member holds a code effectively
points at \verb|pstype|, and also holds some flags.
This member is initialized by \verb|new_gen| and must not
be changed by the user.

Only C language syntax may be used in defining the type {\tt S},
except that a single base type may be be used, as in
\begin{indpar}\begin{verbatim}
struct S : public struct B { ... }
\end{verbatim}\end{indpar}
provided that {\tt B} is also a C language structure in this sense.
In this case {\tt S} does
\underline{not} have a `{\tt control}' member, as
the `{\tt control}' member of {\tt B} serves as
the `{\tt control}' member of {\tt S}.

\item[{\tt B}]
The C type of the base of {\tt S}, as indicated above.  If {\tt B}
is also the type of a packed \underline{structure} body, use
{\tt packed\_\EOL struct\_\EOL with\_\EOL base\BRACKETED{S,B}}
in order to enable conversion of
{\tt min::\EOL packed\_\EOL struct\_\EOL xxxptr<S>} pointers
to {\tt min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>}
pointers.

\end{itemlist}

\begin{itemlist}[0.8in]

\item[\ttmkey{subtype}{in {\tt min::packed\_struct}}]
A small integer automatically assigned to uniquely identify \verb|pstype|.
This is stored in the `{\tt control}' member of all packed
structures that are created by {\tt pstype.new\_\EOL gen} or
{\tt pstype.new\_\EOL stub}, and serves as a pointer from any
of these packed structures to \verb|pstype|.

\item[\ttmkey{name}{in {\tt min::packed\_struct}}]
A name unique to the \verb|pstype| datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed structure type when a packed structure is
output.

\end{itemlist}

\begin{itemlist}[1.0in]

\item[\ttmkey{gen\_\EOL disp}{in {\tt min::packed\_struct}}]
This C vector is a list of the displacements (in bytes) of all
the \verb|min::gen| members of \verb|S|,
terminated by the value {\tt min::DISP\_END}\minindex{DISP\_END}.
The displacement of member \verb|m| in structure type \verb|S| should
be computed by {\tt min::\EOL DISP(\&S::m)}.

This displacements vector should not
be given (its address should be \verb|NULL|) if there are no \verb|min::gen|
values in \verb|S|.  But if there are \verb|min::gen| members, this
displacements vector must be given for garbage collection purposes.

\verb|const min::gen| members are treated like \verb|min::gen|
members for these purposes.

\item[\ttmkey{stub\_\EOL disp}{in {\tt min::packed\_struct}}]
Ditto but for \verb|min::stub *| members of \verb|S|
instead of \verb|min::gen| members.

Pointer-to-packed-struct and pointer-to-packed-vector
\label{STUB_DISP}
members, i.e. {\tt min::\EOL packed\_\EOL struct\SARG::\EOL xxxptr} and
{\tt min::\EOL packed\_\EOL vec\EHARG::\EOL xxxptr} members,
are treated like `{\tt const min::\EOL stub~*}' values in that they
must be listed in {\tt stub\_\EOL ptr\_\EOL disp}.

Members of the types `\verb|const min::stub *|', `\verb|min::stub const *|', and
`{\tt const min::\EOL stub \EOL const~*}' are treated like
`{\tt min::\EOL stub~*}' members for these purposes.

\end{itemlist}

The \verb|pstype.new_gen| or \verb|pstype.new_stub|
functions create a new packed structure
datum of the C type described by \verb|pstype| and returns a
\verb|min::gen| or {\tt const min::\EOL stub~*} value pointing at it.
The new packed structure is set to all zeros, except for its
`\verb|control|' member.

The function call {\tt min::\EOL DISP~(~\&~S::m~)} will return the
displacement in bytes of the member \verb|m| of a structure
of \verb|struct| type \verb|S|.  This should be used instead of
assuming that \verb|struct| layouts are tightly packed, as often
they are not.  The type of the \verb|S::m| member must be one of
the types mentioned above: \verb|min::gen|, `{\tt const min::stub~*}',
{\tt min::\EOL packed\_\EOL struct\_\EOL ptr\SARG}, etc.

\verb|pstype.subtype|, \verb|pstype.name|,
{\tt pstype.gen\_\EOL disp},
and {\tt pstype.stub\_\EOL ptr\_\EOL disp}
can be used to retrieve the subtype, name, and displacement
information associated with \verb|pstype|.

The subtype of a packed structure can be retrieved by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{PACKED_STRUCT_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\end{tabular}\end{indpar}

when the argument is a value returned by
{\tt pstype.new\_\EOL gen} or {\tt pstype.new\_\EOL stub}.
Here the subtype is computed by looking in the
`{\tt control}' member of the packed structure.  Packed vectors
also have subtypes that can be discovered by
{\tt min::\EOL packed\_\EOL subtype\_\EOL of}
(see \pagref{PACKED_VEC_SUBTYPE_OF_GEN}),
but no packed structure
has the same subtype as any packed vector.

The two kinds of pointers that can be used to access
a packed structure.  The read-only
{\tt min::\EOL packed\_\EOL struct\_\EOL ptr\SARG} pointers
have the usage:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_ptr|{\tt \SARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::ptr}
\LABEL{MIN::PACKED_STRUCT_PTR_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::packed_struct_ptr<S> & |
	& \TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( min::packed_struct_ptr<S> & psp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_GEN} \\
\verb|min::packed_struct_ptr<S> & |
	& \TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( min::packed_struct_ptr<S> & psp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
          \verb| ( const min::packed_struct_ptr<S> & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_TO_MIN_STUB} \\
\verb|S const * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_ptr<S> & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_->} \\
\verb|S const & |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_ptr<S> & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_*} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * | & \MINNBKEY{NULL\_STUB}
\LABEL{MIN::NULL_STUB} \\
\end{tabular}\end{indpar}

A {\tt min::\EOL packed\_\EOL struct\_\EOL ptr \SARG} value is just
a `{\tt const min::stub~*}' value in fancy clothes, and may be
converted to/from a `{\tt const min::stub~*}' value.

For the constructors and the {\tt =} assignment operator \verb|v| or
\verb|s| must point at packed structure, or \verb|s| must equal
\verb|min::NULL_STUB|, which is just the standard C language \verb|NULL|
cast to the `\verb|const min::stub *|' type.  This cast is necessary
as \verb|NULL| by inself may be convertable to either a `\verb|min::stub *|'
or \verb|min::gen| type and is thus ambiguous when used in a constructor
or on the right side of \verb|=|.

A {\tt min::\EOL packed\_\EOL struct\_\EOL ptr\SARG} value is internally
also a `\verb|S const **|' value that is made to behave externally like a
also a `\verb|S const *|' value with respect to the \verb|->| and
unary \verb|*| operators.  Thus looking ahead at the example below,
if \verb|upv| is a
{\tt min::\EOL packed\_\EOL struct\_\EOL ptr\SARG} value
and \verb|S| has a member \verb|i|, then \verb|upv->i| is the \verb|i|
member of the \verb|S| struct pointed at by \verb|upv|.

Note that in certain
circumstances, such as inside a {\tt template} class,
component names like {\tt min::\EOL packed\_\EOL struct<S>::ptr} will not work
and the alternative {\tt min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
must be used instead.  The later are usually preferred anyway because
they can be defined without defining \verb|S|, and therefore can be
used to build recursive structures.

If a constructor for {\tt min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
is not given an argument, these the pointer is set to
\verb|min::NULL_STUB|.  Such a pointer gives undefined results if
used, though most frequently the result will be a memory fault.

The read-write {\tt min::\EOL packed\_\EOL struct\_\EOL updptr\SARG}
pointer type has the
{\tt min::\EOL packed\_\EOL struct\_\EOL ptr\SARG} pointer type as its
{\tt public} base class, so that it can be implicitly converted to
a read-only pointer.  The new code defined for this read-write
pointer type is:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|
	               \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_updptr|{\tt \SARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::updptr}
\LABEL{MIN::PACKED_STRUCT_UPDPTR_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::packed_struct_updptr<S> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}
	& \verb| ( min::packed_struct_updptr<S>|\\
	& \verb|        & psup,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_GEN} \\
\verb|min::packed_struct_updptr<S> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}
	& \verb| ( min::packed_struct_updptr<S>|\\
	& \verb|        & psup,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|S * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_struct\_udpptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_updptr<S> & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_->} \\
\verb|S & |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_updptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_updptr<S> & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_*} \\
\end{tabular}\end{indpar}

The {\tt ->} and {\tt *} operators are redefined (i.e., \underline{not}
inherited) so that they
return `{\tt S~*}' and `{\tt S~\&}' values instead of
`{\tt S~const~*}' and `{\tt S~const~\&}' values.

{\tt min::gen}, `{\tt const min::stub~*}', and
{\tt min::\EOL packed\_\EOL\ldots ptr\BRACKETED{\ldots}}
elements of packed structures must be locatable.
The {\tt MIN\_REF}\label{PACKED_STRUCT_MIN_REF}
macro described in Section~\itemref{LOCATABLE-MEMBER-REFERENCES}
should be used with a {\tt min::\EOL packed\_\EOL
struct\_\EOL updptr\SARG} container type
for locatable elements of a packed structure.

An example use of a packed structure is:
\begin{indpar}\begin{verbatim}
struct ps;
typedef min::packed_struct_ptr<ps> psptr;
typedef min::packed_struct_updptr<ps> psupdptr;
    // Note: pointers can be defined before struct is defined.

struct ps {
    min::uns32 control;
    min::uns32 i;
    min::uns32 j;
    const min::gen g;
    const psptr pv;
    const min::stub * const s;
};

MIN_REF ( min::gen, g, psupdptr )
MIN_REF ( psptr, pv, psupdptr )
MIN_REF ( const min::stub *, s, psupdptr )

static min::uns32 ps_gen_disp[2] =
    { min::DISP(&ps::g), min::DISP_END };
static min::uns32 ps_stub_disp[2] =
    { min::DISP(&ps::s), min::DISP(&ps::pv), min::DISP_END };

static min::packed_struct<ps> pstype
    ( "pstype", ps_gen_disp, ps_stub_disp );

main ( ... )
{
    . . . . . . .
    min::gen v1 = pstype.new_gen();
        // min::packed_subtype_of ( v1 ) == pstype.subtype
    psupdptr upv ( v1 );
        // min::packed_subtype_of ( upv ) == pstype.subtype
    upv->i = 55;
    upv->j = 99;
    g_ref(upv) = min::new_str_gen ( "Hello" );

    psptr pv = upv;
    // Upv is converted to a `const min::stub *' value
    // that is used to set pv.

    pv_ref(upv) = pv;
    upv = pstype.new_gen();
    // Now upv->i == 0, pv->i == 55, pv->pv->i == 55,
    //     upv->pv == min::NULL_STUB

    . . . . . . .
}
\end{verbatim}\end{indpar}

Packed structure pointers do no caching and
there is \underline{no need} for
a refresh function analogous to the {\tt min::\EOL \ldots\_\EOL refresh}
functions for list pointers (\pagref{LIST-POINTER-CACHE}).

\subsection{Packed Vectors}
\label{PACKED-VECTORS}

A \key{packed vector} is like a packed structure but with an added vector
that follows the structure at the beginning of the packed vector body,
and with a \minnbkey{PACKED\_VEC}\LABEL{MIN::PACKED_VEC}
stub type code instead of a {\tt min::\EOL PACKED\_\EOL STRUCT} type code.

The structure is called the packed vector \mkey{header}{of packed vector}.
Both the header and the vector elements must be C type data that can
be initialized by setting their bytes to all zeros and can be copied
by \verb|memcpy|.
\verb|min::gen| and \verb|min::stub *| values are permitted as members
of \verb|struct|s or as vector element types by themselves.
C++ classes are not permitted, as the types must \underline{not}
have constructors or destructors and must be copyable with
a simple `{\tt =}' operator or with the \verb|memcpy| function.

The C type of a packed vector header, like that of a packed structure,
must be a
C \verb|struct| whose first member is
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}
The header must also have the following two other members,
at no particular offset:
\begin{indpar}
\verb|const min::uns32 length;| \\
\verb|const min::uns32 max_length;|
\end{indpar}

The C type of a packed vector element may but need not be a `\verb|struct|';
it can be a numeric or pointer type or \verb|min::gen|.

There are also three pointer-to-packed-vector types:
\begin{indpar}\begin{tabular}{l@{~~~~~a.k.a~~~~~}l}
\verb|min::packed_vec_ptr<E,H>| & \verb|min::packed_vec<E,H>::ptr| \\
\verb|min::packed_vec_updptr<E,H>| & \verb|min::packed_vec<E,H>::updptr| \\
\verb|min::packed_vec_insptr<E,H>| & \verb|min::packed_vec<E,H>::insptr|
\end{tabular}\end{indpar}
where \verb|H| is the C type of the packed vector header struct and
\verb|E| is the C type of the packed vector element.
The first \mkey{read-only pointer}{to packed vector} type
permits read-only access to packed structure members,
the second \mkey{updatable pointer}{to packed vector} type
permits read-write access, while the
the third \mkey{insertable pointer}{to packed vector} type
permits read-write access \underline{and}
also permits pushing and popping vector elements
and resizing the vector.
These pointers are like the type `\verb|const min::stub *|' but with with extra
clothes.
Pointers of these types can also be included as members in C packed structures
and packed vector headers and elements.

A packed vector type is described at run-time by a
{\tt min::packed\_\EOL vec\EHARG} C++ static object, where
\verb|H| is the C type of the packed vector header and \verb|E| is the C type
of the packed vector element.
The {\tt new\_gen} and {\tt new\_stub}
member functions of this C++ static object can be
used to create new packed vectors of the described type.

More explicitly, to create a new type of \key{packed vector}
named \verb|pvtype| use

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{packed\_vec\_header}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const min::uns32 control;|\ARGBREAK
    \verb|  const min::uns32 length;|\ARGBREAK
    \verb|  const min::uns32 max_length;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PACKED_VEC_HEADER} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\EARGDEFAULT}{packed\_vec\EARG}
	      \verb|pvtype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                            = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_with\_base\BRACKETED{E,H,B}}
		\verb|pvtype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                            = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE_WITH_BASE} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_STUB_VOID} \\
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb| ( min::uns32 max_length,|\ARGBREAK
	  \verb|   min::uns32 length = 0,|\ARGBREAK
	  \verb|   E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb| ( min::uns32 max_length,|\ARGBREAK
	  \verb|   min::uns32 length = 0,|\ARGBREAK
	  \verb|   E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_STUB_MAX_LENGTH} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const char * const pvtype| & \TTDMKEY{subtype}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_SUBTYPE} \\
\verb|const char * const pvtype| & \TTDMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_DISP} \\[1ex]
\verb|min::uns32 pvtype| & \TTDMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 pvtype| & \TTDMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 pvtype| & \TTDMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{tabular}\end{indpar}

where

\begin{itemlist}[0.5in]

\item[{\tt E}]\label{PACKED_VEC_ELEMENT_TYPE}
The C type of the elements in the vector part of the
bodies of packed vectors of the type being
declared.  This need not be a \verb|struct| type; it can
be \verb|min::gen|, \verb|min::stub *|,
any pointer-to-packed-struct or pointer-to-packed-vector
type, or any numeric type.

\item[{\tt H}]\label{PACKED_VEC_HEADER_TYPE}
The C \verb|struct| type of the header data at the beginning of the
bodies of packed vectors of the type being
declared.  The first member of this \verb|struct| type must be
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}
and the \verb|struct| type must also have the two members
\begin{indpar}
\verb|const min::uns32 length;| \\
\verb|const min::uns32 max_length;|
\end{indpar}
These members are initialized by \verb|new_gen| or \verb|new_stub|
and must not
be changed by the user.

\verb|H| defaults to \verb|min::packed_vec_header| which
has just the require header members: \verb|control|, \verb|length|, and
{\tt max\_\EOL length}.  Because of this default,
\verb|H| is the \underline{second} template parameter,
even though is preceeds the vector elements in memory.

Only C language syntax may be used in defining the type {\tt H},
except that a single base type may be be used, as in
\begin{indpar}\begin{verbatim}
struct H : public struct B { ... }
\end{verbatim}\end{indpar}
provided that {\tt B} is also a C language structure in this sense.
In this case {\tt H} does
\underline{not} have a `{\tt control}' member, as
the `{\tt control}' member of {\tt B} serves as
the `{\tt control}' member of {\tt H}.  The `{\tt length}' and
`{\tt max\_length}' members may be in either {\tt H} or {\tt B}.

\item[{\tt B}]
The C type of the base of {\tt H}, as indicated above.  If {\tt B}
is also the type of a packed \underline{structure} body, use
{\tt packed\_\EOL vec\_\EOL with\_\EOL base\BRACKETED{E,H,B}}
in order to enable conversion of
{\tt min::\EOL packed\_\EOL vec\_\EOL xxxptr<E,H>} pointers
to {\tt min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>}
pointers.

Note that {\tt B} must be the type of a packed
structure and \underline{not} of a packed vector header.

\end{itemlist}

\begin{itemlist}[1.0in]

\item[\ttmkey{subtype}{in {\tt min::packed\_vec}}]
A small integer automatically assigned to uniquely identify \verb|pvtype|.
This is stored in the `{\tt control}' member of all packed
vectors that are created by {\tt pvtype.new\_\EOL gen} or
{\tt pvtype.new\_\EOL stub}, and serves as a pointer from any
of these packed vectors to \verb|pvtype|.

\item[\ttmkey{name}{in {\tt min::packed\_vec}}]
A name unique to the \verb|pvtype| datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed vector type when a packed vector is
output.

\end{itemlist}

\begin{itemlist}[1.6in]

\item[\ttmkey{header\_\EOL gen\_\EOL disp}{in {\tt min::packed\_vec}}]
This C vector is a list of the displacements (in bytes) of all
the \verb|min::gen| members of \verb|H|,
terminated by the value {\tt min::DISP\_\EOL END}\minindex{DISP\_END}.
This displacements vector should not
be given (its address should be \verb|NULL|) if there are no \verb|min::gen|
values in \verb|H|.  But if there are \verb|min::gen| members, this
displacements vector must be given for garbage collection purposes.

\item[\ttmkey{header\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \verb|min::stub *| members of \verb|H|.
See \pagref{STUB_DISP} for more details.

\item[\ttmkey{element\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \verb|min::gen| members of \verb|E|.

\item[\ttmkey{element\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \verb|min::stub *| members of \verb|E|.
See \pagref{STUB_DISP} for more details.

\end{itemlist}

\verb|pvtype.name|,~~
{\tt pvtype.header\_\EOL gen\_\EOL disp},
{\tt pvtype.header\_\EOL stub\_\EOL ptr\_\EOL disp},
~~{\tt pvtype.ele\-\EOL ment\_\EOL gen\_\EOL disp},
and {\tt pvtype.ele\-\EOL ment\_\EOL stub\_\EOL ptr\_\EOL disp}
can be used to retrieve the name and displacement
information associated with \verb|pvtype|.
In addition the parameters
{\tt pvtype.ini\-tial\_\EOL max\_\EOL length},
{\tt pvtype.increment\_\EOL ratio}, and
{\tt pvtype.max\_\EOL increment}
may be set by the user:


\begin{itemlist}[1.5in]

\item[\ttmkey{initial\_max\_length}{in {\tt min::packed\_vec}}]
The maximum length of a packed vector newly created by calling the
\verb|pvtype.new_gen| or \verb|pvtype.new_stub|
function with no arguments.  Defaults to \verb|128|.

\item[\ttmkey{increment\_ratio}{in {\tt min::packed\_vec}}]
The \verb|min::reserve| function multiplies the old maximum length by
this ratio to get the maximum length increment: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \verb|0.5|.

\item[\ttmkey{max\_increment}{in {\tt min::packed\_vec}}]
The maximum increment of the maximum length computable by the
\verb|min::reserve| function: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \verb|4096|.

\end{itemlist}

The \verb|pvtype.new_gen| or \verb|pvtype.new_stub|
function creates a new packed vector
datum of the C type described by \verb|pvtype| and returns a
\verb|min::gen| or \verb|const min::stub *|
value pointing at it.  A packed vector has a
\mkey{length}{of packed vector} which is the number of elements
currently in the packed vector.  It also has a
\mkey{maximum length}{of packed vector} which is the maximum length
allowed before the packed vector must be reallocated.
The \verb|pvtype.new_gen| or \verb|pvtype.new_stub|
function may be given the maximum length
and length and a vector of length type \verb|E| elements that is copied
to the initial value of the packed vector.
If the vector \verb|vp| of initial elements is given as \verb|NULL|,
the initial elements will be zeros.
If no parameters are given to
\verb|pvtype.new_gen| or \verb|pvtype.new_stub|,
the length defaults to \verb|0| and
the maximum length defaults to {\tt pvtype.initial\_\EOL max\_\EOL length}.

A newly created packed vector is set to all zeros, except for its
`{\tt control}', `{\tt length}', and `{\tt max\_\EOL length}' members.

The subtype of a packed vector can be retrieved by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{PACKED_VEC_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{PACKED_VEC_SUBTYPE_OF_STUB} \\
\end{tabular}\end{indpar}

when the argument is a value returned by {\tt pvtype.new\_\EOL gen}
or {\tt pvtype.new\_\EOL stub}.
Here the subtype is computed by looking in the
`{\tt control}' member of the packed vector.  Packed structures
also have subtypes that can be discovered by
{\tt min::\EOL packed\_\EOL subtype\_\EOL of}
(see \pagref{PACKED_STRUCT_SUBTYPE_OF_GEN}),
but no packed vector
has the same subtype as any packed structure.

There are three kinds of pointers that can be used to access
a packed vector.  The read-only
{\tt min::\EOL packed\_\EOL vec\_\EOL ptr\EARG}
packed vector pointer type has the usage:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr\EARGDEFAULT}{packed\_vec\_ptr\EARG}
	      \verb|pvp|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr\EARGDEFAULT}{packed\_vec\_ptr\EARG}
	      \verb|pvp|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr\EARGDEFAULT}{packed\_vec\_ptr\EARG}
	      \verb|pvp|\ARGBREAK
	  \verb| ( void )|
\LABEL{MIN::PACKED_VEC_PTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_ptr|{\tt \EHARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\EHARG::ptr}
\LABEL{MIN::PACKED_VEC_PTR_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::packed_vec_ptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}
	& \verb| ( min::packed_vec_ptr<E,H>|\\
	& \verb|        & pvp,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_GEN} \\
\verb|min::packed_vec_ptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}
	& \verb| ( min::packed_vec_ptr<E,H>|\\
	& \verb|        & pvp,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
          \verb| ( const min::packed_vec_ptr<E,H> & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_TO_MIN_STUB} \\
\verb|H const * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb| ( const min::packed_vec_ptr<E,H> & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_->} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 pvp| & \TTARMKEY{length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_LENGTH} \\
\verb|E const & pvp| & \TTBMKEY{i}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_[]} \\
\verb|E const * pvp| & \TTDMKEY{begin\_ptr()}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_BEGIN_PTR} \\
\verb|E const * pvp| & \TTDMKEY{end\_ptr()}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_END_PTR} \\
\end{tabular}\end{indpar}

As for packed structures, read-only packed vector pointers used as the left
operand of \verb|->| are converted to
`\verb|H const *|'.  This can be used to access the `\verb|length|'
and \verb|max_length| members of the header.

In addition subscripting read-only packed vector
pointers gives read-only access to the elements of the vector.  The subscripting
operator \verb|[]| checks the index \verb|i| against the current length
of the vector to ensure the access is legal (e.g., \verb|pvp[i]|
checks \verb|0|$\leq$\verb|i|$<$\verb|pvp->length|).
The vector elements in a
packed vector are organized as a C language vector so that
\begin{center}
\verb|(& pvp[0])[i]| is the same as \verb|pvp[i]|
\end{center}
but the vector elements are stored in a body whose address can change
if a relocating function is called, so saving C pointers to packed vector
elements is generally a bad idea.  However, temporary use within a single
statement is all right if the statement does not call a relocating
function.

\verb|pvp.begin_ptr()| is the same as `\verb|& pvp[0]|'
except the latter would fail if {\tt pvp->\EOL length == 0}.
\verb|pvp.end_ptr()| is the same as `\verb|& pvp[pvp->length]|'
except the latter will always fail because the index is not less than
\verb|pvp->length|.
These member functions are only useful
in code that does not call a relocating function.

For example, if \verb|memcpy| is used to copy
from the vector, use {\tt begin\_\EOL ptr()}:
\begin{indpar}\begin{verbatim}
memcpy ( ..., pvup.begin_ptr(), sizeof ( E ) * pvup->length );
\end{verbatim}\end{indpar}
Using \verb|& pvup[0]| instead of \verb|pvup->begin_ptr()|
will fail with a {\tt MIN\_\EOL ASSERT} fault if {\tt pvup->\EOL length == 0}.

The read-write {\tt min::\EOL packed\_\EOL vec\_\EOL updptr\EARG}
pointer type has as its {\tt public} base class the
{\tt min::\EOL packed\_\EOL vec\_\EOL ptr\EARG} pointer type,
so that read-write pointers can be implicitely converted to
read-only pointers.  The new code defined for the read-write
pointer type is:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr\EARGDEFAULT}%
	          {packed\_vec\_updptr\EARG}
	      \verb|pvup|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr\EARGDEFAULT}%
	          {packed\_vec\_updptr\EARG}
	      \verb|pvup|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr\EARGDEFAULT}%
	          {packed\_vec\_updptr\EARG}
	      \verb|pvup|\ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_updptr|{\tt \EHARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\EHARG::updptr}
\LABEL{MIN::PACKED_VEC_UPDPTR_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::packed_vec_updptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}
	& \verb| ( min::packed_vec_updptr<E,H>|\\
	& \verb|        & pvup,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_GEN} \\
\verb|min::packed_vec_updptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}
	& \verb| ( min::packed_vec_updptr<E,H>|\\
	& \verb|        & pvup,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|H * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb| ( const min::packed_vec_updptr<E,H>|\ARGBREAK
	  \verb|      & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_->} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|E & pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
    \hspace*{1.0in} [if \verb|E| \underline{not} locatable]
\LABEL{MIN::PACKED_VEC_UPDPTR_[]} \\
\verb|min::ref<E> pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
    \hspace*{1.0in} [if \verb|E| \underline{is} locatable]
\LABEL{MIN::PACKED_VEC_OF_STUB_PTR_UPDPTR_[]} \\
\verb|E * pvup|
    & \TTDMKEY{begin\_ptr()}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_BEGIN_PTR} \\
\verb|E * pvup| & \TTDMKEY{end\_ptr()}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_END_PTR} \\
\end{tabular}\end{indpar}

The {\tt ->} and {\tt []} operators and
{\tt begin\_ptr()} and {\tt end\_ptr()} members are
redefined (i.e., \underline{not}
inherited) so that they
return `{\tt H~*}', `{\tt E~*}' or `{\tt E~\&} values
instead of `{\tt H~const~*}', `{\tt E~const~*}', or `{\tt E~const~\&}' values.
The {\tt []} operator\label{PACKED_VEC_[]_REF}
is further redefined if {\tt E} is a locatable type
so that a {\tt min::\EOL ref\BRACKETED{E}} value is returned instead of
a `{\tt E~\&}' value.  This does for vector elements what
{\tt MIN\_REF} defined {\tt \ldots\_ref} functions do for structure
elements.

The {\tt MIN\_REF}\label{PACKED_VEC_MIN_REF}
macro described in Section~\itemref{LOCATABLE-MEMBER-REFERENCES}
should be used with a {\tt min::\EOL packed\_\EOL
vec\_\EOL updptr\SARG} container type
for locatable elements of a packed vector header.


The insertable {\tt min::\EOL packed\_\EOL vec\_\EOL insptr\EARG}
pointer type, which permits elements to be added to a packed vector,
has as its {\tt public} base class the
{\tt min::\EOL packed\_\EOL vec\_\EOL updptr\EARG} pointer type,
so that insertable pointers can be implicitely converted to
read-write or read-only pointers.  The new code defined for the insertable
pointer type is:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr\EARGDEFAULT}%
	          {packed\_vec\_insptr\EARG}
	      \verb|pvip|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr\EARGDEFAULT}%
	          {packed\_vec\_insptr\EARG}
	      \verb|pvip|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr\EARGDEFAULT}%
	          {packed\_vec\_insptr\EARG}
	      \verb|pvip|\ARGBREAK
	   \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_insptr|{\tt \EHARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\EHARG::insptr}
\LABEL{MIN::PACKED_VEC_INSPTR_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::packed_vec_insptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}
	& \verb| ( min::packed_vec_insptr<E,H>|\\
	& \verb|        & pvip,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_GEN} \\
\verb|min::packed_vec_insptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}
	& \verb| ( min::packed_vec_insptr<E,H>|\\
	& \verb|        & pvip,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 pvip|
    & \TTARMKEY{max\_\EOL length}{in {\tt min::packed\_vec\_insptr}}
\LABEL{MIN::PACKED_VEC_INSPTR_MAX_LENGTH} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|E & min::|
	& \MINKEY{push\REL} \verb| ( packed_vec_insptr<E,H> pvip )|\\&
	  \hspace*{0.1in} [if \verb|E| \underline{not} locatable]
\LABEL{MIN::PACKED_VEC_PUSH} \\
\verb|min::ref<E> min::|
	& \MINKEY{push\REL} \verb| ( packed_vec_insptr<E,H> pvip )|\\&
          \hspace*{0.1in} [if \verb|E| \underline{is} locatable]
\LABEL{MIN::PACKED_VEC_PUSH_OF_LOCATABLE} \\[2ex]
\verb|void min::|
	& \MINKEY{push\REL}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 n, E const * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|E min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{resize\REL}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve\REL}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{tabular}\end{indpar}

Insertable packed vector pointers permit the current length and maximum
length of the vector to be changed.
The current vector length is \verb|pvip->length| and the maximum
length is \verb|pvip->max_length| (see description of \verb|H| on
\pagref{PACKED_VEC_HEADER_TYPE}).
The current length can be changed by {\tt min::\EOL push\REL} and
{\tt min::\EOL pop} functions and the maximum length can be changed
by {\tt min::\EOL resize\REL} and {\tt min::\EOL reserve\REL} functions.  If
{\tt min::\EOL push\REL} needs more space it automatically calls
{\tt min::reserve\REL}.

The \verb|min::push| function adds elements
to the end of the packed vector
by incrementing the current vector length, and if this would
exceed the maximum length, first calls the \verb|min::reserve| function
with the number of elements to be pushed.

The single argument {\tt min::\EOL push\REL} adds one element to the vector,
zeros that element, and returns a reference to the element.  The
intended use is
\begin{indpar}\begin{verbatim}
push(pvip) = v;
\end{verbatim}\end{indpar}
where \verb|v| is the value of the element to be added to the vector.
If the element type {\tt E} is locatable, {\tt min::\EOL push\REL}
returns a {\tt min::\EOL ref\TARG}
reference.  Otherwise, if {\tt E} is not locatable, an
`{\tt E \&}' reference is returned.

Note that {\tt \& min::push(pvip)}
is an \underline{unprotected} body pointer if {\tt E} is not
locatable.

The two or three argument {\tt min::\EOL push\REL} adds {\tt n}
elements to the vector, and fills the new elements from {\tt vp}
if that is not {\tt NULL}, or with zeros otherwise.
If \verb|vp| is not \verb|NULL|,
new elements are placed within the packed vector in the same
memory order as they appear in the \verb|vp| vector.
In this case
{\tt min::\EOL acc\_\EOL write\_\EOL update} 
(\itemref{ACC-WRITE-UPDATE-FUNCTIONS})
is called if {\tt E} is locatable.

The \verb|min::pop| function removes elements from the end of the
packed vector, decrementing the current vector length (which is checked
to be sure it is large enough).   A single element may be removed and
returned, or \verb|n| elements may be removed and returned in the
\verb|vp| vector.  In the latter case removed elements are placed in
\verb|vp| in the same memory order as they appeared in the packed vector.
Also,
if \verb|vp| is \verb|NULL|, the removed elements are simply discarded
instead of being copied.

The \verb|min::resize| function resets the maximum length.  If
the current length would be larger than the new maximum length,
the current length is reset to the new maximum length.

The \verb|min::reserve| function checks that
the current length plus the \verb|reserve_length| is
at most the maximum length, and if this check fails,
resets the maximum length according to the formula:
\begin{indpar}\begin{verbatim}
new_maximum_length = max ( length + reserve_length,
                           old_maximum_length
                           +
                           min ( pvtype.max_increment,
                                   pvtype.increment_ratio
                                 * old_maximum_length ) )
\end{verbatim}\end{indpar}\label{PACKED-VEC-EXPANSION-FORMULA}

An example use of a packed vector is:
\begin{indpar}\begin{verbatim}
struct pvh;
struct pve;
typedef min::packed_vec_ptr<pvh,pve> pvptr;
typedef min::packed_vec_insptr<pvh,pve> pvinsptr;
    // Note: pointer types may be defined before
    //       header and element types are defined.

struct pvh {
    const min::uns32 control;
          min::uns32 i;
    const min::uns32 length;
    const min::uns32 max_length;
};

struct pve {
    // Note: pve is not a locatable type but contains
    // locatable type elements which means that
    // MUP::acc_write_update must be called explicitely
    // when pve elements are written into a packed vector.

    min::gen g;
    const min::stub * s;
    min::uns8 j;
};

static min::uns32 pve_gen_disp[2] =
    { 0, min::DISP_END };
static min::uns32 pve_stub_disp[2] =
    { 0 + sizeof ( min::gen ), min::DISP_END };

static min::packed_vec<pve,pvh> pvtype
    ( "pvtype", pve_gen_disp, pve_stub_disp );

main ( ... )
{
    min::gen v = pvtype.new_gen ( 5 );
        // min::packed_subtype_of ( v ) == pvtype.subtype
    pvinsptr pvip ( v );
        // pvip->max_length == 5
        // pvip->length == 0
        // min::packed_subtype_of ( pvip ) == pvtype.subtype
    pve e1 = { min::MISSING, NULL, 88 };
    min::push(pvip) = e1;
       // Need not call MUP::acc_write_update as neither
       // e1.g or e1.s point at a stub.
    pvptr pvp ( v );
        // pvp->length == 1
        // pvp[0].j == 88

    pve e2[3] = { { min::MISSING, NULL, 11 },
                  { min::MISSING, NULL, 22 },
                  { min::MISSING, NULL, 33 } };
    min::push ( pvip, 3, e2 );
        // Again no need to call MUP::acc_write_update because
        // e2 does not point at stubs.
        //
        // pvp[1].j == 11
        // pvp[2].j == 22
        // pvp[3].j == 33

    min::locatable_gen name1, name2;
    name1 = min::new_str_gen ( "my-name-1" );
    name2 = min::new_str_gen ( "my-name-2" );

    pve e3 = { name1, min::stub_of ( name2 ), 44 };
    min::push(pvip) = e3;
    MUP::acc_write_update ( pvip, e3.g ); 
    MUP::acc_write_update ( pvip, e3.s ); 

    min::resize ( pvip, 10 );
        // pvp->max_length == 10

    pve e4;
    locatable_gen g2;
    locatable_var<const min::stub *> s2;
    e4 = min::pop ( pvip );
        // e4[0].j == 44
        // pvp->length == 4
    g2 = e4.g;
    s2 = e4.s;
        // We must make e4.g and e4.s locatable before
        // we call any more relocating functions.

    pve e5[3];
    min::pop ( pvip, 2, e5 );
        // e5[0].j == 22
        // e5[1].j == 33
    e4 = min::pop ( pvip );
        // 3e.j == 11
        // pvp->length == 1
}
\end{verbatim}\end{indpar}

Packed vector pointers do no caching and
there is \underline{no need} for
a refresh function analogous to the {\tt min::\EOL \ldots\_\EOL refresh}
functions for list pointers (\pagref{LIST-POINTER-CACHE}).




\subsection{Files}
\label{FILES}

A MIN file is a sequence of UTF-8 encoded NUL-terminated
lines plus descriptive information.  A {\tt min::}\MINKEY{file} value is a
pointer to a packed structure that contains the descriptive information
and also contains
a pointer to a packed {\tt char} vector that contains the lines.

Creation, initialization, and parameterization of files is
accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::file_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{file}
\LABEL{MIN::FILE} \\
\verb|const min::uns32 min::| & \MINNBKEY{ALL\_LINES}
\LABEL{MIN::ALL_LINES} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{init\_\EOL input}\verb| ( min::file & file )|
\LABEL{MIN::INIT_INPUT_OF_FILE} \\
\verb|void min::| & \MINKEY{init\_\EOL output}\verb| ( min::file & file )|
\LABEL{MIN::INIT_OUTPUT_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_print\_flags}
          \begin{argstack}
          \verb| ( min::file & file,| \\
	  \verb|   min::uns32 print_flags )|
	  \end{argstack}
\LABEL{MIN::INIT_PRINT_FLAGS_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_\EOL spool\_\EOL lines}
             \begin{argstack}
	     \verb| ( min::file & file,|\\
             \verb|   min::uns32 spool_lines )|
	     \end{argstack}
\LABEL{MIN::INIT_SPOOL_LINES_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_\EOL file\_\EOL name}
             \begin{argstack}
	     \verb| ( min::file & file,|\\
             \verb|   min::gen file_name )|
	     \end{argstack}
\LABEL{MIN::INIT_FILE_NAME_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_line\_index}\verb| ( void )|
\LABEL{MIN::INIT_LINE_INDEX_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_output\_ostream}
          \begin{argstack}
          \verb| ( min::file & file,| \\
	  \verb|   std::ostream & ostream )|
          \end{argstack}
\LABEL{MIN::INIT_OUTPUT_OSTREAM_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_output\_file}
          \begin{argstack}
          \verb| ( min::file & file,| \\
	  \verb|   min::file ofile )|
          \end{argstack}
\LABEL{MIN::INIT_OUTPUT_FILE_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_output\_printer}
          \begin{argstack}
          \verb| ( min::file & file,| \\
	  \verb|   min::printer printer )|
          \end{argstack}
\LABEL{MIN::INIT_OUTPUT_PRINTER_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_stream}\ARGBREAK
          \verb| ( min::file & file,|\ARGBREAK
	  \verb|   std::istream & istream,|\ARGBREAK
	  \verb|   min::uns32 print_flags = 0,|\ARGBREAK
	  \verb|   min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STREAM_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_file}\ARGBREAK
          \verb| ( min::file & file,|\ARGBREAK
	  \verb|   min::file ifile,|\ARGBREAK
	  \verb|   min::uns32 print_flags = 0,|\ARGBREAK
	  \verb|   min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_named\_file}\ARGBREAK
          \verb| ( min::file & file,|\ARGBREAK
	  \verb|   min::gen filename,|\ARGBREAK
	  \verb|   min::uns32 print_flags = 0,|\ARGBREAK
	  \verb|   min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_NAMED_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_string}\ARGBREAK
          \verb| ( min::file & file,|\ARGBREAK
	  \verb|   const char * data,|\ARGBREAK
	  \verb|   min::uns32 print_flags = 0,|\ARGBREAK
	  \verb|   min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STRING_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::packed_vec_insprt<char> file| & \TTARMKEY{buffer}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER} \\
\verb|min::uns32 file| & \TTARMKEY{buffer-\GT length}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER_LENGTH} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL line\_\EOL number}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_NUMBER} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL line\_\EOL offset}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_OFFSET} \\
\verb|min::uns32 file| & \TTARMKEY{end\_offset}{in {\tt min::file}}
\LABEL{MIN::FILE_END_OFFSET} \\
\verb|min::uns32 file| & \TTARMKEY{file\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_FILE_LINES} \\
\verb|min::packed_vec_insptr<min::uns32> file|
    & \TTARMKEY{line\_index}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_INDEX} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 file| & \TTARMKEY{spool\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_SPOOL_LINES} \\
\verb|min::uns32 file| & \TTARMKEY{print\_flags}{in {\tt min::file}}
\LABEL{MIN::FILE_PRINT_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::istream * file| & \TTARMKEY{istream}{in {\tt min::file}}
\LABEL{MIN::FILE_ISTREAM} \\
\verb|min::file file| & \TTARMKEY{ifile}{in {\tt min::file}}
\LABEL{MIN::FILE_IFILE} \\
\verb|std::ostream * file| & \TTARMKEY{ostream}{in {\tt min::file}}
\LABEL{MIN::FILE_OSTREAM} \\
\verb|min::printer file| & \TTARMKEY{printer}{in {\tt min::file}}
\LABEL{MIN::FILE_PRINTER} \\
\verb|min::file file| & \TTARMKEY{ofile}{in {\tt min::file}}
\LABEL{MIN::FILE_OFILE} \\
\verb|min::gen file| & \TTARMKEY{filename}{in {\tt min::file}}
\LABEL{MIN::FILE_FILENAME} \\
\end{tabular}\end{indpar}

The {\tt min::}\MINKEY{init\ldots} functions all re-initialize existing
files and create new ones.  They take a variable as their
first argument, and if the variable value is {\tt min::\EOL
NULL\_\EOL STUB}, then a new file is created and the
variable is set to point at the new file.
The different forms of {\tt min::\EOL init\ldots} set different
file members.

The members of a file may be read but \underline{not} written, unless
noted below.  They are:

\begin{itemlist}[1.4in]

\item[\ttmkey{buffer}{in {\tt min::file}}]
The vector of {\tt char}'s that contains the lines of the file.  Each
line is UTF-8 encoded and NUL terminated.  A non-NUL-terminated incomplete
last line may appear at the end of the buffer.

Note that in general functions that load data into files do \underline{not}
check for illegal UTF-8 encodings.  They typically treat NUL characters
loaded into the buffer as if they were newline characters, and in any
case must avoid NUL characters in the buffer that are not intended
to be line-terminating.

Initialized to the empty vector when the file is created and by
{\tt min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{buffer-\GT length}{in {\tt min::file}}]
The number of {\tt char} elements in the file buffer
(as per the buffer being a packed vector: see \itemref{PACKED-VECTORS}).
Initialized to {\tt 0} when the file is created and by
{\tt min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{next\_\EOL line\_\EOL number}{in {\tt min::file}}]
The number of the next line to be returned by the
{\tt min::\EOL next\_\EOL line}
function that is used by programs to read lines from a {\tt min::\EOL file}.
Or the total number of lines in the file if there is no next line.
The first line number is {\tt 0}.  Initialized to {\tt 0}.

\item[\ttmkey{next\_\EOL line\_\EOL offset}{in {\tt min::file}}]
The offset in the {\tt buffer} of the first character of the
next line to be returned by the {\tt min::\EOL next\_\EOL line}
function.  I.e., that character is {\tt buffer[next\_\EOL line\_\EOL offset]}.
Or {\tt buffer->\EOL length} if there is no next line (not even a partial
next line).
Initialized to {\tt 0}.

\item[\ttmkey{end\_\EOL offset}{in {\tt min::file}}]
The offset of the {\tt buffer} element just \underline{after} the last
line-terminating NUL character in the {\tt buffer}.  Or {\tt 0} if there
are no line-terminating NUL characters.
Initialized to {\tt 0} when the file is created and by
{\tt min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{file\_\EOL lines}{in {\tt min::file}}]
If all the {\tt char}'s in the file have been appended to the file {\tt buffer},
this is the number of complete lines in the file, which equals
the number of NUL's in the {\tt buffer}.  Otherwise this equals
{\tt min::\EOL NO\_\EOL LINE}.

Initialized to {\tt min::\EOL NO\_\EOL LINE} when the file is created and by
{\tt min::\EOL init\_\EOL input\ldots} functions that do not load
the entire contents of the file into the file {\tt buffer}.
Set to the number of complete lines in the file
by {\tt min::\EOL init\_\EOL input\ldots} functions that load
the entire contents of the file into the file {\tt buffer}.
Set to the number of complete lines in the file
when {\tt min::\EOL next\_\EOL line} reads an end of file.

\item[\ttmkey{line\_\EOL index}{in {\tt min::file}}]
If {\tt line\_index~!=~min::NULL\_STUB}, then
{\tt line\_index[m]} is the offset in the buffer of the first
character of line number {\tt n} (or of the line-terminating NUL
if the line is empty), where
\begin{center}
{\tt m = line\_index->length - ( next\_line\_number - n )}
\end{center}
If {\tt spool\_lines~==~min::ALL\_LINES}, this last reduces to {\tt m~=~n}.
Otherwise one must take into account that only the last
{\tt spool\_\EOL lines} returned by the {\tt min::\EOL next\_\EOL line}
function are guarenteed to be
stored in {\tt buffer} and {\tt line\_\EOL index}.

Set to {\tt min::NULL\_STUB} when the file is created.
Set to a vector by {\tt min::\EOL init\_\EOL line\_\EOL index}, and
also automatically if {\tt spool\_\EOL lines} is initialized
to a non-zero value by one of the {\tt init}\ldots{} functions.
The vector is set empty whenever {\tt next\_\EOL line\_\EOL number}
is set to {\tt 0}.

\item[\ttmkey{spool\_\EOL lines}{in {\tt min::file}}]
The buffer is only required to retain the last {\tt spool\_\EOL lines}
returned by the {\tt min::\EOL next\_\EOL line} function.
If there are more complete (i.e., terminated)
lines, then when new lines are read from the buffer
by {\tt min::\EOL next\_\EOL lines},
older complete lines previously
output may be removed from the beginning of the buffer.
When a line is deleted from the beginning of the buffer, any
corresponding element is deleted from {\tt line\_\EOL index}.

If {\tt next\_line\_number~<=~spool\_lines}, all file lines
returned by {\tt min::\EOL next\_\EOL line} so far are
retained in the buffer.
If {\tt spool\_\EOL lines == min::\EOL ALL\_\EOL LINES},
all lines returned are retained.

Set to {\tt 0} when the file is created.  Set to an argument
that defaults to {\tt min::\EOL ALL\_\EOL LINES}
by {\tt min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{print\_\EOL flags}{in {\tt min::file}}]
These are some of the printer {\tt parameters->\EOL flags} used to print
a file line for error message purposes.  The flags involved are:
\begin{indpar}
\tt
\begin{tabular}{l}
min::GRAPHIC\_HSPACE\_FLAG \\
min::GRAPHIC\_VSPACE\_FLAG \\
min::GRAPHIC\_NSPACE\_FLAG \\
min::ALLOW\_HSPACE\_FLAG \\
min::ALLOW\_VSPACE\_FLAG \\
min::ALLOW\_NSPACE\_FLAG \\
min::ASCII\_FLAG \\
min::DISPLAY\_EOL\_FLAG
\end{tabular}
\end{indpar}

These flags determine the number of columns required to display a
UNICODE character, and are therefore also used by input routines
that keep track of the column numbers of input characters for
the purposes of printing error messages.  For example, the carriage
return prints as follows with the given flags:
\begin{center}
\begin{tabular}{l@{~~~~}l}
{\tt min::GRAPHIC\_NSPACE\_FLAG} only
	& {\tiny $\stackrel{\textstyle C~}{~R}$} ~~~ 1 column \\
~~ but no {\tt min::ASCII\_FLAG}
\\[1ex]
{\tt min::GRAPHIC\_NSPACE\_FLAG} & {\tt <CR>} ~~~ 4 columns \\
~~ and {\tt min::ASCII\_FLAG}
\\[1ex]
{\tt min::ALLOW\_NSPACE\_FLAG}   & the carriage return \\
~~ but no {\tt min::GRAPHIC\_NSPACE\_FLAG} & character itself, \\
					   & 0 columns
\\[1ex]
no {\tt min::ALLOW\_NSPACE\_FLAG}   & omitted from output, \\
~~ and no {\tt min::GRAPHIC\_NSPACE\_FLAG}  & 0 columns
\end{tabular}
\end{center}

File lines are to be printed with these
flags set as in {\tt print\_\EOL flags} and with
both {\tt min::\EOL HBREAK\_\EOL FLAG} and {\tt min::\EOL GBREAK\_\EOL FLAG}
off.

Set to {\tt 0} when the file is created.

\item[\ttmkey{istream}{in {\tt min::file}}]
If not {\tt NULL}, the {\tt min::\EOL next\_\EOL line} function
reads lines from this {\tt std::\EOL istream} when it finds
there is no line to return to its caller.
Set to {\tt NULL} when the file is created.

\item[\ttmkey{ifile}{in {\tt min::file}}]
If not {\tt min::NULL\_STUB}, the {\tt min::\EOL next\_\EOL line} function
reads lines from this {\tt min::\EOL file} when it finds
there is no line to return to its caller.
Set to {\tt min::\EOL NULL\_\EOL STUB} when the file is created.

Note that it is a programming error if {\tt istream != NULL}
\underline{and} {\tt ifile != NULL\_\EOL STUB}.

\item[\ttmkey{ostream}{in {\tt min::file}}]
If not {\tt NULL}, the {\tt min::\EOL flush\_\EOL file} function
outputs buffer {\tt char} elements to this {\tt std::\EOL ostream} when it finds
there are elements not yet output.
Set to {\tt NULL} when the file is created.

\item[\ttmkey{printer}{in {\tt min::file}}]
If not {\tt min::NULL\_STUB}, the {\tt min::\EOL flush\_\EOL file} function
outputs buffer {\tt char} elements
to this {\tt min::\EOL printer} when it finds
there are elements not yet output.
Non-NUL elements in a
line are output as per the {\tt min::\EOL verbatim}
printer operation (\pagref{MIN::VERBATIM}),
and the line-terminating
NUL elements are translated into sending {\tt min::eol} to the printer.

Set to {\tt min::\EOL NULL\_\EOL STUB} when the file is created.

\item[\ttmkey{ofile}{in {\tt min::file}}]
If not {\tt min::NULL\_STUB}, the {\tt min::\EOL flush\_\EOL file} function
outputs buffer {\tt char} elements to this {\tt min::\EOL file} when it finds
there are elements not yet output.
Non-NUL elements are simply appended to the end of the {\tt ofile}, and
line-terminating NUL elements are translated into calls to
{\tt min::\EOL line\_\EOL end~(~ofile~)}.
Set to {\tt min::\EOL NULL\_\EOL STUB} when the file is created.

\item[\ttmkey{filename}{in {\tt min::file}}]
If not {\tt min::MISSING}, this
is the name of this file for the purpose of printing error messages
concerning file lines.
Set to {\tt min::\EOL MISSING} when the file is created.

\end{itemlist}

In general, the {\tt min::\EOL init\_\EOL input\ldots} functions
reinitialize all members, while all the other initialization functions
just perform an equivalent of a {\tt min::rewind}, resetting
{\tt next\_\EOL line\_\EOL number}
and {\tt next\_\EOL line\_\EOL offset} to {\tt 0}, emptying
{\tt line\_\EOL index} if it exists, and otherwise
only resetting members from arguments given explicitly to the
initialization functions.
For example, {\tt min::\EOL init\_\EOL print\_\EOL flags} just
rewinds the file and sets {\tt print\_\EOL flags},
and {\tt min::\EOL init\_\EOL output\_\EOL stream} just
rewinds the file and sets {\tt ostream}.

The {\tt min::init\_input} function initializes the file assuming
input to the file will come from some outside source.  For example,
given the code:
\begin{indpar}\begin{verbatim}
min::locatable_ptr<min::file> file1, file2;
init_input ( file1 );
init_input_... ( file2, ... );
init_output_file ( file2, file1 );
\end{verbatim}\end{indpar}
then applying {\tt min::flush} to {\tt file2} will write
its contents to the end of {\tt file1}.

The {\tt min::init\_input\_named\_file} function loads the contents
of the file with the given {\tt file\_\EOL name} into the file.  The
file is rewound, so successive calls the {\tt min::\EOL next\_\EOL line}
will return successive lines of the file.  After loading the contents
of the named file into the file {\tt buffer}, newline characters in the buffer
are converted to line-terminating NUL's.  NUL characters loaded into the
buffer are also treated as line-terminating NUL's.  If there is no error in
reading the file, {\tt true} is returned by this function.  If
there is an error, {\tt false} is returned, and an error message
is written into {\tt min::\EOL error\_\EOL message}
(\pagref{ERROR_MESSAGE}).

The {\tt min::init\_input\_string} function similarly loads the contents
of the file with the value of a given NUL-terminated {\tt data} string.
Newline characters are converted to line-terminating NUL's.
There is no possibility of error in this case.

The {\tt min::init\_input\_stream} function does not load data into
the file {\tt buffer}, but instead sets the file {\tt istream} member
which causes {\tt min::\EOL next\_\EOL line} to load lines into the
file from the {\tt istream} as new lines are required.  Similarly
the {\tt min::\EOL init\_\EOL input\_\EOL file} function sets
{\tt ifile} which causes {\tt min::\EOL next\_\EOL line} to load lines
into the file from the {\tt ifile} as new lines are required.
See {\tt min::\EOL next\_\EOL line} below for details.

You \underline{cannot} append to a file initialized by any
{\tt min::\EOL init\_\EOL input\ldots} function other than
the 1-argument {\tt min::\EOL init\_\EOL input} function.
If you use this function you can write your own code to append
to the file buffer, as for example:
\begin{indpar}\begin{verbatim}
min:locatable_ptr<min::file> file;
init_input ( file );
...
const char * my_string = ...;
int length = ::strlen ( my_string );
min::push ( file->buffer, length, my_string );
min::end_line ( file );
...
\end{verbatim}\end{indpar}

Initializing a file rewinds it.  Then calls to
{\tt min::\EOL next\_\EOL line} sequence through the file
lines:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINNBKEY{NO\_LINE}
\LABEL{MIN::NO_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{next\_line}\verb| ( min::file file )|
\LABEL{MIN::NEXT_LINE_OF_FILE} \\
\end{tabular}\end{indpar}

The {\tt min::\EOL next\_\EOL line} function returns an
{\tt offset} such that the file {\tt buffer[offset]} element
is the first character of the next NUL-terminated line.
If there is no such line, because we are at the end of the file,
{\tt min::\EOL NO\_\EOL LINE} is returned instead.  In this case
there may still be a partial non-NUL-terminated line at the end
of the file.

The number of bytes in any partial line at the end of a file
{\tt buffer} just after {\tt min::\EOL next\_\EOL line} returns
{\tt min::\EOL NO\_\EOL LINE} is
{\tt buffer->\EOL length - next\_\EOL line\_\EOL offset}, and if this
is zero, then there is no partial line.
The offset of a partial line is {\tt next\_\EOL line\_\EOL offset}.
The following functions get these values in
a more mnemonic fashion:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|bool min::|
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL length}\verb| ( min::file file )|
\LABEL{MIN::PARTIAL_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL offset}\verb| ( min::file file )|
\LABEL{MIN::PARTIAL_OFFSET} \\
\end{tabular}\end{indpar}

After processing a partial line, {\tt next\_\EOL line\_\EOL offset}
can be reset to be equal to {\tt buffer->\EOL length} in order to
prevent reprocessing the partial line elements just processed.
This is done by:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{skip\_\EOL partial}\verb| ( min::file file )|
\LABEL{MIN::SKIP_PARTIAL} \\
\end{tabular}\end{indpar}

A file is complete, in the sense the no more characters will be
appended to its {\tt buffer}, if {\tt file\_\EOL lines} contains
the number of complete lines in the file, and is not equal to
{\tt min::\EOL NO\_\EOL LINE}.  This can be tested by

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{file\_\EOL is\_\EOL complete}\verb| ( min::file file )|
\LABEL{MIN::FILE_IS_COMPLETE} \\
\end{tabular}\end{indpar}

The {\tt min::\EOL next\_\EOL line} function does not return
{\tt min::\EOL NO\_\EOL LINE} unless the file is complete.

If the {\tt min::\EOL next\_\EOL line} function encounters the
end of the file {\tt buffer} when the file is not complete
and when {\tt istream} is not {\tt NULL},
then {\tt min::\EOL next\_\EOL line} gets another line from
{\tt istream}, or gets a partial line if {\tt isteam} produces
an end-of-file before it produces a line terminating linefeed
or NUL character (NUL characters produced by {\tt istream}
are interpreted as line terminators).  If {\tt istream} produces
a end-of-file, then the file is completed by setting
{\tt file\_\EOL lines} to {\tt next\_\EOL line\_\EOL number},
and no further use of {\tt istream} is made on this or subsequent calls to
{\tt min::\EOL next\_\EOL line}.

If instead the {\tt ifile} member of the file is not
{\tt min::\EOL NULL\_\EOL STUB}, 
{\tt min::\EOL next\_\EOL line} behaves similarly but gets
more characters by calling
{\tt min::\EOL next\_\EOL line(ifile)} instead of by using
the {\tt istream} member.  If {\tt ifile} is complete, any
characters in an {\tt ifile} partial line are also gotten, and the file
is completed just as it would be if an end-of-file had been read
from {\tt istream}.

It is possible to obtain any line previously returned by
{\tt min::\EOL next\_\EOL line} (since the last rewind of the file)
using the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{line}
	  \begin{argstack}
	  \verb| ( min::file file,|\\
	  \verb|   min::uns32 line_number )|
	  \end{argstack}
\LABEL{MIN::LINE_OF_FILE} \\
\end{tabular}\end{indpar}

Here
{\tt 0 <= line\_\EOL number < file->\EOL next\_\EOL line\_\EOL number}
is required.  However, it is not sufficient.  In order for this function
to work, all the lines previously returned by {min::\EOL next\_\EOL line}
must have been left in {\tt file->\EOL buffer}, and whether or not
this is done is controlled by {\tt file->\EOL spool\_\EOL lines}.

More specifically, in order for the {\tt min::\EOL line} function above
to be able to find the line to return,
\begin{center}\begin{tabular}{r@{~~~~}rl}
\multicolumn{3}{l}{\tt file->next\_line\_number - file->spool\_lines} \\
& \tt <= & \tt line\_number \\
& \tt < & \tt file->next\_line\_number
\end{tabular}\end{center}
is required.  For input files it is common to set {\tt spool\_\EOL lines}
to \verb|min::|\MINNBKEY{ALL\_\EOL LINES}, which is effectively infinity,
and saves all lines previously returned by {\tt min::\EOL next\_\EOL line}.
For output files it is common to set {\tt spool\_\EOL lines} to {\tt 0},
so no lines are saved.

If {\tt min::\EOL line} is asked to return
an unsaved line, or a line not yet returned by {\tt min::\EOL next\_\EOL line}
(since the last rewind), then {\tt min::\EOL line} returns
{\tt min::\EOL NO\_\EOL LINE}.

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{end\_line}\verb| ( min::file file )|
\LABEL{MIN::END_LINE_FILE} \\
\verb|void min::|
    & \MINKEY{end\_line}
	  \begin{argstack}
          \verb| ( min::file file,|\\
	  \verb|   min::uns32 offset )|
	  \end{argstack}
\LABEL{MIN::END_LINE_FILE_WITH_OFFSET} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL file}\verb| ( min::file file )|
\LABEL{MIN::FLUSH_FILE} \\
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL line}
	  \begin{argstack}
          \verb| ( min::file file,|\\
	  \verb|   min::uns32 offset )|
	  \end{argstack}
\LABEL{MIN::FLUSH_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{flush\_partial}\verb| ( min::file file )|
\LABEL{MIN::FLUSH_PARTIAL} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::file}}\ARGBREAK
      \verb| ( std::ostream & out,|\ARGBREAK
      \verb|   min::file file )|
\LABEL{OSTREAM_OPERATOR<<_OF_FILE} \\
\verb|min::file |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::file}}\ARGBREAK
      \verb| ( min::file ofile,|\ARGBREAK
      \verb|   min::file ifile )|
\LABEL{FILE_OPERATOR<<_OF_FILE} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::file}}\ARGBREAK
      \verb| ( min::printer printer,|\ARGBREAK
      \verb|   min::file file )|
\LABEL{PRINTER_OPERATOR<<_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{rewind}
        \begin{argstack}
	\verb| ( min::file file,|\\
	\verb|   min::uns32 line_number = 0 )|
	\end{argstack}
\LABEL{MIN::REWIND_FILE} \\
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line}\ARGBREAK
      \verb| ( min::printer printer,|\ARGBREAK
      \verb|   min::file file,|\ARGBREAK
      \verb|   min::uns32 line_number,|\ARGBREAK
      \verb|   const char * blank_line =|\ARGBREAK
      \verb|       "<BLANK-LINE>",|\ARGBREAK
      \verb|   const char * end_of_file =|\ARGBREAK
      \verb|       "<END-OF-FILE>",|\ARGBREAK
      \verb|   const char * unavailable_line =|\ARGBREAK
      \verb|       "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb| ( min::file file,|\ARGBREAK
    \verb|   min::uns32 first, min::use32 last )|
\LABEL{MIN::PLINE_NUMBERS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer,|\ARGBREAK
      \verb|   const min::pline & pline )|
\LABEL{PRINTER_OPERATOR<<_OF_PLINE} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer,|\ARGBREAK
      \verb|   const min::pline_numbers & pline_numbers )|
\LABEL{PRINTER_OPERATOR<<_OF_PLINE_NUMBERS} \\
\end{tabular}\end{indpar}

\subsection{Printers}
\label{PRINTERS}

A \ttkey{printer} may be used to print general values, print graphics for
control characters, and break long lines to enforce line length.
Internally a {\tt min::\EOL printer} is
a packed structure that points at a {\tt min::\EOL file} and contains
additional information used to format lines put into the file.
Values are written to printers via the \verb|<<| operator, much like the
way values are written to {\tt std::\EOL ostream}'s.  A special
printer line end operation writes a line terminating {\tt NUL}
at the end of the printer file's vector, and optionally flushes the file.

The MIN system has a per-process printer to hold error messages:
\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{error\_\EOL message}
\LABEL{MIN::ERROR_MESSAGE}%
\label{ERROR_MESSAGE} \\
\end{tabular}\end{indpar}

This functions like {\tt errno} in UNIX, but
holds multi-line error messages instead of an integer error
code.  The protocol for writing
an error message into this printer is to first apply
the 1-argument {\tt min::init} function to the printer to create the printer
if necessary, remove any previous message from the printer,
and put the printer into a default state,
and then write an error message consisting of one or more
complete lines to the printer.  The following code is often
used to do this:
\begin{indpar}\begin{verbatim}
# define ERR min::init ( min::error_message )
...
if ( error-occurred )
{
    ERR << ... << min::eol;
    return value-indicating-error-occurred;
}
...
\end{verbatim}\end{indpar}\label{ERROR_MESSAGE_EXAMPLE}.

Creation, initialization, and parameterization of printers is
accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::printer_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{printer}
\LABEL{MIN::PRINTER} \\
\verb|min::printer min::| & \MINKEY{init}\ARGBREAK
    \verb| ( min::printer & printer,|\ARGBREAK
    \verb|   min::file file = min::NULL_STUB )|
\LABEL{MIN::INIT_OF_PRINTER} \\
\verb|min::printer min::| & \MINKEY{init\_output\_stream}\ARGBREAK
    \verb| ( min::printer & printer,|\ARGBREAK
    \verb|   std::ostream & ostream )|
\LABEL{MIN::INIT_OUTPUT_STREAM_OF_PRINTER} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::file printer| & \TTARMKEY{file}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_FILE} \\
\verb|const min::uns32 printer| & \TTARMKEY{column}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_COLUMN} \\
\verb|const min::uns32 printer|
    & \TTARMKEY{break\_offset}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_BREAK_OFFSET} \\
\verb|const min::uns32 printer|
    & \TTARMKEY{break\_column}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_BREAK_COLUMN} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer_parameters printer|
    & \TTARMKEY{parameters}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PARAMETERS} \\
\verb|min::printer_parameters printer|
    & \TTARMKEY{saved\_\EOL parameters[8]}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_SAVED_PARAMETERS} \\
\verb|const min::uns32 printer|
    & \TTARMKEY{save\_index}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_SAVE_INDEX} \\
\end{tabular}\end{indpar}

The {\tt min::}\MINKEY{init} function both re-initializes existing
printers and creates new ones.  It takes a variable as its
first argument, and if the variable value is {\tt min::\EOL
NULL\_\EOL STUB}, then a new printer is created and the
variable is set to point at the new printer.
The second argument to {\tt min::init} supplies the {\tt min::file}
to which the printer is attached.  If this argument is
{\tt min::\EOL NULL\_\EOL STUB}, then {\tt min::\EOL init\_\EOL input}
is applied to {\tt printer->file} to create that file if necessary
and empty it if it already exists; but if the argument is
not {\tt min::\EOL NULL\_\EOL STUB} then {\tt printer->file} is set
to the argument and the file is \underline{not} emptied or changed.

The {\tt min::}\MINKEY{init\_\EOL output\_\EOL stream}
function just executes
\begin{indpar}\begin{verbatim}
min::init ( printer );
min::init_output_stream ( printer->file, ostream );
printer << min::eol_flush;
\end{verbatim}\end{indpar}

which is a very common way of setting up a printer.

Both initialization functions return the printer, which is
sometimes convenient, as in the code often used 
with {\tt min::\EOL error\_\EOL message}: see \pagref{ERROR_MESSAGE_EXAMPLE}.

The members of a printer may be read but \underline{not} written, unless
noted below.  They are:

\begin{itemlist}[0.8in]

\item[\ttmkey{file}{in {\tt min::printer}}]
The {\tt min::file} which contains the lines produced by the printer.
Initialized by the second argument of {\tt min::\EOL init}, if that is
not {\tt min::\EOL NULL\_\EOL STUB}, or otherwise created when the
printer is created.  Initialized by {\tt min::\EOL init(printer->\EOL file)}
except when 2-argument {\tt min::init} is called (see above).

\item[\ttmkey{column}{in {\tt min::printer}}]
The number of columns currently in the line being assembled,
or the column number of the next character to be input to the
printer.  The first column number is {\tt 0}.  Initialized to {\tt 0}.

\end{itemlist}

\begin{itemlist}[1.2in]

\item[\ttmkey{break\_\EOL offset}{in {\tt min::printer}}]
If there is no break point in the current line, this equals
{\tt file->\EOL next\_\EOL line\_\EOL offset}.
Otherwise it is the {\tt file->buffer} offset of the
first byte in the current line after the last break point in the line.
Initialized to {\tt 0}.

\item[\ttmkey{break\_\EOL column}{in {\tt min::printer}}]
If there is no break point in the current line, this equals {\tt 0}.
Otherwise it is the column of the
first byte in the current line after the last break point in the line.
Initialized to {\tt 0}.

\end{itemlist}

\begin{itemlist}[1.6in]

\item[\ttmkey{parameters}{in {\tt min::printer}}]
Contains parameters that control the printing process.
These parameters are described below.
This member may be written.
Initialized to the value of
{\tt min::\EOL default\_\EOL printer\_\EOL parameters}.

\item[\ttmkey{saved\_\EOL parameters[8]}{in {\tt min::printer}}]
A stack of copies of the {\tt parameters}.
The {\tt min::push\_\EOL parameters} operation copies
{\tt parameters} into {\tt saved\_\EOL parameters[i]} where
the index {\tt i~== save\_\EOL index}, and then
increments {\tt save\_\EOL index}.
The {\tt min::pop\_\EOL parameters} operation reverses this process.

\item[\ttmkey{save\_\EOL index}{in {\tt min::printer}}]
See {\tt saved\_parameters}.  Initialized to {\tt 0}.

\end{itemlist}

The \ttmkey{parameters}{in {\tt min::printer}} member of a printer
contains parameters that control the printing process.  The code for
these is:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{printer\_parameters}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const min::printer_format * format;|\ARGBREAK
    \verb|  min::uns32 line_length;|\ARGBREAK
    \verb|  min::uns32 indent;|\ARGBREAK
    \verb|  min::uns32 flags;|\ARGBREAK
    \verb|};|
\ttmindex{format}{in {\tt min::printer\_parameters}}
\ttmindex{line\_length}{in {\tt min::printer\_parameters}}
\ttmindex{indent}{in {\tt min::printer\_parameters}}
\ttmindex{flags}{in {\tt min::printer\_parameters}}
\LABEL{MIN::PRINTER_PARAMETERS_STRUCT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINNBKEY{GRAPHIC\_HSPACE\_FLAG}
\LABEL{MIN::GRAPHIC_HSPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINNBKEY{GRAPHIC\_VSPACE\_FLAG}
\LABEL{MIN::GRAPHIC_VSPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINNBKEY{GRAPHIC\_NSPACE\_FLAG}
\LABEL{MIN::GRAPHIC_NSPACE_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINNBKEY{ALLOW\_HSPACE\_FLAG}
\LABEL{MIN::ALLOW_HSPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINNBKEY{ALLOW\_VSPACE\_FLAG}
\LABEL{MIN::ALLOW_VSPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINNBKEY{ALLOW\_NSPACE\_FLAG}
\LABEL{MIN::ALLOW_NSPACE_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINNBKEY{ASCII\_FLAG}
\LABEL{MIN::ASCII_FLAG} \\
\verb|const min::uns32 min::| & \MINNBKEY{DISPLAY\_\EOL \_FLAG}
\LABEL{MIN::DISPLAY_EOL_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINNBKEY{HBREAK\_FLAG}
\LABEL{MIN::HBREAK_FLAG} \\
\verb|const min::uns32 min::| & \MINNBKEY{GBREAK\_FLAG}
\LABEL{MIN::GBREAK_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINNBKEY{EOL\_FLUSH\_FLAG}
\LABEL{MIN::EOL_FLUSH_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINNBKEY{GRAPHIC\_FLAGS}
\LABEL{MIN::GRAPHIC_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::printer\_parameters
                       min::\MINKEY{default\_printer\_parameters} =}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  & min::default_printer_format,   // format|\ARGBREAK
    \verb|  72,                              // line_length|\ARGBREAK
    \verb|  4,                               // indent|\ARGBREAK
    \verb|    min::HBREAK_FLAG               // flags|\ARGBREAK
    \verb|  + min::ALLOW_VSPACE_FLAG|\ARGBREAK
    \verb|  // Additional members may be added.|\ARGBREAK
    \verb|};|
\LABEL{MIN::DEFAULT_PRINTER_PARAMETERS}
\end{tabular}\end{indpar}

The {\tt min::printer\_parameters} members are:

\begin{itemlist}

\item[\ttmkey{line\_length}{in {\tt min::printer\_parameters}}]
When a character representative other that single space or horizontal
tab is to be inserted into the line, and this would cause the number
of columns in the line to exceed the {\tt line\_length}, then if a
break point exists and
\begin{center}
\verb|printer->break_column > printer->parameters.indent|
\end{center}
then a break, consisting of a line end followed by indentation spaces,
is pushed into the printer vector before the character representative.
Any space characters before the break are deleted.

Breaks may be inserted automatically by using
{\tt min::\EOL HBREAK\_\EOL FLAG} or
{\tt min::\EOL BBREAK\_\EOL FLAG}: see below.

\item[\ttmkey{ indent}{in {\tt min::printer\_parameters}}]
When a break is automatically pushed into a printer vector, the
break consists of a line end ({\tt NUL} character) followed by
{\tt indent} single space characters.

\item[\ttmkey{format}{in {\tt min::printer\_parameters}}]
The {\tt format}
controls the printing of
{\tt min::gen} values by the {\tt min::pgen} function described
below.

\item[\ttmkey{flags}{in {\tt min::printer\_parameters}}]
The following flag bits control printing.  Some of these
flags affect only certain categories of characters, which are
defined as follows:

\begin{itemlist}[0.8in]
\item[\ttnbmkey{HSPACE}{character category}]
    Horizontal Space Characters: single space, horizontal tab
\item[\ttnbmkey{VSPACE}{character category}]
    Vertical Space Characters: form feed, vertical tab
\item[\ttnbmkey{NSPACE}{character category}]
    Non-Space Control Characters: all other characters
with codes {\tt < 0x20}, including line feed and carriage return \\
plus the delete character
\item[] Non-ASCII Characters: characters
with codes {\tt > 0x7F}.
\end{itemlist}

\end{itemlist}

\begin{indpar}\begin{itemlist}[1.4in]

\item[\ttnbmkey{GRAPHIC\_HSPACE\_FLAG}{{\tt min::printer\_parameters} flag}]
\item[\ttnbmkey{GRAPHIC\_VSPACE\_FLAG}{{\tt min::printer\_parameters} flag}]
\item[\ttnbmkey{GRAPHIC\_NSPACE\_FLAG}{{\tt min::printer\_parameters} flag}]
{\raggedright~\\}
{\tt GRAPHIC\_XXX} causes all characters in class {\tt XXX} to be
represented by `graphic' characters that print some mark.
This is referred to as `\key{graphic mode}'.

If both the {\tt ASCII\_FLAG} and a {\tt GRAPHIC\_XXX} are on,
the characters in class {\tt XXX} are printed as `{\tt <YY>}',
where {\tt YY} is the 2 or 3 letter ASCII standard character name.
The possibilities are:
\begin{indpar} \tt
    <NUL>, <SOH>, <STX>, <ETX>, <EOT>, <ENQ>, \\
    <ACK>, <BEL>, <BS>, <HT>, <LF>, <VT>, \\
    <FF>, <CR>, <SO>, <SI>, <DLE>, \\
    <DC1>, <DC2>, <DC3>, <DC4>, <NAK>, <SYN>, \\
    <ETB>, <CAN>, <EM>, <SUB>, <ESC>, \\
    <FS>, <GS>, <RS>, <US>, <SP>, <DEL>
\end{indpar}

For example, `{\tt <FF>}' represents the form-feed characters, and
`{\tt <SP>}' represents the single space character.

If the {\tt GRAPHIC\_XXX\_FLAG} is on and the {\tt ASCII\_FLAG} is
\underline{off}, control and space characters are
printed as UNICODE Control Pictures script characters,
range 2400-243F (hexadecimal).
For example, single space prints as {\tt \textvisiblespace} and
line feed as {\tiny $\stackrel{\textstyle N~}{~L}$}.
All these character representations take exactly 1 column.

\item[\ttnbmkey{GRAPHIC\_FLAGS}{{\tt min::printer\_parameters} flag}]
The sum of the {\tt min::GRAPHIC\_XXX} flags:
\begin{indpar}
\tt
min::GRAPHIC\_HSPACE \\
min::GRAPHIC\_VSPACE \\
min::GRAPHIC\_NSPACE
\end{indpar}

\item[\ttnbmkey{ASCII\_FLAG}{{\tt min::printer\_parameters} flag}]
This controls the printing of non-ASCII UNICODE characters, and in
graphics mode, the printing of ASCII control characters.

If the {\tt ASCII\_FLAG} is on,
non-ASCII characters are printed as `{\tt <XXXX>}', where
{\tt XXXX} represents the character code in hexadecimal,
and consists of some non-zero number of hexadecimal digits.
{\tt XXXX} begins with
one of the digits {\tt 0},\dots,{\tt 9}, so as to avoid
ambiguity with representations of control characters.  Thus
{\tt <0FF>} represents the character whose code in decimal is
{\tt 255}, whereas {\tt <FF>} represents the form feed character.

If the {\tt ASCII\_FLAG} is off, non-ASCII characters print as
themselves.  They are all considered to occupy {\tt 1} column, except
for \skey{diacritical combining mark}s
20D0-20FF (hexadecimal) which are considered
to occupy {\tt 0} columns.

If the {\tt ASCII\_FLAG} is on,
ill-formed UTF-8 encodings are printed as `{\tt <ILL>}'.  If it is
off, they are printed as character 2368 (hexadecimal), the `\key{smirk}', a.k.a
the APL FUNCTIONAL SYMBOL TILDE DIAERESIS, $\stackrel{..}{\sim}$.

If the {\tt ASCII\_FLAG} and {\tt GRAPHIC\_\EOL XXX\_\EOL FLAG} are both off,
printing of characters of class {\tt XXX} is controled by the
{\tt ALLOW\_\EOL XXX\_\EOL FLAG} flag.

\item[\ttnbmkey{ALLOW\_HSPACE\_FLAG}{{\tt min::printer\_parameters} flag}]
\item[\ttnbmkey{ALLOW\_VSPACE\_FLAG}{{\tt min::printer\_parameters} flag}]
\item[\ttnbmkey{ALLOW\_NSPACE\_FLAG}{{\tt min::printer\_parameters} flag}]
{\raggedright~\\}
{\tt ALLOW\_XXX\_FLAG} causes all characters in class {\tt XXX} to
represent themselves.  The single space character takes {\tt 1}
column, the horizontal tab character takes from {\tt 1} to {\tt 8}
columns depending on its position (tabs are every 8 spaces), and
all vertical space and non-space control characters take {\tt 0}
columns.  The {\tt ALLOW\_XXX\_FLAG} flag only has effect if the
{\tt GRAPHIC\_XXX\_FLAG} flag is off.

If the {\tt ALLOW\_XXX\_FLAG} adn
{\tt GRAPHIC\_XXX\_FLAG} flag are both off, the single space
character represents itself, the horizontal tab character is
represented by {\tt 1} to {\tt 8} single spaces, and all
vertical space and non-space control characters are represented
by the empty string: i.e., they do not output anything.

\item[\ttnbmkey{DISPLAY\_\EOL \_FLAG}{{\tt min::printer\_parameters} flag}]
If this flag is on, the end of line prints as a graphic mode control
character (even if the {\tt GRAPHIC\_FLAG} is off).
If the {\tt ASCII\_FLAG} is on, it prints as
{\tt <LF>}.  Otherwise it prints as {\tiny $\stackrel{\textstyle N~}{~L}$}.

\item[\ttnbmkey{HBREAK\_FLAG}{{\tt min::printer\_parameters} flag}]
If this flag is on, a line break is automatically set
just after every single space or horizontal tab character output.

\item[\ttnbmkey{GBREAK\_FLAG}{{\tt min::printer\_parameters} flag}]
If this flag is on, a line break is automatically set
just before and just after every character
representative that prints a mark.  This applies to space and control
characters printed in graphic mode, but not to these characters
printed in non-graphic mode.

A non-control, non-space character followed by a
\key{diacritical combining mark} is considered to represent one character if
printed in non-ascii mode.

\item[\ttnbmkey{EOL\_FLUSH\_FLAG}{{\tt min::printer\_parameters} flag}]
If this flag is on, a {\tt min::flush()} printer operation is
executed at the very end of a {\tt min::\EOL eol} or
{\tt min::\EOL eom} printer operation.

\end{itemlist}\end{indpar}

Copying characters into a printer is done by the
{\tt <<} operator:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer, const char * s )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR_*} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer, char c )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer, min::int32 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer, min::int64 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer, min::uns32 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer, min::uns64 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer, min::float64 f )|
\LABEL{PRINTER_OPERATOR<<_OF_FLOAT64} \\
\end{tabular}\end{indpar}

A `{\tt const char *}' is interpreted as a UTF-8 encoded
string of UNICODE characters as per
{\tt min::\EOL utf8\_\EOL to\_\EOL unicode}, \pagref{MIN::UTF8_TO_UNICODE}.

\ikey{Horizontal tabs}{horizontal tab} are set every 8 columns.
When a horizontal tab is copied to a printer vector in non-graphic mode with
the {\tt min::\EOL ALLOW\_\EOL HSPACE} flag off,
the horizontal tab is converted to between 1 and 8 single space characters.

When a \ttnbkey{NUL} is copied into a printer vector, which can only happen
in non-graphic mode with {\tt min::\EOL ALLOW\_\EOL NSPACE} on,
it is encoded as the overlong encoding {\tt 0xC0},{\tt 0x80}.

Values of types other than `\verb|const char *|'
which are presented to {\tt <<} are converted to `{\tt const char~*}' strings
as follows:
`{\tt char}' converts to a 1-{\tt char} string whose only element
is the {\tt char} value.  Numbers are converted by {\tt printf}
formats as follows:
\begin{center}
\tt
\begin{tabular}{l@{~~~~~~~~~~}l}
min::uns32	& "\%u" \\
min::uns64	& "\%llu" \\
min::int32	& "\%d" \\
min::int64	& "\%lld" \\
min::float64	& "\%.15g" \\
\end{tabular}
\end{center}

Operations can be performed on printers by applying the
{\tt <<} operator to a {\tt min::}\MINKEY{op}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}{of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer printer,|\ARGBREAK
      \verb|   const min::op & op )|
\LABEL{OPERATOR<<_OF_PRINTER_OP} \\
\end{tabular}\end{indpar}

Operations behave for printers as {\tt iomanip}
C++ objects behave for {\tt iostreams}.  For example, the
printer analog of {\tt std::\EOL endl} is the \key{end of line}
operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{eol}
\LABEL{MIN::EOL} \\
\end{tabular}\end{indpar}

The flush operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{flush}
\LABEL{MIN::FLUSH} \\
\end{tabular}\end{indpar}

just executes
\begin{indpar}\begin{verbatim}
min::flush_file ( printer->file );
\end{verbatim}\end{indpar}

A {\ldots{} \tt << printer} operation can be used to
flush the contents of {\tt printer->\EOL file} into
an {\tt std::\EOL ostream}, a {\tt min::\EOL file}, or
into another {\tt min::\EOL printer}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( std::ostream & out,|\ARGBREAK
      \verb|   min::printer printer )|
\LABEL{OSTREAM_OPERATOR<<_OF_PRINTER} \\
\verb|min::file |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::file file,|\ARGBREAK
      \verb|   min::printer printer )|
\LABEL{FILE_OPERATOR<<_OF_PRINTER} \\
\verb|min::printer |
    & \TTOMKEY{<<}{\LT\LT}%
              {of {\tt min::printer}}\ARGBREAK
      \verb| ( min::printer oprinter,|\ARGBREAK
      \verb|   min::printer iprinter )|
\LABEL{PRINTER_OPERATOR<<_OF_PRINTER} \\
\end{tabular}\end{indpar}

In general {\ldots{} \tt << printer} is equivalent to
{\ldots{} \tt << printer->file} (see \pagref{OSTREAM_OPERATOR<<_OF_FILE}).

The {\tt min::setbreak} printer operation can be used to
explicitly set a break point:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{setbreak}
\LABEL{MIN::SETBREAK} \\
\end{tabular}\end{indpar}

More specifically, {\tt printer<<min::setbreak} sets a break point after
the last character in the printer vector by executing:
\begin{indpar}\begin{verbatim}
printer->break_offset = printer->buffer->length;
printer->break_column = printer->column;
\end{verbatim}\end{indpar}

The {\tt min::left} and {\tt min::right} operations can be used to
left or right adjust text in a line:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{left} \verb|( min::uns32 width )|
\LABEL{MIN::LEFT} \\
\verb|const min::op min::| & \MINKEY{right} \verb|( min::uns32 width )|
\LABEL{MIN::RIGHT} \\
\end{tabular}\end{indpar}

These operations add spaces to make the current printer column
equal to {\tt printer->\EOL break\_\EOL column + width}.
The {\tt min::\EOL left} operation simply appends spaces to the
current line.  The {\tt min::\EOL right} operation inserts spaces
at the last break point.  Both operations end with an implicit
{\tt min::\EOL setbreak} that resets the breakpoint.
Both operations behave exactly as if spaces were inserted at the
appropriate point by {\tt printer << "~"}, except that
{\tt min::right} will give undefined results if a horizontal
tab has been output since the last break point.

The {\tt min::reserve} operation can be used to
force a line break if there are fewer than {\tt width}
columns remaining in a line:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{reserve} \verb|( min::uns32 width )|
\LABEL{MIN::RESERVE} \\
\end{tabular}\end{indpar}

Here the line break consists of a {\tt min::eol} end of line followed
by {\tt parameters.indent} single spaces followed by setting a break
with {\tt min::\EOL setbreak}.

The {\tt min::indent} operation forces a line break if the current
printer column is greater than {\tt parameters.indent}, and otherwise inserts
single spaces until the current printer column is equal to
{\tt parameters.indent}.  In either case the operation
ends by setting a break as per {\tt min::setbreak}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{indent}
\LABEL{MIN::INDENT} \\
\end{tabular}\end{indpar}

The {\tt parameters} of a printer may be saved in the
\ttmkey{saved\_\EOL parameters}{in {\tt min::printer}}
stack of the printer, and restored from that stack.
This may be done explicitly by the following
operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{push\_parameters}
\LABEL{MIN::SAVE_PARAMETERS} \\
\verb|const min::op min::|
    & \MINKEY{restore\_parameters}
\LABEL{MIN::RESTORE_PARAMETERS} \\
\end{tabular}\end{indpar}

The \key{end of message} operation ends the current line,
flushes {\tt printer->\EOL file}
if {\tt min::\EOL EOL\_\EOL FLUSH\_\EOL FLAG} is set,
and restores the parameters from the {\tt save\_\EOL parameters}
stack.  The \key{beginning of message} operation is just a
synonym for pushing the parameters.

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{bom}
\LABEL{MIN::BOM} \\
\verb|const min::op min::| & \MINKEY{eom}
\LABEL{MIN::EOM} \\
\end{tabular}\end{indpar}

The idea is that
a message that consists of several lines with special flags set
can be bracketted by {\tt min::bom} and {\tt min::eom}
to restore parameters at the end of the message.

Operations can also be used to print values with specified
formats.  The {\tt min::\EOL pgen} operation prints
{\tt min::gen} values using a {\tt min::\EOL printer\_\EOL format}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{pgen}
	  \begin{argstack}
	  \verb| ( min::gen v,|\\
	  \verb|   const min::printer_format * format = NULL )|
	  \end{argstack}
\LABEL{MIN::PGEN} \\
\end{tabular}\end{indpar}

The expression `{\tt printer<<min::pgen(v,f)}' prints the {\tt min::gen}
value \verb|v| to the printer {\tt printer} using the
{\tt min::\EOL printer\_\EOL format} value pointed at by {\tt f}.
If {\tt f} is {\tt NULL}, {\tt printer->\EOL parameters.for\-mat} is used
instead.  If that is also {\tt NULL},
{\tt \&min::default\_\EOL printer\_\EOL format} is used.

Note that `{\tt printer<<v}' for a {\tt min::gen} value {\tt v} will
\underline{not} have the desired result, as {\tt v} will be taken to be
an integer.

A {\tt min::printer\_format} is as follows:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{printer\_format}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const char * number_format;|\ARGBREAK
    \verb|  const char * str_prefix;|\ARGBREAK
    \verb|  const char * str_postfix;|\ARGBREAK
    \verb|  const char * lab_prefix;|\ARGBREAK
    \verb|  const char * lab_separator;|\ARGBREAK
    \verb|  const char * lab_postfix;|\ARGBREAK
    \verb|  const char * special_prefix;|\ARGBREAK
    \verb|  const char * special_postfix;|\ARGBREAK
    \verb|  min::printer & ( * pr_stub )|\ARGBREAK
    \verb|       ( min::printer & printer,|\ARGBREAK
    \verb|         const min::stub * s );|\ARGBREAK
    \verb|  // Additional members may be added.|\ARGBREAK
    \verb|};|
\ttmindex{number\_format}{in {\tt min::printer\_format}}
\ttmindex{str\_prefix}{in {\tt min::printer\_format}}
\ttmindex{str\_postfix}{in {\tt min::printer\_format}}
\ttmindex{lab\_prefix}{in {\tt min::printer\_format}}
\ttmindex{lab\_separator}{in {\tt min::printer\_format}}
\ttmindex{lab\_postfix}{in {\tt min::printer\_format}}
\ttmindex{special\_prefix}{in {\tt min::printer\_format}}
\ttmindex{special\_postfix}{in {\tt min::printer\_format}}
\ttmindex{pr\_stub}{in {\tt min::printer\_format}}
\LABEL{MIN::PRINTER_FORMAT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::printer\_format
                       min::\MINKEY{default\_printer\_format} =}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  "%.15g",     // number_format|\ARGBREAK
    \verb|  "`","'",     // str_prefix/postfix|\ARGBREAK
    \verb|  "["," ","]", // lab_prefix/separator/postfix|\ARGBREAK
    \verb|  "","",       // special_prefix/postfix|\ARGBREAK
    \verb|  NULL         // pr_stub|\ARGBREAK
    \verb|};|
\LABEL{MIN::DEFAULT_PRINTER_FORMAT} \\
\end{tabular}\end{indpar}

The {\tt number\_format} member is used as a {\tt printf} format
for printing {\tt min::gen} numbers convered to {\tt min::\EOL float64} values.
The {\tt str\_\EOL \BRA pre,post\KET fix} members are printed just before and
just after the string of characters in a {\tt min::gen} string value
(which is itself a UTF-8 encoded UNICODE character string).
The {\tt lab\_\EOL \BRA pre,post\KET fix} members are printed just before and
just after the elements of a label {\tt min::gen} value,
and the {\tt lab\_\EOL separator} member is printed between elements.
The {\tt special\_\EOL \BRA pre,post\KET fix}
members are printed just before and
just after special {\tt min::gen} values (such as `{\tt MISSING}').
The {\tt pr\_\EOL stub} function, if it is not {\tt NULL}, is called
with any {\tt min::stub} that is not a number, label, or string.

A single UNICODE character {\tt c}, or a string of UNICODE characters
{\tt str} of a given {\tt length},
can be printed using the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{punicode}\verb| ( min::uns32 c )|
\LABEL{MIN::PUNICODE} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb| ( min::unsptr length,|\ARGBREAK
      \verb|   const min::uns32 * str )|
\LABEL{MIN::PUNICODE_BUFFER} \\
\end{tabular}\end{indpar}

Sometimes it is desireable to find out how many columns a
single UNICODE character will take for a given value of
{\tt parameters.flags}.  For the horizontal tab character,
this depends upon the column the character is printed in.
So the following function updates a {\tt column} variable
whose initial value is that of {\tt printer->column}
before a UNICODE character is printed with
{\tt printer << min::\EOL punicode~(~c~)}
and whose final value is {\tt printer->\EOL column}
after the character is printed.  Here {\tt printer->\EOL parameters.flags}
must be input to the function.

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{pwidth}\ARGBREAK
         \verb| ( min::uns32 & column,|\ARGBREAK
         \verb|   min::uns32 c,|\ARGBREAK
         \verb|   min::uns32 flags )|
\LABEL{MIN::PWIDTH} \\
\end{tabular}\end{indpar}

Numbers may be formatted by specified {\tt printf} formats and the results
printed by using the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{pint}
	  \begin{argstack}
	  \verb| ( min::int64 i,|\\
	  \verb|   const char * printf_format )|
	  \end{argstack}
\LABEL{MIN::PINT} \\
\verb|min::op min::|
    & \MINKEY{puns}
	  \begin{argstack}
	  \verb| ( min::uns64 u,|\\
	  \verb|   const char * printf_format )|
	  \end{argstack}
\LABEL{MIN::PUNS} \\
\verb|min::op min::|
    & \MINKEY{pfloat}
	  \begin{argstack}
	  \verb| ( min::float64 f,|\\
	  \verb|   const char * printf_format )|
	  \end{argstack}
\LABEL{MIN::PFLOAT} \\
\end{tabular}\end{indpar}

The components of a printer {\tt parameters} member may be set
by the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{set\_\EOL format}\verb| ( min::printer_format * format )|
\LABEL{MIN::SET_FORMAT} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL line\_length}\verb| ( min::uns32 line_length )|
\LABEL{MIN::SET_LINE_LENGTH} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL indent}\verb| ( min::uns32 indent )|
\LABEL{MIN::SET_INDENT} \\
\verb|min::op min::|
    & \MINKEY{set\_flags}\verb| ( min::uns32 flags )|
\LABEL{MIN::SET_PRINTER_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{clear\_flags}\verb| ( min::uns32 flags )|
\LABEL{MIN::CLEAR_PRINTER_FLAGS} \\
\end{tabular}\end{indpar}

For example, `{\tt printer<<min::set\_flags(min::ASCII\_FLAG)}'
sets the {\tt ASCII\_FLAG} of {\tt para\-meters.flags}.

Particular {\tt parameters->flags} may be set and cleared by the
following

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{ascii}
\LABEL{MIN::ASCII} \\
\verb|const min::op min::| & \MINKEY{noascii}
\LABEL{MIN::NOASCII} \\
\end{tabular}\end{indpar}
\begin{indpar}[1em]\begin{tabular}{r@{}l}

\verb|const min::op min::| & \MINKEY{graphic\_vspace}
\LABEL{MIN::GRAPHIC_VSPACE} \\
\verb|const min::op min::| & \MINKEY{nographic\_vspace}
\LABEL{MIN::NOGRAPHIC_VSPACE} \\
\verb|const min::op min::| & \MINKEY{graphic\_nspace}
\LABEL{MIN::GRAPHIC_NSPACE} \\
\verb|const min::op min::| & \MINKEY{nographic\_nspace}
\LABEL{MIN::NOGRAPHIC_NSPACE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{allow\_hspace}
\LABEL{MIN::ALLOW_HSPACE} \\
\verb|const min::op min::| & \MINKEY{noallow\_hspace}
\LABEL{MIN::NOALLOW_HSPACE} \\
\verb|const min::op min::| & \MINKEY{allow\_vspace}
\LABEL{MIN::ALLOW_VSPACE} \\
\verb|const min::op min::| & \MINKEY{noallow\_vspace}
\LABEL{MIN::NOALLOW_VSPACE} \\
\verb|const min::op min::| & \MINKEY{allow\_nspace}
\LABEL{MIN::ALLOW_NSPACE} \\
\verb|const min::op min::| & \MINKEY{noallow\_nspace}
\LABEL{MIN::NOALLOW_NSPACE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{display\_eol}
\LABEL{MIN::DISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_eol}
\LABEL{MIN::NODISPLAY_EOL} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{hbreak}
\LABEL{MIN::HBREAK} \\
\verb|const min::op min::| & \MINKEY{nohbreak}
\LABEL{MIN::NOHBREAK} \\
\verb|const min::op min::| & \MINKEY{gbreak}
\LABEL{MIN::GBREAK} \\
\verb|const min::op min::| & \MINKEY{nogbreak}
\LABEL{MIN::NOGBREAK} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{eol\_flush}
\LABEL{MIN::EOL_FLUSH} \\
\verb|const min::op min::| & \MINKEY{noeol\_flush}
\LABEL{MIN::NOEOL_FLUSH} \\
\end{tabular}\end{indpar}

For example, `{\tt printer<<min::ascii}' sets the
{\tt printer->\EOL parameters.flags} {\tt min::\EOL ASCII\_\EOL FLAG}
and `{\tt printer<<\EOL min::\EOL noascii}' clears this flag.

There are several operations that set and clear several flags each:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{graphic}
\LABEL{MIN::GRAPHIC} \\
\verb|const min::op min::| & \MINKEY{nographic}
\LABEL{MIN::NOGRAPHIC} \\
\verb|const min::op min::| & \MINKEY{verbatim}
\LABEL{MIN::VERBATIM} \\
\end{tabular}\end{indpar}

The {\tt min::\EOL graphic} operation sets the following flags:
\begin{indpar}
\tt
min::GRAPHIC\_HSPACE\_FLAG \\
min::GRAPHIC\_VSPACE\_FLAG \\
min::GRAPHIC\_NSPACE\_FLAG \\
min::GBREAK\_FLAG
\end{indpar}

and the {\tt min::\EOL nographic} operation clears these flags.
{\tt min::\EOL graphic} permits all characters to be represented
by a graphic, i.e., a printed mark, and automatically sets line breaks
just before
and just after each of these character representations, in order to
enforce line length limits.

The {\tt min::\EOL verbatim} operation sets the following flags:
\begin{indpar}
\tt
min::ALLOW\_HSPACE\_FLAG \\
min::ALLOW\_VSPACE\_FLAG \\
min::ALLOW\_NSPACE\_FLAG
\end{indpar}

and clears the following flags:
\begin{indpar}
\tt
min::GRAPHIC\_HSPACE\_FLAG \\
min::GRAPHIC\_VSPACE\_FLAG \\
min::GRAPHIC\_NSPACE\_FLAG \\
min::HBREAK\_FLAG \\
min::GBREAK\_FLAG \\
min::ASCII\_FLAG
\end{indpar}

This permits characters in a {\tt printer->file} line to be copied
to another printer verbatim.  Note that {\tt min::\EOL DISPLAY\_\EOL EOL}
is not affected, as when copying to a printer from
from some {\tt printer->\EOL file}
line terminating NULs are translated to {\tt min::\EOL eol}
operations.  Also note that the operation to undo the results
of {\tt min::\EOL verbatim} does not exist (you must push and pop
the parameters).

\subsection{Objects}
\label{OBJECTS}

An \key{object} is conceptually a hash table that maps
\skey{attribute name}s to \skey{attribute value}s.
An attribute name is a sequence of name components, which
are numbers, strings, and labels.
The part of the hash table that maps attribute names that are equal to
or begin with small unsigned integers is actually a vector.
An attribute value is a \verb|min::gen| datum.

Each map of an attribute name to an attribute value represents an
arrow in the data base.  Some arrows can be double arrows pointing
both to and from another object.
If the arrow is a double arrow,
a reverse direction label, called the \key{reverse attribute name}
is attached to the arrow, and the object at the other end of the
arrow has the same arrow but with directions and direction names reversed.

There can be several arrows with the same attribute name,
and even several arrows with both the same attribute name and the
same value.
There can be several double arrows with the same attribute name and
the same reverse attribute name, and even several double arrows with
the same names and target object.

Therefore an attribute name and reverse attribute name together name a
multi-set of values, where the reverse attribute name can be missing to
indicate that only single arrows are to be considered, and is present to
indicate that only double arrows are to be considered.
For single arrows the values are any \verb|min::gen| values, but for
double arrows the values are always other objects.
It is possible to add a value to one of these multi-sets
or delete a value from a
multi-set.  It is possible to delete an entire multi-set.
It is possible to treat a multi-set as a set, by adding a value
to it only if the value does not already occur in the multi-set.
When testing for value equality, {\tt ==} is normally used, as this tests for
equality of both name components and objects.

Flags, called \key{attribute flags}, can be attached to an attribute name.
Note that flags are attached to object attribute names, and not to arrows,
values, or reverse attribute names.

There are also typed objects, each of which is a pair of objects,
one called the type that is constant, is shared among many typed objects,
and contains attribute labels, and one called the
context, which contains a vector of \skey{variable}s that hold attribute
values.  Typed objects are described in more detail in
\itemref{TYPED-OBJECTS}.

An object has a body that consists of the following 6 parts in
the order given:

\begin{center}
\begin{tabular}{l}
header \\
variable vector \\
hash table \\
attribute vector \\
unused area\\
auxiliary area
\end{tabular}
\end{center}

The \mkey{header}{of object} contains object flags
(including {\tt min::OBJ\_\EOL PRIVATE}, {\tt min::OBJ\_\EOL PUBLIC},
and {\tt min::OBJ\_\EOL TYPED})
and the sizes of the other 5 parts.
The \mkey{variable vector}{of object} stores the object's variables.
The \mkey{hash table}{of object}
stores attribute name/value pairs, for attributes whose names do not
begin with small unsigned integers.
The \mkey{attribute vector}{of object} stores attribute values
for attributes whose names begin with small unsigned integers.
The \mkey{auxiliary area}{of object}
stores elements of lists headed by hash table and attribute vector
elements, and any other data that would overflow a single
\verb|min::gen| value.
The \mkey{unused area}{of object}
provides for growth of the attribute vector and auxiliary area.

The variable vector and hash table are of fixed size;
their size can only be changed by resizing, reorganizing, and often relocating
the object body.  The attribute vector
grows up from the end of the hash table into the unused
area, and the auxiliary storage grows down from the end of the body into
the unused area.

A variable vector, hash table, and attribute vector element is accessed
using an index relative to the beginning of the vector or table that
contains the element.  Auxiliary area elements are accessed by
\skey{auxiliary pointer}s\label{OBJECT-BODY-AUXILIARY-POINTER}
that give the index of the element relative to the end of the
object body.  Auxiliary pointers with zero index do not address
a body vector element.
For more details see the {\tt var/\EOL hash/\EOL attr/\EOL aux}
functions on \pagref{MIN::VAR_OF_OBJ_VEC_PTR}, and their equivalents on
\pagref{OBJECT-VECTOR-EQUIVALENTS}.

An object may be grown or compacted by relocating and reorganizing its body.
It may be
grown to expand its unused area or hash table, or, less commonly,
its variable vector.  An object may be compacted to eliminate, or less
commonly to shrink, its unused area, and possibly to shrink its hash
table.

There are two kinds of objects: short and long.  A \key{short object}
has an 8 byte header that stores 16 bit unsigned sizes.
A \key{long object}
has a 16 byte header that stores 32 bit unsigned sizes.
Otherwise there is
no essential difference between a short and a long object.%
\footnote{Provision is made to permit future implement of two
additional kinds of objects, a \key{tiny object} with 4 byte header
and 8 bit unsigned sizes that can only be implemented for
compact implementations with 32 bit {\tt min::gen} values because
otherwise the header size would a 1/2, and
a \key{huge object}\label{HUGE_OBJECT}
with 32 byte header and 64 bit unsigned sizes that
can only be implemented for loose implementations with 64 bit
{\tt min::gen} values because otherwise auxiliary pointers would not
be able to point into the auxiliary area.}

An object body may be \smkey{relocate}d{object body}, which means the
body is simply copied to a new address, or
\smkey{reorganize}d{object body}, which means the object body is reformatted,
and possibly converted from short to long or vice versa.  Frequently an
object whose attribute labels and number of values for each label are no
longer subject to change will be compacted, to make it as small as possible,
and this is one kind of object body reorganization.
Objects are compacted by the `{\tt min::\EOL publish\REL}'
function that sets the
object {\tt OBJ\_\EOL PUBLISH} flag which prevents changes to the
attribute labels, attribute label flags, and number of attribute values
of an object.
Reorganization can also occur whenever an object is relocated,
provided that the {\tt OBJ\_\EOL PRIVATE} and
{\tt OBJ\_\EOL PUBLIC} object flags are not set.

The data structure of an object body can be viewed at any of three levels:
vector level (\itemref{OBJECT-VECTOR-LEVEL}),
list level (\itemref{OBJECT-LIST-LEVEL}),
and attribute level (\itemref{OBJECT-ATTRIBUTE-LEVEL}).
The interfaces to all of these levels is protected.  In addition
there is an unprotected vector level interface
(\itemref{OBJECT-UNPROTECTED-VECTOR-LEVEL}) and a
typed object interface (\itemref{TYPED-OBJECTS}).

\subsubsection{Object Creation}
\label{OBJECT-CREATION}

An object header encodes the variables vector size,
hash table size, and total size of the object
indirectly using a logarithmic or pseudo-floating-point code.
Therefore not every variables vector size,
hash table size, or total size is supported.
In order to create an object it is necessary to determine possible
variable vector, hash table, and total sizes.

Note that all sizes are in \verb|min::gen| units.

The following functions return the smallest
possible size equal to or greater than the function argument,
\underline{unless} all possible sizes are less than the function argument,
in which case the largest possible size is returned.  The caller of
one of these functions must check the returned value to be sure it is
as large as the function argument.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
    & \MINKEY{obj\_var\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_VAR_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_hash\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_HASH_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_total\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_TOTAL_SIZE} \\
\end{tabular}\end{indpar}

Maximum possible total, hash table, and variables vector
size values can be determined
by presenting these functions with the \verb|u| argument value
`\verb|min::unsptr(-1)|'.

All power of two sizes not larger than the maximum sizes are
supported.  In particular, hash table sizes that are powers
of two are supported, so hash values can be mapped to
hash table indices by simple masking.

An object can be created by the protected function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}%
    \begin{tabular}[t]{@{}l@{}}
    \verb| ( min::unsptr unused_size,| \\
    \verb|   min::unsptr hash_size = 0,| \\
    \verb|   min::unsptr variable_size = 0 )| \\
    \end{tabular}
\LABEL{MIN::NEW_OBJ_GEN} \\
\end{tabular}\end{indpar}

The variables vector size of the returned object is the smallest possible
variables vector size that is at least as large as that given.
The hash table size of the returned object is the smallest possible
hash table size that is at least as large as that given.  The total
size of the returned object is the smallest possible total size
that is at least as large as the sum of
the actual variables vector size, the actual hash table size,
the unused area size given, and the header size.
Then the actual unused size is set by subtracting the other sizes from
the total size; this actual size is never smaller than the given size.
Note that if the given sizes of the variables vector and hash table
are powers of two
not greater than the maximums allowed, the corresponding actual sizes will
be equal to the given sizes.

The returned object is short if the given sizes are small enough.
Otherwise the object is long.
It is a fatal programming error if no possible hash table or total size
is large enough, but this is unlikely, given the large sizes allowed
by a long object.

The sizes allowed for short and long objects are implementation dependent.
The maximum sizes are available as the value of the following:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::unsptr min::| & \MINNBKEY{SHORT\_OBJ\_MAX\_VAR\_SIZE}
\LABEL{MIN::SHORT_OBJ_MAX_VAR_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{SHORT\_OBJ\_MAX\_HASH\_SIZE}
\LABEL{MIN::SHORT_OBJ_MAX_HASH_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{SHORT\_OBJ\_MAX\_TOTAL\_SIZE}
\LABEL{MIN::SHORT_OBJ_MAX_TOTAL_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{LONG\_OBJ\_MAX\_VAR\_SIZE}
\LABEL{MIN::LONG_OBJ_MAX_VAR_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{LONG\_OBJ\_MAX\_HASH\_SIZE}
\LABEL{MIN::LONG_OBJ_MAX_HASH_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{LONG\_OBJ\_MAX\_TOTAL\_SIZE}
\LABEL{MIN::LONG_OBJ_MAX_TOTAL_SIZE} \\
\end{tabular}\end{indpar}

{\tt MIN::LONG\_OBJ\_MAX\_TOTAL\_SIZE} is $2^{24}$ for a compact implementation
(as auxiliary pointers are 24 bits)
and $2^{32}$ for a loose implementation (as long object headers store at most
32 bit unused and auxiliary area offsets).%
\footnote{{\tt MIN::LONG\_OBJ\_MAX\_TOTAL\_SIZE} could be $2^{40}$ for
a loose implementation with 40 bit auxiliary pointers if
huge objects were implemented (\pagref{HUGE_OBJECT}).}
{\tt MIN::SHORT\_OBJ\_MAX\_TOTAL\_SIZE} is typically $2^{12}$ as having a
smaller header is not important for larger sizes and the left over header bits
are needed for flags.

The hash table of the returned object is filled with \verb|min::LIST_END|
values (\pagref{MIN::LIST_END}), and is therefore an empty hash table.
The variables vector is filled with \verb|min::UNDEFINED| values.
Unused area elements are initialized to some implementation defined
value like \verb|0| or \verb|min::NONE|.
The attribute vector and auxiliary areas of the returned object are
zero length, and all space not used by the header, hash table, and
variables vector is allocated to the unused area.
The attribute vector and auxiliary area can be
filled by `push' instructions described below
(\pagref{OBJECT_PUSH_FUNCTIONS}).

\subsubsection{Object Vector Level}
\label{OBJECT-VECTOR-LEVEL}

At the \key{vector level}, the object body is viewed as
a \key{body vector} of \verb|min::gen| values.
The entire body vector, except
for the header, consists of \verb|min::gen| elements of the
body vector.
A \key{body vector index} is an index of an element in this vector,
and ranges from 0
to one less than the total size of the object, which is the size of
the body vector.  The index 0 cannot be used, as it corresponds to the
header, which does not contain \verb|min::gen| values.
It can be used as a form of null pointer.

An auxiliary pointer index \verb|i| corresponds to the
body vector index \verb|total_size - i|, so \verb|i=1| corresponds
to the last element of the auxiliary area.
The 0 auxiliary pointer index corresponds to the location just
beyond the body vector and is not
usable as the index of auxiliary area element, so it
can also be used as a form of null pointer.

There are three kinds of vector level protected object pointers.
A read-only {\tt min::\EOL obj\_\EOL vec\_\EOL ptr} pointer
permits read-only access to body
vector elements.
A read-write or updatable
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr} pointer
permits read-write access to body vector elements,
but does not permit pushing or popping elements from the
object's attribute vector or auxiliary area.
An insertable {\tt min::\EOL obj\_\EOL vec\_\EOL insptr} pointer
does permit these pushes and pops, in addition to permitting
read-write access to body vector elements.

An object has two flags that regulate the creation of vector level
pointers: \minnbkey{OBJ\_PRIVATE} and \minnbkey{OBJ\_PUBLIC}.
If an object has neither of these flags, an object vector pointer
to the object may be created, and this will set the \verb|min::OBJ_PRIVATE|
flag.  When the object vector pointer is destructed, this flag will be cleared.
While this flag is set, no other vector pointer to the object may be
created.  The object is therefore private to the code possessing the
vector pointer.

If an object has neither flag, its \verb|min::OBJ_PUBLIC| flag may be set
by calling the `{\tt min::\EOL publish\REL}' function
(\pagref{MIN::PUBLISH}).
When this is set, any number of read-only and read-write (updatable) vector
pointers to the object may be created, but no insertable vector pointers
to the object may be created.  Constructing and destructing
pointers in this case does not set or clear object flags.
The \verb|min::OBJ_PUBLIC| flag may not be cleared by
protected functions.  The idea here is that setting the \verb|min::OBJ_PUBLIC|
flag fixes the attribute label structure of the object, the flags attached
to attribute labels, and the size of
the value multiset of each attribute, but permits the existing values of an
attribute to be read or written.  This permits read-only and limited
read-write sharing of the object.

Note that object bodies can be relocated whenever a
relocating function (\pagref{RELOCATING-FUNCTIONS}) is called.
However object bodies may be reorganized by a relocating
function only if neither the
\verb|min::OBJ_PRIVATE| or \verb|min::OBJ_PUBLIC| flags are set.
Object bodies may also be reorganization when insertions are made
using the {\tt min::\EOL insert\_\EOL reserve\REL} function
(\pagref{MIN::INSERT_RESERVE}) on an insertable pointer,
or when the {\tt min::\EOL OBJ\_\EOL PUBLIC} flag is set on an object
by the {\tt min::\EOL publish\REL} function (\pagref{MIN::PUBLISH}).

\subsubsubsection{Protected Object Vector Pointers}
\label{PROTECTED-OBJECT-VECTOR-POINTERS}

A read-only \minkey{obj\_\EOL vec\_\EOL pointer}
to the body vector of an object with stub \verb|s| or with
general value \verb|v| pointing to its stub
may be created by the following functions:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}\verb| vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( void )|
\LABEL{MIN::OBJ_VEC_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb| ( const min::obj_vec_ptr & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_MIN_STUB} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_GEN} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_STUB} \\
\end{tabular}\end{indpar}

The constructors point the new vector pointer at an object designated
by a \verb|min::gen| value or \verb|min::stub *| pointer, or in the
case of the constructor with no argument, leave the vector pointer
unpointed at any object, which is equivalent to providing the constructor
with a {\tt min::\EOL NULL\_\EOL STUB} argument.
Use of the pointer when it is not pointed at any object will give
undefined results, though access to object elements will usually
result in a memory fault.

The {\tt =} operator destructs the vector pointer and then
reconstructs it.  The pointer can be set to
{\tt min::\EOL NULL\_\EOL STUB}.

The following protected functions may be used to discover information
about the object pointed at by a read-only {\tt min::obj\_vec\_ptr}:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr min::| & \MINKEY{var\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::VAR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::AUX_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}\label{OBJECT_SIZE_FUNCTIONS}

Here the sizes are in \verb|min::gen| units.  When an object
body is reorganized, some of these sizes may change, but simply
relocating the object body does not change these sizes.

The following functions can be used for \underline{read-only}
access to object elements:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::gen | & \MINKEY{var}%
    \verb| ( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{hash}%
    \verb| ( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{attr}%
    \verb| ( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{aux}%
    \verb| ( min::obj_vec_ptr & vp, min::unsptr aux_ptr )|
\LABEL{MIN::AUX_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

Given a vector pointer \verb|vp|, \verb|min::var(vp,i)| can be used
to read the \verb|i+1|'st variable in the object pointed at
by \verb|vp|, for $0\leq i<\mbox{\tt min::var\_size\_of(vp)}$.
Similarly, \verb|min::hash(vp,i)| can be used
to read the \verb|i+1|'st hash table entry
for $0\leq i<\mbox{\tt min::hash\_size\_of(vp)}$,
\verb|min::attr(vp,i)| can be used
to read the \verb|i+1|'st attribute vector entry
for $0\leq i<\mbox{\tt min::attr\_size\_of(vp)}$.
\verb|min::aux(vp,p)| differs slightly in that it reads
the \verb|i|'th auxiliary area element ordering the
elements from the end of the auxiliary area to its beginning,
for $1\leq i\leq\mbox{\tt min::attr\_size\_of(vp)}$.
Auxiliary area indices are defined in this manner
so that an object body may be resized by simply
expanding or contracting its unused area, without modifying
the contents of the other parts of the object body.

A \minkey{obj\_vec\_updptr} is like a \verb|min::obj_vec_ptr|
but has additional functions which support writing object body vector
elements.  The additional functions for this type of pointer are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}%
    \verb| vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}%
    \verb| vp ( min::stub * s )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}%
    \verb| vp ( void )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_updptr}}\ARGBREAK
          \verb| ( const min::obj_vec_updptr & vp )|
\LABEL{MIN::OBJ_VEC_UPDPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|void min::| & \MINKEY{set\_var}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_updptr & vp,| \\
      \verb|   min::unsptr index,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_VAR_OF_VEC_UPDPTR} \\
\verb|void min::| & \MINKEY{set\_hash}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_updptr & vp,| \\
      \verb|   min::unsptr index,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_HASH_OF_VEC_UPDPTR} \\
\verb|void min::| & \MINKEY{set\_attr}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_updptr & vp,| \\
      \verb|   min::unsptr index,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_ATTR_OF_VEC_UPDPTR} \\
\verb|void min::| & \MINKEY{set\_aux}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_updptr & vp,| \\
      \verb|   min::unsptr aux_ptr,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_AUX_OF_VEC_UPDPTR} \\

\end{tabular}\end{indpar}

A {\tt min::set\_var/\EOL hash/\EOL attr/\EOL aux}
function writes its \verb|min::gen|
value argument into the same body vector element as is read by the
corresponding {\tt min::\EOL var/\EOL hash/\EOL attr/\EOL aux} function.
The set function invokes the
{\tt min::\EOL acc\_\EOL write\_\EOL update}
Accumu\-la\-tor/\EOL Col\-lec\-tor/\EOL Com\-pac\-tor function
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}) that must
be called when a \verb|min::gen| value is written into an object.

A {\tt min::\EOL obj\_\EOL vec\_\EOL updptr} may be automatically
downcast to a {\tt min::\EOL obj\_\EOL vec\_\EOL ptr}.  This means that
all the non-constructor functions applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL ptr}'s
are applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr}'s.
Exceptions are destructors, the {\tt min::\EOL ini\-tial\-ize}
functions, and the {\tt min::\EOL de\-ini\-tial\-ize} functions, which
will suffer a {\tt MIN\_\EOL ASSERT} error if applied to a
downcast object vector pointer.

A \minkey{obj\_vec\_insptr} is like a
{\tt min::obj\_\EOL vec\_\EOL updptr}
but has additional functions which support pushing or popping elements
from the end of the object body attribute vector or the beginning
of the object body auxiliary area and resizing the unused area and
variables vector portions of the object body.
The additional functions for this type of pointer are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr}%
    \verb| vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr}%
    \verb| vp ( min::stub * s )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr}%
    \verb| vp ( void )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_insptr}}\ARGBREAK
          \verb| ( const min::obj_vec_insptr & vp )|
\LABEL{MIN::OBJ_VEC_INSPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_GEN} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|void min::| & \MINKEY{attr\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::ATTR_PUSH_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{attr\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   const min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_VEC_INSPTR} \\

\verb|void min::| & \MINKEY{aux\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::AUX_PUSH_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   const min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_VEC_INSPTR} \\

\end{tabular}\end{indpar}\label{OBJECT_PUSH_FUNCTIONS}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|void min::| & \MINKEY{attr\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::gen & value )| \\
      \end{tabular}
\LABEL{MIN::ATTR_POP_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{attr\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_VEC_INSPTR} \\

\verb|void min::| & \MINKEY{aux\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::gen & value )| \\
      \end{tabular}
\LABEL{MIN::AUX_POP_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::AUX_POP_MULTIPLE_OF_VEC_INSPTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|bool min::| & \MINKEY{resize\REL}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::unsptr unused_size )| \\
      \end{tabular}
\LABEL{MIN::RESIZE_UNUSED_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{resize\REL}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::obj_vec_insptr & vp,| \\
      \verb|   min::unsptr unused_size,| \\
      \verb|   min::unsptr var_size )| \\
      \end{tabular}
\LABEL{MIN::RESIZE_UNUSED_AND_VAR_OF_VEC_INSPTR} \\

\end{tabular}\end{indpar}

The push functions push values to the end of the attribute vector
and the beginning of the unused area.  The pop functions pop values
from the end of the attribute vector and the beginning of the unused
area.

There are two versions of each push or pop: one that
handles a single {\tt min::gen} value, and one that handles
{\tt n} values stored in a C/C++ vector pointed at by {\tt p}.
These latter push and pop functions preserve the order of the values in memory,
so \verb|p[0]| is pushed into or popped from a body vector location immediately
before the location into which \verb|p[1]| is pushed into or popped from, etc.
Thus the attribute vector push function pushes
in the order \verb|p[0]|, \verb|p[1]|, \verb|p[2]|, \ldots; while the
auxiliary vector push function pushes
in the order \verb|p[n-1]|, \verb|p[n-2]|, \verb|p[n-3]|, \ldots.
The order of the elements of {\tt p} in memory is the same
as the order of the elements in the object body.

The push functions fail (via \verb|MIN_ASSERT|) if the unused
area size is smaller
than the number of {\tt min::gen} values being pushed.
The size of the unused area can be determined by the
\verb|min::unused_size_of| function
(\pagref{MIN::UNUSED_SIZE_OF_OBJ_VEC_PTR}).
These push functions invoke the
{\tt min::\EOL acc\_\EOL write\_\EOL update}
Accumu\-la\-tor/\EOL Col\-lec\-tor/\EOL Com\-pac\-tor function
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}) that must
be called when a \verb|min::gen| value is written into an object.

The {\tt min::resize\REL} functions change the size of the unused
area and variables vector.  The sizes can be either increased or
decreased.  Elements added to the variables vector are added to
its end and initialized with the value {\tt min::\EOL UNDEFINED}.
The object body may be relocated by these functions in order to
resize it, and may be converted from a short object to a long
object or vice versa.  The sizes of the attribute vector and
auxiliary area are not changed, but can be changed by later pushes
and pops.
No change is made to object contents outside the unused
area, whose elements are reinitialized to some implementation defined
value like \verb|0| or \verb|min::NONE|.

The {\tt min::resize\REL} functions return \verb|true| if they
relocate the object's body, and \verb|false| if they do not.
They set the relocated flag (\pagref{RELOCATED-FLAG}) if they
relocate any \underline{other} body, but not if they just relocate
the body being resized.

It is \underline{not}
possible to resize the hash table with these functions because
this involves moving data from a hash table entry with a given index
to another hash table entry with a different index, and the vector level
does not have enough information to do this.  The hash table can be
resized at the
attribute level (\pagref{MIN::RESIZE_OF_ATTR}).

A {\tt min::\EOL obj\_\EOL vec\_\EOL insptr} may be automatically
downcast to either a {\tt min::\EOL obj\_\EOL vec\_\EOL updptr}
or a {\tt min::\EOL obj\_\EOL vec\_\EOL ptr}.  This means that
all the non-constructor functions applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr}'s or
{\tt min::\EOL obj\_\EOL vec\_\EOL ptr}'s are applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL insptr}'s.
Exceptions are destructors, the {\tt min::\EOL ini\-tial\-ize}
functions, and the {\tt min::\EOL de\-ini\-tial\-ize} functions, which
will suffer a {\tt MIN\_\EOL ASSERT} error if applied to a
downcast object vector pointer.

\subsubsubsection{Unprotected Object Vector Level}
\label{OBJECT-UNPROTECTED-VECTOR-LEVEL}

Using unprotected functions, an object body can be treated
as a simple C/C++ vector of {\tt min::gen} values.  The
required functions are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|const min::gen * & MUP::| & \MUPKEY{base}%
    \verb| ( min::obj_vec_ptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_PTR} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}%
    \verb| ( min::obj_vec_updptr & v )|
\LABEL{MUP::BASE_OF_VEC_UPDPTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::STUB_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::VAR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb| ( min::obj_vec_insptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_INSPTR} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb| ( min::obj_vec_insptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_INSPTR} \\

\end{tabular}\end{indpar}

The offset values returned by the above are those of the
variable vector({\tt var}), hash table({\tt hash}),
attribute vector({\tt attr}), unused area ({\tt unused}), 
and auxiliary area({\tt aux}).  These offsets are in \verb|min::gen|
units, and these offsets and the sizes returned by the functions
on page \pagref{OBJECT_SIZE_FUNCTIONS} are related by

\begin{center}
\begin{tabular}{rcl}
variable vector offset	& = & header size \\
hash table offset       & = & variable vector offset + variable vector size \\
attribute vector offset & = & hash table offset + hash table size \\
unused area offset      & = & attribute vector offset + attribute vector size \\
auxiliary area offset   & = & unused area offset + unused area size \\
total size              & = & auxiliary area offset + auxiliary area size \\
\end{tabular}
\end{center}

Note that when an object is reorganized all these values may
change, including the header size.

Note that the {\tt min::\EOL unused\_\EOL offset\_\EOL of} and
{\tt min::\EOL aux\_\EOL offset\_\EOL of} functions for a
{\tt min::\EOL obj\_\EOL vec\_\EOL insptr} return an
lvalue.  For insertable pointers these offsets change when
values are pushed into or popped from the attribute vector or
auxiliary area.

The following are equivalences except for
the omission of {\tt MIN\_\EOL ASSERT} checks that the index \verb|i|
is not too large or two small (auxiliary area indices may not be 0),
checks that the unused area
is non-empty for pushes and that the attribute vector or auxiliary area
is non-empty for pops,
and calls to {\tt MUP::\EOL acc\_\EOL write\_\EOL update}
for set and push operations
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}):

\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|var ( vp, i )| & $\equiv$
    & \verb|return base(vp)[var_offset_of(vp) + i]| \\
\verb|hash ( vp, i )| & $\equiv$
    & \verb|return base(vp)[hash_offset_of(vp) + i]| \\
\verb|attr ( vp, i )| & $\equiv$
    & \verb|return base(vp)[attr_offset_of(vp) + i]| \\
\verb|aux ( vp, i )| & $\equiv$
    & \verb|return base(vp)[total_size_of(vp) - i]| \\
\end{tabular}\end{indpar}\label{OBJECT-VECTOR-EQUIVALENTS}
\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|set_var ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[var_offset_of(vp) + i] = v| \\
\verb|set_hash ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[hash_offset_of(vp) + i] = v| \\
\verb|set_attr ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[attr_offset_of(vp) + i] = v| \\
\verb|set_aux ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[total_size_of(vp) - i] = v| \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|attr_push ( vp, v )| & $\equiv$
    & \verb|base(vp)[unused_offset_of(vp)++] = v| \\
\verb|attr_pop ( vp, v )| & $\equiv$
    & \verb|v = base(vp)[--unused_offset_of(vp)]| \\
\verb|aux_push ( vp, v )| & $\equiv$
    & \verb|base(vp)[--aux_offset_of(vp)] = v| \\
\verb|aux_pop ( vp, v )| & $\equiv$
    & \verb|v = base(vp)[aux_offset_of(vp)++]| \\
\end{tabular}\end{indpar}



Recall that there are two kinds of objects: short and long.
A \key{short object stub}\label{SHORT-OBJECT-STUB} is collectible, has
\minnbkey{SHORT\_OBJ}\LABEL{MIN::SHORT_OBJ} stub type code, and has
a value that is a pointer to a body with an 8 byte object header
that allows an object with total size up to $2^{16}$ \verb|min::gen|
values.
A \key{long object stub}\label{LONG-OBJECT-STUB} is collectible, has
\minnbkey{LONG\_OBJ}\LABEL{MIN::LONG_OBJ} stub type code, and has
a value that is a pointer to a body with a 16 byte object header
that allows an object with total size up to $2^{32}$ \verb|min::gen|
values.

The header is the only part of an object body that is
\underline{not} \verb|min::gen| values.  Even so it is
sized in \verb|min::gen| units; e.g., a short object header size
is {\tt 2} for a compact implementation and {\tt 1}
for a loose implementation (\pagref{COMPACT-OR-LOOSE}).

The header may contain implementation dependent information used
for optimization.  Most implementations do not store all the required
sizes directly.  For example, an implementation usually permits only
particular hash table sizes, and uses 7 bits for short objects
and 12 bits for long objects to encode a reference to a table
of hash table sizes.  Similarly and implementation typically stores
a total size as a 12 bits in a short object and as a 15 bit integer
mantissa and 5 bit exponent in a long object.
The {\tt min::\EOL OBJ\_\EOL PRIVATE},
{\tt min::\EOL OBJ\_\EOL PUBLIC},
and {\tt min::\EOL OBJ\_\EOL TYPED} flags are stored in bits made
available by these packed size encodings.
Additional implementation dependent
flags may be used to optimize garbage collection.
For example, objects which have auxiliary stubs
(\pagref{OBJECT-AUXILIARY-STUBS})
may be flagged, thereby identifying objects that need extra work
when deallocated or reorganized.

An implementation is not required to support all possible values of
the variables vector size, hash table size, or total size, but should support
values that permit objects that are read-only to be efficiently compacted.
Size values that are powers of two and not
greater than the maximum supported sizes must be supported.
Within the bounds set by these size values, arbitrary sizes
of the attribute vector, unused area, and auxiliary area must
be supported.



\subsubsection{Object List Level}
\label{OBJECT-LIST-LEVEL}

At the \key{list level},\label{LIST-LEVEL}
the body consists of two vectors whose
elements are lists.  The two vectors are the hash table, and the
attribute vector (the variable vector is ignored).
The elements of the lists are
\verb|min::gen| values other than the list or sublist auxiliary
pointers, and sublists.  The lists are constructed with
the help of the list and sublist auxiliary pointers:

\begin{center}
\begin{tabular}{lp{3in}}
\key{list auxiliary pointer} &
The list is continued at the target of the list auxiliary pointer.
\\[2ex]
\key{sublist auxiliary pointer}	&
A sublist starts at the target of the sublist auxiliary pointer.
\end{tabular}
\end{center}

Lists also make use of two constant values:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::gen min::}\MINKEY{LIST\_END}]~\LABEL{MIN::LIST_END}\\
The list ends here.
This actually equals a list auxiliary pointer with zero index.
\item[{\tt const min::gen min::}\MINKEY{EMPTY\_SUBLIST}]~%
	\LABEL{MIN::EMPTY_SUBLIST}\\
A list element value that represents an empty sublist.
This actually equals a sublist auxiliary pointer with zero index.
\end{list}
\end{indpar}

Each hash table or attribute vector element is a \key{list head}.
Each list head is a \key{list continuation}, which is an element of the
body vector that has a particular interpretation, described below.
However, not all list continuations are list heads.

A list continuation represents a final segment of a list.
If it has the value \verb|min::LIST_END|, the final segment is empty.
If the list continuation has a list auxiliary pointer value,
that pointer points at another list continuation that continues the list.
Otherwise the list continuation represents an element of the list,
and is called a \key{list element}.

A list element is an element of the list, and cannot be a list auxiliary
pointer or the special value \verb|min::LIST_END|.  But it can be
a sublist auxiliary pointer, or the special value \verb|min::EMPTY_SUBLIST|,
both of which denote a list element that is a sublist.

Given a list element, the rest of the list after the element begins with
a list continuation that has an index one less than that of the list
element within the object body vector, unless the list element is a
list head, in which case there is no next element, and the list has only
one element.  All list heads lie in the hash table or attribute vector,
so testing whether a list element is a list head can be done if just the
index of the list element in the body vector is known.

A list element
that is a sublist auxiliary pointer or the value \verb|min::EMPTY_SUBLIST|
represents a sublist, and is the \key{sublist head} of that sublist.  A
sublist head is a list element of the list containing a sublist,
but cannot be a list element of the sublist.
If it is a sublist auxiliary pointer,
it points at a list continuation of the sublist.  If it is the
value \verb|min::EMPTY_SUBLIST|, it represents an empty sublist.

There are several rules that the list level obeys that lead to
some efficiencies:

\begin{indpar}
{\bf No Superfluous {\tt \bf min::LIST\_END}'s}.%
\index{superfluous LIST_END@superfluous {\tt LIST\_END}}%
\label{NO-SUPERFLUOUS-LIST}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a \verb|min::LIST_END| value.

{\bf No Superfluous List Auxiliary Pointers}.%
\index{superfluous list auxiliary pointers}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a list auxiliary pointer.

{\bf No List Sharing}.%
\index{list sharing}
Parts of lists may not be shared with other lists.  In other words,
there is only one way to reach any element of the auxiliary area.

Or more specifically, list and sublist
auxiliary pointers must point at elements of the auxiliary area,
two list or sublist auxiliary pointers are not permitted to point
at the same auxiliary
area element, and an auxiliary area element that is followed
in the auxiliary area by a list element may not be pointed at by
a list or sublist auxiliary pointer (because the following list element
in effect points at the auxiliary area element as being the
continuation of the list containing the following list element).
\end{indpar}

Thus if the one way to reach an element of
the auxiliary area is deleted, the element may be put on a list of
free elements for the auxiliary area.  As an optimization,
an implementation may use the unused area or space in the object's header
to hold a count of the freed elements as an aid to determine when to
reorganize the object.  It is even possible to establish a list of
free elements for reuse, but due to auxiliary area fragmentation this
may not be efficient.

As an optimization, \skey{auxiliary stub}s can be used in place of object
auxiliary area elements.  When this is done, the description of this
section must be modified as explained in \itemref{OBJECT-AUXILIARY-STUBS}.

\subsubsubsection{List Pointers}
\label{LIST-POINTERS}

A \key{list pointer} can be used to move around in a object at
the list level.
There are three kinds of list pointers.
A read-only \verb|min::list_ptr| permits read-only access to list
elements.
A read-write or updatable {\tt min::\EOL list\_\EOL updptr}
permits read-write access to list elements, but does not permit
adding or removing list elements.
An insertable {\tt min::\EOL list\_\EOL insptr}
permits adding and removing elements, in addition to permitting
read-write access to elements.

Note that unlike vector pointers, you \underline{cannot} downcast more capable
list pointers to less capable list pointers.  E.g., an
{\tt min::\EOL obj\_\EOL vec\_\EOL insptr} may be
explicitly or implicitly downcast to an
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr}
or {\tt min::\EOL obj\_\EOL vec\_\EOL ptr}, but 
a {\tt min::\EOL list\_\EOL insptr} may \underline{not} be
explicitly or implicitly downcast to an
{\tt min::\EOL list\_\EOL updptr}
or {\tt min::\EOL list\_\EOL ptr}.

The functions for using a read-only {\tt min::\EOL list\_\EOL ptr} are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_ptr}\verb| lp ( min::obj_vec_ptr & vp )|
\LABEL{MIN::LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINKEY{obj\_vec\_ptr\_of}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_ptr & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_ptr & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_ATTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_ptr & lp )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_ptr & lp )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_REFRESH_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_PTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{is\_list\_end}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{tabular}\end{indpar}

A list pointer is created to move around in a particular object.
Once created it can be started on a new list by one of the
\skey{start list function}s:
{\tt min::\EOL start\_\EOL hash}, {\tt min::\EOL start\_\EOL attr},
{\tt min::\EOL start\_\EOL copy}, or
the 2-argument {\tt min::\EOL start\_\EOL sublist}.
The {\tt min::\EOL next} function moves forward one element
in the current list,
while the {\tt min::\EOL peek} function returns the next element without
moving to it.
The list is always pointing at a current element, whose value is
returned by the {\tt min::\EOL current} function.

If the current element
is updated using {\tt min::\EOL update}
on another updatable or insertable list pointer,
the {\tt min::\EOL update\_\EOL refresh} function
must be used to reestablish the
current element's value,
which is \ikey{cached}{cache!list pointer}\label{LIST-POINTER-CACHE}
in the list pointer.
Similarly one of the {\tt min::\EOL\ldots\_refresh} functions may
need to be used when another pointer is used to insert elements into
or remove elements
from the object, though in some situations this is
not adequate and the list pointer must be restarted
with a {\tt min::\EOL start\_\dots} function.

A list pointer that has been created but not started by one of the
list start functions appears to be
at the end of an immutable empty list.

The {\tt min::\EOL start\_\EOL hash} function positions
a list pointer at the beginning of the
list whose head is at the given index within the hash table, treating the
hash table as a vector.  This function returns the value of the first
element of the list, or returns {\tt min::\EOL LIST\_\EOL END}
if the list is empty.
The index is usually the hash value of a name component
(number, string, or label),
modulo the size of the hash table,
but exactly how the index is computed is not determined by the object
list level.  Index 0 refers to the first element of the
hash table, and the maximum index is the size of the hash table minus 1.
The size of the hash table may be obtained from the
{\tt min::\EOL hash\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index.

The {\tt min::\EOL start\_\EOL attr} function is analogous except it is given
an index within the object attribute vector and positions the list pointer
at the beginning of the list whose head is the attribute vector element
at that index.  Index 0 refers to the first element of the attribute vector,
and the maximum index is the size of the attribute vector minus 1.
The size of the attribute vector may be obtained from the
{\tt min::\EOL attr\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index.

The {\tt min::\EOL start\_\EOL copy} function
positions a list pointer ({\tt lp})
to the same place as another list pointer ({\tt lp2}).
The two list pointers must have been constructed from the same
vector pointer.
Also note that the list pointer {\tt lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before {\tt min::\EOL start\_\EOL copy} is executed.

The value of a list element can represent a sublist
(see the {\tt min::\EOL is\_\EOL sublist} function described below).
The 2-argument {\tt min::\EOL start\_\EOL sublist} function
positions a list pointer ({\tt lp})
to the first element of the sublist represented by the current
element of another list pointer ({\tt lp2}).
The current element of the second pointer must represent a sublist.
This function returns the value of the first element of
the sublist, or returns {\tt min::\EOL LIST\_\EOL END} if the sublist is empty.
The two list pointers must have been constructed from the same
vector pointer.
Also note that the list pointer {\tt lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before {\tt min::\EOL start\_\EOL sublist} is executed.

The 1-argument {\tt min::\EOL start\_\EOL sublist} function
positions a list pointer
to the first element of the sublist represented by the current
element of the pointer (it is equivalent to 2-argument
{\tt min::\EOL start\_\EOL sublist} with \verb|lp2|$\equiv$\verb|lp|).
Again the list pointer must be valid before this function is executed.

The {\tt min::\EOL next} function moves the list pointer
to the next list element of the
list the pointer points at, and returns the value of that
list element.  It returns {\tt min::\EOL LIST\_\EOL END} if there is
no next list element because the end of the list has been reached.
After the end of a list has been reached, additional
calls to {\tt min::next}
will do nothing but return {\tt min::\EOL LIST\_\EOL END}.

The {\tt min::\EOL peek} function returns the next element of the
list, i.e., the
same value as the {\tt min::\EOL next} function would return, but does not
change the element the list pointer is pointing at, i.e., does not
modify the list pointer.

The {\tt min::current} function just returns the value of the list
element the list pointer currently points at, or returns
{\tt min::\EOL LIST\_\EOL END}
if there is no such element because the pointer is at the end of a list.
This function does not modify the list pointer.

The {\tt min::update\_\EOL refresh}
function must be called for
a pointer that points at an element if the {\tt min::\EOL update} function
is used with \underline{another} pointer to the same object to update
the element, or if the element is a sublist head and a function is used
to remove the first element of the sublist or insert elements at the
beginning of the sublist or after the first element of the sublist.
The {\tt min::\EOL insert\_\EOL refresh} function must be called if the
{\tt min::\EOL insert\_\EOL reserve} function is used with \underline{another}
pointer to the same object and that function returned \verb|true| indicating
that it resized the object.  The 
{\tt min::\EOL insert\_\EOL reserve} function also does what the
{\tt min::\EOL update\_\EOL reserve} function does, and therefore it is
never necessary to call both functions.
There are also situations detailed on \pagref{RESTARTING_LIST_PTR}
in which use of {\tt min::\EOL insert\_\EOL before},
{\tt min::\EOL insert\_\EOL after}, or
{\tt min::\EOL remove} with \underline{another} pointer to the same object
absolutely requires that the current pointer be
restarted by a {\tt min::\EOL start\_\ldots} function.

Determining whether a list pointer current element value
represents a sublist requires
the {\tt min::\EOL is\_\EOL sublist} function, which must check whether the
value is a sublist auxiliary pointer,
is the value {\tt min::\EOL EMPTY\_\EOL SUBLIST},
or is a pointer to a sublist auxiliary stub as described in
\itemref{OBJECT-AUXILIARY-STUBS}.
The {\tt min::\EOL is\_\EOL empty\_\EOL sublist}
function, on the other hand, merely checks whether the value is
{\tt min::\EOL EMPTY\_\EOL SUBLIST}.

Determining whether a list pointer current element value
represents the end of a list can be done by
simply checking whether the value equals {\tt min::\EOL LIST\_\EOL END},
or can be done equivalently
with the {\tt min::\EOL is\_\EOL list\_\EOL end} function.

An {\tt min::list\_\EOL updptr} allows read-write access to
list elements without permitting insertion or removal of elements
from lists.  The functions for using this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_updptr} \verb|lp| \\
	& \verb|    ( min::obj_vec_updptr & vp )|
\LABEL{MIN::LIST_UPDPTR_OF_VEC_UPDPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_updptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of} \\
	& \verb|    ( min::list_updptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_updptr & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_HASH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_updptr & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_ATTR_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::list_updptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::list_updptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::list_updptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_updptr & lp )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_updptr & lp )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_REFRESH_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::list_updptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_UPDPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::list_updptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_updptr & lp,| \\
	  \verb|   min::gen value )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}

Functions defined for read-only list pointers are also
applicable to updatable (read-write) list pointers with the
same results.  However, updatable list pointers
can\underline{not} be converted to be read-only list pointers
(unlike the situation with vector pointers).
Also note that {\tt min::start\_\EOL sublist} works when
\verb|lp2| is a read-only list pointer, but {\tt min::start\_\EOL copy}
does not.

The {\tt min::update} function can be used to replace the
value of the current element of a list.
Neither the previous value of the element nor the
new value of the element may be {\tt min::\EOL LIST\_\EOL END},
and neither may represent a sublist (even an empty sublist).

If a list pointer {\tt lp2} points at a element that is
{\tt min::update} using a different updatable list pointer {\tt lp1},
then {\tt lp2} will be invalid until
{\tt min::\EOL update\_\EOL refresh(lp2)},
{\tt min::\EOL insert\_\EOL refresh(lp2)}, or
{\tt min::\EOL start\_\ldots(lp2,\ldots)}
has been executed.

Inserting and removing elements from a list requires yet another
kind of list pointer, an insertable list pointer,
{\tt min::\EOL list\_\EOL insptr}.
The functions defined for this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_insptr} \verb|lp| \\
	& \verb|    ( min::obj_vec_insptr & vp )|
\LABEL{MIN::LIST_INSPTR_OF_VEC_INSPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_insptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of} \\
	& \verb|    ( min::list_insptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_HASH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_ATTR_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::list_insptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::list_insptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::list_insptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_REFRESH_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::list_insptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_INSPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::list_insptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp,| \\
	  \verb|   min::gen value )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{insert\_reserve\REL}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp,| \\
	  \verb|   min::unsptr insertions,| \\
	  \verb|   min::unsptr elements = 0,| \\
	  \verb|   bool use_obj_aux_stubs =| \\
	  \verb|       min::use_obj_aux_stubs )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp,| \\
	  \verb|   min::gen * p, min::unsptr n )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp,| \\
	  \verb|   min::gen * p, min::unsptr n )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_AFTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{remove}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_insptr & lp,| \\
	  \verb|   min::unsptr n = 1 )|
	  \end{tabular}
\LABEL{MIN::REMOVE_FROM_LIST_INSPTR} \\
\end{tabular}\end{indpar}

Functions defined for updatable (and read-only) list pointers are also
applicable to insertable list pointers with the
same results.  However, insertable list pointers
can\underline{not} be converted to be updatable or read-only list pointers
(unlike the situation with vector pointers).
Note that {\tt min::start\_\EOL sublist} works when
\verb|lp2| is a read-only or updatable
list pointer, but {\tt min::start\_\EOL copy}
does not.

Also, there is one function, {\tt min::update}, that can do more for
an insertable list pointer than it can for an updatable list pointer.  For
an insertable list pointer (but not for an updatable list pointer)
the current value replaced by {\tt min::update}
may be a sublist, and/or the replacing value may be
{\tt min::\EOL EMPTY\_\EOL SUBLIST}.  Thus {\tt min::update} can be used
to remove a sublist or to create an empty sublist.

Making insertions in object lists requires reservation of the necessary
space first, in order to be sure that a sequence of insertions will
all succeed.
The {\tt min::insert\_reserve} function reserves space for the given number
of insertion function calls and the given total number of list elements
to be inserted.  If the later is {\tt 0}, the default, it is taken to
be equal to the number of insertion function calls.  If space is not
reserved for insertion function calls in this way, the calls will be
in error.

The {\tt min::insert\_reserve\REL} function may resize the body of
the object in which space is being reserved
(using {\tt min::\EOL resize\REL},
\pagref{MIN::RESIZE_UNUSED_OF_VEC_INSPTR}).
It returns \verb|true| if it
resizes the object's body, and \verb|false| if it does not.
It sets the relocated flag (\pagref{RELOCATED-FLAG}) if it
resizes the body and must relocate any \underline{other} body,
but not if it just resizes and possibly relocates
the body of the object in which space is being reserved.
It returns \verb|false| if it relocates the body but does
\underline{not} resize it.

Only one pointer at a time
for a given object may have an effective reservation.
Each call to {\tt min::\EOL insert\_reserve} for a list pointer
to an object invalidates all previous calls to
{\tt min::\EOL insert\_reserve} for any list pointer
to the same object.  Errors in this regard involving two different
list pointers will be detected if insufficient memory is reserved,
but not otherwise.

Note that {\tt min::\EOL insert\_reserve} is the only list pointer
function that may cause a relocation and/or resizing of
the object pointed at, and if a resizing occurs (i.e., if \verb|true|
is returned),
all other list pointers to the same object
become invalid and must be refreshed by
a call to {\tt min::\EOL insert\_\EOL refresh}.

The {\tt min::\EOL insert\_reserve} function can increase the size of the object
if it is insufficient, or instead it can depend upon using
object auxiliary stubs (\itemref{OBJECT-AUXILIARY-STUBS}) if the object
runs out of space, in which case {\tt min::\EOL insert\_reserve} must be sure
there are sufficient free stubs to satisfy the insertion calls.  The
last argument to {\tt min::\EOL insert\_reserve} determines which strategy is
used.  It defaults to the value of \minkey{use\_obj\_aux\_stubs}
(see \pagref{MIN::USE_OBJ_AUX_STUBS}).%
\footnote{But if the auxiliary stub code is not compiled in, the last
argument is treated as if it was always {\tt false}:
see {\tt MIN\_\EOL USE\_\EOL OBJECT\_\EOL AUX\_\EOL STUBS} on
\pagref{MIN_USE_OBJ_AUX_STUBS}.}

The {\tt min::\EOL insert\_before} function inserts list elements
just before the current position of a list pointer and positions the
list pointer to the first element inserted.
The {\tt min::\EOL insert\_after} function inserts list elements just after the
current position and leaves the pointer position unchanged (pointing at
the element before the first inserted element).
If the list pointer is at the end of list,
{\tt min::\EOL insert\_before} inserts the elements at the end of the list, and
{\tt min::\EOL insert\_after} is in error.
The elements are specified by a length {\tt n}
vector {\tt p} of {\tt min::gen} values.
\verb|p[0]| is inserted into the list before \verb|p[1]|, etc.
If \verb|n=0| elements are to be inserted, both insert
functions are no operations.

To insert a sublist, first insert {\tt min::\EOL EMPTY\_SUBLIST}, then
position the pointer to the sublist and use
{\tt min::\EOL start\_sublist} to enter the sublist, and then use
{\tt min::\EOL insert\_before} to insert the elements of the sublist.
Also, as noted above, you can use {\tt min::\EOL update} with an
insertable pointer to change
the current element to {\tt min::\EOL EMPTY\_\EOL SUBLIST}.

A sequence of instructions that begins with a
call to {\tt min::\EOL insert\_reserve} and ends with the last
list insertion function for which the beginning call made a reservation
is called a `\key{list insertion sequence}'.  A list insertion sequence
must not contain any call to
a relocating (\REL) function (\pagref{RELOCATING-FUNCTIONS}), aside from
the beginning call to {\tt min::\EOL insert\_reserve}.  In particular, there can
be no call to {\tt min::\EOL interrupt\REL} (\pagref{MIN::INTERRUPT}) and no
second call to {\tt min::\EOL insert\_reserve\REL}.  There can be calls to
create and position list pointers, and to read, update, and remove
list elements.

If {\tt min::\EOL insert\_\EOL before}
or {\tt min::\EOL insert\_\EOL after}
are used to insert elements at the beginning of a sublist or elements
just after the first element of a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to {\tt min::\EOL update\_\EOL refresh} or
{\tt min::\EOL insert\_\EOL refresh} or restarted with a call to a
{\tt min::\EOL start\_\ldots} function.

The {\tt min::\EOL remove} function can be used to remove
{\tt n} consecutive elements
of a list, the first of which is the element currently pointed at by
the list pointer.
After removal, the list pointer points at the first element after the
elements removed, or at the end of the list if there is no such element.
If there are fewer than {\tt n} elements in the list at and after
the list pointer current element, then there is no error, but all the
elements at and after the current element are removed, and the list
pointer is pointed at the end of the list.  The returned value is the
number of elements actually removed (and is less than {\tt n} if the
list was too short).  Element removal requires no reservation.

If {\tt min::\EOL remove} is used to remove the first element of
a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to {\tt min::\EOL update\_\EOL refresh} or
{\tt min::\EOL insert\_\EOL refresh} or restarted with a call to a
{\tt min::\EOL start\_\ldots} function.

If an insertable list pointer {\tt lp2} is used to add or remove
elements or remove sublists, and there is another list pointer {\tt lp1}
pointing at the same object, then {\tt lp1} is invalidated and must
be restarted with a
{\tt min::\EOL start\_}\,\ldots function\label{RESTARTING_LIST_PTR}
if {\tt lp1} is pointing at:

\begin{enumerate}
\item an element that is removed
\item an element in a removed sublist
\item the end of a removed sublist
\item an element adjacent to an element that is inserted or removed
\item the end of a list whose last element is inserted or removed
\item the first element of a sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\item the end of an empty sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\end{enumerate}

The effects can be subtle
and not obvious: for example, using {\tt lp2} to insert before or after
a list element that is an empty sublist can invalidate {\tt lp1}
if {\tt lp1} points at the end of that empty sublist.

The invalidation of {\tt lp1} in the above situations
is \underline{not} a detectable error.

\begin{quote}
\key{List Implementation Note}:\label{LIST-IMPLEMENTATION-NOTE}
In order to enforce the `No Superfluous' rules on 
\pagref{NO-SUPERFLUOUS-LIST}, {\tt MUP::list\_insptr}'s keep
track of the location of any auxiliary pointer
(or equivalent as per \itemref{OBJECT-AUXILIARY-STUBS})
pointing a the current
element.  Insertions before or after the current element may change
this auxiliary pointer, and may move the current element to another
location.  Otherwise insertions replace the current element
by an auxiliary pointer (or equivalent)
pointing at a vector of elements (or equivalent),
one of which is a copy of the replaced element.
This last is done for insertions after the single element of a one
element list headed in the hash table or attribute vector.
Any insertion before the end of a list of such a single element list
is transformed into an insertion after the list's single element.
\end{quote}

The various list pointer types are instances of
\verb|MUP::|\MUPKEY{list\_ptr\_type} defined as follows:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_ptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_ptr}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_updptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_updptr}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_insptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_insptr}\verb|;| \\
\end{tabular}\end{indpar}

It is important not to instantiate {\tt MUP::list\_ptr\_type}
with any parameter that is not a vector pointer type (which is why
it is unprotected).

\subsubsubsection{Object Auxiliary Stubs}
\label{OBJECT-AUXILIARY-STUBS}

As an optimization, \skey{object auxiliary stub}s\index{auxiliary stub!object}
can be used instead of object
auxiliary area elements.  Object auxiliary stubs are a way of adding
list elements to
an object whose unused area has been exhausted, without relocating the
object.  Object auxiliary stubs
are considered to be \skey{extension}s of the object.
If the object is later relocated, it can be reorganized to
eliminate the use of any object auxiliary stubs that extend the object
by moving information from these into a new larger object auxiliary area.

The code implementing object auxiliary stubs can be compiled into a program
or left out of a program according to the setting of the macro:


\begin{indpar}
\begin{tabular}{l}
\TTNBKEY{MIN\_USE\_OBJ\_AUX\_STUBS} \\
~~~~~ 1 if code to use object auxiliary stubs is to be compiled; \\
~~~~~ 0 if this code is not to be compiled; the default.
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\end{tabular}
\end{indpar}

If compiled, the code can be enabled or disabled by setting the
following variable:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs} \\
& ~~~~\verb|true| to enable use of object auxiliary stubs; the default \\
& ~~~~\verb|false| to disable use of object auxiliary stubs
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{tabular}\end{indpar}

The value of an object
auxiliary stub is treated like an auxiliary area element value that is
always a list element, and is never a list auxiliary pointer
or a \verb|min::LIST_END| value.  However, as a list element,
the value may be a sublist auxiliary pointer (or equivalent, see below)
or a \verb|min::EMPTY_SUBLIST| value.

The control of an object auxiliary stub is treated like an auxiliary
area element value that is always a list auxiliary pointer
or a \verb|min::LIST_END| value, and is never a list element.

The value and control of an object auxiliary stub are treated like
consecutive elements of the object auxiliary area, with the control
preceding the value in the area, and therefore
following the value in list order.

An object auxiliary stub has one of the following two uncollectable stub type
codes:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const int min::}\MINKEY{LIST\_AUX}]~%
	\LABEL{MIN::LIST_AUX}\\
A \verb|min::gen| value or stub control
pointing at this stub behaves like a list pointer.
\item[{\tt const int min::}\MINKEY{SUBLIST\_AUX}]~%
	\LABEL{MIN::SUBLIST_AUX}\\
A \verb|min::gen| value pointing at this stub behaves like a sublist pointer.
\end{list}
\end{indpar}

Any stub pointer to an object auxiliary stub of type \minnbkey{LIST\_AUX}
is treated as a list auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \verb|min::gen| values or in auxiliary stub controls.

Any stub pointer to an object auxiliary stub of type \minnbkey{SUBLIST\_AUX}
is treated as a sublist auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \verb|min::gen| values or in auxiliary stub \verb|min::gen|
values.

Thus the following rules are obeyed:

\begin{indpar}

{\bf \minnbkey{LIST\_AUX} stubs}.
An auxiliary area element
holding a \verb|min::gen| value that points at a stub $S$
of type \verb|min::LIST_AUX| is the equivalent of a list auxiliary
pointer pointing at the list element that is stub $S$'s value.

If the control of an object auxiliary stub holds a stub pointer, that pointer
must point at an object auxiliary stub $S$ of type \verb|min::LIST_AUX| and the
control is the equivalent of a list auxiliary pointer pointing at
the list element that is stub $S$'s value.

{\bf \minnbkey{SUBLIST\_AUX} stubs}.
An auxiliary area element holding a \verb|min::gen| value that points at
a stub $S$
of type \verb|min::SUBLIST_AUX| is the equivalent of a sublist auxiliary
pointer pointing at the list element that is stub $S$'s value.

An object auxiliary stub \verb|min::gen| value that points at
a stub $S$ of type {\tt min::\EOL SUBLIST\_\EOL AUX}
is the equivalent of a sublist auxiliary
pointer pointing at the list element that is stub $S$'s value.

{\bf Values of Object Auxiliary Stubs}.%
\index{value!of object auxiliary stub}
An object auxiliary stub value is always a list element, and can never
be a list auxiliary pointer value, a \verb|min::gen| value pointing at
a stub of type \verb|min::LIST_AUX|, or a \verb|min::LIST_END| value.

However, it can be a sublist auxiliary pointer value, a \verb|min::gen|
value pointing at a stub of type \verb|min::SUBLIST_AUX|, or a
\verb|min::EMPTY_SUBLIST| value.

{\bf Controls of Object Auxiliary Stubs}.%
\index{control!of object auxiliary stub}
An object auxiliary stub control is never a list element, and must
be a list auxiliary pointer value, a stub pointer value pointing at
a stub of type \verb|min::LIST_AUX|, or a \verb|min::LIST_END| value.

{\bf Pointers to Object Auxiliary Stubs}.%
\index{pointer!to object auxiliary stub}
Every object auxiliary stub is pointed at by a \verb|min::gen|
value or by the control of another object auxiliary stub.  There is
only one such pointer pointing at each object auxiliary stub.
A \verb|min::gen| value pointing at an object auxiliary stub $S$
must the the value of an auxiliary area element or the value of
an object auxiliary stub, and in this latter case $S$ must be of type
\verb|min::SUBLIST_AUX|.

\end{indpar}

Object auxiliary stubs
must obey the object list level rules on \pagref{NO-SUPERFLUOUS-LIST}.
This means, for example, that a list auxiliary pointer cannot point
at an auxiliary area element that holds a \verb|min::gen| value
pointing at an object auxiliary stub of type \verb|min::LIST_AUX|,
as this would be equivalent to a list auxiliary pointer pointing at an
element holding another list auxiliary pointer.

The use of object auxiliary stubs by an implementation is hidden from
the user of MIN by object list level functions.  There are no functions
for dealing explicitly with object auxiliary stubs.  There are, however,
functions to read and write stubs of all kinds in
\itemref{UNPROTECTED-STUB-FUNCTIONS}, though the only use of these functions on
object auxiliary stubs would be for debugging.

\subsubsection{Typed Objects}
\label{TYPED-OBJECTS}

A \key{typed object} is a pair of objects: the \mkey{type}{of typed object}
which provides attribute labels, and the \mkey{context}{of typed object}
which provides variables that give attribute values.  The type
contains variable indices that act as indirect pointers to the
variables in the context.  By abuse of language the context may be
called the `typed object'.

Typed objects may be introduced in two different ways.  In the first
method the context is given the {\tt min::\EOL OBJ\_\EOL TYPED} flag
and its first variable points at the type.  In the second method
the typed object is represented by a stub of {\tt min::\EOL TYPED\_\EOL OBJECT}
type which in turn points at an auxiliary stub that holds two pointers
to stubs: one pointing at the type and the second pointing at the context.
The type is pointed at by the control of the auxiliary stub, the context
is pointed at by the value of the auxiliary stub.

Typed objects make use of two kinds of indirect pointer.  The first is
just a single index \verb|min::gen| value that holds the index of a
variable vector element.  This always refers to a variable in the context.
The second is an indirect \verb|min::gen| value that points at a pair
of values in an auxiliary area: the first being an index \verb|min::gen|
value and the second a pointer-to-object-stub \verb|min::gen| value.
This refers the the variable vector element of the object pointed to
that is indexed by the given index.  If an attribute value is an indirect
pointer, the indirection is taken to the variable element referred to.
If that in turn has an indirect pointer value, that indirection is also
taken, to any depth.

\subsubsection{Object Attribute Level}
\label{OBJECT-ATTRIBUTE-LEVEL}

At the \key{attribute level}\,, the object is a map from attribute-names to
flags and multi-sets of values and from attribute-name/reverse-attribute-name
pairs to multi-sets of values.
Here names are sequences of name components, which are
numbers, strings, or labels.  The object map is stored in a set of lists which
are entries in the hash table or attribute vector.  These lists have
one of two syntaxes depending upon the setting of the following macro:

\begin{indpar}
\begin{tabular}{l}
\TTNBKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS} \\
~~~~~ 1 if partial attribute labels are supported; \\
~~~~~ 0 if partial attribute labels are not supported.
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}
\end{indpar}

If partial attribute labels are supported, the attribute name given to
a function that locates an attribute may be too long,
and the function will use only an initial segment of that name,
returning the length of that segment.

If partial attribute names are \underline{not} supported
the object lists have the syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em hash-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em vector-list}
\\[1ex]
\emkey{hash-list} ::= {\em attribute-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{vector-list} ::= {\em attribute-descriptor-option}
\\[1ex]
\emkey{attribute-name-descriptor-pair} ::=
    {\em attribute-name } {\em attribute-descriptor}
\\[1ex]
\emkey{attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{attribute-descriptor} ::= {\em value} $|$ {\em attribute-sublist}
\\[1ex]
\emkey{attribute-sublist} ::=
    {\em value}$\,^\star$ {\em double-arrow-sublist-option} {\em flag-set}
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

Here the syntactic categories represent \verb|min::gen| values
or lists or sublists
of \verb|min::gen| values in the sense of the object list level.

An {\em X-list} is a list, in the sense of the object list level.  Thus
a {\em hash-list} and {\em vector-list} are lists.

An {\em X-sublist} is a sublist, in the sense of the object list level, which
is to say it is a list that is an element of another list.  Thus
{\em attribute-sublists} and {\em double-arrow-sublists} are sublists.

An {\em X-option} is an optional element of a list that is an {\em X} if
it is not omitted.

Everything else is a single list element or
a sequence of elements in some list or sublist.
{\em X-pairs} are sequences of two elements.
{\em Flag-sets} are sequences of {\em control-codes}.

An {\em atom} is a \verb|min::gen| number or string.
An {\em label} is a \verb|min::gen| label.
An {\em object} is a \verb|min::gen| value pointing at an object stub.
A {\em control-code} is a \verb|min::gen| control code value.
An {\em index} is a \verb|min::gen| index value.
An {\em indirect-auxiliary} is a \verb|min::gen| indirect auxiliary value.

The above form of object map maps an {\em attribute-name} to a list of
{\em values}, a list of flag {\em control codes}, and a optional
{\em double-arrow-sublist}.  This last maps {\em reverse-attribute-names}
to lists of values.

The lists of {\em values} here represent multisets of {\em values}.
That is, the
order of the {\em values} in the list is not meaningful.
Similarly the order of {\em attribute-name-descriptor-pairs}
in a {\em hash-list}
or the order of {\em double-arrow-name-descriptor-pairs}
in a {\em double-arrow-sublist} is not meaningful.
On the other hand, a {\em flag-set} is actually an ordered list
of {\em control-codes}; here order matters.

A {\em hash-list} is simply a list of alternating {\em attribute-names}
and {\em attribute-descriptors}.
The long form of an {\em attribute-descriptor} is an
{\em attribute-sublist} that gives  a possibly empty list of {\em values},
an optional {\em double-arrow-sublist}, and a possibly empty
list of flag control codes.
If the {\em attribute-sublist}
would be nothing but a one element list containing
a single {\em value}, a common case, the {\em attribute-sublist}
may be replaced by this single
{\em value}, in the interests of optimizing memory.

An empty {\em attribute-sublist} is equivalent to a missing
{\em attribute-name-descriptor-pair}.
{\em Attri\-bute-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

A {\em vector-list} may either be empty or have exactly one element.
If it has one element, that element is
the {\em attribute-descriptor} which is associated with the
{\em attribute-name} that equals the vector index of the
attribute vector element in which the {\em vector-list} is stored.
If a vector index has no associated attribute, either its
{\em vector-list} can be empty, or its
{\em attribute-descriptor} can be the empty sublist.

{\em Attribute-names} can be either {\em atoms} or {\em labels}.
If an {\em attribute-name} is an integer {\em atom}
that is in the range of a legal
attribute vector index then a {\em vector-list} with one element that is
an {\em attribute-descriptor}
is put in the attribute vector element
indexed by the integer.
Otherwise an {\em attribute-name-descriptor-pair} containing
the {\em attribute-name} is put
in the {\em hash-list} of the object's hash table entry whose index
in the hash table
equals the hash of the {\em attribute-name} modulo the length of the
hash table.

A {\em double-arrow-sublist} is 
simply a sublist of alternating {\em reverse-attribute-names}
and {\em value-multisets}.  The former are just like {\em attribute-names}
and the latter are just like {\em attribute-descriptors} that have no
flag control codes or {\em double-arrow-sublists}.

An empty {\em value-multiset} is equivalent to a missing
{\em double-arrow-name-descriptor-pair}.
{\em Dou\-ble-arrow-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are \underline{not} supported, multi-component
attribute names are represented in object data lists as labels.
Thus an {\em attribute-name} is an {\em atom} if it represents a 1-component
attribute name, and a {\em label} if it represents a several component
attribute name, or if it represents a 1-component name whose one component
is itself a label.

In the interests of compatibility with the case where partial attribute
names are supported, {\em attribute-names} and {\em reverse-attribute-names}
that are {\em labels} whose sole element is an {\em atom} are not
permitted in the object data lists, and when functions are presented with
such names, the functions replace them with their sole element, namely the
{\em atom}.  In addition, {\em attribute-names} that are labels with no elements
are forbidden, for reasons of compatibility.

If partial attribute names \underline{are} supported
the object lists have the following alternative syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em node-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em vector-list}
\\[1ex]
\emkey{node-list} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{vector-list} ::= {\em node-descriptor-option}
\\[1ex]
\emkey{node-name-descriptor-pair} ::=
    {\em attribute-name-component } {\em node-descriptor}
\\[1ex]
\emkey{attribute-name-component} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{node-descriptor} ::= {\em value} $|$ {\em node-sublist}
\\[1ex]
\emkey{node-sublist}
    \begin{tabular}[t]{@{}r@{~}l@{}}
    ::= & {\em value}$\,^\star$
          {\em flag-set} \\
    $|$ & {\em value}$\,^\star$
          {\em child-sublist}
	  {\em double-arrow-sublist-option}
	  {\em flag-set}
    \end{tabular}
\\[1ex]
\emkey{child-sublist} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

This differs from the previous representation in that the object map
is represented by a tree of nodes,
where each node is labeled by an {\em attribute-name-component}.
An {\em attribute-name} is viewed as a sequence of
{\em attribute-name-components}, so the {\em attribute-name}
defines a path in the tree from the root to a node.
Each node has an associated {\em node-descriptor} that
contains the node {\em values},
optional {\em double-arrow-sublist}, and flag control codes,
which are associated
with the {\em attribute-name} that names the path from the root to the
node.  The {\em node-descriptor} also may contain
an optional {\em child-sublist}
which describes the children of the node in the tree.

A {\em hash-table-entry} is a {\em node-list} that gives alternating
{\em attribute-name-component}/\EOL {\em node-\EOL de\-scrip\-tor} pairs for
children of the object root node.  A {\em attribute-vector-entry}
just describes one node that is a child of the root, namely the node
whose {\em attribute-name-component} equals the vector index of the
{\em attribute-vector-entry} in the object's attribute vector.
For a node that is a child of the object root,
if the child node's {\em attribute-name-component} is an integer in the legal
range of the object's attribute vector indices, then the child node's
{\em node-descriptor} is stored in the {\em vector-list}
that is stored in the object's attribute vector element.
A {\em vector-list} is either empty or is a one element list whose element is a
{\em node-descriptor}.  If a vector index is not the first component of
any of the object's attribute names, then the corresponding {\em vector-list}
can either be empty or can consist of just an empty {\em node-descriptor}
{\em node-sublist}.

For a child of the root whose name component is not a legal attribute
vector index, its {\em attribute-name-component} and
{\em node-descriptor} is placed in the {\em hash-table-entry}
whose index in the object's hash table equals the hash of the
{\em attribute-name-component} modulo the length of the hash table.

A {\em node-descriptor} that consists of nothing but a single {\em value}
can be represented by just that {\em value}; otherwise it is represented
by a {\em node-sublist}.  If this last contains a sublist, the first
such sublist must
be the {\em child-sublist}, which has the same structure as a {\em node-list}
and describes the children of the node.  Otherwise neither the
{\em child-sublist} nor the {\em double-arrow-sublist} can be present.
Note that to avoid ambiguity it is not permitted to omit the
{\em child-sublist} without also omitting
the {\em double-arrow-sublist}, but the
{\em child-sublist} can be empty.  Except for these details
the {\em node-descriptor} structure is the same was as that of the
{\em attribute-descriptor} in the case where partial attribute names are
not allowed.  The {\em double-arrow-sublist} structure is exactly
the same.

An empty {\em node-sublist} is equivalent to a missing
{\em node-name-descriptor-pair}.
{\em Node-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are supported, an attribute name is viewed
as a sequence of {\em attribute-name-components}.  If this sequence is
a single {\em atom}, function arguments representing the name can be
either this {\em atom} or a {\em label} whose only element is the {\em atom}.
Otherwise function arguments must be non-empty
{\em labels} whose elements are the {\em attribute-name-components}.
Note that zero length attribute names are forbidden.

\ikey{Attribute flags}{attribute flag!representation}\label{ATTRIBUTE-FLAGS}
are represented by a {\em flag-set} in an {\em attribute-sublist} or
{\em node-sublist}.
The {\em flag-set} is a sequence of \verb|min::gen|
control codes.

The flags are numbered 0, 1, 2, \ldots.  Flag $N$ corresponds to
the bit in the $I+1$'st control code
selected by the mask $2^K$ where $I=\mbox{floor}(N/\mbox{\tt VSIZE})$,
$K=N~\mbox{mod}~\mbox{\tt VSIZE}$, where {\tt VSIZE},
the number of bits in a control code integer,
is the value of the \verb|min::VSIZE| constant (\pagref{MIN::VSIZE}),
which is 24 if \verb|min::gen|
values are 32-bits, and 40 if \verb|min::gen| values are 64-bits.
A flag is set for an attribute name if and only if its corresponding
bit is present and set and in the attribute's {\em flag-set}.
If a flag's bit is not present in the {\em flag-set}, the flag is
treated as if its bit were present and cleared.

\subsubsubsection{Attribute Pointers}
\label{ATTRIBUTE-POINTERS}

An \key{attribute pointer} can be used to access attribute
flags and values
in an object.
An attribute pointer stores an attribute name
and a reverse attribute name.  The latter can take the special
values {\tt min::NONE} and {\tt min::ANY}.  The attribute name designates
the object attribute pointed at by the attribute pointer.
The flag set pointed at is always
the flag set of this attribute, regardless of the setting of the
reverse attribute name.  The attribute name and
reverse attribute name together designate the
value multiset pointed at.  If the reverse attribute name
is {\tt min::NONE}, the value multiset pointed at is the set of all values
\underline{not} associated with any reverse attribute name.  If the
reverse attribute name is {\tt min::ANY},
the value multiset is the set of all
values that are associated with any reverse attribute name.
Otherwise the value multiset pointed at is the set of values
associated with the reverse attribute name stored in the pointer.

There are three kinds of attribute pointers.
A read-only {\tt min::\EOL attr\_\EOL ptr}
permits read-only access to attribute values and flags.
An updatable {\tt min::\EOL attr\_\EOL updptr}
permits read-write access to attribute values, and read-only access
to flags, but does not permit values to be added or removed from attributes.
An insertable {\tt min::\EOL attr\_\EOL insptr}
permits read-write access to attribute values and flags
and also permits values to be added or removed from attributes.

The functions for using a read-only {\tt min::\EOL attr\_\EOL ptr}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_ptr}\verb| ap ( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_PTR_OF_OBJ_VEC_PTR} \\
\verb|void min::|
	& \MINKEY{locate}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_ptr & ap,| \\
	  \verb|   min::gen name )|
	  \end{tabular}
\LABEL{MIN::LOCATE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_ptr & ap, int name )|
	  \end{tabular}
\LABEL{MIN::LOCATEI_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_ptr & ap, min::unsptr name )|
	  \end{tabular}
\LABEL{MIN::LOCATEI_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_ptr & ap,| \\
	  \verb|   min::unsptr & length, min::gen name )|
	  \end{tabular}
\LABEL{MIN::LOCATE_PARTIAL_ATTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_ptr & ap,| \\
	  \verb|   min::gen reverse_name )|
	  \end{tabular}
\LABEL{MIN::LOCATE_REVERSE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_ptr & ap )| \\
	  \end{tabular}
\LABEL{MIN::RELOCATE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}%
    \begin{tabular}[t]{@{}l@{}}
    \verb| ( min::gen * out, min::unsptr n,| \\
    \verb|   min::attr_ptr ap )| \\
    \end{tabular}
\LABEL{MIN::GET_OF_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}%
    \verb| ( min::attr_ptr ap )|
\LABEL{MIN::GET1_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}%
    \begin{tabular}[t]{@{}l@{}}
    \verb| ( min::gen * out, unsigned n,| \\
    \verb|   min::attr_ptr ap )| \\
    \end{tabular}
\LABEL{MIN::GET_FLAGS_OF_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb| ( min::attr_ptr wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|  min::unsptr flag_count;|\ARGBREAK
    \verb|  min::unsptr reverse_attr_count;|\ARGBREAK
    \verb|};|
\ttmindex{name}{in {\tt min::attr\_info}}
\ttmindex{value\_count}{in {\tt min::attr\_info}}
\ttmindex{flag\_count}{in {\tt min::attr\_info}}
\ttmindex{reverse\_attr\_count}{in {\tt min::attr\_info}}
\LABEL{MIN::ATTR_INFO} \\
\verb|typedef | & \verb|min::packed_vec<attr_info>|\ARGBREAK
                       \verb|min::|\MINKEY{attr\_info\_vec}
\LABEL{MIN::ATTR_INFO_VEC} \\
\verb|min::attr_info_vec | & 
                       \verb|min::|\MINKEY{attr\_info\_vec\_type}
\LABEL{MIN::ATTR_INFO_VEC_TYPE} \\
\verb|typedef | & \verb|min::attr_info_vec::ptr|\ARGBREAK
                       \verb|min::|\MINKEY{attr\_info\_ptr}
\LABEL{MIN::ATTR_INFO_PTR} \\
\verb|min::gen min::| & \MINKEY{get\_attrs}\ARGBREAK
    \verb| ( min::attr_ptr ap )|
\LABEL{MIN::GET_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_attr\_info} \verb|( min::gen v )|
\LABEL{MIN::SORT_ATTR_INFO} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{reverse\_attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|};|
\ttmindex{name}{in {\tt min::reverse\_attr\_info}}
\ttmindex{value\_count}{in {\tt min::reverse\_attr\_info}}
\LABEL{MIN::REVERSE_ATTR_INFO} \\
\verb|typedef | & \verb|min::packed_vec<reverse_attr_info>|\ARGBREAK
                       \verb|min::|\MINKEY{reverse\_attr\_info\_vec}
\LABEL{MIN::REVERSE_ATTR_INFO_VEC} \\
\verb|min::reverse_attr_info_vec | & 
                       \verb|min::|\MINKEY{reverse\_attr\_info\_vec\_type}
\LABEL{MIN::REVERSE_ATTR_INFO_VEC_TYPE} \\
\verb|typedef | & \verb|min::reverse_attr_info_vec::ptr|\ARGBREAK
                       \verb|min::|\MINKEY{reverse\_attr\_info\_ptr}
\LABEL{MIN::REVERSE_ATTR_INFO_PTR} \\
\verb|min::gen min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
    \verb| ( min::attr_ptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_reverse\_attr\_info} \verb|( min::gen v )|
\LABEL{MIN::SORT_REVERSE_ATTR_INFO} \\
\end{tabular}\end{indpar}

Attribute pointers are tied to an object, which is specified by
giving a vector pointer to the object to the constructor of the
attribute pointer.

\ikey{Locator functions}{locator function}
find attributes within an object and set the current
attribute name and reverse attribute name of an attribute pointer.
The {\tt min::\EOL locate} function sets the attribute name of the pointer.
If the `{\tt length}' argument is \underline{not} given, {\tt min::\EOL locate}
uses the complete attribute name.
The {\tt min::\EOL locatei} function does the
same thing as {\tt min::\EOL locate}
but is optimized for the case where the attribute
name has a single component that is an integer.\footnote{
In some implementations {\tt min::gen} is defined to be {\tt min::uns64},
and in these implementations {\tt int} and {\tt min::unsptr} are
incorrectly convertible to the
{\tt min::gen} type by a C++ implicit conversion.  As a consequence of this
the {\tt min::\EOL locatei} function must have a different name from the
{\tt min::\EOL locate} function.}

The form of the {\tt min::\EOL locate} function that takes a `{\tt length}'
argument exists only if the
{\tt MIN\_\EOL ALLOW\_\EOL PARTIAL\_\EOL ATTR\_\EOL LABELS}
(\pagref{MIN_ALLOW_PARTIAL_ATTR_LABELS}) macro is set to {\tt 1}.
This form of {\tt min::\EOL locate} uses the longest initial segment of the
attribute name that locates an attribute that has a non-empty
multiset of values.  The
length of this initial segment is returned in the `\verb|length|'
argument.  If \verb|0| is returned in `\verb|length|',
no initial segment having a non-empty multiset of values was found.

The {\tt min::\EOL locate\_reverse} function sets the reverse attribute name of
a pointer.  This can take the special value {\tt min::NONE} or
{\tt min::ANY}, as noted above.  A call to {\tt min::\EOL locate} or
{\tt min::\EOL locatei} sets the
reverse attribute name to {\tt min::NONE}.

Both the {\tt min::\EOL locate} and {\tt min::\EOL locate\_reverse}
functions take name
arguments that are labels (\itemref{LABELS}).  If an atom (number or
string) is given instead, this is treated as the equivalent of
a label whose only element is the atom.

If ab object is reorganized by the \verb|min::publish| function or
relocated by use of an insertable pointer to set attribute values or
flags, every attribute pointer to the object other than the insertable
pointer used to set values or flags will become invalid.
When an attribute pointer becomes invalid, it may be restored to
validity by calling the {\tt min::\EOL relocate} function, without
changing the pointer's attribute and reverse attribute names.  Alternatively,
the {\tt min::\EOL locate} and if necessary {\tt min::\EOL locate\_reverse}
functions may be called for the pointer to reset or change
the pointer's attribute and reverse attribute names.

\ikey{Accessor functions}{accessor function}
can be used for reading attribute values and flags.
For the purposes of describing these functions,
an attribute pointer is considered to point at the attribute
named by the pointer's attribute name, and the reverse attribute
pointed at by the pointer's attribute and reverse attribute names,
unless the latter are \verb|min::NONE| or \verb|min::ANY|.
If these names have never been set it is an error to call an accessor
function for the pointer.

The value multiset pointed at by a pointer is that of the attribute pointed
at if the reverse attribute name is \verb|min::NONE|, or is that of
the reverse attribute pointed at if the reverse attribute name is not
\verb|min::NONE| or \verb|min::ANY|.
If the reverse attribute name is \verb|min::ANY| the value multiset is
the set of all values associated with any reverse attribute name, but
this \verb||min::ANY|
value set can only be read by the 3-argument \verb|min::get|
function, and made empty by the \verb|min::set| function with 0 new values.
It is an error to attempt any other access to this \verb|min::ANY| value set.

The flag set pointed at by a pointer is that of the attribute pointed
at regardless of the setting of the reverse attribute name.
If there are $N$ control codes in a flag set, $N${\tt *VSIZE} flags are
represented by the set, and any flag with number $\geq N${\tt *VSIZE} is
read as zero.  `High order' control codes may contain all zero flags,
and such zero high order control code may be removed when an object
is reorganized.

Attributes whose value and flag sets have never been set are treated
as if they have empty value multisets and flag control code lists.
Similarly reverse attributes
whose value multisets have never been set are treated as having empty value
multisets.

The 3-argument {\tt min::\EOL get} function gets the values in the value
multiset pointed at and stores them in the `{\tt out}' vector.
The total number of values in the value
multiset is returned (regardless of the value of {\tt n}).
The argument {\tt n}, the length of `{\tt out}',
the maximum number of values that may be returned in `{\tt out}'.
If there are more then {\tt n} values, only the first {\tt n}
are returned in `{\tt out}'.
If {\tt n==0} the function just returns
the number of values in the value multiset.

The 1-argument {\tt min::\EOL get} function assumes that there is exactly
one value in the value multiset
and returns that value, or returns the special value
\verb|min::NONE| (\pagref{MIN::NONE}) if the value multiset is empty,
or returns the special value
\verb|min::MULTI_VALUED| (\pagref{MIN::MULTI_VALUED}) if the value multiset
has more than one value.

The {\tt min::\EOL get\_\EOL flags}
function returns the control codes in the flag set pointed at and stores
these in the \verb|min::gen| vector `{\tt out}'.
The total number of control codes in the flag set is returned
(regardless of the value of {\tt n}).
The argument {\tt n}, the length of `{\tt out}',
the maximum number of control codes that may be returned in `{\tt out}'.
If there are more then {\tt n} control codes, only the first {\tt n}
are returned in `{\tt out}'.
If {\tt n==0} the function just returns
the number of control codes in the flag set.

In all of this, high order zero control codes are treated as if
they did not exist (control codes are stored lowest order first
in `{\tt out}').  If there are no non-zero flags, no control codes
are stored in `{\tt out}', and {\tt 0} is returned as the number of
control codes.

In the `{\tt out}' vector, flag $N$ is the bit selected by mask $2^K$
in the vector element with index $I$, where $K=N~\mbox{mod}~\mbox{\tt VSIZE}$
and $I=\mbox{floor}(N/\mbox{\tt VSIZE})$.
If there are $J$ control codes
in the flag set, and $N\geq J*\mbox{\tt VSIZE}$, then
flag $N$ is zero.

The {\tt min::\EOL test\_\EOL flag} function returns the value
of flag {\tt n}.

The attribute names for an object form a list ordered in an implementation
dependent fashion.  
The {\tt min::\EOL get\_\EOL attrs} function gets information about each
attribute in this list.  The information about an attribute is stored in a
{\tt min::\EOL attr\_\EOL info} structure and includes the attribute
name in the {\tt name} member,
the number of values in the attribute value multiset in the {\tt value\_count}
member, the number of control codes in the attribute flag set in
the {\tt flag\_count} member, and the number of associated
reverse attribute names which have non-empty value multisets in the
{\tt reverse\_attr\_count} member.
If a name as only one component that is an {\em atom}, the name is returned
as that {\em atom}; all other names are returned as {\em labels}.
At least one of the three counts must be
non-zero for an attribute, or else the attribute is treated as if it
were not in the list of all attribute names.  In computing
{\tt flag\_count}, high order zero control codes are treated as if they
did not exist, and the value of {\tt flag\_count} is the
same as the value that would be returned by {\tt min::\EOL get\_\EOL flags}.

The {\tt min::\EOL attr\_\EOL info} structs are stored in a packed vector
returned by the {\tt min::\EOL get\_\EOL attrs} function
as a \verb|min::gen| value.  This can be accessed by a read-only
packed vector pointer (\pagref{MIN::PACKED_VEC_PTR_OF_GEN})
of {\tt min::\EOL attr\_\EOL info\_\EOL ptr} type.
Sample usage is:
\begin{indpar}\begin{verbatim}
min::gen airv = min::get_attrs ( ... );
min::attr_info_ptr aip ( airv );
for ( min::unsptr i = 0; i < aip->length; ++ i )
{
    min::attr_info ai = aip[i];
    . . . . . . . . . . . . . .
}
\end{verbatim}\end{indpar}\label{ATTR-INFO-POINTER-EXAMPLE}

The implementation dependent order of the \verb|attr_info|
values returned by {\tt min::\EOL get\_\EOL attrs} may change if attribute
values are added to or removed from the object or
attribute flags are set or cleared, or if the object is reorganized.
The {\tt min::\EOL sort\_\EOL attr\_\EOL info} function can be used
to sort by attribute name
the packed vector returned by {\tt min::\EOL get\_\EOL attrs}.
A {\tt min::\EOL attr\_\EOL info} packed vector can be manipulated in other
ways using its packed vector type information in
{\tt min::\EOL attr\_\EOL info\_\EOL vec}
and {\tt min::\EOL attr\_\EOL info\_\EOL vec\_\EOL type}:
see Section~\itemref{PACKED-VECTORS}.

The {\tt min::\EOL get\_\EOL reverse\_\EOL attrs}
function is analogous but involves the list of
reverse attribute names associated
with a particular object and attribute name stored in the attribute
pointer.  In this case there is a {\tt min::\EOL reverse\_\EOL
attr\_\EOL info} struct for each reverse attribute name, and there is only
one count member in this, the {\tt value\_count} member that is the number
of values in the value multiset of the reverse attribute pointed at.
A reverse attribute name with an empty value multiset is treated as if it
were not in the list of reverse attribute names.

Updatable attribute pointers can set existing values as well as perform
the operations of read-only attribute pointers.
The functions for using a
{\tt min::\EOL attr\_\EOL updptr}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_updptr} \verb|ap|\ARGBREAK
	  \verb| ( min::obj_vec_updptr & vp )|
\LABEL{MIN::ATTR_UPDPTR_OF_VEC_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::attr_updptr & ap,|\ARGBREAK
	  \verb|   min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::attr_updptr & ap,|\ARGBREAK
	  \verb|   int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::attr_updptr & ap,|\ARGBREAK
	  \verb|   min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::attr_updptr & ap,|\ARGBREAK
	  \verb|   min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb| ( min::attr_updptr & ap,|\ARGBREAK
	  \verb|   min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb| ( min::attr_updptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|   min::attr_updptr ap )|
\LABEL{MIN::GET_OF_ATTR_UPDPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::attr_updptr ap )|
\LABEL{MIN::GET1_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb| ( min::gen * out, unsigned n,|\ARGBREAK
    \verb|   min::attr_updptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_UPDPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb| ( min::attr_updptr wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{get\_attrs}\ARGBREAK
    \verb| ( min::attr_updptr ap )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_UPDPTR} \\
\verb|min::gen min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
    \verb| ( min::attr_updptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb| ( min::attr_updptr wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

Functions defined for read-only attribute pointers are also
applicable to updatable list pointers with the
same results.  However, updatable list pointers
can\underline{not} be converted to be read-only list pointers
(unlike the situation with vector pointers).

The {\tt min::\EOL update} function requires that the current
value multiset have a single value and that it be the value multiset
of an attribute, and not a reverse attribute.
This function replaces the single value, returning the previous value.
It is an error if the value multiset is empty or has more than one
value, or if the attribute pointer
reverse attribute name is not \verb|min::NONE|.

Insertable attribute pointers can remove and insert values and
set and clear flags,
as well as perform the operations of updatable attribute pointers.
The functions for using a
{\tt min::\EOL attr\_\EOL insptr}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_insptr} \verb|ap|\ARGBREAK
	  \verb| ( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_INSPTR_OF_VEC_INSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::attr_insptr & ap,|\ARGBREAK
	  \verb|   min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::attr_insptr & ap,|\ARGBREAK
	  \verb|   int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::attr_insptr & ap,|\ARGBREAK
	  \verb|   min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::attr_insptr & ap,|\ARGBREAK
	  \verb|   min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb| ( min::attr_insptr & ap,|\ARGBREAK
	  \verb|   min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb| ( min::attr_insptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|   min::attr_insptr ap )|
\LABEL{MIN::GET_OF_ATTR_INSPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::attr_insptr ap )|
\LABEL{MIN::GET1_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb| ( min::gen * out, unsigned n,|\ARGBREAK
    \verb|   min::attr_insptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_INSPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{get\_attrs}\ARGBREAK
    \verb| ( min::attr_insptr ap )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_INSPTR} \\
\verb|min::gen min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
    \verb| ( min::attr_insptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::SET1_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{add\_to\_set\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_set\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::ADD1_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::REMOVE_ONE1} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::REMOVE_ALL1} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\_flags\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\_some\_flags\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{set\_flag\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::SET_FLAG} \\
\verb|bool min::| & \MINKEY{clear\_flag\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::CLEAR_FLAG} \\
\verb|bool min::| & \MINKEY{flip\_flag\REL}\ARGBREAK
    \verb| ( min::attr_insptr wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::FLIP_FLAG} \\
\end{tabular}\end{indpar}

Functions defined for updatable attribute pointers are also
applicable to insertable list pointers with the
same results.  However, insertable list pointers
can\underline{not} be converted to be updatable or read-only list pointers
(unlike the situation with vector pointers).

The {\tt min::\EOL set}
function sets all the values in the value multiset the
attribute pointer is pointing at, deleting any previous values.
For 3-argument {\tt min::\EOL set}
the new values are given in the `{\tt in}' vector, and
the number of values is given in {\tt n}.  If {\tt n} is zero, all
values are deleted.
For 2-argument {\tt min::\EOL set} there is one new value given as an
argument, unless {\tt v} is \verb|min::NONE|,
in which case there are no new values and all previous values are simply
deleted.

For the {\tt min::\EOL set} function the
pointer's reverse attribute name can be \verb|min::NONE|
but cannot be \verb|min::ANY|, which the exception of the case
where all values are being deleted.  If the reverse attribute name
is \verb|min:ANY| and the {\tt min::\EOL set} function is called to
delete all previous values,
all double arrows with the current attribute name and any
reverse attribute name are deleted.

The {\tt min::\EOL add\_\EOL to\_\EOL set} function
adds values to the multiset set of values,
but adds each value if and only if the value is not already in the multiset,
using {\tt ==} to compare values for equality.
The {\tt min::\EOL add\_\EOL to\_\EOL multiset} function
adds values even if they are already in the multiset.
Both functions have a 3-argument version with a vector of new values,
and a 2-argument version with a single new value.  In the latter case
if {\tt v} is \verb|min::NONE| there is no new value and the function
is a no-operation.
For these functions the pointer's reverse attribute name
can be \verb|min::NONE|
but cannot be \verb|min::ANY|.

The {\tt min::\EOL remove\_\EOL one} function
removes values from the multiset set of values, removing only one copy of
each value,
using {\tt ==} to compare values for equality.
The {\tt min::\EOL remove\_\EOL all} function
removes all copies of each value  
from the multiset of values (it may be less efficient if
the multiset is actually a set).
Both functions have a 3-argument version with a vector of values to remove,
and a 2-argument version with a single value to remove.  In the latter case
if {\tt v} is \verb|min::NONE| there is no value to remove and the function
is a no-operation.  These functions return the number of values actually
removed from the multiset of values.
For these functions the pointer's reverse attribute name
can be \verb|min::NONE| but cannot be \verb|min::ANY|.

Note that attribute values cannot be control codes, and reverse attribute
values must be pointers to objects.

If the attribute pointer is pointing at a multiset of values
associated with a reverse attribute name,
the values represent double arrows.
In this case, let the object being pointed at by the attribute pointer
be $O_1$,
the pointer attribute name be $N$, and the pointer reverse
attribute name be $R$.
If a double arrow value pointing at object $O_2$ is set or removed, the value
pointing at $O_1$ will also be set or removed from the attribute named
$R$ with
reverse attribute name $N$ of the object $O_2$.  That is, the other end of
the double arrow will also be set or removed.
In the unusual special case where $O_1=O_2$ and also $N=R$, only one value
pointing at $O_1=O_2$ is put in the reverse attribute multiset; that
is, this value is \underline{not} duplicated.

The {\tt min::\EOL set\_\EOL flags} function sets the control codes
of the flag set the attribute pointer points at.
The new control codes are given in the `{\tt in}' vector which
has length {\tt n}: see the discussion of
{\tt min::\EOL get\_\EOL flags} on \pagref{MIN::GET_FLAGS_OF_ATTR}
for the format of this vector.
If the previous flag set had more control codes that the new flag
set, the extra control codes will be retained but will be zeroed.
If {\tt n} is zero, all existing control codes are zeroed.
When the object is reorganized, high order zero control codes will
be deleted.

The {\tt min::\EOL set\_\EOL some\_\EOL flags},
{\tt min::\EOL clear\_\EOL some\_\EOL flags},
and {\tt min::\EOL flip\_\EOL some\_\EOL flags}
functions can be used to alter flags.  If the bit corresponding
to the flag is on in the `{\tt in}' vector, it is set, cleared,
or flipped, respectively.

The {\tt min::\EOL set\_\EOL flag},
{\tt min::\EOL clear\_\EOL flag},
and {\tt min::\EOL flip\_\EOL flag}
functions can be used to alter a single flag whose number is
given as the argument {\tt n}.  The flag is set, cleared,
or flipped, respectively.  The previous value of the flag is
returned.

TBD: The `{\tt min::\EOL publish\REL}' function.\label{MIN::PUBLISH}

TBD: resize functions\label{MIN::RESIZE_OF_ATTR}.

\section{Code and Execution}

\subsection{Execution Flags}
\label{EXECUTION-FLAGS}

TBD: relocation flag

\section{TBD Implementation Ideas}


\subsection{Stack and not Ephemeral}

Instead of ephemeral, we use stack objects.  A stack stub is a stub that
is only reachable from pointers in the stack.   When a stack stub
pointer (as a general value) is stored in a non-stack object, the price
of tracing what it points at to make its target non-stack is paid.
This is a logical time to pay this cost.

\section{To Do}

\clearpage

\appendix

\centerline{\Large \bf Appendices}

\section{C/C++ Interface}
\label{C/C++-Interface}

{
\renewcommand{\LABEL}[1]{\dotfill~\pagref{#1}}
\renewcommand{\TTKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\TTMKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\TTBMKEY}[2]{{\tt ~~[#1]~~}}
\renewcommand{\TTDMKEY}[2]{{\tt ~~.#1~~}}
\renewcommand{\TTOMKEY}[3]{{\tt ~~operator~~#2~~}}
\renewcommand{\TTARMKEY}[2]{{\tt ~~->#1~~}}
\renewcommand{\TTNBKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MINKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MINIKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\MINNBKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MUPKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\ttkey}[1]{{\tt ~~#1~~}}
\renewcommand{\ARGBREAK}{\\&{\tt ~~~~}}

\newcommand{\INDEXHEADER}[1]{{\bf #1}:\vspace{1ex}}
\newlength{\TABULARLEN}
\newenvironment{TABULAR}[1]%
  {\setlength{\TABULARLEN}{6.2in}
   \addtolength{\TABULARLEN}{-#1}
   \begin{tabular}{@{}r@{}l@{}}
   \hspace*{#1} & \hspace*{\TABULARLEN} \\[-4ex]}%
  {\end{tabular}}

Unless otherwise noted, this interface is defined by \verb|min.h|.

\INDEXHEADER{Abbreviations}

These are to be included in user's code, and are \underline{not}
in \verb|min|\ldots\verb|.h| files.

\begin{indpar}[0.2in]
\begin{tabular}{@{}p{6.2in}@{}}
\verb|#define MUP  min::unprotected|
\LABEL{MUP} \\
\verb|#define MOS  min::os|
\LABEL{MOS} \\
\verb|#define MACC min::acc|
\LABEL{MACC} \\
\verb|#define MINT min::internal|
\LABEL{MINT} \\
\end{tabular}
\end{indpar}

\INDEXHEADER{Compilation Macros}

These are in \verb|min_parameters.h|.

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTNBKEY{MIN\_IS\_COMPACT}
\LABEL{MIN_IS_COMPACT} \\
\TTNBKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\TTNBKEY{MIN\_IS\_LOOSE}
\LABEL{MIN_IS_LOOSE}	 \\
\TTNBKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
\LABEL{MIN_MAX_NUMBER_OF_STUBS} \\
\TTNBKEY{MIN\_STUB\_BASE}
\LABEL{MIN_STUB_BASE} \\
\TTNBKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS} \\
\TTNBKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS} \\
\TTNBKEY{MIN\_PROTECT}
\LABEL{MIN_PROTECT} \\
\TTNBKEY{MIN\_ASSERT($e$)}
\LABEL{MIN_ASSERT} \\
\TTNBKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\TTNBKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS}
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}

\end{indpar}

\INDEXHEADER{Numeric Types}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{uns8}
\LABEL{MIN::UNS8} \\
\verb|min::| & \MINKEY{int8}
\LABEL{MIN::INT8} \\
\verb|min::| & \MINKEY{uns16}
\LABEL{MIN::UNS16} \\
\verb|min::| & \MINKEY{int16}
\LABEL{MIN::INT16} \\
\verb|min::| & \MINKEY{uns32}
\LABEL{MIN::UNS32} \\
\verb|min::| & \MINKEY{int32}
\LABEL{MIN::INT32} \\
\verb|min::| & \MINKEY{float32}
\LABEL{MIN::FLOAT32} \\
\verb|min::| & \MINKEY{uns64}
\LABEL{MIN::UNS64} \\
\verb|min::| & \MINKEY{int64}
\LABEL{MIN::INT64} \\
\verb|min::| & \MINKEY{float64}
\LABEL{MIN::FLOAT64} \\
\verb|min::| & \MINKEY{unsptr}
\LABEL{MIN::UNSPTR} \\
\verb|min::| & \MINKEY{intptr}
\LABEL{MIN::INTPTR} \\
\verb|min::| & \MINKEY{unsgen}
\LABEL{MIN::UNSGEN} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{General Value Types and Constants}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{stub}
\LABEL{MIN::STUB} \\
\verb|min::| & \MINKEY{gen}
\LABEL{MIN::GEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.0in}
\verb|typedef |
	& \verb|min::uns32|
	  \verb|min::|\MINKEY{unsgen}\COMPACT
\LABEL{MIN::COMPACT_UNSGEN} \\
\verb|typedef |
	& \verb|min::uns64|
	  \verb|min::|\MINKEY{unsgen}\LOOSE
\LABEL{MIN::LOOSE_UNSGEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.0in}
\verb|const unsigned min::| & \MINKEY{TSIZE}
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
\LABEL{MIN::VSIZE}
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Stub Type Codes}\label{STUB-TYPE-CODE-LIST}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|const int min::| & \MINKEY{DEALLOCATED}
\LABEL{MIN::DEALLOCATED} \\
\verb|const int min::| & \MINKEY{NUMBER}
\LABEL{MIN::NUMBER} \\
\verb|const int min::| & \MINKEY{SHORT\_STR}
\LABEL{MIN::SHORT_STR} \\
\verb|const int min::| & \MINKEY{LONG\_STR}
\LABEL{MIN::LONG_STR} \\
\verb|const int min::| & \MINKEY{LABEL}
\LABEL{MIN::LABEL} \\
\verb|const int min::| & \MINKEY{PACKED\_STRUCT}
\LABEL{MIN::PACKED_STRUCT} \\
\verb|const int min::| & \MINKEY{PACKED\_VEC}
\LABEL{MIN::PACKED_VEC} \\
\verb|const int min::| & \MINKEY{SHORT\_OBJ}
\LABEL{MIN::SHORT_OBJ} \\
\verb|const int min::| & \MINKEY{LONG\_OBJ}
\LABEL{MIN::LONG_OBJ} \\
\verb|const int min::| & \MINKEY{LIST\_AUX}
\LABEL{MIN::LIST_AUX} \\
\verb|const int min::| & \MINKEY{SUBLIST\_AUX}
\LABEL{MIN::SUBLIST_AUX} \\
\end{TABULAR}
\end{indpar}

\INDEXHEADER{Stub Related Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|int min::| & \MINKEY{type\_of}\verb| ( const min::stub * s )|
\LABEL{MIN::TYPE_OF} \\[1ex]
\verb|bool min::| & \MINKEY{is\_collectible}\verb| ( int type )|
\LABEL{MIN::IS_COLLECTIBLE} \\[1ex]
\verb|bool min::| & \MINKEY{relocated\_flag}\verb| ( void )|
\LABEL{MIN::RELOCATED_FLAG} \\
\verb|bool min::| & \MINKEY{set\_relocated\_flag}\verb| ( bool value )|
\LABEL{MIN::SET_RELOCATED_FLAG} \\
\verb|class min::| & \MINKEY{relocated}
\LABEL{MIN::RELOCATED} \\
\verb|void min::| & \MINKEY{interrupt\REL}\verb| ( void )|
\LABEL{MIN::INTERRUPT} \\
\verb|void min::| & \MINKEY{deallocate\REL}\verb| ( const min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\verb|bool min::| & \MINKEY{is\_deallocated}\verb| ( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{gen}\verb| ( void )|
\LABEL{MIN::GEN_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_stub}\verb| ( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::| & \MINKEY{is\_direct\_float\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::| & \MINKEY{is\_direct\_int\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::| & \MINKEY{is\_direct\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::| & \MINKEY{is\_index}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::| & \MINKEY{is\_control\_code}\verb| ( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::| & \MINKEY{is\_special}\verb| ( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::| & \MINKEY{is\_list\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_sublist\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_indirect\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::| & \MINKEY{is\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_AUX} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.4in}
\verb|const min::stub * min::| & \MINKEY{stub\_of}\ARGBREAK
                        \verb| ( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen min::| & \MINKEY{new\_stub\_gen}\verb| ( const min::stub * s )|
\LABEL{MIN::NEW_STUB_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE}\verb| ( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen}\verb| ( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen\COMPACT}\verb| ( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int min::| & \MINKEY{gen\_subtype\_of}\verb| ( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::| & \MUPKEY{new\_gen}\verb| ( min::unsgen value )|
\LABEL{MUP::NEW_GEN} \\
\verb|min::unsgen MUP::| & \MUPKEY{value\_of}\verb| ( min::gen value )|
\LABEL{MUP::VALUE_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::|
    & \MUPKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::| & \MUPKEY{new\_stub\_gen}\verb| ( min::stub * s )|
\LABEL{MUP::NEW_STUB_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_float\_gen\LOOSE}\verb| ( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_int\_gen\COMPACT}\verb| ( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen}\verb| ( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb| ( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::| & \MUPKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen}\verb| ( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\

\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Subtype Codes}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_INT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_FLOAT}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::| & \MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::| & \MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_PACKED\_AUX}
\LABEL{MIN::GEN_PACKED_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::| & \MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Special Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINNBKEY{MISSING()}
\LABEL{MIN::MISSING} \\
\verb|min::gen min::| & \MINNBKEY{NONE()}
\LABEL{MIN::NONE} \\
\verb|min::gen min::| & \MINNBKEY{ANY()}
\LABEL{MIN::ANY} \\
\verb|min::gen min::| & \MINNBKEY{MULTI\_VALUED()}
\LABEL{MIN::MULTI_VALUED} \\
\verb|min::gen min::| & \MINNBKEY{UNDEFINED()}
\LABEL{MIN::UNDEFINED} \\
\verb|min::gen min::| & \MINNBKEY{SUCCESS()}
\LABEL{MIN::SUCCESS} \\
\verb|min::gen min::| & \MINNBKEY{FAILURE()}
\LABEL{MIN::FAILURE} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{ACC Locatable Types}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{locatable\_gen} \verb| ( void )|
\LABEL{MIN::LOCATABLE_GEN} \\
\verb|min::gen |
    & \TTOMKEY{min::gen}{min::gen}%
              {of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( min::locatable_gen & location )|
\LABEL{MIN::LOCATABLE_GEN_TO_GEN} \\
\verb|min::gen |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( min::locatable_gen & location,|\ARGBREAK
      \verb|  min::gen value )|
\LABEL{MIN::=LOCATABLE_GEN_OF_GEN} \\
\verb|min::gen |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_gen}}\ARGBREAK
      \verb|( min::locatable_gen & location,|\ARGBREAK
      \verb|  const min::locatable_gen & p )|
\LABEL{MIN::=LOCATABLE_GEN_OF_LOCATABLE_GEN} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
In compact implementation: \\
~~~~\verb|typedef  |
	& \verb|min::locatable_gen  min::|\MINKEY{locatable\_num\_gen} \\
In loose implementation: \\
~~~~\verb|typedef  |
	& \verb|min::gen  min::|\MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|(constructor) min::|
    & \MINKEY{locatable\_var}\BRACKETED{T}\verb| ( void )|
\LABEL{MIN::LOCATABLE_VAR} \\
\verb|T |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var}}\ARGBREAK
      \verb|( min::locatable_var<T> & location,|\ARGBREAK
      \verb|  T value )|
\LABEL{MIN::=LOCATABLE_VAR} \\
\verb|T |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var}}\ARGBREAK
      \verb|( min::locatable_var<T> & location,|\ARGBREAK
      \verb|  const min::stub * s )|
\LABEL{MIN::=LOCATABLE_VAR_OF_STUB} \\
\verb|T |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var}}\ARGBREAK
      \verb|( min::locatable_var<T> & location,|\ARGBREAK
      \verb|  const min::locatable_var<T> & p )|
\LABEL{MIN::=LOCATABLE_VAR_OF_LOCATABLE_VAR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|typedef |
	& \verb|min::locatable_var<min::gen>|\ARGBREAK
	  \verb|min::|\MINKEY{locatable\_gen}
\LABEL{MIN::LOCATABLE_GEN_TYPEDEF} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{ACC Stub Pointer Write Update Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::stub * s2 )|
\LABEL{MUP::ACC_WRITE_STUB_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   min::gen g )|
\LABEL{MUP::ACC_WRITE_GEN_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
          \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   min::gen g )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_UPDATE} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::stub * const * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_STUB_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_GEN_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
	  \verb| ( const min::stub * s1,|\ARGBREAK
	  \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_VEC_UPDATE} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Unprotected Stub Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub}\verb| ( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub}\verb| ( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Read/Write Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::VALUE_OF_STUB} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{ptr\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::PTR_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_value\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of}\ARGBREAK
      \verb| ( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of}\ARGBREAK
      \verb| ( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_ptr\_of}\ARGBREAK
      \verb| ( min::stub * s, void * p )|
\LABEL{MUP::SET_PTR_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Control Functions}

\begin{indpar}[0.2in]


\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}\ARGBREAK
      \verb| ( const min::stub * s, min::uns64 flags )|
\LABEL{MUP::TEST_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_control\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of}\ARGBREAK
      \verb| ( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator}\ARGBREAK
      \verb| ( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value}\ARGBREAK
      \verb| ( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub}\ARGBREAK
      \verb| ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int MUP::| & \MUPKEY{locator\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub}\ARGBREAK
      \verb| ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
[1ex]
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type}\ARGBREAK
      \verb| ( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Control Flags}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|const min::uns64 MUP::| & \MUPKEY{STUB\_ADDRESS}
\LABEL{MIN::STUB_ADDRESS}\\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Body Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|void MUP::|
    & \MUPKEY{new\_body}\verb| ( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body}\ARGBREAK
      \verb|    ( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\verb|void * & MUP::| & \MUPKEY{ptr\_ref\_of}%
	     \verb| ( min::stub * s )| 
\LABEL{MUP::PTR_REF_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\ARGBREAK
    \verb|    ( min::stub * s,|\ARGBREAK
    \verb|      min::unsptr new_size,|\ARGBREAK
    \verb|      min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_ptr\_ref}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_PTR_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT}\verb| ( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_num}\verb| ( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of}\verb| ( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash}\verb| ( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{floathash}\verb| ( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{String Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb| ( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb| ( const min::uns32 * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_UNICODE} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|const min::uns32 min::|
    & \MINNBKEY{UTF8\_ILLEGAL}
\LABEL{MIN::UTF8_ILLEGAL} \\
\verb|min::uns32 min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb| ( const char * & s )|
\LABEL{MIN::UTF8_TO_UNICODE} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb| ( char * & s, min::uns32 c )|
\LABEL{MIN::UNICODE_TO_UTF8} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|int min::| & \MINKEY{is\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min:uns32 min::| & \MINKEY{strhash}\verb| ( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\
\verb|char * min::| & \MINKEY{strcpy}\verb| ( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::| & \MINKEY{strncpy}\ARGBREAK
                      \verb| ( char * p,|\ARGBREAK
		      \verb|   min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\
\verb|int min::| & \MINKEY{strcmp}\verb| ( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::| & \MINKEY{strncmp}\ARGBREAK
                   \verb| ( const char * p,|\ARGBREAK
		   \verb|   min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash}\verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{String Pointers}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MIN::STR_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MIN::STR_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.3in}
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( min::str_ptr & sp, min::gen v )|
\LABEL{MIN::=_STR_PTR_OF_GEN} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( min::str_ptr & sp1, const min::str_ptr & sp2 )|
\LABEL{MIN::=_STR_PTR_OF_STR_PTR} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( min::str_ptr & sp1, const min::stub * s )|
\LABEL{MIN::=_STR_PTR_OF_STUB} \\
\verb|const char & |
    & \TTOMKEY{[ ]}{[ ]}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb| ( const min::str_ptr & sp, int index )|
\LABEL{MUP::[]_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::gen v )|
\LABEL{MIN::STRLEN_OF_STR_PTR} \\
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( min::str_ptr & sp )|
\LABEL{MIN::STRHASH_OF_STR_PTR} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\ARGBREAK
      \verb| ( char * p, min::str_ptr & sp )|
\LABEL{MIN::STRCPY_OF_STR_PTR} \\
\verb|char * min::|
    & \MINKEY{strncpy}\ARGBREAK
      \verb| ( char * p,|\ARGBREAK
      \verb|   min::str_ptr & sp, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_STR_PTR} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp}\ARGBREAK
      \verb| ( const char * p,|\ARGBREAK
      \verb|   min::str_ptr & sp )|
\LABEL{MIN::STRCMP_OF_STR_PTR} \\
\verb|int min::|
    & \MINKEY{strncmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_ptr & sp, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_STR_PTR} \\[1ex]
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( min::str_ptr & sp )|
\LABEL{MUP::STR_OF_STR_PTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{String Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) MUP::| & \MUPKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MUP::STR_PTR_OF_GEN} \\
\verb|(constructor) MUP::| & \MUPKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MUP::STR_PTR_OF_STUB} \\
\verb|(constructor) MUP::| & \MUPKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MUP::STR_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.3in}
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp, min::gen v )|
\LABEL{MUP::=_STR_PTR_OF_GEN} \\
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp1, const min::str_ptr & sp2 )|
\LABEL{MUP::=_STR_PTR_OF_STR_PTR} \\
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp1, const MUP::str_ptr & sp2 )|
\LABEL{MUP::=_STR_PTR_OF_MUP_STR_PTR} \\
\verb|MUP::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt MUP::str\_ptr}}\ARGBREAK
      \verb| ( MUP::str_ptr & sp1, const min::stub * s )|
\LABEL{MUP::=_STR_PTR_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::uns64 MUP::|
    & \MUPKEY{short\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::SHORT_STR_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Labels}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MIN::LAB_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( min::stub * s )|
\LABEL{MIN::LAB_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MIN::LAB_PTR_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt min::lab\_ptr}}\ARGBREAK
          \verb| ( const min::lab_ptr & labp )|
\LABEL{MIN::LAB_PTR_TO_MIN_STUB} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb| ( min::lab_ptr & labp, min::gen v )|
\LABEL{MIN::=_LAB_PTR_OF_GEN} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb| ( min::lab_ptr & labp, const min::stub * s )|
\LABEL{MIN::=_LAB_PTR_OF_STUB} \\
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb| ( const min::lab_ptr & labp,|\ARGBREAK
	  \verb|   min::uns32 i )|
\LABEL{MIN::[]_OF_LAB_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
	& \MINKEY{length\_of}\ARGBREAK
	  \verb| ( min::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{hash\_of}\ARGBREAK
	  \verb| ( min::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_LAB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|const min::uns32 min::| & \MINKEY{labhash\_initial}\verb| = 1009|
\LABEL{MIN::LABHASH_INITIAL} \\
\verb|min::uns32 min::| & \MINKEY{labhash}%
    \verb| ( min::uns32 hash, min::uns32 h )|
\LABEL{MIN::LABHASH_INCREMENTAL} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\ARGBREAK
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   const min::stub * s )|
	  \end{tabular}
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   min::gen v )|
	  \end{tabular}
\LABEL{MIN::LAB_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_lab}\verb| ( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MUP::LAB_PTR_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::stub * s )|
\LABEL{MUP::LAB_PTR_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MUP::LAB_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::lab\_ptr}}\ARGBREAK
          \verb| ( const MUP::lab_ptr & labp )|
\LABEL{MUP::LAB_PTR_TO_MIN_STUB} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb| ( MUP::lab_ptr & labp, min::gen v )|
\LABEL{MUP::=_LAB_PTR_OF_GEN} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb| ( MUP::lab_ptr & labp, const min::stub * s )|
\LABEL{MUP::=_LAB_PTR_OF_STUB} \\
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb| ( const MUP::lab_ptr & labp,|\ARGBREAK
	  \verb|   min::uns32 i )|
\LABEL{MUP::[]_OF_LAB_PTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Names}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_name}\verb| ( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash}\verb| ( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare}\verb| ( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Objects}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.5in}
\verb|min::unsptr min::|
    & \MINKEY{obj\_var\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_VAR_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_hash\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_HASH_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_total\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_TOTAL_SIZE} \\
\end{TABULAR}

\end{indpar}

\medskip

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}\ARGBREAK
    \verb| ( min::unsptr unused_size,|\ARGBREAK
    \verb|   min::unsptr hash_size = 0,|\ARGBREAK
    \verb|   min::unsptr variables_size = 0 )|
\LABEL{MIN::NEW_OBJ_GEN} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Protected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}\verb| vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( void )|
\LABEL{MIN::OBJ_VEC_PTR_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb| ( const min::obj_vec_ptr & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_MIN_STUB} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_GEN} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.0in}
\verb|min::unsptr min::| & \MINKEY{var\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::VAR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::AUX_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen | & \MINKEY{var}\ARGBREAK
    \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|   min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{hash}\ARGBREAK
    \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|   min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{attr}\ARGBREAK
    \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|   min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{aux}\ARGBREAK
    \verb| ( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|   min::unsptr aux_ptr )|
\LABEL{MIN::AUX_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|\ARGBREAK
    \verb| ( min::gen v )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|\ARGBREAK%
    \verb| ( min::stub * s )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|\ARGBREAK%
    \verb| ( void )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_updptr}}\ARGBREAK
          \verb| ( const min::obj_vec_updptr & vp )|
\LABEL{MIN::OBJ_VEC_UPDPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_STUB} \\
\end{TABULAR}

\medskip


\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{set\_var}\ARGBREAK
      \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
      \verb|   min::unsptr index,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_VAR_OF_VEC_UPDPTR} \\
\verb|void min::| & \MINKEY{set\_hash}\ARGBREAK
      \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
      \verb|   min::unsptr index,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_HASH_OF_VEC_UPDPTR} \\
\verb|void min::| & \MINKEY{set\_attr}\ARGBREAK
      \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
      \verb|   min::unsptr index,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_ATTR_OF_VEC_UPDPTR} \\
\verb|void min::| & \MINKEY{set\_aux}\ARGBREAK
      \verb| ( min::obj_vec_updptr & vp,|\ARGBREAK
      \verb|   min::unsptr aux_ptr,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_AUX_OF_VEC_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK
    \verb| ( min::gen v )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK%
    \verb| ( min::stub * s )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK%
    \verb| ( void )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_VOID} \\
\end{TABULAR}


\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_insptr}}\ARGBREAK
          \verb| ( const min::obj_vec_insptr & vp )|
\LABEL{MIN::OBJ_VEC_INSPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_GEN} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::ATTR_PUSH_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_VEC_INSPTR} \\

\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::AUX_PUSH_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::gen & value )|
\LABEL{MIN::ATTR_POP_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_VEC_INSPTR} \\

\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::gen & value )|
\LABEL{MIN::AUX_POP_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::AUX_POP_MULTIPLE_OF_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::| & \MINKEY{resize\REL}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OF_VEC_INSPTR} \\
\verb|bool min::| & \MINKEY{resize\REL}\ARGBREAK
      \verb| ( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|   min::unsptr unused_size,|\ARGBREAK
      \verb|   min::unsptr var_size )|
\LABEL{MIN::RESIZE_UNUSED_AND_VAR_OF_VEC_INSPTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|const min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb| ( min::obj_vec_ptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_PTR} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb| ( min::obj_vec_updptr & v )|
\LABEL{MUP::BASE_OF_VEC_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::STUB_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::VAR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}%
    \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb| ( min::obj_vec_insptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_INSPTR} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb| ( min::obj_vec_insptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_INSPTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Object List Level}

\begin{indpar}[0.2in]
\begin{TABULAR}{1.8in}
(macro) & \TTNBKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs}
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{TABULAR}
\end{indpar}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|const min::gen min::| & \MINKEY{LIST\_END}
\LABEL{MIN::LIST_END} \\
\verb|const min::gen min::|
    & \MINKEY{EMPTY\_SUBLIST}
\LABEL{MIN::EMPTY_SUBLIST} \\
\end{TABULAR}

\end{indpar}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
(constructor)~\verb|min::|
	& \MINKEY{list\_ptr} \verb|lp|\ARGBREAK
	  \verb| ( min::obj_vec_ptr & vp )|
\LABEL{MIN::LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb| ( min::list_ptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_ATTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_ptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_PTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::list_ptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|bool min::|
	& \MINKEY{is\_list\_end}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
(constructor)~\verb|min::|
	& \MINKEY{list\_updptr} \verb|lp|\ARGBREAK
	  \verb| ( min::obj_vec_updptr & vp )|
\LABEL{MIN::LIST_UPDPTR_OF_VEC_UPDPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_updptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb| ( min::list_updptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_updptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb| ( min::list_updptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb| ( min::list_updptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb| ( min::list_updptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|    ( min::list_updptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|    ( min::list_updptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb|    ( min::list_updptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_UPDPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb|    ( min::list_updptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb| ( min::list_updptr & lp,|\ARGBREAK
	  \verb|   min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{list\_insptr} \verb|lp|\ARGBREAK
	  \verb| ( min::obj_vec_insptr & vp )|
\LABEL{MIN::LIST_INSPTR_OF_VEC_INSPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_insptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.3in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   const min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_INSPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb| ( min::list_insptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|bool min::|
	& \MINKEY{insert\_reserve\REL}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   min::unsptr insertions,|\ARGBREAK
	  \verb|   min::unsptr elements = 0,|\ARGBREAK
	  \verb|   bool use_obj_aux_stubs =|\ARGBREAK
	  \verb|       min::use_obj_aux_stubs )|
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_AFTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::|
	& \MINKEY{remove}\ARGBREAK
	  \verb| ( min::list_insptr & lp,|\ARGBREAK
	  \verb|   min::unsptr n = 1 )|
\LABEL{MIN::REMOVE_FROM_LIST_INSPTR} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Object Attribute Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Structures}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\SARG} \verb|pstype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_with\_base\BRACKETED{S,B}}
		\verb|pstype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE_WITH_BASE} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::| & \MINNBKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINNBKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{TABULAR}

\begin{TABULAR}{3.0in}
\verb|min::gen pstype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\verb|const min::stub * pstype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_STUB} \\
\verb|min::uns32 pstype|
    & \TTDMKEY{subtype}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_SUBTYPE} \\
\verb|const char * const pstype.|
    & \TTDMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{gen\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISP} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{stub\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_DISP} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{PACKED_STRUCT_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_ptr|{\tt \SARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::ptr}
\LABEL{MIN::PACKED_STRUCT_PTR_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::packed_struct_ptr<S> & |
	& \TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( min::packed_struct_ptr<S> & psp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_GEN} \\
\verb|min::packed_struct_ptr<S> & |
	& \TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( min::packed_struct_ptr<S> & psp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
          \verb| ( const min::packed_struct_ptr<S> & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_TO_MIN_STUB} \\
\verb|S const * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_ptr<S> & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_->} \\
\verb|S const & |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_ptr<S> & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_*} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|\ARGBREAK
	               \verb| ( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_updptr|{\tt \SARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::updptr}
\LABEL{MIN::PACKED_STRUCT_UPDPTR_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{2.8in}
\verb|min::packed_struct_updptr<S> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}
	& \verb| ( min::packed_struct_updptr<S>|\\
	& \verb|        & psup,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_GEN} \\
\verb|min::packed_struct_updptr<S> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}
	& \verb| ( min::packed_struct_updptr<S> |\\
	& \verb|        & psup,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{0.8in}
\verb|S * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_struct\_udpptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_updptr<S> & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_->} \\
\verb|S & |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_updptr}}\ARGBREAK
	  \verb| ( const min::packed_struct_updptr<S> & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_*} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::stub * | & \MINNBKEY{NULL\_STUB}
\LABEL{MIN::NULL_STUB} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Vectors}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|struct min::| & \MINKEY{packed\_vec\_header}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const min::uns32 type;|\ARGBREAK
    \verb|  const min::uns32 length;|\ARGBREAK
    \verb|  const min::uns32 max_length;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PACKED_VEC_HEADER} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\EARGDEFAULT} \verb|pvtype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                            = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_with\_base\BRACKETED{E,H,B}}
		\verb|pvtype|\ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                            = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE_WITH_BASE} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_STUB_VOID} \\
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb| ( min::uns32 max_length,|\ARGBREAK
	  \verb|   min::uns32 length = 0,|\ARGBREAK
	  \verb|   E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb| ( min::uns32 max_length,|\ARGBREAK
	  \verb|   min::uns32 length = 0,|\ARGBREAK
	  \verb|   E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_STUB_MAX_LENGTH} \\
\end{TABULAR}

\begin{TABULAR}{3.0in}
\verb|const char * const pvtype| & \TTDMKEY{subtype}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_SUBTYPE} \\
\verb|const char * const pvtype| & \TTDMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_DISP} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::uns32 pvtype| & \TTDMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 pvtype| & \TTDMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 pvtype| & \TTDMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{PACKED_VEC_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{PACKED_VEC_SUBTYPE_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr\EARGDEFAULT} \verb|pvp|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr\EARGDEFAULT} \verb|pvp|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr\EARGDEFAULT} \verb|pvp|\ARGBREAK
	  \verb| ( void )|
\LABEL{MIN::PACKED_VEC_PTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_ptr|{\tt \EHARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\EHARG::ptr}
\LABEL{MIN::PACKED_VEC_PTR_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{2.6in}
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}
	& \verb| ( min::packed_vec_ptr<E,H>|\\
	& \verb|        & pvp,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_GEN} \\
\verb|min::packed_vec_ptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}
	& \verb| ( min::packed_vec_ptr<E,H>|\\
	& \verb|        & pvp,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
          \verb| ( const min::packed_vec_ptr<E,H> & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_TO_MIN_STUB} \\
\verb|H const * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb| ( const min::packed_vec_ptr<E,H> & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_->} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::uns32 pvp| & \TTARMKEY{length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_LENGTH} \\
\verb|E const & pvp| & \TTBMKEY{i}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_[]} \\
\verb|E const * pvp| & \TTDMKEY{begin\_ptr()}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_BEGIN_PTR} \\
\verb|E const * pvp| & \TTDMKEY{end\_ptr()}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_END_PTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr\EARGDEFAULT} \verb|pvup|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr\EARGDEFAULT} \verb|pvup|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr\EARGDEFAULT} \verb|pvup|\ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_updptr|{\tt \EHARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\EHARG::updptr}
\LABEL{MIN::PACKED_VEC_UPDPTR_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{2.6in}
\verb|min::packed_vec_updptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}
	& \verb| ( min::packed_vec_updptr<E,H>|\\
	& \verb|        & pvup,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_GEN} \\
\verb|min::packed_vec_updptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}
	& \verb| ( min::packed_vec_updptr<E,H>|\\
	& \verb|        & pvup,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\verb|H * |
	& \TTOMKEY{-\GT}{-\GT}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb| ( const min::packed_vec_updptr<E,H>|\ARGBREAK
	  \verb|      & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_->} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|E & pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
    \hspace*{1.0in} [if \verb|E| \underline{not} locatable]
\LABEL{MIN::PACKED_VEC_UPDPTR_[]} \\
\verb|min::ref<E> pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
    \hspace*{1.0in} [if \verb|E| \underline{is} locatable]
\LABEL{MIN::PACKED_VEC_OF_STUB_PTR_UPDPTR_[]} \\
\verb|E const * pvup|
    & \TTDMKEY{begin\_ptr()}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_BEGIN_PTR} \\
\verb|E const * pvup| & \TTDMKEY{end\_ptr()}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_END_PTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr\EARGDEFAULT} \verb|pvip|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr\EARGDEFAULT} \verb|pvip|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr\EARGDEFAULT} \verb|pvip|\ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_insptr|{\tt \EHARG}\ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\EHARG::insptr}
\LABEL{MIN::PACKED_VEC_INSPTR_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{2.6in}
\verb|min::packed_vec_insptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}
	& \verb| ( min::packed_vec_insptr<E,H>|\\
	& \verb|        & pvip,|\\
	& \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_GEN} \\
\verb|min::packed_vec_insptr<E,H> & | \\
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}
	& \verb| ( min::packed_vec_insptr<E,H>|\\
	& \verb|        & pvip,|\\
	& \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::uns32 pvip|
    & \TTARMKEY{max\_\EOL length}{in {\tt min::packed\_vec\_insptr}}
\LABEL{MIN::PACKED_VEC_INSPTR_MAX_LENGTH} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|E & min::|
	& \MINKEY{push\REL} \verb| ( packed_vec_insptr<E,H> pvip )|\\&
	  \hspace*{0.1in} [if \verb|E| \underline{not} locatable]
\LABEL{MIN::PACKED_VEC_PUSH} \\
\verb|min::ref<E> min::|
	& \MINKEY{push\REL} \verb| ( packed_vec_insptr<E,H> pvip )|\\&
          \hspace*{0.1in} [if \verb|E| \underline{is} locatable]
\LABEL{MIN::PACKED_VEC_PUSH_OF_LOCATABLE} \\[2ex]
\verb|void min::|
	& \MINKEY{push\REL}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 n, E const * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|E min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{resize\REL}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve\REL}\ARGBREAK
	  \verb| ( packed_vec_insptr<E,H> pvip,|\ARGBREAK
	  \verb|   min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{TABULAR}

\end{indpar}


} % end of renewcommand for \LABEL, \{TT,MIN,MUP}KEY, etc.

\section{Operating System Interface}
\label{OPERATING-SYSTEM-INTERFACE}

The interface between MIN implementation code and the operating system
consists of standard C++/C functions available on all operating
systems, such as \verb|iostreams|, plus \ttkey{min::os}
namespace interface functions that are
declared in \verb|min_os.h| and defined in \verb|src/min_os.cc|.
This code division is intended to make it easy to port MIN to different
operating systems by placing all the code that must be
changed in the small \verb|src/min_os.cc| file.
\verb|min::os| is commonly abbreviated to
`\ttnbmkey{MOS}{abbreviates {\tt min::os}}'\label{MOS}
by including the following definition in code that accesses
the interface:

\begin{center}
\verb|#define  MOS  min::os|
\end{center}

Details of the \verb|min::os| interface are in \verb|min_os.h|.  The
following is an overview.

\subsection{Configuration Parameters}
\label{CONFIGURATION-PARAMETERS}

In UNIX the \ttnbkey{MIN\_CONFIG} environment variable value consists
of whitespace separated entries of the form `{\em name}\verb|=|{\em value}'
that specify configuration parameters, most of which control the
Allocator/Collector/Compactor.

\subsection{Memory Pools}

A memory pool is a contiguous block of pages of \underline{virtual}
memory.  Memory pools may be allocated, and it is possible to
specify that a pool being allocated has its starting address in
a particular range (e.g., so stub addresses can be limited to
44 bits).  Segments of memory pools may be freed, may be made
into inaccessible virtual memory, and may be made reaccessible.
Segments of memory pools may be moved by copying page table entries,
which is faster than copying bytes.

\section{Allocator/Collector/Compactor}
\label{ALLOCATOR/COLLECTOR/COMPACTOR}\label{ACC}

The \key{Allocator/Collector/Compactor}, or \ttnbkey{acc}, 
is a replaceable component of the MIN code, which should not
normally be accessed directly.  It can be controlled by parameters
passed to the program (see Configuration Parameters,
\pagref{CONFIGURATION-PARAMETERS}), or by defaults for these
provided at compile time in \verb|min_acc_parameters.h|.
Documentation for these parameters is in this last file.
The acc code is in the 
\verb|min::acc| namespace which is abbreviated to
`\ttnbmkey{MACC}{abbreviates {\tt min::acc}}'\label{MACC}
by including the following definition in acc code:

\begin{center}
\verb|#define  MACC  min::acc|
\end{center}

Details of the acc code are in \verb|min_acc.h|.  The
following is an overview.

TBD

\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}
