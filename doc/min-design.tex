% Minimal Descriptive Programming System Design
%
% File:         min-design.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{makeidx}
\usepackage{pictex}
\usepackage{upquote}
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newsavebox{\LAQUOTEBOX}
\begin{lrbox}{\LAQUOTEBOX}
{\tt \guillemotleft}
\end{lrbox}
\newcommand{\LAQUOTE}{\usebox{\LAQUOTEBOX}}

\newsavebox{\RAQUOTEBOX}
\begin{lrbox}{\RAQUOTEBOX}
{\tt \guillemotright}
\end{lrbox}
\newcommand{\RAQUOTE}{\usebox{\RAQUOTEBOX}}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \vspace*{-15ex}
	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MINKEY}[1]%
	   {\TT{#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\MINIKEY}[2]%
           {\TT{#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\MINMKEY}[3]%
           {\TT{#1}\ttmindex{min::#2}{#3}\ttmindex{#2}{#3}}
\newcommand{\MUPKEY}[1]%
	   {\TT{#1}\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Internal Design\\[2ex]of the\\[2ex]
       Minimal\\Descriptive Programming\\System\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton}

\date{August 3, 2014}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the internal design of MIN,
the Minimal Descriptive Programming System.
This document is written for readers who wish to add C++ code
to a MIN implementation, or who wish to maintain an implementation.

A programming system provides run time and compile time support
for programming languages.
A programming system, such as MIN, is
built on top of an underlying programming system provided by the
implementation language, in this case C++.
MIN consists of a data store, of the single-thread execution system
inherited from C++, and of MIN compatible threads.
Other programming language specific
programming systems can be built on top of MIN.

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{center}
\begin{tabular}{ll}
\ttmkey{acc}{abbreviation}	& allocator/collector/compactor
			          (\itemref{ACC-INTERFACE},\itemref{ACC}) \\
\ttmkey{aux}{abbreviation}	& auxiliary (\itemref{AUXILIARY}) \\
\ttmkey{attr}{abbreviation}	& attribute (\itemref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{DISP}{abbreviation}	& displacement (\pagref{MIN::DISP}) \\
\ttmkey{gen}{abbreviation}	& general value (\itemref{GENERAL-VALUES}) \\
\ttmkey{insptr}{abbreviation}	& insertable pointer
				  (read-write, push, pop pointer) \\
\ttmkey{int}{abbreviation}	& signed integer (\pagref{INT}) \\
\ttmkey{lab}{abbreviation}	& label (\itemref{LABELS}) \\
\ttmkey{min}{abbreviation}	& the `\TT{min}' namespace (\pagref{min::}) \\
\ttmkey{MACC}{abbreviation}	& \TT{min::acc} (\pagref{MACC}) \\
\ttmkey{MIN\_}{abbreviation}	& the \TT{MIN\_} macro preface
				  (\pagref{MIN_}) \\
\ttmkey{MINT}{abbreviation}	& \TT{min::internal} (\pagref{MINT}) \\
\ttmkey{MOS}{abbreviation}	& \TT{min::os} (\pagref{MOS}) \\
\ttmkey{MUP}{abbreviation}	& \TT{min::unprotected} (\pagref{MUP}) \\
\ttmkey{num}{abbreviation}	& number (\pagref{NUMBERS}) \\
\ttmkey{obj}{abbreviation}	& object (\pagref{OBJECTS}) \\
\ttmkey{ptr}{abbreviation}	& pointer (often read-only, see updptr and
                                  insptr) \\
\ttmkey{ref}{abbreviation}	& reference 
    (\pagref{BODY-REFERENCES-AND-POINTERS}) \\
\ttmkey{str}{abbreviation}	& string (\pagref{STRINGS}) \\
\ttmkey{uns}{abbreviation}	& unsigned integer (\pagref{UNS}) \\
\ttmkey{updptr}{abbreviation}	& updatable pointer
                                  (i.e., read-write pointer) \\
\ttmkey{var}{abbreviation}	& variable (\itemref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{vec}{abbreviation}	& vector (\itemref{OBJECT-VECTOR-LEVEL}) \\
\end{tabular}
\end{center}

Also one of a small number of \skey{subscript}s may be attached to a
function name to indicate that the function is of a certain class
of functions:

\begin{center}
\begin{tabular}{ll}
\subsmkey{C}{function qualifier}	& compact function
                                          (\pagref{COMPACT-FUNCTIONS}) \\
\subsmkey{L}{function qualifier}	& loose function
                                          (\pagref{LOOSE-FUNCTIONS}) \\
\subsmkey{R}{function qualifier}	& relocating function
                                          (\pagref{RELOCATING-FUNCTIONS}) \\
\subsmkey{S}{function qualifier}	& resizing function
                                          (\pagref{RESIZING-FUNCTIONS}) \\
\subsmkey{O}{function qualifier}	& reorganizing function
                                          (\pagref{REORGANIZING-FUNCTIONS}) \\

\end{tabular}
\end{center}

\section{Interfaces}
\label{INTERFACES}

MIN code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{min/include} & \TT{*.h} files such as \TT{min.h}
\\[1ex]
\ldots\TT{/}\ttkey{min/unicode} & UNICODE data base files such as
				  \TT{unicode\_data.h} \\
				& (independent of the rest of MIN)
\\[1ex]
\ldots\TT{/}\ttkey{min/src} & \TT{*.cc} files such as \TT{min.cc}
\\[1ex]
\ldots\TT{/}\ttkey{min/test} & test scripts such as \TT{min\_interface\_test.cc}
\\[1ex]
\ldots\TT{/}\ttkey{min/doc} & documentation files such as \TT{min-design.tex}
\end{tabular}
\end{center}



The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}
\verb|#include  <min.h>|
\end{center}

External MIN data and functions are placed in the
\ttmkey{min}{namespace}\label{min::} namespace.
There are some macros that can be defined to control compilation, and
these have names beginning with \ttkey{MIN\_}\label{MIN_}.

MIN has two interfaces:
the \key{protected interface}, which can be used
by C++ code to access MIN while maintaining the integrity
of MIN data, and the \key{unprotected interface}, which provides
more efficient access to MIN data but requires the user to
follow certain protocols to be sure that data are not damaged.

From the syntactic point of view the
only distinction between these interfaces is that the unprotected
interface is in the with \minkey{unprotected} namespace, whereas
the protected interface is in the \ttkey{min} namespace.  User code
that accesses the unprotected interface typically abbreviates the long
`\TT{min::unprotected::}' prefix to
`\ttmkey{MUP}{abbreviates {\tt min::unprotected}}\TT{::}'\label{MUP}
by including the following definition:
\begin{center}
\verb|#define  MUP  min::unprotected|
\end{center}

In this document we will use the abbreviation `\TT{MUP}' for
`\TT{min::unprotected}'.
Note that namespace \TT{\#define}'s such as the above are \underline{not}
included in \TT{min.h} or other MIN \TT{.h} files; they must
be included explicitly in \TT{.cc} files.

Most \TT{MUP} functions `produce \key{undefined results}' when their arguments
are out of legal range.
This means that when the arguments are out of range,
function execution may lose control and crash, or may produce result
values that are wrong or out of legal range.
When documentation of a \TT{MUP} function
states that particular argument range checks are not performed,
then the \TT{MUP} function always produces undefined results when its
arguments would not pass these checks,
unless the documentation explicitly says otherwise.

Most, but not all, of the protection provided by the protected interface
is obtained by the functions of that interface using the
\TT{MIN\_ASSERT} macro:

\begin{indpar}
\begin{tabular}{lp{4.0in}}
\TTKEY{MIN\_ASSERT}\TT{(}$e$\TT{)}
	& By default defined as `\TT{assert(}$e$\TT{)}' if
	  \TT{MIN\_PROTECT} is defined to be \TT{1} (its default),
	  and defined to be a no-operation otherwise.  Alternatively
	  may be defined by the compilation before
	  \TT{\#include <min.h>}.
\LABEL{MIN_ASSERT}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{lp{4.0in}}
\TTKEY{MIN\_PROTECT}	& 1 (the default)
                          if \TT{MIN\_ASSERT} is to be mapped to
			  the C++ \ttkey{assert} macro if \TT{MIN\_ASSERT}
			  not otherwise defined; 0 to map \TT{MIN\_ASSERT}
			  to a no-operation if it is not otherwise defined.
\LABEL{MIN_PROTECT} \\
\end{tabular}
\end{indpar}

By setting \TT{MIN\_PROTECT} to \TT{0}, a compilation can optimize
debugged code, although this will remove the protection
provided by the protected interface.  Alternatively,
a compilation can provide its own definition for the
\TT{MIN\_ASSERT} macro,
such as a definition printing extra information
in case of an assertion failure.

The above macros (\TT{MIN\_ASSERT}, \TT{MIN\_PROTECT})
can be defined independently for each separately compiled
part of a program, but most \TT{MIN\_} macros must be defined identically
for all separately compiled parts of a single program.

The following are the most commonly used compiler options that
redefine \TT{MIN\_} macros:

\begin{indpar}
\begin{tabular}{lll}
Macro Name		& Meaning	& Page Reference \\[1ex]
\TT{-DMIN\_PROTECT=0}	& delete assert checks
					& \pagref{MIN_PROTECT} \\
\TT{-DMIN\_IS\_COMPACT=1}
			& make implementation compact
					& \pagref{MIN_IS_COMPACT} \\
\end{tabular}
\end{indpar}

The other compilation parameters involve technical details of
memory management.  For specifics see the file
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

Protected functions are in the \ttmkey{min}{namespace} namespace
and have names beginning with
`\ttmkey{min::}{in function name}', while
unprotected MIN functions are in the \ttmkey{min::unprotected}{namespace}
namespace and have names beginning with
`\ttmkey{min::unprotected::}{in function name}'.
The \TT{min} and \TT{min::unprotected} namespaces hold \underline{all}
the stable interfaces of the MIN implementation.

Code in \TT{min.h} that is not meant to be accessed
by users is in the following namespaces:

\begin{indpar}[0.1in]
\begin{tabular}{llp{4.0in}}
	    & Abbre- \\
Namespace   & viation   & Use
\\[1ex]
\minkey{os} & \ttkey{MOS}
			& Operating system independent interface to
			  operating system functions
			  not covered by C++ standards.
			  See Appendix \itemref{MOS}.
\\[1ex]
\minkey{acc} & \ttkey{MACC}
			& The part of the interface to the
			  Allocator/\EOL Collector/\EOL Compactor
			  that can be
			  changed when the acc is changed.
			  See Appendix \itemref{ACC}.
\\[1ex]
\minkey{internal} & \ttkey{MINT}\label{MINT}
		        & Interface to internal MIN code that can
			  be changed without notice at any time.
			  Not described in this document; see
			  \TT{.h} files.
\\[1ex]
\minkey{unicode} & \ttkey{UNI}
		        & Interface to UNICODE data base.
\end{tabular}
\end{indpar}

\section{Initialization}

Because C++ compilers are inconsistent in the order in which they
call constructors for \TT{static} data, MIN initialization is
not done until after \TT{main()} begins execution.  \TT{main()}
should begin with either
\begin{center}
\tt min::initialize();
\end{center}
or
\begin{center}
\tt min::interrupt\REL();
\end{center}

Either will initialize MIN.

Generally MIN out-of-line functions \underline{cannot} be called
by constructors of \TT{static} or \TT{extern} data, because
MIN is not initialized when these constructors execute.
MIN constructors designed to be used by such data do not call
MIN out-of-line functions or depend upon other MIN data being
constructed.  The following are some of the MIN constructors
and \TT{inline} functions that can be invoked during construction
of \TT{static} and \TT{extern} data:
\begin{center}
\tt
\begin{tabular}{l}
min::gen; \\
min::MISSING(); \\
min::NONE(); \\
min::locatable\_gen; \\
min::locatable\_var<T>; \\
min::ptr<T>; \\
min::packed\_struct<S>; \\
min::packed\_vector<E>; \\
min::packed\_vector<E,H,L>; \\
\end{tabular}
\end{center}

After MIN initializes itself it calls initializers that are
declared by including the following in a translation unit:

\begin{center}
\tt
\begin{tabular}{l}
static void my\_initialize ( void ) \{~...~\} \\
static min::initializer my\_initializer ( ::my\_initialize ); \\
\end{tabular}
\end{center}

Immediately after MIN performs its own initialization
it calls \TT{my\_initialize()} and other functions specified by
\TT{min::\EOL initializer}'s.  The order in which these
are called is indeterminate.  These functions can call any
MIN function and can finish initialization of \TT{static} or
\TT{extern} data.

\section{Data}

In defining MIN data the following number types are used to be sure
the size of each number is clear:
\begin{center}
\begin{tabular}{l@{~~~~~}p{4.5in}}
\minkey{uns8}	& unsigned 8-bit integer \\
\minkey{int8}	& signed 8-bit integer \\
\minkey{uns16}	& unsigned 16-bit integer \\
\minkey{int16}	& signed 16-bit integer \\
\minkey{uns32}	& unsigned 32-bit integer \\
\minkey{int32}	& signed 32-bit integer \\
\minkey{float32}	& 32-bit IEEE floating point number \\
\minkey{uns64}	& unsigned 64-bit integer \\
\minkey{int64}	& signed 64-bit integer \\
\minkey{float64}	& 64-bit IEEE floating point number \\
\minkey{unsptr}	& unsigned integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{intptr}	& signed integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{unsgen}	& unsigned integer of same length as a general value
                  (32 or 64 bits, see \itemref{GENERAL-VALUES})
                  \\
\minkey{Uchar}	& unsigned 32-bit integer (used as UNICODE character) \\
\end{tabular}
\end{center}%
\LABEL{MIN::UNS8}%
\LABEL{MIN::INT8}%
\LABEL{MIN::UNS16}%
\LABEL{MIN::INT16}%
\LABEL{MIN::UNS32}%
\LABEL{MIN::INT32}%
\LABEL{MIN::FLOAT32}%
\LABEL{MIN::UNS64}%
\LABEL{MIN::INT64}%
\LABEL{MIN::FLOAT64}%
\LABEL{MIN::UNSPTR}%
\LABEL{MIN::INTPTR}%
\LABEL{MIN::UNSGEN}%
%\LABEL{MIN::UCHAR}%
\label{INT}%
\label{UNS}

Current implementations of MIN assume a compiler that has
direct support for 64 bit integers.  It is possible, but not recommended,
to modify the implementations to use compilers without such support.

MIN depends upon certain undocumented C++ conventions.

First, it is assumed that classes will not have hidden
padding that is not required to align member offsets.
It is assumed that the compiler will allocate class members
in order without any hidden padding if this will lead to
an allocation in which each member of a number type above or
of any pointer type has an offset in class instances
that is a multiple of the member length.

Second, it is assumed that the contents of a base class are
allocated is if the class contained an unnamed first member
whose type is the base class.

Care is taken to use these first two assumptions when defining
MIN data this may be input or output in binary form.
Some checks on these assumptions are programmed into MIN
initialization routines using C++ `\TT{assert}' statements.

Third, it is assumed that a class containing just one element
that is a number or pointer is just as efficient in optimized
code as a number or pointer not in a class.  In particular,
such a one-element class used as an argument or return value
should be passed in a register.

All these assumptions seem to be satisfied by the GNU C++
compiler.

\subsection{Stubs and Bodies}

MIN data memory consists of regions that contain stubs and regions
that contain bodies.  A region is a contiguous block
of memory, typically consisting of an integral number of hardware
pages.

\ikey{Stubs}{stub}
are small fixed size units of memory that cannot be relocated:
the usual stub size for MIN is 16 bytes.
Each object has a stub, and the address of the stub is in effect
the internal name of the object.  Some atoms (e.g., numbers, strings)
have stubs, and some (e.g., integers that are not large, and very short
strings) do not.

A stub is divided into an 8 byte \key{stub value}
and an 8 byte \key{stub control}.
The stub value can be a 64-bit IEEE floating point number,
an 8 \TT{char} string, or, as we will soon see, a pointer to a body.
It is also possible for a stub value to hold any other 8 bytes of information.

The stub control holds a 1 byte \key{type code} and other information used,
for example, by the allocator/collector/compactor (acc).

The type name of a stub is `\minkey{stub}', and a pointer to a stub
has type `\TT{min::stub *}'.\LABEL{MIN::STUB}
Protected functions can return `\TT{const min::stub *}' values,
but only unprotected functions can return `\TT{min::stub *}' values.

A \key{body} is a variable sized
\ttmkey{relocatable}{body}\label{RELOCATABLE-BODY}
block of memory
attached to a particular stub.  A stub may have a body attached to
it, in which case the stub value is a pointer to that body.
When certain functions are called,
any body can be moved and its corresponding stub value reset to
point at the new location of the body.
Functions with this property are called
`\key{relocating functions}'\label{RELOCATING-FUNCTIONS}
and their names are marked by the superscript
\subsmkey{R}{of function} in this document.  Included
are functions that allocate objects.
Obtaining a C++ pointer into a body is an unprotected operation, because
the pointer must be updated if a relocating function is called.

\ikey{Interrupts}{interrupt!and relocation} can relocate bodies.
Therefore interrupts are only allowed
at specific points in the code.  The inline function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{interrupt\REL} \verb|( void )|
\LABEL{MIN::INTERRUPT} \\
\end{tabular}\end{indpar}%
\index{interrupt!relocating}

checks an interrupt
flag, and if that is set, calls an out-of-line function to process
the interrupt.  The function returns \TT{true} if and only if
there was actually an interrupt (this should be used only
for optimization).

A body may be \mkey{deallocated}{by moving}
by moving it to unimplemented memory.  When this is done the
stub \mkey{type code}{reset on deallocation}
is reset to the value \minkey{DEALLOCATED}\LABEL{MIN::DEALLOCATED},
which indicates the body is deallocated.
Deallocation is considered to be a variant of relocation.
Relocating functions, those marked marked by {\REL} in documentation,
may also deallocate objects.

Deallocation is done by the \TT{min::\EOL deallocate\REL}
function (\pagref{MIN::DEALLOCATE}) and testing to see if a 
a body has been deallocated is done by the
\TT{min::is\_deallocated} function
(\pagref{MIN::IS_DEALLOCATED}).

Bodies are always some multiple
of 8 bytes long, and are allocated on 8 byte boundaries.

\ikey{Protected functions}{protected function!using {\tt MIN\_ASSERT}}
that take a stub pointer as argument use
\ttmkey{MIN\_ASSERT}{in protected function} macros
(\pagref{MIN_ASSERT}) to check
the \mkey{type code}{checked by {\tt MIN\_ASSERT}}
of the stub and various lengths.  Unprotected functions
contain no such checks.

Memory consisting of unrelocatable stubs pointing at relocatable
bodies is called a `\key{stub/\EOL body memory}'.
Thus MIN has a stub/body memory.
The main advantages of stub/body memory are that relocation of bodies
can happen independently of other program activity, and bodies can be
deallocated by program command at any time.\footnote{
Stub/body memories are certainly not new.  For example, Kyoto COMMONLISP
used a stub/body implementation of arrays, and the author has heard about
implementations that go back to the late 1950's or early 60's: see
p33 of the author's thesis, R-CODE, A Very Capable Virtual Computer.}


\subsection{General Values}
\label{GENERAL-VALUES}

A general value can store any of:

\begin{center}
\begin{tabular}{l}
a direct atom value \\
a pointer to a stub \\
an auxiliary pointer \\
an index \\
a control code \\
a special value
\end{tabular}
\end{center}

General values are used as attribute names and values in
objects and as function arguments and return values.

General values that represent numbers or character strings
are called \skey{atom}s, because they have no subcomponents.
There are two kinds of atoms: \skey{direct atom}s that
are stored completely in a general value, and
\skey{indirect atom}s that are stored in a stub or in
a body pointed at by a stub, with the stub being pointed
at by a general value.

Efficiency aside, it does not matter
whether a general value stores a direct atom value or a pointer
to a stub holding an indirect atom value,
as atom values are immutable and cannot be changed.  Of course not all
atom values will fit into a general value, and those that do not must
be stored in stubs or in bodies pointed at by stubs.

An \key{auxiliary pointer} is an integer that is used by a general value
stored inside a body to point at some part, called an
\key{auxiliary},\label{AUXILIARY} of the same body.
There are several subtypes of auxiliary pointers storable in bodies.
See~\pagref{OBJECT-BODY-AUXILIARY-POINTER}.

An \key{index} is an integer that is used to give the index of a variable
that is an element of an object body.
See~\pagref{OBJECTS}.

A \key{control code} is an integer that represents flags and codes
stored in a general value.  Control codes can have different
interpretations in different contexts.
For example, see `Attribute Flags', \pagref{ATTRIBUTE-FLAGS}.

A \key{special value} is a unique value that has some
special meaning.  \TT{min::MISSING()}, for example, is a special
value that may be input or output to indicate that data is missing,
and \TT{min::NONE()} is a special value used only to
indicate that a function argument or result does not exist.
See \itemref{SPECIAL-VALUES}.

The \TT{min::}\MINKEY{gen}\LABEL{MIN::GEN}
type is defined as a C++ class that
consists of a single \TT{private} element of type
\TT{min::}\MINKEY{unsgen}, which is an unsigned integer.
From the point of view of C++ type checking, a \TT{min::\EOL gen}
value is a class, but from the computational point of view it is
an unsigned integer.

Because \TT{min::gen} is a class type, it is not possible to
present \TT{min::\EOL gen} constants to the compiler for use in
optimized code in a completely straightforward way.  To get the
desired effect, \TT{min::\EOL gen} constants are represented by
\TT{inline} functions, which allows the optimizing compiler 
to insert the constants directly into instructions.  Thus
we have the constant \TT{min::\EOL MISSING()}, a function call
with no arguments, \underline{instead of} \TT{min::\EOL MISSING}, a datum.

There are two kinds of MIN implementation: `\key{compact}' and
`\key{loose}'.\label{COMPACT}\label{LOOSE}\label{COMPACT-OR-LOOSE}
A compact implementation uses 32-bit general values, while
a loose implementation uses 64-bit general values.
An implementation cannot use both 32-bit and 64-bit general values;
the implementation must use one or the other.

The 64-bit loose implementation formats a \TT{min::\EOL gen}
value as an IEEE floating point number, using the NaN (Not-a-Number)
values to encode non-numeric \TT{min::\EOL gen} values, such as
pointers to stubs.  Thus
in the loose implementation \TT{min::\EOL float64} values are
stored verbatim in \TT{min::\EOL gen} values.

Some functions and constants are defined only for compact implementations,
and some only for loose implementations.  Those defined only for
compact implementations are called
`\skey{compact function}s'\label{COMPACT-FUNCTIONS} and their
names are marked with the superscript \subsmkey{C}{of function}
in this document.
Those defined only for
loose implementations are similarly called
`\skey{loose function}s'\label{LOOSE-FUNCTIONS} and their
names are marked with the superscript \subsmkey{L}{of function}.

The value of a compact implementation is that it uses less memory%
\footnote{However, double precision floating point numbers only
use less memory if each is replicated several times.},
but there may be a speed penalty.
The value of a loose implementation is that it may run faster, but
there is a memory penalty.  It is not clear what the speed difference
between the two implementations really is, so both implementations
are offered in order to decide the issue by experiment.

Also compact implementations do not permit more than
about $2^{32}$ objects to exist in memory at one time, whereas
loose implementations permit up to about $2^{44}$ objects.

\subsubsection{General Value Subtypes}
\label{GENERAL-VALUE-SUBTYPES}

A \key{general value} has type \minkey{gen} and
is a 32 or 64 bit aligned value that can be of one of the following
subtypes;

\begin{indpar}[3em]
a pointer to a stub \\
a 64-bit IEEE floating point direct number atom\LOOSE \\
a 28-bit direct integer atom\COMPACT \\
a 0-5 \TT{char} direct string atom\LOOSE \\
a 0-3 \TT{char} direct string atom\COMPACT \\
a VSIZE-bit index \\
a VSIZE-bit control code \\
a VSIZE-bit special value \\
a VSIZE-bit list auxiliary pointer \\
a VSIZE-bit sublist auxiliary pointer \\
a VSIZE-bit indirect auxiliary pointer
\end{indpar}
\hspace*{1in}\begin{minipage}{4.5in}
where \key{VSIZE} equals 24 for a compact implementation
and 40 for a loose implementation
\end{minipage}

Here {\COMPACT} subtypes are only implemented by compact
implementations, and {\LOOSE} subtypes are only implemented by
loose implementations (\pagref{COMPACT-OR-LOOSE}).

Numbers and character strings stored inside a \TT{min::gen} value are
called `\skey{direct atom}s\,'.  Numbers and character strings
stored in stubs or bodies which are pointed at by a
\TT{min::gen} value are called `\skey{indirect atom}s'.  An atom is
always stored in only one way by an implementation.  If a number will fit
into a direct atom, it is stored as a direct atom, and never as an
indirect atom.  Similarly if a character string will fit into a direct atom,
it is stored as a direct atom, and never as an indirect atom.

Analogously indirect atoms are stored in only one place in memory, so
two indirect numbers are equal if and only the \TT{min::gen} values
pointing at them point at the same place, and similarly
two indirect character strings are equal if and only
the \TT{min::gen} values pointing at them point at the same place.

Therefore two atoms are equal if and only if the \TT{min::gen} values
designating them are \TT{==} as 32-bit or 64-bit values.

General values that point at stubs hold stub addresses in a
packed format.  44 bits are available to store a stub address in a
64-bit general value, and 32 bits are available to store a stub address
in a 32-bit general value, but in the latter case the packed address must be
less than $2^{32}-2^{29}$ (the $2^{29}$ other 32 bit values are used to store
direct integers, direct strings,
auxiliary pointers, indices, control codes, and special
values).  There are three
\skey{stub address packing scheme}s,\label{STUB-ADDRESS-PACKING} and the fastest
is selected for each type of general value according to the settings of
the following `\skey{stub address packing parameter}\,' macros:

\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTKEY{MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum absolute address of any stub as an unsigned integer
	  constant.  See \pagref{MIN_MAX_ABSOLUTE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTKEY{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum address of any stub relative to a constant
	  stub base address, as an unsigned integer
	  constant.  See \pagref{MIN_MAX_RELATIVE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}

The fastest scheme is the \key{absolute stub address} scheme,
where the absolute stub
address is stored.  For 64 bit general values this is
just a matter of inserting the stub address into the low order 44 bits
of the value.  For 32 bit general values this is just a matter of
using the stub address as the general value.
This scheme can be used if
\TT{MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The second fastest scheme is the \key{relative stub address}
\label{RELATIVE-STUB-ADDRESS} scheme, where the
stub address relative to a constant \key{stub base}
address is stored.
The relation between the absolute and relative stub addresses is:

\begin{center}
stub absolute address = stub base + stub relative address
\end{center}

where `stub base' is a constant determined when the program is
initialized.
This scheme can be used if
\TT{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The slowest scheme is the \key{stub index} scheme, where the
relative stub address divided by the stub length is stored.
The stub length is chosen to be a power of 2 so that this
scheme will be efficient.  Again, this scheme can be used
if the relative address of the stub is not too large, but since
the stub length is 16, the relative address can be 16 times larger
for the stub index packing scheme than it is for the stub relative address
packing scheme.
Thus the index scheme can be used if
\TT{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS/16}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

Note that on machines that have 32 bit addresses (e.g.,
the IA32\footnote{Intel Architecture 32-bit, a.k.a, i386 machines.}
machines), there is little to gain by either the relative stub address
or stub index packing schemes,
so only the absolute stub address scheme should be used on such machines.

A 32-bit general value direct integer consists of a high order 4-bit
subtype code and a low order 28-bit signed integer stored in offset form,
so the true integer can be derived from the \TT{min::gen} value by
subtracting the \TT{min::gen} representation of zero.
The range of such a direct integer is the same as the range of a 28-bit
two's complement integer: $-2^{27}$ to $2^{27}-1$, inclusive.

Other 32-bit general values consist of a high order
8-bit subtype code and a low order 24-bit datum.
For most auxiliary pointer
general values the datum is a 24-bit auxiliary pointer
(see~\pagref{OBJECT-BODY-AUXILIARY-POINTER}
for a definition of auxiliary pointers).
For index and special values the datum is a 24-bit index.
For control code general values the datum is 24-bits that
contains flags and codes that have different interpretations in different
contexts.  And for direct string general values the datum
holds 0 to 3 8-bit \TT{char}'s.

For 64-bit general values that point at stubs, the high order 20 bits
are used as a subtype code.  For other 64-bit general values, the high
order 24 bits are the subtype code and the low order 40 bits are the datum.
The values chosen for these subtype codes make stub pointers, direct strings,
auxiliary pointers, indices, and control codes -- that is, all non-number
\TT{min::gen} values --
into IEEE Nan (Not-a-Number)
values that are never generated by hardware instructions.

For most auxiliary pointer general values the 40-bit datum is used to hold
a 40-bit auxiliary pointer.
For index and special values the datum holds a 40-bit index.
For control code general values the datum is a 40-bit control code;
and for direct string general values the datum holds 0-5 \TT{char}'s.

The \TT{min::gen} type has the alignment
properties of either \TT{min::uns32} or \TT{min::uns64},
and \TT{min::}\EOL \MINKEY{unsgen} is \TT{typedef}'ed to the appropriate one
of these two types.

Many \TT{min::gen} values, which are 32 or 64 bits, are divided into a subtype,
either 8 or 24 bits, and a datum, either 24 or 40 bits.  In this context the
datum is called the `\mkey{value}{part of a \TT{min::gen} value}'.

The following definitions are provided in \TT{min.h} to facilitate coding:

\begin{indpar}
\begin{tabular}{r@{}l}
\verb|typedef min::uns32 min::| & \MINKEY{unsgen}\COMPACT
\LABEL{MIN::COMPACT_UNSGEN} \\
\verb|typedef min::uns64 min::| & \MINKEY{unsgen}\LOOSE
\LABEL{MIN::LOOSE_UNSGEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_gen} \verb|( min::unsgen value )|
\LABEL{MUP::NEW_GEN} \\
\verb|min::unsgen MUP::| & \MUPKEY{value\_of} \verb|( min::gen value )|
\LABEL{MUP::VALUE_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{gen} \verb|( void )|
\LABEL{MIN::GEN_OF_VOID} \\
\verb|const unsigned min::| & \MINKEY{TSIZE}
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
\LABEL{MIN::VSIZE} \\
\end{tabular}
\end{indpar}

\TT{min::unsgen} is typedef'ed to
\TT{min::uns32}\COMPACT or \TT{min::uns64}\LOOSE.
\TT{MUP::\EOL new\_\EOL gen} and \TT{MUP::\EOL value\_of} are
unprotected converters between \TT{min::\EOL unsgen} and \TT{min::\EOL gen}
values.

\TT{min::\EOL gen (~void~)} is the default constructor that sets
an unassigned \TT{min::\EOL gen} value so it will more likely
trigger a fault if read by mistake (there is an exception for
\TT{min::gen} elements of packed structures and packed vectors,
which are set to \TT{0} when the structures or vectors are
created: see \itemref{PACKED-STRUCTURES} and \itemref{PACKED-VECTORS}).
Note that the existence of this constructor makes it impossible to
include \TT{min::\EOL gen} values in C++ \TT{union}'s, but
\TT{min::\EOL unsgen} values can be included instead and converted
using the unprotected converters.

\TT{TSIZE} is the subtype size in bits;
equal to \TT{8}\COMPACT or \TT{24}\LOOSE.
\TT{VSIZE} is the value size in bits;
equal to \TT{24}\COMPACT or \TT{40}\LOOSE.

\subsubsection{General Value Compilation}
\label{GENERAL-VALUE-COMPILATION}

The decisions on whether an implementation is
compact or loose (\pagref{COMPACT-OR-LOOSE})
must be made before C++ code is compiled.
Decisions must also be made determining the stub address packing
parameters (\pagref{STUB-ADDRESS-PACKING}).
The following macros, which must be defined identically
for all separately compiled parts of a single program, describe
these decisions.  These macros are in two groups, first the macros
that are set by the programmer, and then the macros which by default
are computed from the settings of the first group of macros.
All these macros are defined in
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

The macros set by the programmer are:

\begin{indpar}[0.2in]\begin{tabular}{p{2.1in}p{3.5in}}
\TTKEY{MIN\_IS\_COMPACT}	& 1 if compact implementation; 0 if loose;
				  defaults to 0.
\LABEL{MIN_IS_COMPACT}
\end{tabular}\end{indpar}
\begin{indpar}[0.2in]\begin{tabular}{p{2.1in}p{3.5in}}
\TTKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
				& Maximum number of garbage collector
				  ephemeral levels allowed in
				  \underline{any} execution of the
				  compiled binary; defaults to 2.
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\end{tabular}\end{indpar}

The macros which are normally set to default values computed from
the above macro settings are:
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTKEY{MIN\_IS\_LOOSE}	& 1 if loose implementation; 0 if compact;
				  Must equal `\TT{!~MIN\_IS\_COMPACT}\,'.
\LABEL{MIN_IS_LOOSE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
				& The maximum number of stubs that can
				  exist in \underline{any} execution
				  of the compiled binary.  Defaults: \\
& \hspace*{1em}\begin{tabular}{ll}
if \TT{MIN\_IS\_COMPACT} = 1:	& $2^{28} - 2^{25}$ \\
else pointers are 32 bits:	& $2^{28}$ \\
else:				& $2^{40-4e}$ \\
\end{tabular} \\
& where \\
& ~~$e = max(0,\mbox{\TT{MIN\_MAX\_EPHEMERAL\_LEVELS}}-2)$.
\LABEL{MIN_MAX_NUMBER_OF_STUBS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTKEY{MIN\_STUB\_BASE}
	& The value of the `stub base' for relative addressing
          (see \pagref{RELATIVE-STUB-ADDRESS}).  If defined
          this must be a non-negative integer constant.  Defaults to
	  \TT{0} if \TT{MIN\_MAX\_NUMBER\_OF\_STUBS} is set by
	  default, and otherwise is left undefined.
\LABEL{MIN_STUB_BASE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\multicolumn{2}{l}{\TTKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}} \\
	& The maximum address of any stub relative to the `stub base' (address
	  of the first stub), as an unsigned integer constant.  Default: \\
	& ~~\TT{16*MIN\_MAX\_NUMBER\_OF\_STUBS - 1}.
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\multicolumn{2}{l}{\TTKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}} \\
	& The maximum absolute address of any stub.  Defaults: \\
	& ~~~~ if \verb|MIN_STUB_BASE| defined: \\
	& ~~~~~~~~ \verb|  MIN_STUB_BASE| \\
	& ~~~~~~~~ \verb|+ MIN_MAX_RELATIVE_STUB_ADDRESS| \\
	& ~~~~ else if \begin{tabular}[t]{@{}l@{}}
	               \verb|MIN_IS_COMPACT| = 1 and \\
		       pointers are 32 bits:
		       \end{tabular} \\
	& ~~~~~~~~ $2^{32}-2^{29}-1$ \\
	& ~~~~ else if pointers are 32 bits: \\
	& ~~~~~~~~ $2^{32}-1$ \\
	& ~~~~ else: \\
	& ~~~~~~~~ $2^{48}-1$
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS}
\end{tabular}
\end{indpar}

\subsubsection{General Value Functions}
\label{GENERAL-VALUE-FUNCTIONS}

General values can be assigned using the default
\TT{=} operator and compared by the usual equality operations:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::==_OF_GEN} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::!=_OF_GEN} \\
\end{tabular}\end{indpar}

The following functions return \TT{true} if a \TT{min::gen} datum is of the
indicated subtype and \TT{false} otherwise:

\begin{indpar}
\verb|bool min::|\MINKEY{is\_stub} \verb|( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::|\MINKEY{is\_direct\_float\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::|\MINKEY{is\_direct\_int\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::|\MINKEY{is\_direct\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::|\MINKEY{is\_index} \verb|( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::|\MINKEY{is\_control\_code} \verb|( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::|\MINKEY{is\_special} \verb|( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::|\MINKEY{is\_list\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::|\MINKEY{is\_sublist\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::|\MINKEY{is\_indirect\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::|\MINKEY{is\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_AUX}
\end{indpar}

For a 32-bit general value \TT{is\_direct\_float\LOOSE} is unimplemented.
For a 64-bit general value \TT{is\_direct\_int\COMPACT} is unimplemented.
The \TT{min::\EOL is\_\EOL aux} function returns true if the general
value is any auxiliary pointer (i.e., list, sublist, etc.).

The following protected functions return the value appropriate for a given
subtype, after checking the subtype with a \TT{MIN\_ASSERT} statement:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * | & \MINKEY{NULL\_STUB}
\LABEL{MIN::NULL_STUB} \\
\verb|const min::stub * min::| & \MINKEY{stub\_of} \verb|( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of} \verb|( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\
\end{tabular}\end{indpar}

The \TT{min::stub\_of} function is unusual in that it can be applied
to a \TT{min::\EOL gen} value that does not contain a stub pointer, and will
return \TT{min::\EOL NULL\_\EOL STUB} in this case.  The latter is
just a \TT{NULL} value that has been
type cast to the \TT{const min::\EOL stub~*} type.
The other functions must be applied to \TT{min::\EOL gen}
values of the right kind else a \TT{MIN\_\EOL ASSERT} failure will
occur.

Here the \TT{min::uns64} value returned by \minkey{direct\_str\_of}
should be overlaid by a union with a \TT{char[]} buffer, as in
the code:

\begin{indpar}\begin{verbatim}
union { min::uns64 u; char s[6]; } v;
min::gen g;
. . . set g to a direct string value . . .
v.u = min::direct_str_of ( g );
cout << v.s;
\end{verbatim}\end{indpar}

The \TT{min::direct\_str\_of} function merely copies the 3 or
5 \TT{char}'s of the \TT{min::gen} direct string value and
appends a \TT{NUL} character.
It does this by writing an appropriate value into \TT{v.u}.

The \TT{min::\ldots{}\_aux\_of}, the \TT{min::index\_of} function,
the \TT{min::control\_code\_of} function,
and the \TT{min::\EOL spec\-ial\_\EOL index\_\EOL of} function all
return a 24-bit\COMPACT or 40-bit\LOOSE unsigned integer as a
\TT{min::unsgen} value.

The following unprotected functions return the value appropriate for a given
subtype, \underline{without} checking the subtype:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of} \verb|( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::| & \MUPKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of} \verb|( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of} \verb|( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{tabular}\end{indpar}

Note that \TT{MUP::stub\_of} returns a `\TT{min::stub *}' pointer
whereas \TT{min::stub\_of} returns a `\TT{const min::stub *}' pointer.
Also, if the \TT{min::\EOL gen} argument does not contain a stub pointer,
the argument is illegal for \TT{MUP::\EOL stub\_\EOL of}, but
it is legal for \TT{min::\EOL stub\_\EOL of} which will return
\TT{min::\EOL NULL\_\EOL STUB}.

The \TT{MUP::\EOL aux\_\EOL of} function returns the auxiliary pointer
of any \TT{min::gen} value containing an auxiliary pointer (list,
sublist, or indirect).

New \TT{min::gen} values can be generated by the following protected
functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_stub\_gen} \verb|( const min::stub * s )|
\LABEL{MIN::NEW_STUB_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE} \verb|( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen\COMPACT} \verb|( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_str\_gen} \verb|( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen} \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{tabular}\end{indpar}

These protected functions check for argument range errors.  Stubs are
\underline{not} allocated by these functions, so an \TT{int}
argument to \TT{min::new\_direct\_int\_gen\COMPACT} must fit in 28 bits,
and the \TT{const char *} strings must be short enough to
fit into a direct string.  For \TT{min::new\_\EOL direct\_\EOL str\_\EOL gen}
with a second argument \TT{n}, a string longer than \TT{n} characters
is shortened to \TT{n} characters (analogously to \TT{strncpy} and
\TT{strncmp}).
The \TT{min::unsgen} arguments used to make auxiliary pointers, indices,
control codes, and special values must fit within \TT{min::VSIZE} bits.

The subtype codes used for 64-bit \TT{min::gen} direct string, stub pointer,
auxiliary pointer, index, control code, and special values
-- that is, all the non-numeric \TT{min::gen} values --
are chosen to avoid being the same as the high order bits of any
IEEE floating point number normally generated by the compiler,
run-time system, or program execution.  A \TT{min::float64}
input to \TT{min::new\_direct\_\EOL float\_\EOL gen} is assumed not to have
these subtype
codes, and no check is made for such, even by range-checking protected
functions.

The following unprotected functions are analogous but do not check for
range errors.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen MUP::| & \MUPKEY{new\_stub\_gen} \verb|( min::stub * s )|
\LABEL{MUP::NEW_STUB_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_float\_gen\LOOSE}
     \verb|( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_int\_gen\COMPACT} \verb|( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen} \verb|( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen}
     \verb|( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::| & \MUPKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN}
\end{tabular}\end{indpar}

The following unprotected functions can be used to replace the data
(non-subtype) part of a \TT{min::gen} value that is \underline{not}
a pointer to a stub or a number (direct float or direct integer).
The intended use is for changing the value of an auxiliary pointer
in a general value, or the flags in a condition code.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen} \verb|( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\
\end{tabular}\end{indpar}

The actual direct atom, stub pointer, auxiliary pointer, index,
and control code
\TT{min::gen} subtype codes
are implementation dependent.  The following constants equal these
subtype codes:

\begin{indpar}
\verb|const unsigned min::|\MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_FLOAT\LOOSE}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_INT\COMPACT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::|\MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_PACKED\_AUX}
\LABEL{MIN::GEN_PACKED_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::|\MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::|\MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::|\MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL}
\end{indpar}

\TT{min::GEN\_ILLEGAL} is actually illegal as a subtype code but may
be returned by the following function which be used to retrieve
the subtype code field:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{gen\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{tabular}\end{indpar}

For 64-bit \TT{min::gen} values, this retrieves the high order
24 bits of the value, and then zeros any low order bits that are not
part of the subtype code (that is, the 64-bits are right shifted by
40 bits and then bits of the result that are not part of the
subtype, such as bits in a number, are zeroed).
For 32-bit \TT{min::gen} values, this retrieves
the high order 8 bits, and then zeros any low order bits that are not
part of the subtype code (similarly the 32-bits are right shifted by
24 bits, etc.).
\TT{min::GEN\_ILLEGAL} is returned by this function if the \TT{min::gen}
value is not a legal general value.

There are also unprotected functions to convert between
\TT{min::\EOL gen} and \TT{min::\EOL unsgen} values:
see \pagref{MUP::NEW_GEN}.

\subsection{Special Values}
\label{SPECIAL-VALUES}

Special general values are \TT{min::gen} values that are unique
and not equal to any non-special \TT{min::\EOL gen}
value that can be generated during
program execution.  Special general values are C/C++ \TT{const}
values, and must only be used as specified by documentation.
They are used as return or argument values by some functions.

For reasons given below, special values are defined by \TT{inline}
functions of no-arguments.
The special values defined by MIN are:

\begin{indpar}
\begin{list}{}{}
\item[\TT{const min::gen min::}\MINKEY{MISSING()}]~%
	\LABEL{MIN::MISSING}\\
Denotes a missing value or an empty set of values, and may be input
or output and used as an attribute value.
\item[\TT{const min::gen min::}\MINKEY{NONE()}]~%
	\LABEL{MIN::NONE}\\
Denotes a non-existent function value or result, but may \underline{not} be
input or output or used in an attribute value or label.  May be used
as a function argument or return value.
\item[\TT{const min::gen min::}\MINKEY{ANY()}]~%
	\LABEL{MIN::ANY}\\
An argument value used to specify that any value from a set of values may be
used or returned.
\item[\TT{const min::gen min::}\MINKEY{MULTI\_VALUED()}]~%
	\LABEL{MIN::MULTI_VALUED}\\
A value returned to indicate that
a set of values has more than one element.
\item[\TT{const min::gen min::}\MINKEY{UNDEFINED()}]~%
	\LABEL{MIN::UNDEFINED}\\
A value given to an object variable vector element
(\itemref{TYPED-OBJECTS}) that has no value and can be indirected.
\item[\TT{const min::gen min::}\MINKEY{SUCCESS()}]~%
	\LABEL{MIN::SUCCESS}\\
A value returned to indicate a function has succeeded.
\item[\TT{const min::gen min::}\MINKEY{FAILURE()}]~%
	\LABEL{MIN::FAILURE}\\
A value returned to indicate a function has failed.
\item[\TT{const min::gen min::}\MINKEY{ERROR()}]~%
	\LABEL{MIN::ERROR}\\
A value returned to indicate a function call has suffered an error.
The function may print an error message in
this case, or may leave an error message in
\TT{min::\EOL error\_\EOL message} (\pagref{ERROR_MESSAGE}).
\end{list}
\end{indpar}

Special general values each have a unique \ikey{index}{of special value}
that identifies them relative to other special values.  These
indices are in the range $0$ through $2^{24}-1$.  The last 1024 indices of this
range, $2^{24}-1024$ through $2^{24}-1$, are reserved for use by the MIN
system.  Other special values can be created by other systems,
and indices near 0 are reserved for non-system users.

For efficiency reasons it is desirable for special values to be
compile time constants.  Because \TT{min::\EOL gen} is a class type,
C++ constants cannot be used to insert special values into optimized
instructions, and \TT{inline} functions are used instead.  A
special value \TT{S} with index \TT{I} should be defined by:

\begin{indpar}\begin{verbatim}
inline min::gen S ( void )
{
    return min::new_special_gen ( I );
}
\end{verbatim}\end{indpar}

where \TT{I} is an integer constant in the range $0,\ldots,2^{24}-1025$.


\subsection{Stubs}
\label{STUBS}

General values may point at object stubs, which are 16 byte structures
that are \underline{not} relocated during execution.
Some stubs have pointers to object bodies, which can be
relocated during execution, either
because the object is being expanded or contracted, or because
memory is being compacted.

A stub contains an 8 byte stub value and an 8 byte stub control.
The type of a stub is \minkey{stub}.  Only pointers to stubs
are used, and these come in two flavors:
\TT{const min::stub~*} is used by protected functions and
\TT{min::stub~*} without the `\TT{const}' is used
by unprotected functions.

If the stub control is viewed as a 64 bit integer, its high order byte
is the type code.  The high order bit of this type code,
which is the high order
bit of the 64 bit stub control integer, is off if the stub is managed by
the allocator/collector/compactor (acc, of which the garbage collector is
a part).  In this case the stub is said to be `\key{collectible}'.
In the other case, where the bit is on, the stub is
said to be `\key{uncollectable}', and the stub is allocated and freed
by explicit calls to the acc, but is not garbage collected or compacted by the
acc.

If an stub has a body, its stub value is a pointer at that body.
Any other pointer into the body is called a `\key{body pointer}', and
will become invalid if the body is moved
by a relocating function (see \pagref{RELOCATING-FUNCTIONS}).

\subsubsection{Stub Type Codes}
\label{STUB-TYPE-CODES}

The \key{type code} of a stub may be returned by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MIN::TYPE_OF} \\
\verb|int MUP::| & \MUPKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MUP::TYPE_OF}
\end{tabular}\end{indpar}

If the argument is \TT{min::NULL\_STUB},
the \TT{min::type\_of} function returns \TT{0}, which is not
a stub type code (it does not even equal \TT{min::GEN\_ILLEGAL}),
whereas \TT{MUP::\EOL type\_\EOL of} suffers a memory fault (it
tries to read a byte near address \TT{0}).

The type code of the stub pointed at by a \TT{min::gen} value
can be obtained by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{type\_of} \verb|( min::gen v )|
\LABEL{MIN::TYPE_OF_GEN}
\end{tabular}\end{indpar}

This function will return \TT{0}, which is not a legal stub type,
if \TT{v} does not contain a stub pointer.

A determination of whether or not a stub is collectible may be made
by applying the function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_collectible} \verb|( int type )|
\LABEL{MIN::IS_COLLECTIBLE}
\end{tabular}\end{indpar}

to the type code of the stub.  Notice that type codes are \underline{signed}
integers, so that negative type codes are uncollectable and positive type codes
are collectible.

A partial list of stub type codes is:

\begin{indpar}
\begin{list}{}{}
\item[\TT{const int min::NUMBER}]~\\
Stub value is an IEEE 64-bit floating point number.
\item[\TT{const int min::SHORT\_STR}]~\\
Stub value is 0-8 \TT{const char} string, \TT{NUL} padded.
\item[\TT{const int min::LONG\_STR}]~\\
Stub value is a pointer at a body of type \TT{min::long\_\EOL string}
that contains a \TT{const char} vector and its size. 
\item[\TT{const int min::DEALLOCATED}]~\\
Stub has a deallocated body.
\end{list}
\end{indpar}

A full list of stub type codes complete with page references
is given on \pagref{STUB-TYPE-CODE-LIST}.

\subsubsection{Stub Values}
\label{STUB-VALUES}

A stub contains a 64-bit \key{stub value}.  If the stub is collectible
(as determined by its type), the type of this value
is determined by the stub type code (\itemref{STUB-TYPE-CODES}).
Otherwise the stub is typically attached to an object and the type of the stub
value is determined by how it is attached; in this case the type of the
stub value is most often just \TT{min::gen}.

Many stubs are immutable
and their stub values cannot be written after the stub has been created;
nevertheless we describe unprotected functions
below (\itemref{STUB-CONTROL-FUNCTIONS} and
\itemref{STUB-VALUE-READ-WRITE-FUNCTIONS}) that
write these values.  Unprotected functions are also provided to obtain
body pointers from stubs when these are the stub values of the stubs.
This cannot be done by protected
functions as these body pointers are relocatable and require special
programming be sure they are up-to-date (\itemref{UNPROTECTED-BODY-POINTERS}).

\subsubsection{Stub Control}
\label{STUB-CONTROL}

A stub contains a 64-bit \key{stub control}.  The high order 8 bits
of this is the stub type code, and the high order bit of this type
code determines whether the stub is collectible (bit is off)
or uncollectable (bit is on).

If the stub is collectible,
the stub control is used exclusively by the acc,
except for the type code, which is shared between the acc
and the rest of the system.  Such a control word is called
an `\key{acc control}\,'.  A typical (but not required)
organization of an acc control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 12-24 bits:	& acc flags \\
low order 44-32 bits:	& chain pointer \\
\end{tabular}
\end{center}

Here the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING})
that is used to build lists of allocated stubs which
the acc manages.

If a stub is uncollectable, its stub control, which is called
a `\key{non-acc control}\,', can be organized in different
ways according to the type code value.  The standard way of organizing
a non-acc stub control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 8 bits:		& subtype code \\
low order 48 bits:	& chain pointer or unsigned integer value \\
\end{tabular}
\end{center}

Again the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING}),
but now it has enough bits to be packed with the fastest packing scheme.

A non-acc control may also be used outside a stub, say by the acc, and
in this case it may be alternatively organized as:

\begin{center}
\begin{tabular}{ll}
high order 16 bits:	& locator \\
low order 48 bits:	& stub pointer \\
\end{tabular}
\end{center}

The main use of uncollectable stubs is as auxiliary stubs.
An `\key{auxiliary stub}' is an uncollectable stub attached to an object.
When the object is garbage collected, the auxiliary stub is freed.  Auxiliary
stubs are a means of adding memory to an object without relocating the object.
For example, if the object stores 64-bit IEEE floating point numbers,
a chain of auxiliary stubs can be used to add memory to the object
for additional numbers.  Note that the auxiliary stub itself does not
contain information that tells the type of the value it stores;
one has to trace the reference from the object pointing at the
auxiliary stub to determine this type.  Usually auxiliary stub
values are \TT{min::gen} values.
See \itemref{STUB-CONTROL-FUNCTIONS} and
\itemref{STUB-VALUE-READ-WRITE-FUNCTIONS}
for unprotected functions that can read and write auxiliary stubs.

\subsection{Protected Body Pointers}
\label{PROTECTED-BODY-POINTERS}

Bodies are relocatable
(\pagref{RELOCATABLE-BODY}) and pointers into bodies,
called \skey{body pointer}s,
require special handling to
ensure that they are up-to-date.  There are two ways of managing
this: the protected way and the unprotected way.
In this section we will describe the protected way.
The unprotected way is described, primarily for the benefit of those
who want to implement new types of stubs,
in \itemref{UNPROTECTED-BODY-POINTERS}.

Note also that \ikey{deallocation}{deallocate} of a body is treated as
reallocation of the body to inaccessible virtual memory.

\subsubsection{Type Specific Body Pointers}
\label{TYPE-SPECIFIC-BODY-POINTERS}

The protected way of handling body pointers
uses special pointer data that is adapted to
the type of datum being pointed at.  For example, the following
code can access any string:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some string
assert ( min::is_str ( x ) );
min::str_ptr xp ( x );
int length = min::strlen ( xp );
for ( int i = 0; i < length; ++ i )
{
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Here the \TT{str\_ptr} datum is a \key{protected body pointer}.
For strings that are long enough to have a body, the
\TT{str\_ptr} stores a pointer to the stub of the string,
and `\TT{xp[i]}' is an inline function that expands to
code that reads the body pointer from the stub and adds both
an appropriate constant offset and then the index `\TT{i}'
to that pointer in order to get the address of the character.

It might be thought that this is inefficient as the body pointer
is re-read from the stub for every different iteration of the `\TT{for}'
loop.  However, if no out-of-line functions are called in the
loop, an optimizing compiler will typically eliminate
the excess reads and load the body pointer plus constant offset
into a register before the loop begins.  The key here is to
avoid out-of-line function calls, as for each such call the
optimizer must assume that the body pointer in the stub might
change.

Specialized protected pointer types are provided for most types of object
that have bodies.

\subsubsection{Body References and Pointers}
\label{BODY-REFERENCES-AND-POINTERS}

In addition to specialized pointer types for each type of object,
there are a general body reference and pointer types
that reference any type an element in any body associated with any stub.
The functions for creating and using reference types are:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T const & location )|
\LABEL{MUP::NEW_REF_OF_LOCATION} \\
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_REF_OF_OFFSET} \\
\verb|min::|\MINKEY{ref<T>}\verb| min::| & \MINKEY{new\_ref}\ARGBREAK
    \verb|( T & location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_REF} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * MUP::| & \MUPKEY{ZERO\_STUB}
\LABEL{MUP::ZERO_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * const r| & \TTDMKEY{s}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_STUB} \\
\verb|min::unsptr const r| & \TTDMKEY{offset}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_OFFSET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T const & value )| \\
\LABEL{MIN::=REF_OF_T} \\
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  min::ref<T> const & r2 )|
\LABEL{MIN::=REF_OF_REF} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|T |
    & \TTOMKEY{T}{T}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_TO_T} \\
\verb|T |
	& \TTOMKEY{->}{->}{of {\tt min::ref<T>}}
	   \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_->} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::==REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}
      \verb|( T v, min::ref<T> const & r )|
\LABEL{MIN::==T_AND_REF} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::!=REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}
      \verb|( T v, min::ref<T> const & r )|
\LABEL{MIN::!=T_AND_REF} \\
\end{tabular}\end{indpar}

In addition, the following are defined
only if \TT{T} is a packed structure or vector pointer,
i.e., \TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<S>} or
\TT{min::\EOL packed\_\EOL vec\_\EOL xxxptr<E,H,L>}:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, const min::stub * s )|
\LABEL{MIN::==REF_AND_STUB} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, const min::stub * s )|
\LABEL{MIN::!=REF_AND_STUB} \\
\end{tabular}\end{indpar}

A \TT{min::ref<T>} type is similar to the `\TT{T \&}' type.
Internally a \TT{min::ref<T>} value \TT{r}
is a pointer to a location of type \TT{T} that
consists of a \TT{const min::\EOL stub~*} pointer \TT{r.s} to a stub
and an \TT{min::\EOL unsptr} byte offset \TT{r.offset}
of a location in the body
associated with the stub.  Setting a reference type equal to a value
of type \TT{T} stores the value in the location.  Setting a reference
\TT{r} equal to another reference \TT{r2}, as in `\TT{r~=~r2}', does
\underline{not} copy the internal pointers, but instead copies the
value at the \TT{r2} location to the \TT{r} location.

A \TT{min::ref<T>} value is implicitly convertible to the type \TT{T}
by reading the value referenced.
As this implicit conversion
is not activated by C++ in the case of an expression of the form
`\TT{r->\ldots}'\label{REF->},
`\TT{operator~->}' of a \TT{min::\EOL ref<T>}
argument is defined to invoke the conversion explicitly.
Similarly for \TT{operator ==} and \TT{operator !=}.
In addition, these are defined to make the conversion when
\TT{T} is convertible to \TT{const min::\EOL stub~*} and the
second argument is of this latter type, so that expressions such as
\begin{center}
\tt r == min::NULL\_STUB
\end{center}
can be used.

The implicit conversion of a \TT{min::\EOL ref<T>} value \TT{r} to a \TT{T}
value is \underline{not} activated by the C++ `\TT{.}' operator,
so if \TT{T} is a structure type with member \TT{m}, then \TT{r.m}
fails.  One must use \TT{(\&r)->m} instead, which works because
the `\TT{->}' operator has been defined for \TT{min::\EOL ptr<T>}
values (see \pagref{PTR->}).
Unfortunately C++ does not allow a similar definition for the
`\TT{.}' operator.

\TT{min::ref<T>} values are returned by protected functions described
elsewhere:
\begin{center}
\begin{tabular}{ll}
packed structures & see \TT{MIN\_REF}
    \pagref{MIN_REF} and \pagref{PACKED_STRUCT_MIN_REF} \\
packed vector headers & see \TT{MIN\_REF}
    \pagref{MIN_REF} and \pagref{PACKED_VEC_MIN_REF} \\
packed vector elements	& see \TT{operator []}
    \pagref{MIN::PACKED_VEC_PTR_[]},
    \TT{push} function \pagref{MIN::PACKED_VEC_PUSH} \\
locatable variables	& see \TT{operator min::ref<T>}
    \pagref{LOCATABLE_VAR_REF} \\
object vector elements	& see access functions \pagref{OBJ_VEC_UPDPTR_REF},
			  push functions \pagref{OBJ_VEC_UPDPTR_PUSH_REF}
\end{tabular}
\end{center}

The unprotected \TT{MUP::new\_ref} function is used by these
protected functions to construct a \TT{min::\EOL ref<T>} value
from a pointer \TT{s} to a stub and either a \TT{const} location
within the body associated with that stub or an \TT{offset}
within the body
(i.e., an address in bytes relative to the beginning of the body).
Note that in either case, and in particular for a location
of a `\TT{T const}' type, the resulting
\TT{min::\EOL ref<T>} reference value will allow the location
to be written.  This is done because locations inside data bodies
that point at stubs are declared as `\TT{const}' locations
so they cannot be written without using
the \TT{MIN\_\EOL REF} macro to construct a
\TT{min::\EOL ref<T>} value: see \pagref{MIN_REF_USAGE}.
Note also that when an offset is given to
\TT{MUP::\EOL new\_\EOL ref<T>}, the type \TT{T}
must be included in the function name,
which is \TT{MUP::\EOL new\_\EOL ref<T>}
and not just \TT{MUP::\EOL new\_\EOL ref}, as \TT{T} cannot
be deduced from the argument types.

The protected \TT{min::new\_ref} function\label{NEW_REF_USAGE}
may be used to construct
a \TT{min::\EOL ref<T>} value from a \underline{non-relocatable} location,
such as a global location or a location in the stack.
This function constructs a \TT{min::\EOL ref<T>} value whose
stub is the special \TT{MUP::\EOL ZERO\_\EOL STUB} stub that
has a body pointer equal to \TT{0} so the offset of the
\TT{min::\EOL ref<T>} value may be the address of the
non-relocatable location.

Actually there are two kinds of \TT{min::\EOL ref<T>} types that
differ according to whether or not the type \TT{T} is
`\mkey{locatable}{\TT{min::ref<T>} reference to}'
\label{LOCATABLE_REF}
(\TT{min::\EOL gen}, \TT{const min::\EOL stub~*}, and
classes such as \TT{min:\EOL packed\_\EOL\ldots ptr<\ldots>}
that encapsulate \TT{const min::\EOL stub~*} values are
locatable types: see \pagref{LOCATABLE-TYPE}).
If \TT{T} is locatable, storing a value in a \TT{min::\EOL ref<T>}
location implicitly calls the
\TT{min::\EOL acc\_\EOL write\_\EOL update} functions of
Section~\itemref{ACC-WRITE-UPDATE-FUNCTIONS} to update the stubs
involved, unless the \TT{min::\EOL ref<T>} value references
\TT{MUP::\EOL ZERO\_\EOL STUB}
or the value stored is \TT{min::\EOL NULL\_\EOL STUB}.
If \TT{T} is not locatable, or if the
\TT{min::\EOL ref<T>} value references \TT{MUP::\EOL ZERO\_\EOL STUB},
or if the value stored is \TT{min::\EOL NULL\_\EOL STUB},
then the \TT{min::\EOL acc\_\EOL write\_\EOL update} functions
are \underline{not} implicitly called.

Associated with the \TT{min::\EOL ref<T>} reference type is
the companion \TT{min::\EOL ptr<T>} pointer type:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T * location )|
\LABEL{MUP::NEW_PTR_OF_LOCATION} \\
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_PTR_OF_OFFSET} \\
\verb|min::|\MINKEY{ptr<T>}\verb| min::| & \MINKEY{new\_ptr}\ARGBREAK
    \verb|( T * location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{ptr<T>} \verb| p|
\LABEL{MIN::PTR_OF_T} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * const p| & \TTDMKEY{s}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_STUB} \\
\verb|const min::unsptr p| & \TTDMKEY{offset}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_OFFSET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}
      \verb|( min::ptr<T> & p, min::ptr<T> const & p2 )|
\LABEL{MIN::=PTR_OF_PTR}
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|T * |
	& \TTOMKEY{->}{->}{of {\tt min::ptr<T>}}
	  \verb|( min::ptr<T> const & p )|
\LABEL{MIN::PTR_->} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::=AMPERSAND_OF_REF_OF_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{*}{*}{of {\tt min::ptr<T>}}
      \verb|( min::ptr<T> const & p )|
\LABEL{MIN::=*_OF_PTR_OF_T} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<T> p| & \TTBMKEY{i}{of {\tt min::ptr}}
\LABEL{MIN::PTR_[]} \\
\verb|min::ptr<T> |
    & \verb|p|\TTMOKEY{+}{of {\tt min::ptr}}\verb|i|
\LABEL{MIN::PTR_+} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}ll}
\verb|T * |
	& \TTOMKEY{!}{!}{of {\tt min::ptr<T>}}
	  \verb|( min::ptr<T> const & p )| & [unprotected]
\LABEL{MIN::!_OF_PTR} \\
\verb|min::ptr<T> |
	& \MINKEY{ptr<T>}
	   \verb|( min::ptr<S> const & p )| & [unprotected]
\LABEL{MIN::PTR_OF_PTR} \\
\end{tabular}\end{indpar}

Internally a \TT{min::\EOL ptr<T>} value is exactly like a
\TT{min::\EOL ref<T>} value; both point at a location defined by
a stub and an offset within the body of the stub.
A main difference is that \TT{=} for reference values copies the
values of the locations pointed at, while \TT{=} for pointer values
copies the pointers themselves; i.e., the pointer to the stub and the offset.
Similarly \TT{==} for reference values compares the values of
the locations pointed at, whereas \TT{==} for pointer values
compares the pointers themselves.

Another difference is that if a \TT{min::\EOL ref<T>} value \TT{r}
designates a location containing a \TT{T} value \TT{v}, then
\TT{r->\ldots}\label{PTR->} is equivalent to \TT{v->\ldots}.
But if a \TT{min::\EOL ptr<T>} value \TT{p}
points at location \TT{loc} containing a \TT{T} value \TT{v}, then
\TT{p->\ldots} is equivalent to \TT{(\&loc)->\ldots}.
This is because
the \TT{->} operator has been defined for \TT{min::\EOL ptr<T>}
types to return \TT{\&loc}, the location designated by the pointer,
but for \TT{min::\EOL ref<T>} types
it returns \TT{v} (see \pagref{REF->}), the location designated by
the value in the location designated by the reference.

A \TT{min::\EOL ptr<T>} value can be created by applying the
\TT{\&} operator to a \TT{min::\EOL ref<T>} value or to a
locatable variable (see \TT{operator \&} for locatable variables,
\pagref{LOCATABLE_VAR_PTR}).
A \TT{min::\EOL ref<T>} value can be recovered from a
pointer value by applying the
\TT{*} operator to the \TT{min::\EOL ptr<T>} value.

Creation of \TT{min::\EOL ptr<T>} values by \TT{\ldots::new\_\EOL ptr}
functions is just like
creation of \TT{min::\EOL ref<T>} values by \TT{\ldots::new\_\EOL ref}
functions (see \pagref{NEW_REF_USAGE}) with one exception.
Unlike \TT{MUP::\EOL new\_\EOL ref}, for which a \TT{const~T~\&}
location creates a \TT{min::\EOL ref<T>} reference in which \TT{T}
is \underline{not} \TT{const},
for \TT{MUP::\EOL new\_\EOL ptr}
a \TT{T~*} location creates a \TT{min::\EOL ptr<T>} pointer in which
the pointer \TT{T} is \TT{const} if and only if the location \TT{T}
is \TT{const}.

Given a \TT{min::\EOL ptr<T>} value \TT{p} and an index \TT{i} of some
suitable index type \TT{I} (such as \TT{int} or \TT{min::\EOL uns32}),
\TT{p[i]} is a \TT{min::\EOL ref<T>}
reference value for the \TT{i+1}'st element of
the vector with elements of type \TT{T} pointed at by \TT{p}, and
\TT{p+i} is a \TT{min::\EOL ptr<T>} pointer to that element.

Because \TT{p[i]} has type \TT{min::\EOL ref<T>} when \TT{p} has
type \TT{min::\EOL ptr<T>}, the expression \TT{p[i].m} fails when
\TT{T} is a structure type with member \TT{m} (see \pagref{REF->}).
In this case it is
necessary to use the alternative but usually equivalent expression
\TT{(\&p[i])->m}, which is undeniably awkward.

This is an unfortunate tradeoff between making the
the value of \TT{p[i]} protected from relocation
but harder to use when \TT{T} is a structure type of a vector element,
and the alternative of making the value of \TT{p[i]}
the type `\TT{T \&}', which would allow \TT{p[i].m}
to work properly, but which contains an unprotected relocatable pointer.
Unfortunately C++ does not permit definitions of `\TT{operator .}' in
the manner that it permits definitions of `\TT{operator ->}', or else
this awkwardness would not arise.

A pointer of type \TT{min::ptr<T>} can be \underline{explicitly} converted
to an unprotected relocatable
pointer of type `\TT{T*}' by the unary `\TT{!}' operator.
This can be of use in code such as
\begin{indpar}\begin{verbatim}
ptr<char> s = ...;
int length = strlen ( ! s );
char buffer[length+1];
strcpy ( buffer, ! s );
\end{verbatim}\end{indpar}

In this case the value of the unary `\TT{!}' is a pointer \underline{not}
protected from relocation, so its only good use is to pass it to a
function such as \TT{strlen} or \TT{strcpy} which will not relocate
anything.  One must be careful that other arguments in the same statement
do not perform relocation, as then with the wrong optimized
order of argument evaluation `\TT{!}' can be performed just before a
relocation and its result used just afterwords.

If \TT{p} is of type \TT{min::ptr<S>}, then \TT{min::ptr<T>(p)} is just
\TT{p} coerced to the type \TT{min::\EOL ptr<T>} without any change to the
actual value of \TT{p}, just as \TT{(T *)(q)} is a coercion of \TT{q}
if \TT{q} has type `\TT{S *}'.  Such coercions are inherently
unprotected, of course.

The following operators defined on \TT{min::ptr<T>} values
allow these values to be used to step through a vector:

\begin{indpar}\begin{tabular}{r@{}l@{~~~~}l}
\verb|bool |
    & \TTOMKEY{<}{<}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1,|\ARGBREAK
      \verb|  min::ptr<T> const & p2 )|
\LABEL{MIN::<_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{++}{++}{of {\tt min::ptr<T>}}
    & [postfix \TT{++}]\ARGBREAK
      \verb|( min::ptr<T> & r, int )|
\LABEL{MIN::POSTFIX_++_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{--}{-{}-}{of {\tt min::ptr<T>}}
    & [prefix \TT{-{}-}]\ARGBREAK
      \verb|( min::ptr<T> & r )|
\LABEL{MIN::PREFIX_--_OF_PTR_OF_T} \\
\end{tabular}\end{indpar}

These are just what is required to take the \TT{min::\EOL ptr<T>}
values of
\TT{min::\EOL begin\_\EOL ptr\_\EOL of} and
\TT{min::\EOL end\_\EOL ptr\_\EOL of} applied to various objects
and step through the vector bracketed by the
resulting pointers.  See, for example, 
\TT{min::\EOL begin\_\EOL ptr\_\EOL of} on
\pagref{MIN::BEGIN_PTR_OF_STR_PTR}
and \TT{min::\EOL begin/end\_\EOL ptr\_\EOL of} on
\pagref{MIN::BEGIN_PTR_OF_LAB_PTR}.
To protect as much as possible from misuse, \TT{<} is defined to be
false if the two pointers point at different relocatable bodies.
So one should use the pointers to access data only if the smaller
pointer is still \TT{<} than the larger pointer.

There is a protected \TT{min::\EOL ptr<T>} constructor of no
variables that constructs a variable with a
\mkey{null}{of {\tt min::ptr<T>} type} value that is
like \TT{NULL}, in that it cannot equal any useful pointer value,
and will probably cause a memory fault if dereferenced.
To allow pointers to be tested for this null value the following
are defined:

\begin{indpar}\begin{tabular}{r@{}l@{~~~~}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::==_OF_PTR_OF_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::!=_OF_PTR_OF_T} \\
\end{tabular}\end{indpar}

Example usages are:
\begin{indpar}\begin{verbatim}
ptr<char> s = ...;
. . . . .
if ( s != min::ptr<char>() )
{
    . . . . .
}

ptr<int> null_p, p = ...;
. . . . .
if ( p != null_p )
{
    . . . . .
}
\end{verbatim}\end{indpar}

\subsubsection{Stack Temporaries of Relocatable Vectors}
\label{STACK-TEMPORARIES-OF-RELOCATABLE-VECTORS}

Sometimes it is useful to make a non-relocatable copy of
a vector that is resident in a body that might be relocated.
This can be done by the \TT{MIN\_\EOL STACK\_\EOL COPY} macro
which expands as follows:

\begin{indpar}
\TTKEY{MIN\_STACK\_COPY} \verb|( T, name, length, source )|
\LABEL{MIN_STACK_COPY}
\\[1ex]
expands to \\[1ex]
\verb|T name [length];| \\
\verb|memcpy ( name, ! (source),| \\
\verb|         sizeof ( T ) * (length) )|
\end{indpar}

The vector at `\TT{source}', which may be inside a body and therefore
be relocatable, is copied to the stack vector `\TT{name}', which
is not relocatable.
Thereafter `\TT{name}' may be used to reference this copy.
Here `\TT{source}' should have type \TT{min::ptr<T>}.

Because copying is fast, it can be more efficient to do this than
it is to reference individual elements of a relocatable vector using
\TT{min::ptr<T>} values.

\subsection{Allocator/Collector/Compactor Interface}
\label{ACC-INTERFACE}

The garbage collector needs to be able to locate all
\TT{min::gen} and \TT{const min::\EOL stub~*} values
that are in use and that might contain stub pointers.
Values of these types are called \skey{locatable value}s.%
\label{LOCATABLE-VALUE}
These types, and types that are just classes which
encapsulate a \TT{min::\EOL gen} or \TT{const min::\EOL stub~*}
value (such as the \TT{min::packed\_\ldots ptr<\ldots>} types,
\itemref{PACKED-STRUCTURES} and
\itemref{PACKED-VECTORS})
are called \skey{locatable type}s.%
\label{LOCATABLE-TYPE}

Values of a locatable type \TT{T} stored in static memory or the stack
need to be locatable by the garbage collector.  This is done
by storing them in \TT{min::\EOL locatable\_\EOL var<T>} type
variables, as described in the first subsection of this section.

When you write a value of locatable type \TT{T} into a stub or associated
body, you need to call the \TT{MUP::\EOL acc\_\EOL write\_\EOL update}
function (\itemref{ACC-WRITE-UPDATE-FUNCTIONS}) to update garbage
collection flags associated with stubs.
This is done automatically if a \TT{min::\EOL ref<T>} reference value is
used to reference the location being written.  Such reference values are created
by functions described in the second subsection of this section.

If you are implementing a new type of stub and maybe bodies
associated with that stub type, or a new class of pointers to stubs,
then you need to use the unprotected
interfaces described in the third and fourth subsections of this section.

\subsubsection{Locatable Variables}
\label{LOCATABLE-VARIABLES}

Values that might contain stub pointers must be locatable
by the garbage collector (the collector part of the acc).  Since
in a compact implementation even double precision numbers are
represented by \TT{min::gen} values pointing at stubs, this means
the just about all general values must be locatable.  However,
in order to benefit loose implementations, a distinction is made
between \TT{min::gen} values known to be numeric and those
that might not be, so loose implementations can encounter less overhead
when dealing with numeric \TT{min::gen} values.

In addition to \TT{min::gen} values that might point at stubs,
\TT{min::packed\_\ldots{}xxxptr<\ldots>} values, which point at stubs
(see \itemref{PACKED-STRUCTURES} and \itemref{PACKED-VECTORS}),
and \TT{const min::stub~*} values must be locatable.

Consequently
locatable values of type \TT{T} in static or stack memory must be stored
in locations of type \TT{min::}\MINKEY{locatable\_\EOL var<T>}:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|class min::| & \MINKEY{locatable\_var<T>} \TT{: public T} \\
    & use \TT{min::stub\_ptr} for \TT{T} instead of \TT{const min::stub *}
\LABEL{MIN::LOCATABLE_VAR_BASECLASS} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|typedef min::locatable<min::gen> min::| & \MINKEY{locatable\_gen}
\LABEL{MIN::LOCATABLE_GEN} \\
\verb|typedef min::locatable<min::stub_ptr> min::|
    & \MINKEY{locatable\_stub\_ptr}
\LABEL{MIN::LOCATABLE_STUB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{In compact implementation:} \\
~~~~\verb|typedef min::locatable_gen  min::| & \MINKEY{locatable\_num\_gen} \\
\multicolumn{2}{l}{In loose implementation:} \\
~~~~\verb|typedef min::gen  min::| & \MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb| var ( void )|
\LABEL{MIN::LOCATABLE_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( min::locatable_var<T> const & var )|
\LABEL{MIN::LOCATABLE_VAR_OF_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( T const & value )|
\LABEL{MIN::LOCATABLE_VAR_OF_VALUE} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  min::locatable_var<T> const & var2 )|
\LABEL{MIN::=LOCATABLE_VAR_OF_LOCATABLE_VAR} \\
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  T const & value )|
\LABEL{MIN::=LOCATABLE_VAR_OF_VALUE} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::ref<T const> |
    & \TTOMKEY{min::ref<T const>}{min::ref<T const>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::CONST_LOCATABLE_VAR_TO_REF_CONST_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{min::ref<T>}{min::ref<T>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::LOCATABLE_VAR_TO_REF_T} \\
\verb|min::ptr<T const> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::AMPERSAND_CONST_LOCATABLE_VAR} \\
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::AMPERSAND_LOCATABLE_VAR} \\
\end{tabular}\end{indpar}

The name \TT{min::\EOL locatable\_\EOL gen} should be used instead
of the equivalent \TT{min::\EOL locatable\_\EOL var<min::gen>}.
If the implementation is loose (\pagref{LOOSE}),
\TT{min::locatable\_\EOL num\_\EOL gen} is equivalent to
\TT{min::gen}.  If the implementation is compact, it is equivalent to
\TT{min::locatable\_\EOL gen}.

Normally \TT{min::\EOL locatable\_\EOL var<T>} is only used with 
\TT{T = min::\EOL packed\_\ldots{}ptr<\ldots>}
(see \itemref{PACKED-STRUCTURES} and \itemref{PACKED-VECTORS}).
It cannot be used
with \TT{T = const min::stub *} as this is not a class type and
cannot be a base type for the locatable vector type.  Instead
use \TT{T = min::\EOL stub\_\EOL ptr}, which is a class whose
only member is a \TT{const min::stub~*} value that can be read
and written using standard operations:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{stub\_ptr}\ARGBREAK
    \verb| var ( void )|
\LABEL{MIN::STUB_PTR} \\
\verb|(constructor) min::| & \MINKEY{stub\_ptr}\ARGBREAK
    \verb|var ( const min::stub * s )|
\LABEL{MIN::STUB_PTR_OF_S} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::locatable_var<T> & |
    & \TTOMKEY{const min::stub *}{const min::stub *}%
              {of {\tt min::stub\_ptr}}\ARGBREAK
      \verb|( min::stub_ptr const & var )|
\LABEL{MIN::STUB_PTR_OF_STUB_PTR} \\
\verb|min::stub_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::stub\_ptr}}\ARGBREAK
      \verb|( min::stub_ptr & var,|\ARGBREAK
      \verb|  const min::stub * s )| \\
\LABEL{MIN::=STUBPTR} \\
\end{tabular}\end{indpar}

The main operations that can be performed on a
\TT{min::\EOL locatable\_\EOL var<T>} location are to copy a
value of type \TT{T} into it or out of it.
Setting one \TT{min::\EOL locatable\_\EOL var<T>}
location equal to another copies the value of the locations,
and not the location structure itself.
Setting a \TT{min::\EOL locatable\_\EOL var<T>} location to a value \TT{v}
of type \TT{T} value writes the value to the location.
A \TT{min::\EOL locatable\_\EOL var<T>} locatable variable
has its \TT{T} value as its base class, most other operations on
the \TT{T} value can be performed on the \TT{min::\EOL locatable\_\EOL var<T>}
variable.

A \TT{min::\EOL locatable\_\EOL var<T>} locatable variable
\label{LOCATABLE_VAR_REF}
is also implicitly convertible to a reference
of type \TT{min::\EOL ref<T>}
that references the value stored in the locatable variable.
Note that if the locatable variable is \TT{const}, the reference type
will be \TT{min::\EOL ref<const T>}, which does not allow
the variable to be written.

Applying the \TT{\&} operator to a
\label{LOCATABLE_VAR_PTR}
\TT{min::\EOL locatable\_\EOL var<T>} locatable variable
returns a pointer of type \TT{min::\EOL ptr<T>} that points
at the variable value.
Note that if the locatable variable is \TT{const}, the pointer type
will be \TT{min::\EOL ptr<const T>}, which does not allow
the value to be written.

An example using \TT{min::locatable\_gen} is:

\begin{indpar}\begin{verbatim}
static min::locatable_gen v;
. . . . . . . . . .
void f ( ref<min::gen> const & r );
. . . . . . . . . .
min::gen some_function ( min::gen x, min::gen y )
{
    min::locatable_gen q = x;
    min::ptr<min::gen> p = & q;
    min::ref<min::gen> r = q;
    . . .
    v = q;     // Copies the min::gen value of q to v.
    * p = y;   // Sets q to y.
    r = x;     // Sets q to x.
    . . .
    f ( v );   // Converts v to min::ref<min::gen>
    f ( q );   // Converts q to min::ref<min::gen>
    . . .
    return q;  // Returns the value of q.
}
\end{verbatim}\end{indpar}

An example using \TT{min::\EOL locatable\_\EOL var<T>} with
\TT{T = min::\EOL packed\_\EOL vec\_\EOL insptr<char>}
(see \itemref{PACKED-VECTORS}) is:

\begin{indpar}\begin{verbatim}

typedef min::packed_vec_insptr<char> bufvec;
min::locatable_var<bufvec> x;
void f ( min::ref<bufvec> p );
... some_function ( ... )
{
    min::locatable_var<bufvec> y = x;
    f ( y );  // Converts y to a min::ref<bufvec> reference.
}
\end{verbatim}\end{indpar}

Importantly a \TT{min::gen} or \TT{const min::stub *}
value need \underline{not} be stored
in a locatable variable if it can be located by the garbage collector by some
other means.  For example, if it is stored in one locatable variable,
it need not be stored in another.  Or if a \TT{min::gen}
or \TT{const min::\EOL stub~*} value
$V$ is stored in an object pointed at by another \TT{min::gen}
or \TT{const min::\EOL stub~*}
value $P$, and $P$ is locatable, then $V$ need not
be stored in a locatable variable.

A very important rule is that when a function is called, the caller
must be sure every \TT{min::gen}
or \TT{const min::\EOL stub~*} value passed to the called
function can be located by the garbage collector \underline{without} the called
function needing to store the value in a locatable variable.
For example, the caller can store the value in its own locatable
variable.  This is called the `\key{caller locating convention}'.

Also \TT{min::gen} and \TT{const min::\EOL stub~*}
values need only be locatable by
the garbage collector when a relocating function (\pagref{RELOCATING-FUNCTIONS})
is called.  In between such calls \TT{min::gen}
and \TT{const min::\EOL stub *} values can be
stored in other places.  In particular, there is no problem
returning these values from a called function to its caller.

\subsubsection{Locatable Member References}
\label{LOCATABLE-MEMBER-REFERENCES}

Suppose we have some kind of stub/body data type whose body
is the structure \TT{S} defined and used in the following:

\begin{indpar}\begin{verbatim}
struct S;
struct S_ptr
    // Pointer to a stub whose body is a datum of type S.
{
    const min::stub * s;

    S_ptr ( const min::stub * s ) : s ( s ) {}

    S * operator -> ( void )
    {
        return (S *) MUP::ptr_of ( s );
            // Return pointer to body.
    }

    operator const min::stub * ( void ) const
    {
        return s;
            // Return pointer to stub.
    }
};

struct S
{
    // Examples of different member types:
    //
    int x;
    min::gen g;
    S_ptr p;
};

void foo ( S_ptr q )
{
    // Examples of usage of members:
    //
    int x2 = q->x.
    q->x = ...;
    min::gen g2 = q->g;
    q->g = ...;
    MUP::acc_write_update ( q, q->g );
    S_ptr p2 = q->p;
    q->p = ...;
    MUP::acc_write_update ( q, q->p );
}
\end{verbatim}\end{indpar}

Because \TT{min::gen} and \TT{S\_ptr} are locatable types,
\TT{MUP::\EOL acc\_\EOL write\_\EOL update}
(\itemref{ACC-WRITE-UPDATE-FUNCTIONS}) must be called when
members of these types are written into a stub or associated body.  There is
a danger of unintentional omission of these calls.

An alternative is to replace some of the above code by the following:

\begin{indpar}\begin{verbatim}
struct S
{
    int x;
    const min::gen g;    // Added `const'.
    const S_ptr p;       // Added `const'.
};

inline min::ref<min::gen> g_ref ( S_ptr q )
{
    return MUP::new_ref ( q, q->g );
}

inline min::ref<S_ptr> p_ref ( S_ptr q )
{
    return MUP::new_ref ( q, q->p );
}

void foo ( S_ptr q )
{
    int x2 = q->x.
    x = ...;
    min::gen g2 = q->g;
    g_ref(q)= ...;       // q->g replaced by g_ref(q).
    S_ptr p2 = q->p;
    p_ref(q) = ...;      // q->p replaced by p_ref(q).
}
\end{verbatim}\end{indpar}

Here the calls to \TT{MUP::acc\_write\_update} are inside the
\TT{\ldots\_ref(q) =} calls (\pagref{LOCATABLE_REF}).
Writing \TT{q->g = \ldots}
and \TT{q->p = \ldots} is prevented by making the \TT{g} and \TT{p}
members `\TT{const}', so accidentally updating locatable members
without calling \TT{MUP::\EOL acc\_\EOL write\_\EOL update}
is prevented.

To make the above easier to code, the \TT{MIN\_REF}\label{MIN_REF_USAGE} macro
is provided which expands as follows:

\begin{indpar}
\TTKEY{MIN\_REF} \verb|( type, name, ctype )|
\LABEL{MIN_REF}
\end{indpar}

expands to

\begin{indpar}
\verb|inline min::ref<type> name_ref ( ctype container )| \\
\verb|{| \\
\verb|    return MUP::new_ref ( container, container->name );| \\
\verb|}|
\end{indpar}

Here `\TT{type}' is the member type and `\TT{ctype}' is
the `\key{container type}'.

This enables the \TT{inline} function definitions above to be
replaced by

\begin{indpar}\begin{verbatim}
MIN_REF ( min::gen, g, S_ptr )
MIN_REF ( S_ptr, p, S_ptr )
\end{verbatim}\end{indpar}

The \TT{MIN\_\EOL REF} macro is frequently
used with packed structures (see \itemref{PACKED-STRUCTURES}) and
packed vectors (see \itemref{PACKED-VECTORS}).

\subsubsection{Deallocation}
\label{DEALLOCATION}

The operation of \ikey{deallocating a body}{deallocate!body}\index{deallocation}
is considered to be a relocation of the body.  The body pointer in the
stub is pointed at a `deallocated body' located in
inaccessible virtual memory, and the type code in the stub
is set to \TT{min::DEALLOCATED} (\pagref{MIN::DEALLOCATED}).

The function that deallocates a body is:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{deallocate\REL} \verb|( const min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\end{tabular}\end{indpar}%
\index{deallocate!relocating}

If the stub has a body, this function relocates the body to inaccessible
memory and changes the type code of the stub to
\TT{min::DEALLOCATED}.  Otherwise the function does nothing; and
in particular, it does nothing to stubs with no body, and to stubs
that have already been deallocated.

The function that tests whether a stub
has \TT{min::DEALLOCATED} type code (\pagref{MIN::DEALLOCATED}) is:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_deallocated} \verb|( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED}
\end{tabular}\end{indpar}

The inaccessible memory to which a \TT{min::DEALLOCATED} stub is
pointed is called the `\key{deallocated body}' of the stub.
This is large enough that any attempt to access the body of a
deallocated stub will cause a memory fault.

\subsection{Implementing New Stub Types}
\label{IMPLEMENTING-NEW-STUB-TYPES}

If you are implementing a new type of stub, and maybe bodies
associated with that stub type, or a new class of pointers to stubs,
then you will probably need to use the unprotected
interfaces described in this section.

As described in the first subsection, you need to be able update stubs
using the \TT{MUP::\EOL acc\_\EOL write\_\EOL update} functions
when locatable values are written into stubs or associated bodies.
You need to be able to allocate and free stubs, as described in the
second subsection.  You need to be able to read and write stub values,
as described in the third subsection.  If you are using acc stubs you
need to be able to write the type field in stub controls, and if
you are using auxiliary stubs, you need to be able to read, write,
and manipulate entire stub controls.
This is described in the fourth subsection.

\subsubsection{ACC Write Update Functions}
\label{ACC-WRITE-UPDATE-FUNCTIONS}

In addition to needing to locate \TT{min::gen}
and \TT{min::\EOL stub~*} values, the acc
must be notified whenever a pointer to a collectible stub \TT{s2}
is stored in the data of a collectible stub \TT{s1} (i.e., in
the stub \TT{s1} or its body or auxiliary stubs attached to either).
This is done by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * s2 )|
\LABEL{MUP::ACC_WRITE_STUB_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_GEN_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_UPDATE} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * const * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_STUB_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_GEN_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_VEC_UPDATE} \\
\end{tabular}\end{indpar}

The first of the above functions updates the stubs \TT{s1} and \TT{s2}
if \TT{s2} is not \TT{NULL}.  The second updates the stub \TT{s1}
and the stub pointed at by \TT{g} if \TT{g} points at a stub.
The third of the above functions equals the second function for a compact
(\pagref{COMPACT}) implementation, and is a no-operation for a loose
implementation.

The last three of the above functions look at all the
values \TT{p[0]}, \ldots, \TT{p[n-1]}, and for each of these
call the corresponding function chosen from the first three
of the above functions.

The \TT{min::\EOL acc\_\EOL write\_\EOL num\_\EOL update}
functions should only be used if all the
\TT{min::gen} values they reference are numeric, as in a loose
implementation these functions do nothing.

These \TT{min::acc\_write\_update} functions
\underline{must not} be called with any argument that points at a stub
with \TT{min::ACC\_\EOL FREE} type, which can only happen when the
stub has been recently returned by
\TT{min::\EOL new\_\EOL acc\_\EOL stub}.
See \itemref{STUB-ALLOCATION-FUNCTIONS}.


\subsubsection{Stub Allocation Functions}
\label{STUB-ALLOCATION-FUNCTIONS}

The following functions are used to allocate stubs:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub} \verb|( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub} \verb|( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\end{tabular}\end{indpar}

The \TT{min::new\_acc\_stub} function returns a garbage collectible (acc)
stub with its type set to \minkey{ACC\_FREE}.  A stub with this type
\underline{must not} be visible to the garbage collector; no pointer
to it can be stored in an acc locatable variable.
The \TT{MUP::acc\_\EOL write\_\EOL update}
function \underline{must not} be called with any
\TT{min::gen} or \TT{min::\EOL stub~*} argument that points at
a stub with \TT{min::ACC\_\EOL FREE} type.  All
\TT{min::gen} or \TT{min::\EOL stub~*} values stored in
the data of a \TT{min::ACC\_\EOL FREE} stub must also be stored
in acc locatable variable, or must themselves point at 
\TT{min::ACC\_\EOL FREE} stubs.

The actions of changing the type of a stub
from \TT{min::ACC\_\EOL FREE}
to another collectible type and storing a
\TT{min::gen} or \TT{min::\EOL stub~*}
value pointing at the stub in an acc
locatable variable must not be separated by any
call to a relocating function.

It is permissible to allocate and build a graph of stubs some of
which have \TT{min::\EOL ACC\_\EOL FREE} type.  No stub locatable
by the garbage collector may contain (in its stub or body or
auxiliary stubs) a pointer to a stub with
\TT{min::\EOL ACC\_\EOL FREE} type.  Any stub with
\TT{min::\EOL ACC\_\EOL FREE} type can contain only pointers
to stubs of this type or stubs that are locatable by the garbage
collector.  After building the graph, the types of all stubs with
\TT{min::\EOL ACC\_\EOL FREE} type should be changed to
normal acc types, and pointers that permit the garbage collector
to locate these stubs should be stored in locatable variables,
all without making any calls to relocating functions.

The \TT{min::new\_aux\_stub} function returns a non-acc (i.e.,
not garbage collectible)
stub with its type set to \minkey{AUX\_FREE}.  This kind of stub is
is \underline{not} freed by the garbage collector.  It may be
freed only by calling:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::| & \MUPKEY{free\_aux\_stub} \verb|( min::stub * s )|
\LABEL{MUP::FREE_AUX_STUB} \\
\end{tabular}\end{indpar}

A non-acc stub is most often attached to an acc stub in such a way
that when the acc stub is garbage collected, the non-acc stub is
freed.  Such a non-acc stub is called an \key{auxiliary stub}, and
because most non-acc stubs are of this kind, functions dealing with
non-acc stubs have names containing `\ttkey{aux}' instead of
`\TT{non\_acc}'.

\subsubsection{Stub Value Read/Write Functions}
\label{STUB-VALUE-READ-WRITE-FUNCTIONS}

The following unprotected functions read or write the stub value part of a stub:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of} \verb|( const min::stub * s )|
\LABEL{MUP::VALUE_OF_STUB} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of} \verb|( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{ptr\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PTR_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_value\_of} \verb|( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of} \verb|( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of} \verb|( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_ptr\_of} \verb|( min::stub * s, void * p )|
\LABEL{MUP::SET_PTR_OF} \\
\end{tabular}\end{indpar}

Thus the stub value can be taken to be of type \TT{min::uns64},
\TT{min::float64}, \TT{min::gen}, or
of some pointer type.

These functions do \underline{not} check type codes,
call \TT{MUP::acc\_write\_update},
or check
that values read or written are within legal range for a particular
stub.  For example, a stub value that is not a floating point number can be
read by \TT{MUP::float\_of} with undefined results.

\subsubsection{Stub Control Functions}
\label{STUB-CONTROL-FUNCTIONS}

If you are using auxiliary stubs, you need to be able to read, write,
and manipulate the stub control part of the stub.  If you are using
acc stubs, you only need to read or write the type part of the control.

The following
read or write the stub control:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of} \verb|( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|int min::| & \MINKEY{type\_of} \verb|( const min::stub * s )| \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}\ARGBREAK
      \verb|( const min::stub * s,|\ARGBREAK
      \verb|  min::uns64 flags )|
\LABEL{MUP::TEST_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_control\_of} \verb|( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of} \verb|( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of} \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of} \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{tabular}\end{indpar}

The \TT{MUP::control\_of} and \TT{MUP::set\_control\_of} functions
deal with the entire 64 bit stub control value of a stub.  The other
functions deal only with parts.

For acc stubs, only the type part of the control should be read or
written.  The other parts of the control are for use by the
acc, and should not be accessed by non-acc code,
in order to ensure that the acc is independent of other code.

The stub control in a stub is an example of a MIN \key{control value}.
A MIN control value holds a stub address or an unsigned integer
in its low order bits.  It may hold an 8 bit type code in its highest order
bits.  Any bits left over are flag bits, or if there is no 8 bit type
code, the high order 16 bits may be a signed integer field called the
`\mkey{locator}{field of control value}'
which is used only by some acc code.  Control values have type
\TT{min::uns64}.  Control values are used as stub controls, and
may be use in other places, e.g., by the acc to hold pointers from
a block that holds a body back to the stub pointing at the body.

Thus control values contain an address/value low order field, and optional
type code high order field, and flag bits.  There are two kinds of
control values: (ordinary) control values and acc control values:

\begin{indpar}
Ordinary control value with type: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-56 & int8 type \\
55-48 & 8 flag bits \\
47-0 & unsigned integer value or absolute stub address
\end{tabular}

Ordinary control value with locator: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-48 & int16 locator \\
47-0 & unsigned integer value or absolute stub address
\end{tabular}

Acc control value: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-56 & int8 type \\
55-(56-$G$) & $G$ flag bits \\
(55-$G$)-0 & absolute or packed stub address
\end{tabular}

where $8\leq G\leq 24$.
\end{indpar}

The larger G, the more acc flags, which may permit the
garbage collector to be more efficient (e.g., to have more ephemeral
levels).

The packed stub address is an absolute stub address,
relative stub address, or stub index.  The possible packing schemes used for
these are the same as the packing schemes used for general values:
see \pagref{STUB-ADDRESS-PACKING}.  However, the actual packing scheme
used for acc control values may differ from the actual packing scheme
used for general values, because the number of bits available for the
packed stub address may differ in the two cases.

Addresses stored in a control value must be stub addresses, as only they
can be packed into less than 64 bits.

The control values used as stub controls do have a type code field which
can be read by \TT{min::type\_of} (which is protected) and
written by \TT{MUP::set\_type\_of}.  For stub controls,
acc control values are used with
collectible types, and ordinary control values with
uncollectable types.

The flag bits are set, cleared, and tested individually.  They are
defined by constants of type \TT{min::uns64}, such as

\begin{indpar}
\begin{list}{}{}
\item[\TT{const min::uns64 MUP::}\MUPKEY{STUB\_ADDRESS}]~%
	\LABEL{MIN::STUB_ADDRESS}\\
Indicates that the address/value field of an ordinary (non-acc)
control holds a stub address.  This flag is only used for
uncollectable stubs whose control address/value field might
be either a stub address or an unsigned integer.
\end{list}
\end{indpar}

These flag constants are defined by expressions of the form

\begin{center}
\verb|( min::uns64(1) << |$K$\verb| )|
\end{center}

The above functions assume that any flag constants select bits
in a control value that are not inside the address/value field
or inside the type code field.

Ordinary (non-acc) control values that have a locator
field cannot have any flag bits.

The flags in the stub control value of a stub can be tested, set, or
cleared by some of the above functions.
The \TT{MUP::test\_flags\_of} function
returns true if and only if the logical AND of the \TT{flags} arguments
and the flags in the stub's control is non-zero.  The \TT{MUP::set\_flags\_of}
function sets one or more individual flags by logically ORing its
argument into the stub's control, and the
\TT{MUP::clear\_flags\_of} function clears flags by logically ANDing
the complement of its argument into the stub's control.

The above functions do \underline{not} check type codes, nor do they check
that values read or written are within legal range for a particular
stub.  Thus a stub control value
can be written by \TT{MUP::set\_control\_of} even if the written
control datum is incompatible with the garbage collector implementation,
and may produce undefined results when the garbage collector
next executes.

The high order byte of any control written by \TT{MUP::set\_control\_of}
is the type code, and the high order bit is clear if the stub is collectible
and set if the stub is uncollectable (\itemref{STUB-CONTROL}).
Changing a stub from collectible to uncollectable or vice versa requires
removing or adding the stub to garbage collector lists that are threaded
through the pointer field of the stub control.  So one cannot simply
change the type code field of a stub from collectible to uncollectable
or vice versa.

Ordinary (non-acc) control values can be manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator} \verb|( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value} \verb|( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|int MUP::| & \MUPKEY{locator\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{tabular}\end{indpar}

The `\TT{new}' functions compute a control value,
the `\TT{renew}' functions modify control values
by inserting a new locator, value, or stub address, and
the other functions return the parts of a control value.
Here the 16-bit locator is represented as an \TT{int}
in the range from $-2^{15}$ through $2^{15}-1$.

None of these functions check the ranges of their arguments.

Acc control values can be manipulated by the following similar functions
(this is only done by acc code):

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
\end{tabular}\end{indpar}

Either ordinary or acc control values can be
manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type} \verb|( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{tabular}\end{indpar}

Here the 8-bit type code is represented as an \TT{int} in
the range from $-128$ through $127$.

\subsubsection{Unprotected Body Functions}
\label{UNPROTECTED-BODY-FUNCTIONS}

If you are implementing a new kind of stub, and your stubs have bodies,
you need to be able to allocate, relocate, and deallocate the bodies.
The following functions allocate and deallocate bodies:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void MUP::|
    & \MUPKEY{new\_body} \verb|( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body} \verb|( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{tabular}\end{indpar}

Here \TT{n} is the size in bytes of the body to be allocated or deallocated.
The allocator is not required to remember the size of a body,
so when deallocating the body the caller must provide the same size
as was used to allocate the body.  The allocator will likely
run a check that will likely catch a wrong size, but it may not
be able to determine the right size.

Bodies are always aligned on 8 byte boundaries, but the size \TT{n}
need \underline{not} be a multiple of 8.

When a body is deallocated, the stub type is set to
\TT{min::DEALLOCATED} and the stub pointer is set to
point at a block of inaccessible memory.
As a special case, if the body size \TT{n} is zero,
\TT{MUP::\EOL deallocate\_\EOL body} does nothing
(see \TT{MIN::\EOL body\_\EOL size\_\EOL of} below).


The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of} \verb|( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\end{tabular}\end{indpar}

returns the size of the body, that is, the same size
as that passed to \TT{MUP::new\_\EOL body} when the
body was allocated.  This is necessary as the acc does
\underline{not} keep track of body sizes, and depends upon
this \TT{MUP::body\_\EOL size\_\EOL of} function to
find body sizes.  If the stub is deallocated (of type
\TT{min::DEALLOCATED}) or if the stub has no body,
\TT{0} is returned.  This enables the code
\begin{center}
\TT{MUP::deallocate\_body ( s, MUP::body\_size\_of ( s ) )}
\end{center}

The \TT{min::body\_size\_of} function uses the type of the
stub to select a type-appropriate algorithm to compute
the body size.  The code of this function must be modified
if a new stub type is added.

The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void * & MUP::| & \MUPKEY{ptr\_ref\_of}
	                \verb|( min::stub * s )| 
\LABEL{MUP::PTR_REF_OF_STUB} \\
\end{tabular}\end{indpar}

returns a pointer to a pointer to the body.
The first pointer points to a location P with a fixed address
(P is the stub value); P holds
a pointer to the body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS}).
Whenever the body is relocated the value of P is changed to
point to the new body location.

In order to change the size of a body, the following
can be used:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\ARGBREAK
    \verb|( min::stub * s,|\ARGBREAK
    \verb|  min::unsptr new_size, min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_ptr\_ref}
	     \verb|( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_PTR_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}
	     \verb|( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\verb|void MUP::| & \MUPKEY{retype\_resize\_body}\ARGBREAK
	     \verb|( MUP::resize_body & rb, int new_type )| 
\LABEL{MUP::RETYPE_RESIZE_BODY} \\
\end{tabular}\end{indpar}

When constructed the \TT{MUP::resize\_body} datum allocates
a new body for a stub \TT{s}, and when deconstructed the datum
installs the new body in the stub \TT{s} while deallocating the
old body of \TT{s}.  Stub \TT{s}
is not altered until the \TT{MUP::\EOL resize\_\EOL body}
datum is deconstructed, and the \TT{MUP::\EOL abort\_\EOL resize\_\EOL body}
function can be used to abort the body resizing
and prevent stub \TT{s} from ever being altered.
The sizes of the old and new body of \TT{s} must be passed to
the \TT{MUP::\EOL resize\_\EOL body} constructor.

Given a \TT{MUP::\EOL resize\_\EOL body} datum \TT{rb},
\begin{center}
\verb|MUP::new_body_ptr_ref ( rb )|
\end{center}
returns a pointer to a pointer to the new body.  The first pointer
points to a location P with a fixed address that exists as long
as the \TT{MUP::\EOL resize\_\EOL body} datum \TT{rb} exists.   P holds
a pointer to the new body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS})
as all bodies
can be, and will be pointed to by a changed value of P if it is
relocated.

After the new body is obtained, information should be copied from
the old body to the new body before the \TT{MUP::\EOL resize\_\EOL body}
datum is deconstructed.  The new body will not be touched by
the garbage collector while the \TT{MUP::\EOL resize\_\EOL body} datum
exists, but it may be relocated.  The existing stub \TT{s}
\underline{must} be protected from garbage collection and
its body protected from reorganization by the user while the
\TT{MUP::\EOL resize\_\EOL body} datum exists, but that body may
also be relocated.  \TT{s} must NOT be deallocated
while the \TT{MUP::\EOL resize\_\EOL body} datum exists, unless
\TT{MUP::\EOL abort\_\EOL resize\_\EOL body} has been called.

While the \TT{MUP::\EOL resize\_\EOL body} datum exists,
the garbage collector will process the stub and old body normally.
Any locatable values stored in the new body must also be stored
in a separate garbage collector locatable place, as the garbage collector
ignores the new body.

Normally the type of stub \TT{s} is not changed, but
if the \TT{MUP::\EOL retype\_\EOL resize\_\EOL body} function is called
with a new stub type, that type will be installed in stub \TT{s}
if and when the new body is installed in stub \TT{s}.

\subsubsection{Unprotected Body Pointers}
\label{UNPROTECTED-BODY-POINTERS}

\ikey{Unprotected body pointers}{unprotected body pointer}%
\index{pointer!unprotected body}\index{body pointer!unprotected}
are C/C++ pointers that point directly into a body.
Functions that obtain body unprotected
pointers from stubs are unprotected (\TT{MUP}) functions because
the unprotected body pointers they return are invalidated
if the body pointed at
is relocated.

In order to track possible relocation,
names of functions that might relocate bodies are marked
with the superscript {\REL} in this document.
Relocation can only happen inside such \skey{relocating function}s
(\pagref{RELOCATING-FUNCTIONS}).

The following uses unprotected body pointers to point at a character
string stored in a body:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some long string
assert ( min::is_stub ( x ) );
const min::stub * xstub = min::stub_of ( x );
assert ( min::type_of ( xstub ) == min::LONG_STR );
MUP::long_str * xstr = MUP::long_str_of ( xstub );
const char * xp = MUP::str_of ( xstr );
int length = MUP::length_of ( xstr );
for ( int i = 0; i < length; ++ i )
{
    // Relocating functions must NOT be called in this loop.
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Strings are in fact of three types, `direct' which stores characters
in the general value, `short' which stores up to 8 characters in the stub
value, and `long' which stores more than 8 characters in the body.  The
above code only works for long strings (\pagref{LONG-STRING-STUB}).


\subsection{UNICODE Characters}
\label{UNICODE-CHARACTERS}

Unicode characters are implemented by the following:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef min::uns32 min::| & \MINKEY{Uchar}
\LABEL{MIN::UCHAR} \\
\verb|const min::Uchar min::|
    & \MINKEY{UNKNOWN\_UCHAR}
\LABEL{MIN::UNKNOWN_UCHAR} \\
\verb|const min::Uchar min::|
    & \MINKEY{SOFTWARE\_NL}
\LABEL{MIN::SOFTWARE_NL} \\
\verb|min::Uchar min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( const char * & s, const char * ends )|
\LABEL{MIN::UTF8_TO_UNICODE} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb|( char * & s, min::Uchar c )|
\LABEL{MIN::UNICODE_TO_UTF8} \\
\end{tabular}\end{indpar}

Here UNICODE characters are represented as \TT{min::Uchar} values
that are 32-bit unsigned integers.  `\TT{char *}' strings are treated
as `Modified UTF-8' encodings of UNICODE character strings.
In these the NUL (zero) UNICODE \TT{min::Uchar} value is encoded as
the 2 string bytes \TT{"\textbackslash xC0\textbackslash x80"},
while the zero `\TT{char}' is used to terminate the `\TT{char *}' string.
The term `\key{Modified UTF-8}'\label{MODIFIED-UTF8} applies
to a UTF-8 encoding in which the \underline{only} permitted
overlong encoding is this 2-byte encoding of NUL.

The \TT{UNKNOWN\_UCHAR}\label{UNKNOWN_UCHAR} UNICODE character
is returned by the \TT{min::\EOL utf8\_\EOL to\_\EOL unicode}
function when it finds an illegal UTF8 encoding.  This is actually
the `\key{unicode replacement character},
FFFD (hexadecimal), which is designated by the UNICODE standard
as representing an input
that is not encodable in UNICODE.

The \TT{SOFTWARE\_NL}\label{SOFTWARE_NL} UNICODE character is used
to represent the end of line in a \TT{min::\EOL file},
which is internally represented by a line-ending NUL character,
when the end of line is displayed on a printer.
See \pagref{DISPLAY_EOL}.
This is actually an arbitrary UNICODE private use character, and is not
actually input or output itself.

The \TT{min::uft8\_to\_unicode} function reads a UNICODE character
encoded as a UTF-8 byte string.  Here \TT{s} points at the first byte
of the encoding and is updated to point after the encoding, while
\TT{ends} points just after the last byte that can be part of
the encoding.

The \TT{min::uft8\_to\_unicode} function will accept
\mkey{overlong}{UTF-8 encoding} UTF-8 encodings as legal,
and also accept 7-byte encodings (first byte \TT{0xFE})
so that $2^{32}-1$ can be encoded.  If it encounters an
illegal encoding it returns \TT{min::\EOL UNKNOWN\_\EOL UCHAR}
and updates \TT{s} to point just after the illegal encoding.
Applying the \TT{min::uft8\_to\_unicode} function repeatedly
until \TT{s >= ends} will produce a sequence of UNICODE
characters from any byte string, even one that is not legal UTF-8,
though if the string is not legal some \TT{min::\EOL UNKNOWN\_\EOL UCHAR}
characters will be returned.

More specifically, an illegal encoding is a string of bytes such that
the last byte cannot be UTF-8 legal given the previous bytes, or
is an incomplete UTF-8 encoding at the end of the byte string.

The \TT{min::\EOL unicode\_\EOL to\_\EOL utf8} function writes
a UTF-8 character \TT{c} into \TT{s}, updating \TT{s} to point after the
character, and returns the number of bytes written.
This function will output
7-byte encodings (first byte \TT{0xFE}) for
UNICODE character values \TT{=> 0x80000000}, and will output
the overlong encoding \TT{"\textbackslash xC0\textbackslash x80"}
for \ttmkey{NUL}{UTF-8 encoding}.
UTF-8 in which this is the \underline{only} permitted overlong encoding
is called `Modified UTF-8' (\pagref{MODIFIED-UTF8}).
No other overlong encodings are output.
At most 7 bytes will be output, and
\TT{s} \underline{must}
point to a byte string buffer with \underline{at least} 7 bytes.

Strings of UNICODE characters can be converted to/from strings
of UTF-8 encoded characters by the functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( min::Uchar * & u, const min::Uchar * endu,|\ARGBREAK
      \verb|  const char * & s, const char * ends )|
\LABEL{MIN::UTF8_STR_TO_UNICODE_STR} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb| ( char * & s, const char * ends,|\ARGBREAK
      \verb|   const min::Uchar * & u,|\ARGBREAK
      \verb|   const min::Uchar * endu )|
\LABEL{MIN::UNICODE_STR_TO_UTF8_STR} \\
\end{tabular}\end{indpar}

The first of these repeatedly executes
\begin{center}
\tt * u ++ = min::utf8\_to\_unicode ( s, ends );
\end{center}
while \TT{u < endu} and \TT{s < ends}.
The second repeatedly executes
\begin{center}
\tt min::unicode\_to\_utf8 ( s, * u ++ );
\end{center}
while \TT{s < ends} and \TT{u < endu} provided the
next repetion will \underline{not} end with \TT{s > ends}
(so the \TT{s} string end will not be overrun).
Both these functions increment both \TT{s} and \TT{u} and return
the number of string elements, \TT{min::Uchar}'s or \TT{char}'s respectively,
written.

\subsubsection{Unicode Data Base}
\label{UNICODE-DATA-BASE}

Various attributes of UNICODE characters are stored in the
\key{UNICODE Data Base}.

To keep this data base compact, UNICODE characters are grouped
so all characters with the same attributes are assigned the
same group.  This is implemented by mapping each character to
a \key{UNICODE character index}\index{character index!UNICODE},
and then mapping the character index to various
attributes.  To enable a program to load only parts of the
database, each attribute is in a separately loadable vector.

The first part of this mapping is implemented by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns16 min::|
    & \MINKEY{Uindex} \verb|( min::Uchar c )|
\LABEL{MIN::UINDEX} \\
\end{tabular}\end{indpar}

which maps the UNICODE character \TT{c} to its UNICODE
character index \TT{Uindex~(~c~)}.

Given the index \TT{i = min::Uindex ( c )} of \TT{c}, you can
find out the name, picture, and flags of \TT{c} by using:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::ustring * min::|
    & \MINKEY{unicode::name}\verb|[i]|
\LABEL{MIN::UNICODE::NAME} \\
\verb|const min::ustring * min::|
    & \MINKEY{unicode::picture}\verb|[i]|
\LABEL{MIN::UNICODE::PICTURE} \\
\verb|const min::uns32 printer->|
    & \MINKEY{print\_format.char\_flags}\verb|[i]|
\LABEL{MIN::PRINT_FORMAT.CHAR_FLAGS} \\
\verb|const min::uns32 * min::|
    & \MINKEY{standard\_char\_flags}
\LABEL{MIN::STANDARD_CHAR_FLAGS} \\
\end{tabular}\end{indpar}

where usually

\begin{center}
\tt printer->print\_format.char\_flags == min::standard\_char\_flags
\end{center}

Here `\TT{const min::ustring *}' values encode UNICODE character
strings in a format optimized for printing, or are \TT{NULL} to
indicate a missing value.  The \mkey{name}{of UNICODE character}
is non-missing only for common control characters; examples
are the name
\TT{CR} for the ASCII carriage return character with code \TT{0D},
\TT{SP} for the ASCII single space character with code \TT{20} (hex),
and \TT{NBSP} for the LATIN1 non-breaking single space character
with code \TT{A0}.
For ASCII graphic characters (which produce marks on paper) the
name is \TT{NULL}.

The \mkey{picture}{of UNICODE character} is non-missing for
ASCII control characters, and for these is the UNICODE control picture
character corresponding to the ASCII control character name.
For example, the carriage return picture is
{\tiny $\stackrel{\textstyle C~}{\textstyle ~R}$},
which is the single UNICODE character with code \TT{240D}.
As a special case, single space has the picture \TT{\textvisiblespace}.

Also as special cases the \minmkey{UNKOWN\_UCHAR}{name} character 
has name \TT{UUC} but no picture, and the
\minmkey{SOFTWARE\_NL}{name and picture} character has name
\TT{NL} and picture {\tiny $\stackrel{\textstyle N~}{\textstyle ~L}$}.

The most important attributes of a character are its
\smkey{flag}s{of UNICODE character}\index{character flag}.
These are obtained from
the \TT{char\_\EOL flags} member of the \TT{print\_\EOL format} member of
the \TT{printer} being used to print the character, and this
in turn is usually set to the \TT{min::\EOL standard\_\EOL char\_\EOL flags}
vector.  Unlike other character attributes, the flags can be computed
by user code in a very flexible manner, so the standard character
flags which we describe here are only a special case of what is
possible.

The standard character flags are

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_NON\_SPACING}
\LABEL{MIN::IS_NON_SPACING} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_LEADING}
\LABEL{MIN::IS_LEADING} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_MIDDLING}
\LABEL{MIN::IS_MIDDLING} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_TRAILING}
\LABEL{MIN::IS_TRAILING} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_SP}
\LABEL{MIN::IS_SP} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_HT}
\LABEL{MIN::IS_HT} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_OTHER\_HSPACE}
\LABEL{MIN::IS_OTHER_HSPACE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_VSPACE}
\LABEL{MIN::IS_VSPACE} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_OTHER\_CONTROL}
\LABEL{MIN::IS_OTHER_CONTROL} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_UNSUPPORTED}
\LABEL{MIN::IS_UNSUPPORTED} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{CONDITIONAL\_BREAK}
\LABEL{MIN::CONDITIONAL_BREAK} \\
\verb|const min::uns32 min::| & \MINKEY{QUOTE\_SUPPRESS}
\LABEL{MIN::QUOTE_SUPPRESS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_ASCII}
\LABEL{MIN::IS_ASCII} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_LATIN1}
\LABEL{MIN::IS_LATIN1} \\
\end{tabular}\end{indpar}

Of these flags, only the first four:

\begin{center}
\begin{tabular}{l}
\TT{min::IS\_NON\_SPACING} \\
\TT{min::IS\_LEADING} \\
\TT{min::IS\_MIDDLING} \\
\TT{min::IS\_TRAILING} \\
\end{tabular}
\end{center}

are built into MIN printer code and need to be in user
defined character flags as well as standard character flags.
\minkey{IS\_NON\_SPACING} signifies that a character takes zero
columns, instead of 1 column.  \TT{min::IS\_LEADING/MIDDLING/TRAILING}
are used by the single space suppression feature of MIN printers;
see below.

For \TT{min::standard\_char\_flags}, the non-spacing mark characters
and all control characters except single space and horizontal tab
are given the \minkey{IS\_NON\_SPACING} flag.  Note that the
horizontal tabs are handled specially by the printer as far
as the number of columns they take, and this special handling
ignores the character flags of the horizontal tab character.

For \TT{min::standard\_char\_flags}, each character gets exactly
one of the following flags:

\begin{center}
\begin{tabular}{l}
\TT{min::IS\_LEADING} \\
\TT{min::IS\_MIDDLING} \\
\TT{min::IS\_TRAILING} \\
\\
\TT{min::IS\_SP} \\
\TT{min::IS\_HT} \\
\TT{min::IS\_OTHER\_HSPACE} \\
\\
\TT{min::IS\_VSPACE} \\
\TT{min::IS\_OTHER\_CONTROL} \\
\\
\TT{min::IS\_UNSUPPORTED} \\
\end{tabular}
\end{center}

Graphic characters
\label{LEADING/MIDDLING/TRAILING-CHAR-FLAGS}
which make a mark on the paper get one of the
\TT{min::IS\_LEADING/\EOL MIDDLING/\EOL TRAILING}%
\minindex{IS\_LEADING}%
\minindex{IS\_MIDDLING}%
\minindex{IS\_TRAILING}
flags.  The rough concept is
that a string of characters with no spaces may be separated into
lexemes by stripping leading separators from its beginning and
trailing separators from its end, so `\TT{[5;}' becomes the
leading separator lexeme \TT{[}, the middling lexeme \TT{5},
and the trailing separator lexeme \TT{;}, and therefore
\TT{[} is \TT{IS\_LEADING}, \TT{5} is \TT{IS\_MIDDLING}, and
\TT{;} is \TT{IS\_TRAILING}.  See 
\itemref{LEADING-AND-TRAILING-SEPARATORS} for details.

Horizontal space characters get one of the
\TT{min::IS\_SP/HT/OTHER\_HSPACE}%
\minindex{IS\_SP}%
\minindex{IS\_HT}%
\minindex{IS\_OTHER\_HSPACE}
flags.  \TT{IS\_SP} is just for the single space character,
\TT{IS\_HT} is just for the horizontal tab character,
and \TT{IS\_\EOL OTHER\_\EOL HSPACE} is for other horizontal
space characters such as the LATIN1 non-breaking-space character
\TT{NBSP}.  The printer does some special processing on single space
and horizontal tab characters \underline{independently} of the flags
of these characters.

Vertical space characters that standardly appear in printed output
get the \minkey{IS\_VSPACE} flag.  There are four such characters:
form feed \TT{FF}, vertical tab \TT{VT}, line feed \TT{LF},
and carriage return \TT{CR}.  The last is included because
it is associated with line feeds.

All other control characters get the \minkey{IS\_\EOL OTHER\_\EOL CONTROL}
flag.  These are often suppressed in printed output.

All characters not given one of the above flags get the
\minkey{IS\_\EOL UNSUPPORTED} flag.  This means the character
is not supported by keyboard input and/or hardware printers,
and ideally, the character should not be used.

The next two flags are used in conjuction with printer format
masks to perform special printer functions.
The \minkey{CONDITIONAL\_\EOL BREAK} flag marks graphic characters that
can be followed by a line break, such as \TT{-} and \TT{\_}.
See \pagref{CONDITIONAL-BREAK}.
The \minkey{QUOTE\_\EOL SUPPRESS} flag marks characters that
suppress quoting strings if they are the first character of
the string; currently letters are given this flag.
See \pagref{QUOTE-SUPPRESS}.

The last two flags are used in conjunction with printer format
masks to dynamically control which characters are supported.
The \minkey{IS\_\EOL ASCII} flag is on for ASCII characters with
codes from \TT{00} through \TT{7F}.
The \minkey{IS\_\EOL LATIN1} flag is on for LATIN1 non-ASCII characters with
codes from \TT{80} through \TT{FF}.  See \pagref{SUPPORT-CONTROL}.

The question of which characters can be supported is determined
by the file
\begin{center}
\ldots\TT{/min/\EOL unicode/\EOL CompositeCharacters.txt}%
\ttindex{CompositeCharacters.txt}
\end{center}
which lists the multi-key sequences that can be used to input
non-ASCII supportable characters, and also by the file
\begin{center}
\ldots\TT{/min/\EOL unicode/\EOL SupportSets.txt}%
\ttindex{SupportSets.txt}
\end{center}
which defines which sets of characters
are marked with which support set character flags, such as
\TT{min::\EOL IS\_\EOL ASCII/\EOL LATIN1}.

The characters with the \TT{min::IS\_LATIN1} flag 
in \TT{min::standard\_char\_flags}
are listed,
along with the multi-key sequences commonly used to input them,
in Figures~\ref{LATIN1-CHARACTERS-I},
\ref{LATIN1-CHARACTERS-II},
and \ref{LATIN1-CHARACTERS-III}.

\TT{min::standard\_char\_flags} is computed using data taken from
\ldots\TT{/min/\EOL unicode/\EOL uni\-code\_\EOL data.h}%
\ttindex{unicode\_data.h} (which is included in the \ttkey{min::unicode}
namespace by the \ttkey{min\_unicode.h} file that is in turn
included in \TT{min.h}).  Other character flag vectors can be computed
using this data.  For \TT{c <= 0xFF}, \TT{min::Uindex(c) == c}, and
for \TT{c > 0xFF}, \TT{min::Uindex(c) > 0xFF}, so
each ASCII and LATIN1 character has its own private character flag
element in any character flag vector.

Only the low order 16 bits of a 32 bit character flags value are
used for some printer functions, like controlling how the character
displays or breaks are inserted, so flags relevant to these functions
need to be in the low order 16 bits.



\begin{boxedfigure}
\begin{tabular}{llll}
& Hex & Multi-Key \\
& Code & Sequence
\\[1ex]
\TT{~}
  & \TT{A0} & \TT{<space><space>} & No Break Space \\
\TT{\textexclamdown}
  & \TT{A1} & \TT{!!} & Inverted Exclamation \\
\TT{\textcent}
  & \TT{A2} & \TT{c|} & Cent Sign \\
\TT{\textsterling}
  & \TT{A3} & \TT{L-} & Pound Sign \\
\TT{\textcurrency}
  & \TT{A4} & \TT{ox} & Currency Sign \\
\TT{\textyen}
  & \TT{A5} & \TT{Y=} & Yen Sign \\
\TT{\textbrokenbar}
  & \TT{A6} & \TT{!\textasciicircum} & Broken Bar \\
\TT{\textsection}
  & \TT{A7} & \TT{S!} & Section Sign \\
\TT{\"{~}}
  & \TT{A8} & \TT{""} & Diaeresis \\
\TT{\textcopyright}
  & \TT{A9} & \TT{oc} & Copyright Sign \\
\TT{\textordfeminine}
  & \TT{AA} & \TT{\textasciicircum\_a} & Feminine Ordinal Indicator \\
\TT{\guillemotleft}
  & \TT{AB} & \TT{<<} & Left-Pointing Double Angle Quotation Mark \\
\TT{\textlnot}
  & \TT{AC} & \TT{-,} & Not Sign \\
\TT{~}
  & \TT{AD} & \TT{--<space>} & Soft Hypen \\
\TT{\textregistered}
  & \TT{AE} & \TT{or} & Registered Sign \\
\TT{\={~}}
  & \TT{AF} & \TT{\textasciicircum-} & Macron \\
\TT{\textdegree}
  & \TT{B0} & \TT{oo} & Degree Sign \\
\TT{\textpm}
  & \TT{B1} & \TT{+-} & Plus-Minus Sign \\
\TT{\textsuperscript{2}}
  & \TT{B2} & \TT{\textasciicircum2} & Superscript 2 \\
\TT{\textsuperscript{3}}
  & \TT{B3} & \TT{\textasciicircum3} & Superscript 3 \\
\TT{\'{~}}
  & \TT{B4} & \TT{''} & Acute Accent \\
\TT{\textmu}
  & \TT{B5} & \TT{mu} & Micro Sign \\
\TT{\textpilcrow}
  & \TT{B6} & \TT{p!} & Pilcrow Sign \\
\TT{\textperiodcentered}
  & \TT{B7} & \TT{\textasciicircum.} & Middle Dot \\
\TT{\c{~}}
  & \TT{B8} & \TT{,,} & Cedilla \\
\TT{\textsuperscript{1}}
  & \TT{B9} & \TT{\textasciicircum1} & Superscript 1 \\
\TT{\textordmasculine}
  & \TT{BA} & \TT{\textasciicircum\_o} & Masculine Ordinal Indicator \\
\TT{\guillemotright}
  & \TT{BB} & \TT{>>} & Right-Pointing Double Angle Quotation Mark \\
\TT{\textonequarter}
  & \TT{BC} & \TT{14} & Vulgar Fraction One Quarter \\
\TT{\textonehalf}
  & \TT{BD} & \TT{12} & Vulgar Fraction One Half \\
\TT{\textthreequarters}
  & \TT{BE} & \TT{34} & Vulgar Fraction Three Quarters \\
\TT{\textquestiondown}
  & \TT{BF} & \TT{??} & Invered Question Mark \\
\end{tabular}
\caption{LATIN1 Characters: Part I}
\label{LATIN1-CHARACTERS-I}
\end{boxedfigure}

\begin{boxedfigure}
\begin{tabular}{llll}
& Hex & Multi-Key \\
& Code & Sequence
\\[1ex]
\TT{\`A}
  & \TT{C0} & \TT{A\`~} & Latin Capital Letter A With Grave \\
\TT{\'A}
  & \TT{C1} & \TT{A'} & Latin Capital Letter A With Acute \\
\TT{\^A}
  & \TT{C2} & \TT{A\textasciicircum} & Latin Capital Letter A With Circumflex \\
\TT{\~A}
  & \TT{C3} & \TT{A\textasciitilde} & Latin Capital Letter A With Tilde \\
\TT{\"A}
  & \TT{C4} & \TT{A"} & Latin Capital Letter A With Diaeresis \\
\TT{\AA}
  & \TT{C5} & \TT{AA} & Latin Capital Letter A With Ring Above \\
\TT{\AE}
  & \TT{C6} & \TT{AE} & Latin Capital Letter AE \\
\TT{\c{C}}
  & \TT{C7} & \TT{C,} & Latin Capital Letter C With Cedilla \\
\TT{\`E}
  & \TT{C8} & \TT{E\`~} & Latin Capital Letter E With Grave \\
\TT{\'E}
  & \TT{C9} & \TT{E'} & Latin Capital Letter E With Acute \\
\TT{\^E}
  & \TT{CA} & \TT{E\textasciicircum} & Latin Capital Letter E With Circumflex \\
\TT{\"E}
  & \TT{CB} & \TT{E"} & Latin Capital Letter E With Diaeresis \\
\TT{\`I}
  & \TT{CC} & \TT{I\`~} & Latin Capital Letter I With Grave \\
\TT{\'I}
  & \TT{CD} & \TT{I'} & Latin Capital Letter I With Acute \\
\TT{\^I}
  & \TT{CE} & \TT{I\textasciicircum} & Latin Capital Letter I With Circumflex \\
\TT{\"I}
  & \TT{CF} & \TT{I"} & Latin Capital Letter I With Diaeresis \\
\TT{\DH}
  & \TT{D0} & \TT{DH} & Latin Capital Letter ETH \\
\TT{\~N}
  & \TT{D1} & \TT{N\textasciitilde} & Latin Capital Letter N With Tilde \\
\TT{\`O}
  & \TT{D2} & \TT{O\`~} & Latin Capital Letter O With Grave \\
\TT{\'O}
  & \TT{D3} & \TT{O'} & Latin Capital Letter O With Acute \\
\TT{\^O}
  & \TT{D4} & \TT{O\textasciicircum} & Latin Capital Letter O With Circumflex \\
\TT{\~O}
  & \TT{D5} & \TT{O\textasciitilde} & Latin Capital Letter O With Tilde \\
\TT{\"O}
  & \TT{D6} & \TT{O"} & Latin Capital Letter O With Diaeresis \\
\TT{\texttimes}
  & \TT{D7} & \TT{xx} & Multiplication Sign \\
\TT{\O}
  & \TT{D8} & \TT{O/} & Latin Capital Letter O With Stroke \\
\TT{\`U}
  & \TT{D9} & \TT{U\`~} & Latin Capital Letter U With Grave \\
\TT{\'U}
  & \TT{DA} & \TT{U'} & Latin Capital Letter U With Acute \\
\TT{\^U}
  & \TT{DB} & \TT{U\textasciicircum} & Latin Capital Letter U With Circumflex \\
\TT{\"U}
  & \TT{DC} & \TT{U"} & Latin Capital Letter U With Diaeresis \\
\TT{\'Y}
  & \TT{DD} & \TT{Y'} & Latin Capital Letter Y With Acute \\
\TT{\TH}
  & \TT{DE} & \TT{TH} & Latin Capital Letter Thorn \\
\TT{\ss}
  & \TT{DF} & \TT{ss} & Latin Small Letter Sharp S \\
\end{tabular}
\caption{LATIN1 Characters: Part II}
\label{LATIN1-CHARACTERS-II}
\end{boxedfigure}

\begin{boxedfigure}
\begin{tabular}{llll}
& Hex & Multi-Key \\
& Code & Sequence
\\[1ex]
\TT{\`a}
  & \TT{E0} & \TT{a\`~} & Latin Small Letter A With Grave \\
\TT{\'a}
  & \TT{E1} & \TT{a'} & Latin Small Letter A With Acute \\
\TT{\^a}
  & \TT{E2} & \TT{a\textasciicircum} & Latin Small Letter A With Circumflex \\
\TT{\~a}
  & \TT{E3} & \TT{a\textasciitilde} & Latin Small Letter A With Tilde \\
\TT{\"a}
  & \TT{E4} & \TT{a"} & Latin Small Letter A With Diaeresis \\
\TT{\aa}
  & \TT{E5} & \TT{aa} & Latin Small Letter A With Ring Above \\
\TT{\ae}
  & \TT{E6} & \TT{ae} & Latin Small Letter AE \\
\TT{\c{c}}
  & \TT{E7} & \TT{c,} & Latin Small Letter C With Cedilla \\
\TT{\`e}
  & \TT{E8} & \TT{e\`~} & Latin Small Letter E With Grave \\
\TT{\'e}
  & \TT{E9} & \TT{e'} & Latin Small Letter E With Acute \\
\TT{\^e}
  & \TT{EA} & \TT{e\textasciicircum} & Latin Small Letter E With Circumflex \\
\TT{\"e}
  & \TT{EB} & \TT{e"} & Latin Small Letter E With Diaeresis \\
\TT{\`{\i}}
  & \TT{EC} & \TT{i\`~} & Latin Small Letter I With Grave \\
\TT{\'{\i}}
  & \TT{ED} & \TT{i'} & Latin Small Letter I With Acute \\
\TT{\^{\i}}
  & \TT{EE} & \TT{i\textasciicircum} & Latin Small Letter I With Circumflex \\
\TT{\"{\i}}
  & \TT{EF} & \TT{i"} & Latin Small Letter I With Diaeresis \\
\TT{\dh}
  & \TT{F0} & \TT{dh} & Latin Small Letter ETH \\
\TT{\~n}
  & \TT{F1} & \TT{n\textasciitilde} & Latin Small Letter N With Tilde \\
\TT{\`o}
  & \TT{F2} & \TT{o\`~} & Latin Small Letter O With Grave \\
\TT{\'o}
  & \TT{F3} & \TT{o'} & Latin Small Letter O With Acute \\
\TT{\^o}
  & \TT{F4} & \TT{o\textasciicircum} & Latin Small Letter O With Circumflex \\
\TT{\~o}
  & \TT{F5} & \TT{o\textasciitilde} & Latin Small Letter O With Tilde \\
\TT{\"o}
  & \TT{F6} & \TT{o"} & Latin Small Letter O With Diaeresis \\
\TT{\textdiv}
  & \TT{F7} & \TT{-:} & Division Sign \\
\TT{\o}
  & \TT{F8} & \TT{o/} & Latin Small Letter O With Stroke \\
\TT{\`u}
  & \TT{F9} & \TT{u\`~} & Latin Small Letter U With Grave \\
\TT{\'u}
  & \TT{FA} & \TT{u'} & Latin Small Letter U With Acute \\
\TT{\^u}
  & \TT{FB} & \TT{u\textasciicircum} & Latin Small Letter U With Circumflex \\
\TT{\"u}
  & \TT{FC} & \TT{u"} & Latin Small Letter U With Diaeresis \\
\TT{\'y}
  & \TT{FD} & \TT{y'} & Latin Small Letter Y With Acute \\
\TT{\th}
  & \TT{FE} & \TT{th} & Latin Small Letter Thorn \\
\TT{\"y}
  & \TT{FF} & \TT{y"} & Latin Small Letter Y With Diaeresis \\
\end{tabular}
\caption{LATIN1 Characters: Part III}
\label{LATIN1-CHARACTERS-III}
\end{boxedfigure}

\newpage


\subsubsection{UNICODE Strings}
\label{UNICODE-STRINGS}


Constant \skey{UNICODE string}s can be represented
as \TT{const min::\EOL ustring *}\ttindex{ustring}\label{USTRING} values
which are sequences of 8 bit bytes.  The first two bytes,
called the \mkey{header}{of {\tt ustring}},
holds the length of the string (not counting the header) in the first
bytes, and the number of print columns the string will take,
plus some flags, in its second byte.  The remainder of the bytes
constitute a `\TT{const char *}' value that is the Modified UTF-8 encoded,
NUL-terminated, string itself.

Importantly \TT{const ustring *} values are pointers into
\underline{unrelocatable}
memory.  It is intended that \TT{ustrings} be used as parametric values in
printing formats, as character names and pictures, etc.

The following are for programming with \TT{ustring}'s:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef min::uns8 min::| & \MINKEY{ustring}
\LABEL{MIN::USTRING} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_length} \verb|( const min::ustring * p )|
\LABEL{MIN::UNICODE_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{unicode\_columns} \verb|( const min::ustring * p )|
\LABEL{MIN::UNICODE_COLUMNS} \\
\verb|min::uns32 min::|
    & \MINKEY{unicode\_flags} \verb|( const min::ustring * p )|
\LABEL{MIN::UNICODE_FLAGS} \\
\verb|const min::Uchar * min::|
    & \MINKEY{unicode\_string} \verb|( const min::ustring * p )|
\LABEL{MIN::UNICODE_STRING} \\
\end{tabular}\end{indpar}

where the possible \skey{ustring flag}s are:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{USTRING\_LEADING}
\LABEL{MIN::USTRING_LEADING} \\
\verb|const min::uns32 min::| & \MINKEY{USTRING\_TRAILING}
\LABEL{MIN::USTRING_TRAILING} \\
\end{tabular}\end{indpar}

The \TT{min::unicode\_\EOL length} function returns the number
of \TT{char}'s in the \TT{const char *} string within the \TT{ustring}
(not including the terminating \TT{NUL}).
The \TT{min::unicode\_\EOL columns} function returns the number
of print columns these take; the maximum is 31, and it is assumed
there are no space or control characters in the \TT{ustring}.
The \TT{min::unicode\_\EOL flags} function returns the flags,
which can be tested by anding the unsigned flags value with
the \TT{min::USTRING\_LEADING/TRAILING} flags.
The \TT{min::unicode\_\EOL string} function returns a pointer
to the \TT{const char *} string in the \TT{ustring}.

\subsection{Numbers}
\label{NUMBERS}

A \key{number stub} is collectible, has \minkey{NUMBER}\LABEL{MIN::NUMBER}
stub type code, and has
an immutable \TT{min::float64} stub value that can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT} \verb|( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{tabular}\end{indpar}

Number stubs exist only in compact implementations;
in loose implementations number atoms are stored exclusively
in direct number general values
(\itemref{GENERAL-VALUE-SUBTYPES}).

General values that are numbers can be tested, created, and read
by the following protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_num} \verb|( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of} \verb|( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of} \verb|( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash} \verb|( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\end{tabular}\end{indpar}

The \TT{min::is\_num} function for a loose 64-bit \TT{min::gen} argument
is just another name for the \TT{min::is\_direct\_float} function of the same
argument.  For a compact 32-bit \TT{min::gen} argument the function returns
true if the argument is a direct integer or a stub pointer
pointing at a number stub.

The \TT{min::new\_num\_gen} function with \TT{min::float64} argument
and loose 64-bit \TT{min::gen} value
is just another name for \TT{min::new\_\EOL direct\_\EOL gen}, which
simply changes the type of its argument.
The \TT{min::new\_num\_gen} function with \TT{min::float64} argument
and compact 32-bit \TT{min::gen} value creates a direct integer
if the argument is an integer in the
require range; otherwise the function returns a \TT{min::gen} value
that is a pointer to a number stub.  If a pointer to a number stub is
to be returned and a number stub containing the argument value already exists,
a pointer to the existing stub is returned;
otherwise a new number stub is created and a pointer to it returned.
Therefore two 32-bit \TT{min::gen} values that represent equal numbers are
themselves \TT{==}.

The \TT{min::new\_num\_gen} function with an \TT{int} or \TT{min::unsptr}
argument does the
same thing as it would with its argument converted to a \TT{min::float64}
value, but is more efficient in the case where \TT{min::gen} values
are 32 bits and the argument is in the range of a direct integer general
value.

The \TT{min::float\_of} function for a loose 64-bit \TT{min::gen}
argument is just another name for the \TT{min::direct\_float\_of} function
of the same argument, which after checking the subtype of the argument,
simply changes the type of the argument.
For a compact 32-bit \TT{min::gen} argument the
function returns any integer stored directly
in the argument converted to a 64-bit IEEE floating point number, or
returns the stub value for any number stub pointed at by the argument.
In this last case the stub type code is checked by a \TT{MIN\_ASSERT}
statement to be sure the stub is a number stub.

The \TT{min::int\_of} function does the same thing as the
\TT{min::float\_of} followed by conversion to an \TT{int} value,
except that \TT{min::int\_of} includes a check that the result
is a pure integer, without any fractional part, and is within the
range of the \TT{int} type, and
\TT{min::int\_of} is more efficient when given a 32-bit direct integer
\TT{min::gen} argument.

Lastly, the \TT{min::numhash} function
returns the hash value of a \TT{min::gen}
value that is a number.  This value is computed by considering
the \TT{min::float\_of} value of the number
to be a \underline{big endian} string of 8 characters and using the algorithm
on \pagref{HASH-ALGORITHM} to compute the hash value of this string.%
\label{NUMBER-HASH-ALGORITHM}

To permit hash values of arbitrary floating point numbers to be computed,
the following function is provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{floathash} \verb|( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{tabular}\end{indpar}

The above \TT{min::float\_of}, \TT{min::int\_of}, and \TT{min::numhash}
functions of a \TT{min::gen} argument apply \TT{MIN\_ASSERT} to check
that their argument is a number.  The following unprotected function assumes
that its argument is a number without doing any \TT{MIN\_ASSERT} check:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN}
\end{tabular}\end{indpar}

\subsection{Strings}
\label{STRINGS}

In MIN all \skey{string}s\index{strings@strings}
are \TT{NUL} terminated UTF-8 encoded UNICODE character strings.
\key{UTF-8} encodes 32-bit UNICODE characters in 1 to 7 \TT{char}'s.

All ASCII characters are encoded as themselves in
the UTF-8 encoding.  This implies that
all ASCII character strings are UTF-8 encoded character
strings with the same characters as their ASCII representation indicates.%
\footnote{ASCII character codes range from 0 through 127.  UTF-8 extends
this by assigning meaning to codes from 128 to 255.}

It is possible for a string to be miscoded UTF-8.  Unless otherwise
mentioned, the functions given below, including the protected functions,
do \underline{not} check for this.

A MIN string value cannot store the \TT{NUL} character as legal UTF-8.
But it is possible to use the `\key{modified UTF-8}'
\label{MODIFIED-UTF-8} encoding instead of
strict UTF-8.  The difference is that strict UTF-8 encodes the NUL
character in a single byte as an ASCII NUL, whereas modified UTF-8
encodes the \TT{NUL} character as the `overlong' 2-byte string `\TT{0xC0,0x80}'
(which is not legal in strict UTF-8 because it is not the shortest
possible encoding of \TT{NUL} in UTF-8).

There are two kinds of string stubs: short strings and long strings.
In addition, a string of up to 3 \TT{char}'s can be stored within a 32-bit
\TT{min::gen} value, and a string of up to 5 \TT{char}'s can be stored
within a 64-bit \TT{min::gen} value,
without using a stub
(see \itemref{GENERAL-VALUE-SUBTYPES} and
\itemref{GENERAL-VALUE-FUNCTIONS}).
Such strings are called \skey{direct string}s, while strings stored in
stubs or bodies which are pointed at by \TT{min::gen} values,
the short and long strings, are called \skey{indirect string}s.
A short string holds up to 8 characters inside the string stub
(there must be more characters than a direct string will hold).
A long string has an string body that holds the string characters
(there must be more than 8)
along with the string length and hash value.

All three kinds of strings, direct, short, and long, are immutable
and have hash values (\pagref{HASH-VALUE}).

\subsubsection{Protected String Functions}
\label{PROTECTED-STRING-FUNCTIONS}

There are protected functions accessing general values that denote
strings of any kind without distinction, and these are described next.
Unprotected functions that apply only to particular
types of string are described later in
Section~\itemref{UNPROTECTED-STRING-FUNCTIONS}.

The following functions create new general string values:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( min::ptr<const char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}
	 \verb|( min::ptr<const char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( min::ptr<char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}
	 \verb|( min::ptr<char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_WITH_N} \\
\end{tabular}\end{indpar}

The \TT{min::new\_str\_gen} functions copy the input string after the
manner of \TT{strcpy} and \TT{strncpy}, respectively.  That is,
they copy from \TT{p}
until a \TT{NUL} is copied or \TT{n} characters have been copied, whichever
comes first.  The forms with a \TT{min::ptr<const char>}
or \TT{min::ptr<char>}
argument are for use when the input string is part of a relocatable body.
Because \TT{min::ptr<char>} is not implicitly cast-able to
\TT{min::ptr<const char>}, both types are argument are provided for.

When a string general value is created,
\label{STRING-CREATION}
if the input string is short enough for the general value
to hold the string itself, a direct string general value is created.
Otherwise \TT{min::new\_str\_gen} searches to see if any equal string
exists.  If such a string exists, a pointer to the stub of the existing
string is returned in the new \TT{min::gen} value, and no new stub
is created.  Otherwise, if the input string is 8 or fewer \TT{char}'s,
a short string stub is created, and if the input string has more
than 8 \TT{char}'s, a long string stub and body are created.

Thus if two string \TT{min::gen} values are equal as
strings, they have \TT{==~min::gen} values.

There are also functions to create a new general string values from
vectors of UNICODE characters:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( const min::Uchar * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<const min::Uchar> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_CONST_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<min::Uchar> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_UNICODE} \\
\end{tabular}\end{indpar}

TBD

The following functions test a \TT{min::gen} value to see if it
is a string and obtain information from
a string \TT{min::gen} value.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\[1ex]
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy} \verb|( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::|
    & \MINKEY{strncpy} \verb|( char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\[1ex]
\verb|int min::| & \MINKEY{strcmp} \verb|( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::|
    & \MINKEY{strncmp} \\
    & \verb|    ( const char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\verb|min::uns64 min::| & \MINKEY{strhead} \verb|( min::gen v )|
\LABEL{MIN::STRHEAD_OF_GEN} \\
\end{tabular}\end{indpar}

Five of these functions correspond to the standard C/C++
\TT{strlen}, \TT{strcpy}, \TT{strncpy}, \TT{strcmp},
and \TT{strncmp} functions, and differ
from these only in that instead of taking a \TT{char *} source string
argument, these functions take a \TT{min::gen} source argument.

The \TT{is\_str} function simply returns true if and only if
its argument is a string.

The \TT{strhead} function is an optimized function that
returns the first 8 bytes of the string
in a \TT{min::uns64} value.  This is intended to be used by
overloading it with \TT{min::uns8[8]}, as in the code:

\begin{indpar}\begin{verbatim}
union { min::uns64 u; min::uns8 s[8]; } v;
min::gen g;
. . . set g to a string value . . .
v.u = min::strhead ( g );
. . . first 8 bytes of string are now in v.s[0], ..., v.s[7] . . .
\end{verbatim}\end{indpar}

If a string has fewer than 8 bytes, it is padded with zero bytes
at its end so that 8 bytes may always be returned.  If the \TT{min::gen}
argument to \TT{strhead} is not a string, 8 zero bytes are returned
(as if the argument had been an empty string).

\TT{strhead} is useful for testing
to see what kind of lexeme the string represents; for
example, if the first byte is a letter, or the first byte is \TT{'}
and the second byte is a letter, then the string may represent a
word, but if the first byte is \TT{'} and the second is zero,
the string may represent a separator.
Note that the bytes are UTF-8 encoded, and may represent non-ASCII
UNICODE characters.  Note that UTF-8 can encode a UNICODE character
in as many as 7 bytes, so if the string begins with two non-ASCII
characters, the encoding of the second may be truncated.

To permit hash values of arbitrary strings to be computed,
without creating \TT{min::gen} values from them first,
the following functions are provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash} \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{tabular}\end{indpar}

Both \TT{strhash} and \TT{strnhash} accept \TT{NUL} terminated strings, but
\TT{strnhash} stops reading the string after the first \TT{n} characters
if none of these characters is NUL.

A string hash value is computed according to the following machine
independent algorithm:\label{HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = 0
n = length of string
for i = 1 through n:
    c = i'th char of string as unsigned 8 bit integer
    hash = ( hash * 65599 ) + c
if hash = 0, then hash = 2**32 - 1
\end{verbatim}\end{indpar}

where the final result is truncated to 32 bits.  The constant
is a prime such that multiplication by it may be turned into
shifts and adds by compilers: $65599=2^{16}+2^6-1$.
A hash value is never zero (so zero can be used to denote a missing hash value).

The low order bits of the hash value are random, so it can be
truncated to provide a random hash.

The following functions can be used to convert \TT{min::gen}
string values to numbers:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int32 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_INT32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int64 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_INT64} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns32 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_UNS32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns64 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_UNS64} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float32 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT32} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float64 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT64} \\
\end{tabular}\end{indpar}

If the \TT{min::gen} argument is a
string consisting of a space surrounded number legal to the UNIX
\TT{strtol}, \TT{strtoll},
\TT{strtoul}, or \TT{strtoull} functions with given \TT{base} argument,
or to the UNIX
\TT{strtof}, or \TT{strtoud} functions, respectively,
\TT{true} is returned and the number is returned in the \TT{value}
argument.  Otherwise \TT{false} is returned and the \TT{value}
argument is left untouched.  This includes the case where the
\TT{min::gen} argument is not a string, the case where the
\TT{base} argument does not have a legal value,
and the case where the number that might be returned would be
outside the range of
numbers storable in the \TT{value} argument.

\subsubsection{Protected String Pointers}
\label{PROTECTED-STRING-POINTERS}

A read-only pointer to the characters of a string \TT{min::gen} value can
be obtained using the following functions to create and use
a \key{string pointer}:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MIN::STR_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MIN::STR_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp, min::gen v )|
\LABEL{MIN::=_STR_PTR_OF_GEN} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1, min::str_ptr const & sp2 )|
\LABEL{MIN::=_STR_PTR_OF_STR_PTR} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1, const min::stub * s )|
\LABEL{MIN::=_STR_PTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|operator |
    & \MINKEY{bool} \verb|( min::str_ptr const & sp )|
\LABEL{BOOL_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|char sp|
    & \TTBMKEY{i}{of {\tt min::str\_ptr}}
\LABEL{MIN::[]_OF_STR_PTR} \\
\verb|min::ptr<const char> min::|
    & \MINKEY{begin\_ptr\_of} \verb|( min::str_ptr const & sp )|
\LABEL{MIN::BEGIN_PTR_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::str_ptr const & sp )|
\LABEL{MIN::STRLEN_OF_STR_PTR} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::str_ptr const & sp )|
\LABEL{MIN::STRHASH_OF_STR_PTR} \\[1ex]
\verb|char * min::|
    & \MINKEY{strcpy} \verb|( char * p, min::str_ptr const & sp )|
\LABEL{MIN::STRCPY_OF_STR_PTR} \\
\verb|char * min::|
    & \MINKEY{strncpy}\ARGBREAK
      \verb|( char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_STR_PTR} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp} \verb|( const char * p, min::str_ptr const & sp )|
\LABEL{MIN::STRCMP_OF_STR_PTR} \\
\verb|int min::|
    & \MINKEY{strncmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_STR_PTR} \\[1ex]
\end{tabular}\end{indpar}

The constructors create a string pointer pointing to the \TT{char}'s
of the string specified by the \TT{min::gen} or
`\TT{min::stub *}' argument.  A \TT{min::gen} argument
should be a direct string or a pointer to a short or long string stub,
and a stub pointer should be a pointer to a short or long string stub.
If the arguments are not, then the string pointer is set to the
\TT{NULL} state in which using it to access the string will almost
certainly cause a memory fault.  The constructor with no argument also
sets the string pointer to the \TT{NULL} state.  The operator to
convert a string pointer to a \TT{bool} returns \TT{true} if the
string pointer is \underline{not} in the \TT{NULL} state, and \TT{false}
if the string pointer \underline{is} in the \TT{NULL} state.

The \TT{=} operator can reset the string
pointer to point at a different \TT{min::gen} value, or at a stub,
or at the
value pointed at by another string pointer.  Like the constructor,
the string pointer is set to the \TT{NULL} state
if the \TT{min::gen} value or stub pointer is not a string,
or the string pointer being assigned from is itself in the \TT{NULL} state.

The \TT{strlen}, \TT{strhash}, \TT{strcpy}, \TT{strncpy},
\TT{strcmp}, and \TT{strncmp} functions retrieve the same information
about the string pointed at by a string pointer as they retrieve about
the string value the pointer points at.

The \TT{min::begin\_ptr\_of} function
returns a \TT{min::ptr<const char>} pointer to
the \TT{NUL}-termin\-at\-ed vector of \TT{char}'s that is the string.
Its value can be converted to a `\TT{const char *}' by the unitary
`\TT{!}' operator, and that value
may be passed to the \TT{strcpy}, \TT{strcmp}, \ldots{}
C library functions.

\TT{sp[i]} can be used to access the \TT{i+1}'st character of
the \TT{NUL}-terminated string.
There is no protection against the operator index
being longer than the string length.

For direct and short strings the string pointer, when it is created,
copies the string \TT{char}'s into a buffer internal to the string pointer,
in order to save the \TT{char}'s in a direct string value, or to
add a missing \TT{NUL} to the end of the short string \TT{char} vector.
In long string cases no copying is done, and the string pointer
is essentially just a pointer to the string stub, which in turn points
at the string proper inside a relocatable string body.

Numbers can be read from a string pointed at by a string
pointer by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT64_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns64 & value,|\ARGBREAK
	\verb|  min::str_ptr & const sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS64_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float32 & value,|\ARGBREAK
	\verb|  min::str_ptr & const sp, int & i )|
\LABEL{MIN::STRTO_FLOAT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float64 & value,|\ARGBREAK
	\verb|  min::str_ptr & const sp, int & i )|
\LABEL{MIN::STRTO_FLOAT64_OF_STR_PTR} \\
\end{tabular}\end{indpar}

If the string pointer is not in the \TT{NULL} state and
the part of the string beginning with \TT{sp[i]} is
space followed by a number legal to the UNIX
\TT{strtol}, \TT{strtoll},
\TT{strtoul}, or \TT{strtoull} functions with the given
\TT{base} argument, or to the UNIX
\TT{strtof}, or \TT{strtoud} functions, respectively,
\TT{true} is returned, the number is returned in the
\TT{value} argument, and the \TT{i} argument is updated to point
just after the number.  Otherwise \TT{false} is returned and
\TT{value} and \TT{i} are left untouched.  This includes the
case where the string pointer is in the \TT{NULL} state,
the case where the \TT{base} argument does not have a legal value,
and the case where the number that might be returned would be
outside the range of
numbers storable in the \TT{value} argument.

\subsubsection{Unprotected String Functions}
\label{UNPROTECTED-STRING-FUNCTIONS}

The following unprotected
function is equivalent to \TT{min::begin\_ptr\_of()} with its
result cast to `\TT{const char *}':

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( min::str_ptr const & sp )|
\LABEL{MUP::STR_OF_STR_PTR} \\
\end{tabular}\end{indpar}

However, note that the pointer returned is relocatable, so this function
is unprotected.

The following unprotected functions
may be used to access the internals of short
and long strings.

A \key{short string stub}\label{SHORT-STRING-STUB} is collectible, has
\minkey{SHORT\_STR}\LABEL{MIN::SHORT_STR} stub type code, and has
an immutable \TT{min::\EOL uns64} stub value that holds a \TT{NUL} padded
8 \TT{char} vector and can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::|
    & \MUPKEY{short\_str\_of} \verb|( const min::stub * s )|
\LABEL{MUP::SHORT_STR_OF}
\end{tabular}\end{indpar}

This function does \underline{not} check the type of the stub \TT{s}.
The \TT{min::uns64} value returned by \MUPkey{short\_str\_of}
should be overlaid by a union with a \TT{char[~]} buffer, as in

\begin{indpar}\begin{verbatim}
union { min::uns64 str; char buf[9]; } u;
min::stub * s1;
. . . set s1 to point at a short string stub . . .
u.str = MUP::short_str_of ( s1 );
u.buf[8] = 0;	// Be sure result is NUL terminated.
cout << u.buf;
\end{verbatim}\end{indpar}

Short string values are \TT{NUL} (zero) padded 0 to 8 \TT{char}
strings.  To be sure any value read is \TT{NUL} terminated, a \TT{NUL} (zero)
must be stored after the value read, as is done by \TT{u.buf[8] = 0}
in the example.  Of course, short string values have more
characters than can be stored in a direct string
(\pagref{STRING-CREATION}).

A \key{long string stub}\label{LONG-STRING-STUB} is collectible, has
\minkey{LONG\_STR}\LABEL{MIN::LONG_STR} stub type code, and has
a value that is a pointer to a \MUPkey{long\_str} type body
which holds an arbitrary length \TT{NUL} terminated \TT{char} string.

The long string body consists of the 32-bit length and 32-bit hash value
of the string, followed by a \TT{char}
vector containing the string proper with the terminating NUL.  The
\TT{char} vector is padded to a multiple of 8 bytes with NUL
bytes, but the terminating \TT{NUL} and the padding are not included
in the length.  The length is larger than 8.

The following are unprotected functions to return a relocatable pointer to the
long string body, a relocatable pointer to the string itself,
and the length and hash of the string.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of} \verb|( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{tabular}\end{indpar}

These functions are unprotected because \TT{long\_str *} pointers
are relocatable.


\subsection{Labels}
\label{LABELS}

Object attribute labels
(see Section~\itemref{OBJECT-ATTRIBUTE-LEVEL})
are often atoms, i.e., single strings or numbers.
But they may be sequences of atoms.  Such sequences are represented by
\skey{label}s.\footnote{Labels could also be represented by
sublists stored inside objects (\pagref{LIST-LEVEL}), but each label tends to
be reused by many objects, and storing it inside each using object
would be inefficient.  In addition labels are useful as function arguments.}
Labels may also be elements of other labels.

A label is just a vector of name components, where a name
component is an atom or a label.  Labels are immutable and
have the property that no two distinct label stubs can have equal vectors of
name components.  

Note that a label of one element
is distinct from the element itself and has a different
hash code.  Also note that labels can be elements of labels.  A programming
language may wish to require that the elements of labels be numbers or
strings, that numbers and strings be treated as labels of one element,
and that proper labels with zero or one element not be created.  But the
\TT{min.h} code does not do this.

A \key{label stub}\label{LABEL-STUB} is collectible,
has \minkey{LABEL}\LABEL{MIN::LABEL} stub type code,
and has an immutable value.
The label value may be read by using \TT{min::\EOL lab\_\EOL ptr}'s:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr} \verb|labp ( min::gen v )|
\LABEL{MIN::LAB_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr} \verb|labp ( const min::stub * s )|
\LABEL{MIN::LAB_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr} \verb|labp ( void )|
\LABEL{MIN::LAB_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt min::lab\_ptr}}\ARGBREAK
          \verb|( min::lab_ptr const & labp )|
\LABEL{MIN::LAB_PTR_TO_MIN_STUB} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp, min::gen v )|
\LABEL{MIN::=_LAB_PTR_OF_GEN} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp, const min::stub * s )|
\LABEL{MIN::=_LAB_PTR_OF_STUB} \\
\verb|min::gen labp|
    & \TTBMKEY{i}{of {\tt min::lab\_ptr}}
\LABEL{MIN::[]_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{begin\_ptr\_of}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{end\_ptr\_of}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

Here if \TT{v} or \TT{s} do not point at the stub of a label
the new label pointer is set to \TT{min::\EOL NULL\_\EOL STUB},
but this is not in an of itself an error.  The resulting
\TT{min::\EOL lab\_\EOL ptr} can be tested to see if it is \TT{==}
to \TT{min::\EOL NULL\_\EOL STUB}.  Using such a pointer to access
parts of a label, however, gives undefined results,
but usually a memory fault.
The no-argument label
pointer constructor also creates a label pointer equal to
\TT{min::\EOL NULL\_\EOL STUB}, and the \TT{=} operators
set a label pointer just as a constructor with the \TT{=} right side
as the constructor argument would.

Given a label pointer \TT{labp} pointing at a real label,
\TT{labp[i]} is the \TT{i+1}'st
element of the label, for
\TT{0<i<min::lablen(labp)},
where the \TT{min::\EOL lablen} function
returns the number of elements in the label.
The \TT{min::\EOL labhash} function returns the hash of the label.

The \TT{min::\EOL begin\_\EOL ptr\_\EOL of} and
\TT{min::\EOL end\_\EOL ptr\_\EOL of}
functions return \TT{min::\EOL ptr<const min::\EOL gen>} values that
point at the first label element and the location just after the
last label element, respectively.
These functions return \TT{min::ptr} pointers that
remain valid even if the label body is relocated.

The length of a label is the number of elements (general values) in the label.
The length of a label may be read from a label pointer, or may be read
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{tabular}\end{indpar}

The hash value of a label may be computed from the label pointer, or
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{labhash}
     \verb|( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{tabular}\end{indpar}

The last function computes the hash value for a label that could be created
from the given vector \TT{p} of \TT{n} general values, where each
general value is a name component.

The hash of a label is computed from
the hash of each of its elements using:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{labhash\_initial} \verb|= 1009|
\LABEL{MIN::LABHASH_INITIAL} \\
\verb|const min::uns32 min::| & \MINKEY{labhash\_factor}
    \verb|= 65599**10 (mod 2**32)|
\LABEL{MIN::LABHASH_FACTOR} \\
\verb|min::uns32 min::| & \MINKEY{labhash}
     \verb|( min::uns32 hash, min::uns32 h )|
\LABEL{MIN::LABHASH_INCREMENTAL} \\
\end{tabular}\end{indpar}

in the following machine independent algorithm:\label{LABEL-HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = min::labhash_initial;
n = length of label
for i = 1 through n:
    h = hash of i'th element of label
    hash = min::labhash ( hash, h )
\end{verbatim}\end{indpar}

where \TT{min::labhash ( hash, h )} is defined as:

\begin{indpar}\begin{verbatim}
min::labhash ( hash, h ):
    // All arithmetic is mod 2**32
    hash = hash * min::labhash_factor + h
    if ( hash == 0 ) hash = -1
    return hash
\end{verbatim}\end{indpar}

Comparing this with the hash algorithm for strings
on \pagref{HASH-ALGORITHM}, one sees that as long as
label elements are numbers and strings of fewer than 10 characters,
the hash of a label is equivalent to the hash of the
string made by concatenating a prefix and then the label elements, where each
string of fewer than 10 characters is padded to 10 characters
by prefacing it with \TT{NUL} characters.  Note that
numbers are treated as 8 character strings; see
\pagref{NUMBER-HASH-ALGORITHM}.  The prefix is any 10 character string with
hash value \TT{min::\EOL labhash\_\EOL initial = 1009}.

The two argument \TT{labhash ( hash, h )} function performs the
incremental step in the computation of a label hash, and can be useful
in some lookup situations.

Although label values are generally read using lab pointers,
a label value may be read by the protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  const min::stub * s, min::uns32 n )|
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  min::gen v, min::uns32 n )|
\LABEL{MIN::LAB_OF_GEN} \\
\end{tabular}\end{indpar}

These read an initial segment of the label vector into the location
addressed by \TT{p}.  If the label vector has \TT{n} or more elements,
the first \TT{n} elements are read.  Otherwise, as many elements as
the label vector has are read.  The number of elements read is returned
in any case.  The label can be denoted by either its stub address or
by a general value pointing at its stub address.

A label may be created by the following protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( const min::gen * p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<const min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR_CONST} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR} \\
\end{tabular}\end{indpar}

Here \TT{p} must point to a vector of \TT{n} \TT{min::gen}
values that becomes the value vector of the label.  Each
\TT{min::gen} value must be a name component.
This function returns any existing label with elements equal to
those given by the function arguments, in preference to creating a new
label.  Thus two \TT{min::gen} label values with \TT{==} elements are
\TT{==}.

For convenience in generating frequently used labels,
2 and 3 element labels whose elements are strings may be created by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2 )|
\LABEL{MIN::NEW_LAB_GEN_OF_2_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3 )|
\LABEL{MIN::NEW_LAB_GEN_OF_3_STRS} \\
\end{tabular}\end{indpar}

The following function returns true if and only if its argument is
a label:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_lab} \verb|( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\end{tabular}\end{indpar}

The following unprotected constructors and functions operating
on the resulting unprotected label points are just like their
protected versions except that they assume any \TT{min::gen}
value \TT{v} or \TT{min::stub *} value \TT{s} is a label
and furthermore do not check subscript ranges:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr} \verb|labp ( min::gen v )|
\LABEL{MUP::LAB_PTR_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr} \verb|labp ( min::stub * s )|
\LABEL{MUP::LAB_PTR_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr} \verb|labp ( void )|
\LABEL{MUP::LAB_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::lab\_ptr}}\ARGBREAK
          \verb|( MUP::lab_ptr const & labp )|
\LABEL{MUP::LAB_PTR_TO_MIN_STUB} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, min::gen v )|
\LABEL{MUP::=_LAB_PTR_OF_GEN} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, const min::stub * s )|
\LABEL{MUP::=_LAB_PTR_OF_STUB} \\
\verb|min::gen labp|
    & \TTBMKEY{i}{of {\tt MUP::lab\_ptr}}
\LABEL{MUP::[]_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{begin\_ptr\_of}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_MUP_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{end\_ptr\_of}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_MUP_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_MUP_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_MUP_LAB_PTR} \\
\end{tabular}\end{indpar}

\subsection{Names}
\label{NAMES}

A \key{name} is a
number (\itemref{NUMBERS}),
string (\itemref{STRINGS}),
or label (\itemref{LABELS}), i.e., it is an atom or a label.
A name can also be viewed as
a sequence of \skey{name component}s, each of which is a number, string,
or label.
Names and name components are all immutable values which have an associated
hash value.

A number or string is used to represent a 1-component name whose
only component is the number or string.  Other names are represented
by labels whose elements are the components of the names.  A label whose
only component is a number or string is \underline{not}
used to represent a name, in order to ensure that each name has a unique
representation.

The following functions concern names:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_name} \verb|( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash} \verb|( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare} \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\verb|min::int32 min::| & \MINKEY{is\_subsequence}
    \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::IS_SUBSEQUENCE} \\
\end{tabular}\end{indpar}

The \TT{min::is\_name} function returns true if and only if its argument is
a name (number, string, or label).

The \TT{min::hash} function returns a non-zero
\key{hash value}\label{HASH-VALUE} of its argument, which must be
a name.

The \TT{min::compare} function returns an integer $<0$, $=0$, or $>0$
according to whether its \TT{v1} argument is less than, equal to, or
greater than its \TT{v2} argument.
In this ordering numbers are
before strings, strings are before labels, and labels are before
any non-name values.  Numbers are ordered
numerically, strings are ordered lexicographically as per the
C language \TT{strcmp} function, and labels are ordered lexicographically
using the \TT{min::\EOL compare} function recursively to compare
label elements.  Non-name values are ordered by converting their
\TT{min::gen} values to bit strings and comparing the bit strings.
This means that \TT{min::gen} values that point at stubs are ordered
according to their stub addresses.

The \TT{min::subsequence} function
returns the index of the first occurence
of its first argument \TT{v1} as a subsequence of its second
argument \TT{v2}, or returns \TT{-1} if there is no such
occurence.  For this function,
a non-label must be an atom, and is equivalent to a length \TT{1} label
whose sole element is the atom.

\subsection{Packed Structures}
\label{PACKED-STRUCTURES}

A \key{packed structure} is a class datum stored in a body associated
with a stub that has a \minkey{PACKED\_STRUCT}\LABEL{MIN::PACKED_STRUCT}
stub type code.

The class type must be similar to a C-language \TT{struct} in that:
\begin{enumerate}
\item Construction\label{PACKED-STRUCTURE-TYPE-REQUIREMENTS}
of a datum of the type
by a no-argument constructor does not have to
set any datum byte to a non-zero value.  Note that bytes need not be
set to any value, but zero must be an acceptable value for all bytes
of a newly constructed datum.

When a packed structure is created it is zeroed and then one special
header member described below, the \TT{control} member,
is given a value.
No constructor is called.
\item
Destruction of a datum of the type does nothing.

When a packed structure is destroyed, no destructor is called.
\item
Assignment of a datum of the type from another datum of the same type
is equivalent to a \TT{memcpy} operation.

When a packed structure is moved by the copying part of
the ACC, it is moved by \TT{memcpy}.
\end{enumerate}

Numeric, \TT{min::gen}, and \TT{const min::stub *} values are permitted as
packed structure class members, as are
\TT{min::\EOL packed\_\ldots ptr<\ldots>}
values (see below) and C++ pointers.  Note that all these
are initialized to \TT{0} (equal to \TT{NULL} or \TT{min::NULL\_STUB}
for pointers) when a packed structure is created.

The type of a packed structure
must have as its first member
(that is, the member at displacement \TT{0});
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}
This first member holds subtype information and flags.

The packed structure type
may have a public base structure, as long as that also follows the above
rules.  In this case the
`\TT{control}' member must be the first member of the base structure.
This rule can be applied recursively to get, for example, a `\TT{struct}'
based on a public `\TT{struct}'
based on a public `\TT{struct}' whose first member is `\TT{control}'.

There are two types of pointers that can be used to
access members of packed structures:
\begin{indpar}\begin{tabular}{l}
\verb|min::packed_struct_ptr<S>| \\
\verb|min::packed_struct_updptr<S>|
\end{tabular}\end{indpar}
where \TT{S} is the class type of the structure.
The first \mkey{read-only pointer}{to packed structure} type
permits read-only access to packed structure members,
while the second \mkey{updatable pointer}{to packed structure} type
permits read-write access.
These pointers are like the type `\TT{const min::stub *}' but with extra
clothes.
Pointers of these types can also be included as members in packed structures
and in packed vector headers and elements (see \itemref{PACKED-VECTORS}).

The type of a packed structure is described at run-time by a
\TT{min::packed\_\EOL struct<S>} C++ static object, where
\TT{S} is the type of the structure.
The \TT{new\_gen} and \TT{new\_stub}
member functions of this C++ static object can be
used to create new packed structures of the described type.

More explicitly, to create a new type of \key{packed structure}
named \TT{pstype} use

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct<S>} \verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_with\_base<S,B>}
		\verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE_WITH_BASE} \\
\verb|min::uns32 min::| & \MINKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen pstype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\verb|const min::stub * pstype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_STUB} \\
\verb|min::uns32 pstype|
    & \TTDMKEY{subtype}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_SUBTYPE} \\
\verb|const char * const pstype|
    & \TTDMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{gen\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISP} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{stub\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_DISP} \\
\end{tabular}\end{indpar}

where

\begin{itemlist}[0.5in]

\item[\TT{S}]
The type of the body of packed structures of the type being
declared.  This type must be a class whose first
member is
\begin{center}
\verb|const min::uns32 control;|
\end{center}
This member holds a code that effectively
points at \TT{pstype}, and also holds some flags.
This member is initialized by \TT{new\_gen} or \TT{new\_stub} and must not
be changed by the user.
\TT{S} must meet the requirements given on
\pagref{PACKED-STRUCTURE-TYPE-REQUIREMENTS}.

\item[\TT{B}]
\TT{S} may have a single base type \TT{B} as in
\begin{indpar}\begin{verbatim}
struct S : public struct B { ... }
\end{verbatim}\end{indpar}
where \TT{B} is a packed structure type meeting the requirements given
on \pagref{PACKED-STRUCTURE-TYPE-REQUIREMENTS}.
In this case \TT{S} does
\underline{not} have a `\TT{control}' member, as
the `\TT{control}' member of \TT{B} serves as
the `\TT{control}' member of \TT{S}.
If \TT{packed\_\EOL struct\_\EOL with\_\EOL base<S,B>}
is used to define the packed structure type, conversion of
\TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<S>} pointers
to \TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>}
pointers is enabled.

\end{itemlist}

\begin{itemlist}[0.8in]

\item[\ttmkey{subtype}{in {\tt min::packed\_struct}}]
A small integer automatically assigned to uniquely identify \TT{pstype}.
This is stored in the `\TT{control}' member of all packed
structures that are created by \TT{pstype.new\_\EOL gen} or
\TT{pstype.new\_\EOL stub}, and serves as a pointer from any
of these packed structures to \TT{pstype}.

\item[\ttmkey{name}{in {\tt min::packed\_struct}}]
\label{NAME_IN_PACKED_STRUCT}
A name unique to the \TT{pstype} datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed structure type when a packed structure is
output.

\end{itemlist}

\begin{itemlist}[1.0in]

\item[\ttmkey{gen\_\EOL disp}{in {\tt min::packed\_struct}}]
This C vector is a list of the displacements (in bytes) of all
the \TT{min::gen} members of \TT{S},
terminated by the value \TT{min::DISP\_END}\minindex{DISP\_END}.
The displacement of member \TT{m} in structure type \TT{S} should
be computed by \TT{min::\EOL DISP(\&S::m)}.

This displacements vector should not
be given (its address should be \TT{NULL}) if there are no \TT{min::gen}
values in \TT{S}.  But if there are \TT{min::gen} members, this
displacements vector must be given for garbage collection purposes.

\TT{const min::gen} members are treated like \TT{min::gen}
members for these purposes.

\item[\ttmkey{stub\_\EOL disp}{in {\tt min::packed\_struct}}]\label{STUB_DISP}
Ditto but for \TT{const min::stub *} members of \TT{S}
instead of \TT{min::gen} members.  The following member types are
treated as \TT{const min::stub *} members for these purposes:
\begin{center}
\tt
\begin{tabular}{l}
const min::stub * const \\
min::packed\_struct\_xxxptr<S> \\
min::packed\_vec\_xxxptr<E,H,L> \\
\end{tabular}
\end{center}

\end{itemlist}

The \TT{pstype.new\_gen} and \TT{pstype.new\_stub}
functions create a new packed structure
datum of the type described by \TT{pstype} and return a
\TT{min::gen} or \TT{const min::\EOL stub~*} value pointing at it.
The new packed structure is set to all zeros, except for its
`\TT{control}' member.

The function call \TT{min::\EOL DISP~(~\&~S::m~)} will return the
displacement in bytes of the member \TT{m} of a structure
of \TT{struct} type \TT{S}.  This should be used instead of
assuming that \TT{struct} layouts are tightly packed, as often
they are not.  The type of the \TT{S::m} member must be one of
the types mentioned above: \TT{min::gen}, \TT{const min::stub~*},
\TT{min::\EOL packed\_\EOL \ldots{}ptr<\ldots>}, etc.

\TT{pstype.subtype}, \TT{pstype.name},
\TT{pstype.gen\_\EOL disp},
and \TT{pstype.stub\_\EOL disp}
can be used to retrieve the subtype, name, and displacement
information associated with \TT{pstype}.

The subtype of a packed structure (or packed vector)
and the name of that subtype can be retrieved by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype} \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_SUBTYPE} \\
\end{tabular}\end{indpar}

These functions work in the same way for both packed structures
and packed vectors (\itemref{PACKED-VECTORS}).
No packed structure has the same subtype as any packed vector, and
vice versa.

The \TT{min::\EOL packed\_\EOL subtype\_\EOL of}
functions return \TT{0}, which
is not a legal packed structure or packed vector subtype, if the
argument does not reference a packed structure or vector.  This includes
the case where the argument is \TT{min::\EOL NULL\_\EOL STUB}.
The \TT{MUP::\EOL packed\_\EOL subtype\_\EOL of} function gives
undefined result unless its argument references a packed structure
or packed vector.  When the argument is a packed structure
or packed vector,
the subtype is computed by looking in the
`\TT{control}' member of the structure or vector.

The \TT{min::name\_of\_packed\_subtype} function returns the
\TT{pstype.name} (\pagref{NAME_IN_PACKED_STRUCT}) of the
\TT{pstype} associated
with the subtype, which is useful for tracing and debugging.

Note that there can be several different
\TT{min::\EOL packed\_\EOL struct<S>}
values with different subtypes but the same structure
type \TT{S}.  Packed structure pointers such as those of type
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
described below may point at a packed structure with any of these subtypes;
the pointer type is \underline{not} specific to the subtype, but
is rather specific to \TT{S}.

The two kinds of pointers that can be used to access
a packed structure.  The read-only
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointers
have the usage:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	   \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	   \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	   \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
          \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_TO_MIN_STUB} \\
\verb|min::ptr<S const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_->} \\
\verb|min::ref<S const> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_*} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\end{tabular}\end{indpar}

A \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} value is just
a `\TT{const min::stub~*}' value in fancy clothes, and may be
converted to/from a `\TT{const min::stub~*}' value.

For the constructors and the \TT{=} assignment operator, if the
argument \TT{v} or \TT{s} does not point at a packed structure
of type \TT{S}, the \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
result is set to \TT{min::\EOL NULL\_\EOL STUB},
which is just the standard C language \TT{NULL}
cast to the `\TT{const min::stub *}' type.
Note that \TT{NULL} cannot itself be used as an argument to
the constructors or \TT{=} operator, as it is
convertible to either a `\TT{min::stub *}'
or \TT{min::gen} type, and is thus creates ambiguity.
But \TT{min::\EOL NULL\_\EOL STUB} can be used.
If a constructor for \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
is not given an argument, the pointer is also set to
\TT{min::\EOL NULL\_\EOL STUB}.

A pointer equal to
\TT{min::\EOL NULL\_\EOL STUB} gives undefined results if
used to access a structure,
though almost always the result will be a memory fault.
The \TT{==} and \TT{!=} operators can be used to test whether
or not a \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer
equals \TT{min::\EOL NULL\_\EOL STUB}.

A \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer is also
internally a `\TT{S const **}' value that is made to behave externally like a
`\TT{min::\EOL ptr<S~const>}' value with respect to the \TT{->} and
unary \TT{*} operators.  Thus looking ahead at the example below,
if \TT{upv} is a
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} value
and \TT{S} has a member \TT{m}, then \TT{upv->m} is the \TT{m}
member of the \TT{S} struct pointed at by \TT{upv}.

The read-write \TT{min::\EOL packed\_\EOL struct\_\EOL updptr<S>}
pointer type has 
as its \TT{public} base class the
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer type,
so that it can be implicitly converted to
a read-only pointer.  The new code defined for this read-write
pointer type is:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|
	   \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	  \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|
	               \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::ptr<S> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_udpptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_->} \\
\verb|min::ref<S> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_updptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_*} \\
\end{tabular}\end{indpar}

The \TT{->} and \TT{*} operators are redefined (i.e., \underline{not}
inherited) so that they
return `\TT{min::\EOL ptr<S>}' and `\TT{min::\EOL ref<S>}' values instead of
`\TT{min::\EOL ptr<S~const>}' and `\TT{min::\EOL ref<S~const>}' values.

\TT{min::\EOL packed\_\EOL struct\_\EOL updptr<S>} pointers can be
converted implicitly to \TT{const min::stub *} values because
the \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer type
is a \TT{public} base class of
the \TT{min::\EOL packed\_\EOL struct\_\EOL updptr<S>} pointer type.

\TT{min::gen}, \TT{const min::stub~*}, and
\TT{min::\EOL packed\_\EOL\ldots ptr<\ldots>}
elements of packed structures must be locatable.
The \TT{MIN\_REF}\label{PACKED_STRUCT_MIN_REF}
macro described on \pagref{MIN_REF}
should be used with a \TT{min::\EOL packed\_\EOL
struct\_\EOL updptr<S>} container type
for locatable elements of a packed structure.

An example use of a packed structure is:
\begin{indpar}\begin{verbatim}
struct ps;
typedef min::packed_struct_ptr<ps> psptr;
typedef min::packed_struct_updptr<ps> psupdptr;
    // Note: pointers can be defined before struct is defined.

struct ps {
    min::uns32 control;
    min::uns32 i;
    min::uns32 j;
    const min::gen g;
    const psptr pv;
    const min::stub * const s;
};

MIN_REF ( min::gen, g, psupdptr )
MIN_REF ( psptr, pv, psupdptr )
MIN_REF ( const min::stub *, s, psupdptr )

static min::uns32 ps_gen_disp[2] =
    { min::DISP ( & ps::g ), min::DISP_END };
static min::uns32 ps_stub_disp[3] =
    { min::DISP ( & ps::s ), min::DISP ( & ps::pv ), min::DISP_END };

static min::packed_struct<ps> pstype
    ( "pstype", ps_gen_disp, ps_stub_disp );

main ( ... )
{
    . . . . . . .
    min::gen v1 = pstype.new_gen();
        // min::packed_subtype_of ( v1 ) == pstype.subtype
    psupdptr upv ( v1 );
        // min::packed_subtype_of ( upv ) == pstype.subtype
    upv->i = 55;
    upv->j = 99;
    g_ref(upv) = min::new_str_gen ( "Hello" );

    psptr pv = upv;
    // Upv is converted to a `const min::stub *' value
    // that is used to set pv.

    pv_ref(upv) = pv;
    upv = pstype.new_gen();
        // new.stub() could be used here in place of new_gen()

    // Now upv->i == 0, pv->i == 55, pv->pv->i == 55,
    //     upv->pv == min::NULL_STUB

    . . . . . . .
}
\end{verbatim}\end{indpar}

Packed structure pointers do no caching and
there is \underline{no need} for
a refresh function analogous to the \TT{min::\EOL \ldots\_\EOL refresh}
functions for list pointers (\pagref{LIST-POINTER-CACHE}).

\subsection{Packed Vectors}
\label{PACKED-VECTORS}

A \key{packed vector} is like a packed structure but with an added vector
that follows the structure,
and with a \minkey{PACKED\_VEC}\LABEL{MIN::PACKED_VEC}
stub type code instead of a \TT{min::\EOL PACKED\_\EOL STRUCT} type code.

The structure at the beginning of a packed vector
is called the packed vector \mkey{header}{of packed vector}
and the vector elements that follow the header are called the
packed vector \smkey{element}s{of packed vector}.
The types of both the vector header and the vector elements must follow
the three rules stated at the beginning of the Packed Structures
section (\itemref{PACKED-STRUCTURES}), with two exceptions.%
\label{PACKED-VECTOR-TYPE-REQUIREMENTS}

The type of a packed vector header, like that of a packed structure,
must be a class whose first member
(that is, the member at displacement \TT{0}) is
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}

The first exception is that
the header must also have the following two other members,
at no particular displacement:
\begin{indpar}
\verb|const L length;| \\
\verb|const L max_length;|
\end{indpar}
where \TT{L} is an unsigned integer type, and defaults to
\TT{min::\EOL uns32}.  Here \TT{length} is the current number
of elements in the vector and \TT{max\_length} is the
maximum number of elements that can be in the vector before
the vector needs to be resized to increase
\TT{max\_length} (resizing is automatic but moves the vector in memory).

The second exception is that the type of the vector elements
may be a class type, but without any of the members required
for the header, or may be any type appropriate to an element
of such a class.  So, for example, \TT{min::gen} may be
either the vector element type or the type of a member of
the vector element type.

There are also three pointer-to-packed-vector types:
\begin{indpar}\begin{tabular}{l}
\verb|min::packed_vec_ptr<E,H,L>| \\
\verb|min::packed_vec_updptr<E,H,L>| \\
\verb|min::packed_vec_insptr<E,H,L>|
\end{tabular}\end{indpar}
where \TT{E} is the type of the packed vector element,
\TT{H} is the type of the packed vector header struct,
and \TT{L} is the unsigned integer type of the \TT{length}
and \TT{max\_\EOL length} members of the header, and also of the
subscripts used to access vector elements.
The first \mkey{read-only pointer}{to packed vector} type
permits read-only access to packed vector members and elements,
the second \mkey{updatable pointer}{to packed vector} type
permits read-write access, while the
the third \mkey{insertable pointer}{to packed vector} type
permits read-write access \underline{and}
also permits pushing and popping vector elements
and resizing the vector.
These pointers are like the type `\TT{const min::stub *}' but with extra
clothes.
These pointer types can also be used as the types of packed vector
elements or as members of classes that are the types of packed vector
elements or headers or of packed structures.

A packed vector type is described at run-time by a
\TT{min::packed\_\EOL vec<E,H,L>} C++ static object, where
\TT{E}, \TT{H}, and \TT{L} are as above.
The \TT{new\_gen} and \TT{new\_stub}
member functions of this C++ static object can be
used to create new packed vectors of the described type.

More explicitly, to create a new type of \key{packed vector}
named \TT{pvtype} use

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{packed\_vec\_header<L>}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const min::uns32 control;|\ARGBREAK
    \verb|  const L length;|\ARGBREAK
    \verb|  const L max_length;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PACKED_VEC_HEADER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec}{packed\_vec}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_with\_base<E,H,B,L=min::uns32>}
		\verb|pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE_WITH_BASE} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_STUB_VOID} \\
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_STUB_MAX_LENGTH} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const char * const pvtype| & \TTDMKEY{subtype}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_SUBTYPE} \\
\verb|const char * const pvtype| & \TTDMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_DISP} \\[1ex]
\verb|min::uns32 pvtype| & \TTDMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 pvtype| & \TTDMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 pvtype| & \TTDMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{tabular}\end{indpar}

where

\begin{itemlist}[0.5in]

\item[\TT{E}]\label{PACKED_VEC_ELEMENT_TYPE}
The type of the elements in the vector part of the
bodies of packed vectors of the type being
declared.  This must meet the requirements given on
\pagref{PACKED-VECTOR-TYPE-REQUIREMENTS}.

Also, \TT{E} must \underline{not} be a \TT{const} type.

\item[\TT{H}]\label{PACKED_VEC_HEADER_TYPE}
The type of the header at the beginning of the
bodies of packed vectors of the type being
declared.  This must meet the requirements given on
\pagref{PACKED-VECTOR-TYPE-REQUIREMENTS}.

This must be a class (or \TT{struct}) type
whose first member is
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}
and which must also have the two members
\begin{indpar}
\verb|const L length;| \\
\verb|const L max_length;|
\end{indpar}
where \TT{L} is an unsigned integer type.
These members are initialized by \TT{new\_gen} or \TT{new\_stub}
and must not
be changed by the user.

\TT{H} defaults to \TT{min::packed\_vec\_header<min::uns32>} which
has just the require header members: \TT{control}, \TT{length}, and
\TT{max\_\EOL length} with \TT{L=min::uns32}.  Because of this default,
\TT{H} is the \underline{second} template parameter,
even though is precedes the vector elements in memory.

\item[\TT{L}]
The unsigned integer type of the vector length and vector element subscripts
of the vector.  Defaults to \TT{min::\EOL uns32}.
Other sensible values for \TT{L} are
\TT{min::\EOL uns16} and \TT{min::\EOL unsptr}.

\item[\TT{B}]
\TT{H} may have a single base type \TT{B} as in
\begin{indpar}\begin{verbatim}
struct H : public struct B { ... }
\end{verbatim}\end{indpar}
where \TT{B} is a packed structure type (see \itemref{PACKED-STRUCTURES}).
In this case \TT{H} does
\underline{not} have a `\TT{control}' member, as
the `\TT{control}' member of \TT{B} serves as
the `\TT{control}' member of \TT{H}.  The `\TT{length}' and
`\TT{max\_length}' members may be in either \TT{H} or \TT{B}.
If \TT{packed\_\EOL vec\_\EOL with\_\EOL base<E,H,B,L>}
is used to define the packed vector type, conversion of
\TT{min::\EOL packed\_\EOL vec\_\EOL xxxptr<E,H,L>} pointers
to \TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>}
pointers is enabled.

\end{itemlist}

\begin{itemlist}[1.0in]

\item[\ttmkey{subtype}{in {\tt min::packed\_vec}}]
A small integer automatically assigned to uniquely identify \TT{pvtype}.
This is stored in the `\TT{control}' member of all packed
vectors that are created by \TT{pvtype.new\_\EOL gen} or
\TT{pvtype.new\_\EOL stub}, and serves as a pointer from any
of these packed vectors to \TT{pvtype}.

\item[\ttmkey{name}{in {\tt min::packed\_vec}}]
A name unique to the \TT{pvtype} datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed vector type when a packed vector is
output.

\end{itemlist}

\begin{itemlist}[1.6in]

\item[\ttmkey{header\_\EOL gen\_\EOL disp}{in {\tt min::packed\_vec}}]
This vector is a list of the displacements (in bytes) of all
the \TT{min::gen} members of \TT{H},
terminated by the value \TT{min::DISP\_\EOL END}\minindex{DISP\_END}.
This displacements vector should not
be given (its address should be \TT{NULL}) if there are no \TT{min::gen}
values in \TT{H}.  But if there are \TT{min::gen} members, this
displacements vector must be given for garbage collection purposes.

\item[\ttmkey{header\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \TT{min::stub *} members of \TT{H}.
See \pagref{STUB_DISP} for more details.

\item[\ttmkey{element\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \TT{min::gen} members of \TT{E}.

\item[\ttmkey{element\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \TT{min::stub *} members of \TT{E}.
See \pagref{STUB_DISP} for more details.

\end{itemlist}

\TT{pvtype.name},~~
\TT{pvtype.header\_\EOL gen\_\EOL disp},
\TT{pvtype.header\_\EOL stub\_\EOL disp},
~~\TT{pvtype.ele\-\EOL ment\_\EOL gen\_\EOL disp},
and \TT{pvtype.ele\-\EOL ment\_\EOL stub\_\EOL disp}
can be used to retrieve the name and displacement
information associated with \TT{pvtype}.

In addition the parameters
\TT{pvtype.ini\-tial\_\EOL max\_\EOL length},
\TT{pvtype.increment\_\EOL ratio}, and
\TT{pvtype.max\_\EOL increment}
may be set by the user:


\begin{itemlist}[1.5in]

\item[\ttmkey{initial\_max\_length}{in {\tt min::packed\_vec}}]
The maximum length of a packed vector newly created by calling the
\TT{pvtype.new\_gen} or \TT{pvtype.new\_stub}
function with no arguments.  Defaults to \TT{128}.

\item[\ttmkey{increment\_ratio}{in {\tt min::packed\_vec}}]
The \TT{min::reserve} function multiplies the old maximum length by
this ratio to get the maximum length increment: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \TT{0.5}.

\item[\ttmkey{max\_increment}{in {\tt min::packed\_vec}}]
The maximum increment of the maximum length computable by the
\TT{min::reserve} function: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \TT{4096}.

\end{itemlist}

The \TT{pvtype.new\_gen} and \TT{pvtype.new\_stub}
functions create a new packed vector
datum of the type described by \TT{pvtype} and return a
\TT{min::gen} or \TT{const min::stub *}
value pointing at it.  A packed vector has a
\mkey{length}{of packed vector} which is the number of elements
currently in the packed vector.  It also has a
\mkey{maximum length}{of packed vector} which is the maximum length
allowed before the packed vector must be resized.
The \TT{pvtype.new\_gen} or \TT{pvtype.new\_stub}
function may be given the maximum length
and length and a vector of length type \TT{E} elements that is copied
to the initial value of the packed vector.
If the vector \TT{vp} of initial elements is given as \TT{NULL},
the initial elements will be zeros.
If no parameters are given to
\TT{pvtype.new\_gen} or \TT{pvtype.new\_stub},
the length defaults to \TT{0} and
the maximum length defaults to \TT{pvtype.initial\_\EOL max\_\EOL length}.

A newly created packed vector is set to all zeros, except for its
`\TT{control}', `\TT{length}', and `\TT{max\_\EOL length}' members.

The subtype of a packed vector (or packed structure)
and the name of that subtype can be retrieved by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype} \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_VEC_SUBTYPE} \\
\\
\end{tabular}\end{indpar}

These functions work for packed vectors in the same was as for
packed structures; see \pagref{MIN::PACKED_STRUCT_SUBTYPE_OF_GEN} for details.

The following are defined for general use:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|min::packed_vec<char> min::|
	& \MINKEY{char\_packed\_vec\_type}
\LABEL{MIN::CHAR_PACKED_VEC_TYPE} \\
\verb|min::packed_vec<min::uns32> min::|
	& \MINKEY{uns32\_packed\_vec\_type}
\LABEL{MIN::UNS32_PACKED_VEC_TYPE} \\
\verb|min::packed_vec<const char *> min::|
	& \MINMKEY{const\_char\_ptr\_packed\_vec\_type}%
	          {const\_char\_ptr\_}{packed\_vec\_type}
\LABEL{MIN::CONST_CHAR_PTR_PACKED_VEC_TYPE} \\
\verb|min::packed_vec<min::gen> min::|
	& \MINKEY{gen\_packed\_vec\_type}
\LABEL{MIN::GEN_PACKED_VEC_TYPE} \\
\end{tabular}\end{indpar}

Above we listed three types of pointers that can be used to access
a packed vector.  The first is the read-only
\TT{min::\EOL packed\_\EOL vec\_\EOL ptr<E,H,L>}
packed vector pointer type which has the usage:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr}{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr}{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr}{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_PTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
          \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_TO_MIN_STUB} \\
\verb|min::ptr<H const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_->} \\
\verb|min::ref<H const> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_*} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const L pvp| & \TTARMKEY{length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_LENGTH} \\
\verb|const L pvp| & \TTARMKEY{max\_length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_MAX_LENGTH} \\
\verb|min::ref<E const> pvp| & \TTBMKEY{i}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_[]} \\
\verb|min::ptr<E const> pvp|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_ptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_PTR_+} \\
\verb|min::ptr<E const>  min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_PTR} \\
\verb|min::ptr<E const> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_PTR} \\
\end{tabular}\end{indpar}

As for packed structures, read-only packed vector pointers used as the left
operand of \TT{->} are converted to
\TT{min::\EOL ptr<H const>} pointers.
This can be used to access the `\TT{length}'
and \TT{max\_length} members of the header.

Similarly, as for packed structures the \TT{*} operator converts
read only packed vector pointers to \TT{min::\EOL ref<H const>} references.

In addition subscripting read-only packed vector
pointers gives read-only access to the elements of the vector.  The subscripting
operator \TT{[]} checks the index \TT{i} against the current length
of the vector to ensure the access is legal
(i.e., \TT{pvp[i]} executes a \TT{MIN\_\EOL ASSERT}
check that \TT{0<=i<pvp->length}).
The vector elements in a
packed vector are organized as a C language vector so that
\begin{center}
\TT{(!~\& pvp[0])[i]} references the same element as \TT{pvp[i]}
\end{center}
But the vector elements are stored in a body whose address can change
if a relocating function is called, so C pointers to packed vector
elements are relocatable.  However, temporary use within a single
statement is all right if the statement does not call a relocating
function, so, for example, `\TT{!~\& pvp[i]}' may be used as an
argument to \TT{memcpy}.

\TT{pvp+i} can be used to compute a \TT{min::ptr<E const>} pointer that
points at the \TT{pvp[i]} vector element.
The \TT{MIN\_\EOL ASSERT} check \TT{0<=i<pvp->length}
is performed when \TT{pvp+i} is computed.

\TT{min::begin\_ptr(pvp)} is the same as `\TT{pvp + 0}'
except the latter would fail if \TT{pvp->\EOL length == 0}.
\TT{min::end\_ptr(pvp)} is the same as `\TT{pvp + pvp->length}'
except the latter will always fail because the index is not less than
\TT{pvp->length}.

For example, if \TT{memcpy} is used to copy
from the vector, use \TT{min::begin\_\EOL ptr(pvp)}:
\begin{indpar}\begin{verbatim}
memcpy ( ..., ! min::begin_ptr(pvp), sizeof ( E ) * pvp->length );
\end{verbatim}\end{indpar}
Using \TT{!~\& pvp[0]} instead of \TT{!~min::begin\_ptr(pvp)}
will fail with a \TT{MIN\_\EOL ASSERT} fault if \TT{pvp->\EOL length == 0}.

The read-write \TT{min::\EOL packed\_\EOL vec\_\EOL updptr<E,H,L>}
pointer type has as its \TT{public} base class the
\TT{min::\EOL packed\_\EOL vec\_\EOL ptr<E,H,L>} pointer type,
so that read-write pointers can be implicitly converted to
read-only pointers.  The new code defined for the read-write
pointer type is:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr}{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr}{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr}{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<H> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_->} \\
\verb|min::ref<H> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_*} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<E> pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_[]} \\
\verb|min::ptr<E> pvup|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_updptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_UPDPTR_+} \\
\verb|min::ptr<E>  min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_UPDPTR} \\
\verb|min::ptr<E> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_UPDPTR} \\
\end{tabular}\end{indpar}

The \TT{->}, \TT{*}, \TT{[]}, and \TT{+} operators and
\TT{min::begin\_ptr\_of()} and \TT{min::end\_ptr\_of()} functions are
redefined (i.e., \underline{not}
inherited) so that they
return `\TT{min::\EOL ptr<H>}'
or `\TT{min::\EOL ref<E>}' values
instead of `\TT{min::\EOL ptr<H~const>}'
or `\TT{min::\EOL ref<E const>}' values.

The \TT{MIN\_REF}\label{PACKED_VEC_MIN_REF}
macro described in Section~\itemref{LOCATABLE-MEMBER-REFERENCES}
should be used with a \TT{min::\EOL packed\_\EOL
vec\_\EOL updptr<S>} container type
for locatable elements of a packed vector header.

Special considerations are required for writing vector elements
that are structures containing locatable members.
See the example at the end of this section.

The insertable \TT{min::\EOL packed\_\EOL vec\_\EOL insptr<E,H,L>}
pointer type, which permits elements to be added to a packed vector,
has the
\TT{min::\EOL packed\_\EOL vec\_\EOL updptr<E,H,L>} pointer type
as its \TT{public} base class,
so that insertable pointers can be implicitly converted to
read-write or read-only pointers.  The new code defined for the insertable
pointer type is:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr}{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr}{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr}{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	   \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&\
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<E> min::|
	& \MINKEY{push\RESIZE} \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_PUSH} \\[2ex]
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E const * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<const E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR_CONST} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|E min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_POP_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{resize\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{tabular}\end{indpar}

Insertable packed vector pointers permit the current length and maximum
length of the vector to be changed.
The current vector length is \TT{pvip->length} and the maximum
length is \TT{pvip->max\_length} (see description of \TT{H} on
\pagref{PACKED_VEC_HEADER_TYPE}).
The current length can be changed by \TT{min::\EOL push\RESIZE} and
\TT{min::\EOL pop} functions and the maximum length can be changed
by \TT{min::\EOL resize\RESIZE} and \TT{min::\EOL reserve\RESIZE}
functions.  If
\TT{min::\EOL push\RESIZE} needs more space it automatically calls
\TT{min::reserve\RESIZE}.

The \TT{min::push} function adds elements
to the end of the packed vector
by incrementing the current vector length, and if this would
exceed the maximum length, first calls the \TT{min::reserve} function
with the number of elements to be pushed.

The single argument \TT{min::\EOL push\RESIZE} adds one element to the vector,
zeros that element, and returns a reference to the element.  The
intended use is
\begin{indpar}\begin{verbatim}
push(pvip) = v;
\end{verbatim}\end{indpar}
where \TT{v} is the value of the element to be added to the vector.
If \TT{v} is
a structure type containing locatable elements, the situation is
tricky: see the below example.

The two or three argument \TT{min::\EOL push\RESIZE} adds \TT{n}
elements to the vector, and fills the new elements from \TT{vp}
if that is not \TT{NULL}, or with zeros otherwise.
If \TT{vp} is not \TT{NULL},
new elements are placed within the packed vector in the same
memory order as they appear in the \TT{vp} vector.
Here \TT{vp} cannot be an unprotected body pointer, as the data
it points at might be relocated during the execution of \TT{push}.
It can either be a non-body pointer, a \TT{min:\EOL ptr<const E>} pointer,
or a \TT{min:\EOL ptr<E>} pointer.
In any case \TT{min::\EOL acc\_\EOL write\_\EOL update} 
(\itemref{ACC-WRITE-UPDATE-FUNCTIONS})
is called by \TT{min::\EOL push} if \TT{E} is locatable.
Again the situation is tricky if \TT{v} is
a structure type containing locatable elements: see the below example.

The \TT{min::pop} function removes elements from the end of the
packed vector, decrementing the current vector length (which is checked
to be sure it is large enough).   A single element may be removed and
returned, or \TT{n} elements may be removed and returned in the
\TT{vp} vector.  In the latter case removed elements are placed in
\TT{vp} in the same memory order as they appeared in the packed vector.
Also,
if \TT{vp} is \TT{NULL}, the removed elements are simply discarded
instead of being copied.

The \TT{min::resize} function resets the maximum length.  If
the current length would be larger than the new maximum length,
the current length is reset to the new maximum length.

The \TT{min::reserve} function checks that
the current length plus the \TT{reserve\_length} is
at most the maximum length, and if this check fails,
resets the maximum length according to the formula:
\begin{indpar}\begin{verbatim}
new_maximum_length = max ( length + reserve_length,
                           old_maximum_length
                           +
                           min ( pvtype.max_increment,
                                   pvtype.increment_ratio
                                 * old_maximum_length ) )
\end{verbatim}\end{indpar}\label{PACKED-VEC-EXPANSION-FORMULA}

An example use of a packed vector is:
\begin{indpar}\begin{verbatim}
struct pvh;
struct pve;
typedef min::packed_vec_ptr<pve,pvh> pvptr;
typedef min::packed_vec_insptr<pve,pvh> pvinsptr;
    // Note: pointer types may be defined before
    //       header and element types are defined.

struct pvh {
    const min::uns32 control;
          min::uns32 i;
    const min::uns32 length;
    const min::uns32 max_length;
};

struct pve {
    // Note: pve is not a locatable type but contains
    // locatable type elements which means that
    // MUP::acc_write_update must be called explicitly
    // when pve elements are written into a packed vector.

    min::gen g;
    const min::stub * s;
    min::uns8 j;
};

static min::uns32 pve_gen_disp[2] =
    { min::DISP ( & pve::g ), min::DISP_END };
static min::uns32 pve_stub_disp[2] =
    { min::DISP ( & pve::s ), min::DISP_END };

static min::packed_vec<pve,pvh> pvtype
    ( "pvtype", pve_gen_disp, pve_stub_disp );

main ( ... )
{
    min::gen v = pvtype.new_gen ( 5 );
        // min::packed_subtype_of ( v ) == pvtype.subtype
    pvinsptr pvip ( v );
        // pvip->max_length == 5
        // pvip->length == 0
        // min::packed_subtype_of ( pvip ) == pvtype.subtype
    pve e1 = { min::MISSING(), NULL, 88 };
    min::push(pvip) = e1;
       // Need not call MUP::acc_write_update as neither
       // e1.g or e1.s point at a stub.
    pvptr pvp ( v );
        // pvp->length == 1
        // pvp[0].j == 88

    pve e2[3] = { { min::MISSING(), NULL, 11 },
                  { min::MISSING(), NULL, 22 },
                  { min::MISSING(), NULL, 33 } };
    min::push ( pvip, 3, e2 );
        // Again no need to call MUP::acc_write_update because
        // e2 does not point at stubs.
        //
        // pvp[1].j == 11
        // pvp[2].j == 22
        // pvp[3].j == 33

    min::locatable_gen name1, name2;
    name1 = min::new_str_gen ( "my-name-1" );
    name2 = min::new_str_gen ( "my-name-2" );

    pve e3 = { name1, min::stub_of ( name2 ), 44 };
    min::push(pvip) = e3
        // Here it is necessary that the right size of =
        // not call relocating min::new_... functions
        // because min::push returns a `pve &' value and
        // not a min::ref<pve> value.
    MUP::acc_write_update ( pvip, e3.g ); 
    MUP::acc_write_update ( pvip, e3.s ); 
        // We must call acc_write_update ourselves as
        // pve is not itself a locatable type.

        // pvp->length == 5
    min::resize ( pvip, 10 );
        // pvp->max_length == 10

    pve e4;
    locatable_gen g2;
    locatable_var<const min::stub *> s2;
    e4 = min::pop ( pvip );
        // e4.j == 44
        // pvp->length == 4
    g2 = e4.g;
    s2 = e4.s;
        // We must make e4.g and e4.s locatable before
        // we call any more relocating functions, where we
        // are assuming they might no longer be related to
        // name1 and name2 above.

    pve e5[3];
    min::pop ( pvip, 2, e5 );
        // e5[0].j == 22
        // e5[1].j == 33
    e4 = min::pop ( pvip );
        // e4.j == 11
        // pvp[0].j == 88
        // pvp->length == 1
}
\end{verbatim}\end{indpar}

Packed vector pointers do no caching and
there is \underline{no need} for
a refresh function analogous to the \TT{min::\EOL \ldots\_\EOL refresh}
functions for list pointers (\pagref{LIST-POINTER-CACHE}).

\subsection{Files}
\label{FILES}

A MIN \key{file} is a sequence of UTF-8 encoded \TT{NUL}-terminated
lines plus descriptive information.  A {\tt min::}\MINKEY{file} value is a
pointer to a packed structure that contains the descriptive information
and also contains
a pointer to a packed \TT{char} vector,
the \key{file buffer}\index{buffer!file}, that contains the lines.

The main purpose of the \TT{min::file} type is to allow lines
previously read to be retrieved so they can be printed in error messages.
To this end, some or all read file lines are saved in the file buffer,
and an index to these lines is maintained in
a \key{line index}\index{index!file line}\index{file line index}.
There are two main options for managing this: one is to retain
\underline{all} previously read lines, and the other is to maintain
only the last $N$ lines, where $N$ is the \ttmkey{spool\_lines}{of file}
parameter of the file.

The data types and members of a file are:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::file_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{file}
\LABEL{MIN::FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::packed_vec_insprt<char> file| & \TTARMKEY{buffer}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER} \\
\verb|min::uns32 file| & \TTARMKEY{buffer->length}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER_LENGTH} \\
\verb|min::uns32 file| & \TTARMKEY{end\_offset}{in {\tt min::file}}
\LABEL{MIN::FILE_END_OFFSET} \\
\verb|min::uns32 file| & \TTARMKEY{end\_count}{in {\tt min::file}}
\LABEL{MIN::FILE_END_COUNT} \\
\verb|min::uns32 file| & \TTARMKEY{file\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_FILE_LINES} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL line\_\EOL number}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_NUMBER} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL offset}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_OFFSET} \\
\verb|min::packed_vec_insptr<min::uns32> file|
    & \TTARMKEY{line\_index}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_INDEX} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 file| & \TTARMKEY{spool\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_SPOOL_LINES} \\
\verb|min::uns32 file| & \TTARMKEY{line\_display}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_DISPLAY} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::istream * file| & \TTARMKEY{istream}{in {\tt min::file}}
\LABEL{MIN::FILE_ISTREAM} \\
\verb|min::file file| & \TTARMKEY{ifile}{in {\tt min::file}}
\LABEL{MIN::FILE_IFILE} \\
\verb|std::ostream * file| & \TTARMKEY{ostream}{in {\tt min::file}}
\LABEL{MIN::FILE_OSTREAM} \\
\verb|min::printer file| & \TTARMKEY{printer}{in {\tt min::file}}
\LABEL{MIN::FILE_PRINTER} \\
\verb|min::file file| & \TTARMKEY{ofile}{in {\tt min::file}}
\LABEL{MIN::FILE_OFILE} \\
\verb|min::gen file| & \TTARMKEY{file\_name}{in {\tt min::file}}
\LABEL{MIN::FILE_FILENAME} \\
\end{tabular}\end{indpar}


The members of a file may be read but \underline{not} written, unless
noted below.  They are:

\begin{itemlist}[1.4in]

\item[\ttmkey{buffer}{in {\tt min::file}}]
The vector of \TT{char}'s that contains the lines of the file.  Each
line is encoded using modified UTF-8\footnote{Modified UTF-8 is UTF-8
modified by using the overlong 2-byte encoding of \TT{NUL}, so that strings
may both contain the \TT{NUL} character (in the overlong encoding)
and be \TT{NUL} terminated.}
and \TT{NUL} terminated.
A non-\TT{NUL}-terminated, modified UTF-8
encoded, incomplete
last line, called a \key{partial line}\label{PARTIAL-LINE},
may appear at the end of the buffer.

Note that in general functions that load data into files do \underline{not}
check for illegal UTF-8 encodings, and should not be used to load
\TT{NUL} characters into files.  Line terminating
\TT{NUL} characters should be loaded by the \TT{min::end\_line} function.

Initialized to an empty buffer when the file is created.  The
\TT{min::\EOL init\_\EOL input\ldots} functions arrange for filling
the buffer.
Some of these functions fill the buffer with the complete file.
Others arrange for the buffer to be filled as needed from
the file \TT{istream} or \TT{ifile} members.  The 1-argument
\TT{min::\EOL init\_\EOL input} function creates an empty buffer
or empties an existing buffer and expects the user to fill the
buffer using \TT{min::\EOL push}, \TT{min::load\_\ldots},
and \TT{min::\EOL end\_\EOL line}
functions (see \pagref{WRITING-FILE-BUFFER}).

\item[\ttmkey{buffer->length}{in {\tt min::file}}]
The number of \TT{char} elements in the file buffer
(as per the buffer being a packed vector: see \itemref{PACKED-VECTORS}).
This is \TT{0} when the buffer is empty.

\item[\ttmkey{end\_\EOL offset}{in {\tt min::file}}]
The offset of the \TT{buffer} element just \underline{after} the last
line-terminating \TT{NUL} character in the \TT{buffer}.  Or \TT{0} if there
are no line-terminating \TT{NUL} characters.
This is \TT{0} when the buffer is empty.
Initialized to \TT{0} when the file is created and set appropriately by
\TT{min::\EOL init\_\EOL input\ldots}
and \TT{min::\EOL load\_\ldots}
functions.

\item[\ttmkey{end\_\EOL count}{in {\tt min::file}}]
The number of line-terminating \TT{NUL} characters that have ever been
placed into the \TT{buffer} for the file.
Initialized to \TT{0} when the file is created or initialized
for input by a \TT{min::\EOL init\_\EOL input\ldots} function.
Incremented by \TT{min::\EOL load\_\ldots} and
\TT{min::\EOL end\_\EOL line}.

When spooling is used, lines may be deleted from the beginning of
the \TT{buffer}, but \TT{end\_\EOL count} will not be changed, so
\TT{end\_\EOL count} may not be the number of \TT{NUL} characters
\underline{currently} in the buffer.

\item[\ttmkey{file\_\EOL lines}{in {\tt min::file}}]
If all the \TT{char}'s in the file have been appended to the file \TT{buffer},
this is the number of complete lines in the file, which equals
\TT{end\_count}. Otherwise this equals \TT{min::\EOL NO\_\EOL LINE}.

Initialized to \TT{min::\EOL NO\_\EOL LINE} when the file is created and by
\TT{min::\EOL init\_\EOL input\ldots} functions that do not load
the entire contents of the file into the file \TT{buffer}.
Set to the number of complete lines in the file
by \TT{min::\EOL init\_\EOL input\ldots} functions that load
the entire contents of the file into the file \TT{buffer}, or
by \TT{min::\EOL next\_\EOL line} when that function
reads an end of file from \TT{istream} or \TT{ifile}.
Set to \TT{end\_count} by the \TT{complete\_file} function that marks
a file has being complete.

\item[\ttmkey{next\_\EOL line\_\EOL number}{in {\tt min::file}}]
The number of the next line to be returned by the
\TT{min::\EOL next\_\EOL line}
function that is used by programs to read lines from a \TT{min::\EOL file}.
Or the total number of lines in the file if there is no next line
(there may still be a remaining portion of a partial line).
The first line number is \TT{0}.
Set to \TT{0} by \TT{min::\EOL init\_\EOL input\ldots} functions.
Reset appropriately when the file is rewound.

\item[\ttmkey{next\_\EOL offset}{in {\tt min::file}}]
The offset in the \TT{buffer} of the first character of the
next line to be returned by the \TT{min::\EOL next\_\EOL line}
function, when that function returns a line (i.e., does \underline{not}
return \TT{NO\_\EOL LINE}, i.e., when \TT{next\_offset < end\_offset}).
Specifically, \TT{buffer[next\_\EOL offset]} is
the first character of the next line.

Or when \TT{end\_offset <= next\_offset}, so that
\TT{NO\_\EOL LINE} is returned by \TT{min::\EOL next\_\EOL line},
the offset in the \TT{buffer} of the first character of the
partial line at the end of the buffer
that has not been previously skipped by
the \TT{min::\EOL skip\_\EOL remaining} function
(see \pagref{MIN::SKIP_REMAINING}).  This partial line may be
empty, and it is \underline{not} \TT{NUL} terminated:
see \TT{min::\EOL remaining\_\EOL length} on
\pagref{MIN::REMAINING_LENGTH}.

Set to \TT{0} by \TT{min::\EOL init\_\EOL input\ldots} functions.
Reset appropriately when the file is rewound.

\item[\ttmkey{line\_\EOL index}{in {\tt min::file}}]
If \TT{spool\_lines~!=~0} (see below), then
\TT{line\_index[m]} is the offset in the buffer of the first
character of line number \TT{n} (or of the line-terminating \TT{NUL}
if the line is empty), where
\begin{center}
{\tt m = line\_index->length - ( next\_line\_number - n )}
\end{center}
provided
\begin{center}
{\tt 0 < ( next\_line\_number - n ) <= line\_index->length}
\end{center}
or equivalently,
\begin{center}
\tt
next\_line\_number - line\_index->length \\
<= n < \\
next\_line\_number
\end{center}

If the file has not been rewound since it was initialized by
a \TT{min::\EOL init\_\EOL input\ldots} function with
\TT{spool\_lines~!=~0}, it is guarenteed that
\begin{center}
\tt
line\_index->length \\
>= \\
min ( spool\_lines, next\_line\_number)
\end{center}
so at least \TT{min(spool\_lines, next\_line\_number)}
lines can be located using the line index.

If \TT{spool\_lines~==~min::ALL\_LINES}, which is just the largest possible
\TT{min::uns32} integer, then \TT{spool\_lines >= next\_line\_number},
\TT{line\_\EOL index->\EOL length == next\_\EOL line\_\EOL number},
\TT{m~==~n}, and all the lines in the file before the next line can be located
using the line index.

Otherwise, if \TT{spool\_lines~>~0},
\TT{line\_\EOL index->\EOL length} is determined by
the past history of calls to \TT{min::\EOL flush\_\EOL spool} and
\TT{min::rewind} (see \pagref{LINE-INDEX-LENGTH}).

Created when \TT{spool\_\EOL lines} is set to a non-\TT{0} value
and set to \TT{min::\EOL NULL\_\EOL STUB}
when \TT{spool\_\EOL lines} is set to a \TT{0} value.
Truncated when a file is rewound and downsized when
\TT{min::\EOL flush\_\EOL spool} is called.

\item[\ttmkey{spool\_\EOL lines}{in {\tt min::file}}]
If \TT{0}, \TT{line\_index~==~min::NULL\_STUB} and there is
no spooling.  Otherwise when \TT{min::flush\_spool(n)} is called
with \TT{n <= next\_\EOL line\_\EOL number}, then
if there are more than \TT{spool\_\EOL lines} before line number
\TT{n} in the \TT{line\_\EOL index}, lines before
line number \TT{n - spool\_lines} are deleted.

Set to \TT{0} when the file is created.  Set to an argument
that defaults to \TT{min::\EOL ALL\_\EOL LINES}, the largest
\TT{min::uns32} number,
by \TT{min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{line\_\EOL display}{in {\tt min::file}}]\label{FILE_LINE_DISPLAY}
These are some of the printer
\TT{print\_\EOL format.op\_flags}
(see \pagref{PRINT_FORMAT_OP_FLAGS}) used to print
a file line for error message purposes,
in particular by the \TT{min::\EOL print\_\EOL line}
function (\pagref{MIN::PRINT_LINE}).
The flags involved are:
\begin{indpar}
\tt
\begin{tabular}{l}
min::DISPLAY\_EOL \\
min::DISPLAY\_PICTURE \\
\end{tabular}
\end{indpar}

These flags also determine the column position of each character representative
in the line, and are used to this end by the
by the \TT{min::\EOL print\_\EOL line\_\EOL column}
function (\pagref{MIN::PRINT_LINE_COLUMN}).

For example, the carriage
return prints as follows with the given flags:
\begin{center}
\begin{tabular}{l@{~~~~}ll}
\TT{min::DISPLAY\_PICTURE}
	& {\tiny $\stackrel{\textstyle C~}{~R}$} & 1 column \\
\\[1ex]
no \TT{min::DISPLAY\_PICTURE} & \TT{<CR>} & 4 columns \\
\end{tabular}
\end{center}

The \TT{min::print\_line} function, and the other functions that use
it, print file lines with the printer \TT{op\_flags} and \TT{print\_\EOL format}
set by
\begin{center}
\tt printer << min::set\_line\_display ( file->line\_display )
\end{center}

\TT{line\_display} is set
to \TT{0} when the file is created, and set to an argument
that defaults to \TT{0}
by \TT{min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{istream}{in {\tt min::file}}]
If not \TT{NULL}, the \TT{min::\EOL next\_\EOL line} function
reads lines from this \TT{std::\EOL istream} when it finds
there is no line to return to its caller.
Set to \TT{NULL} when the file is created.

\item[\ttmkey{ifile}{in {\tt min::file}}]
If not \TT{min::NULL\_STUB}, the \TT{min::\EOL next\_\EOL line} function
reads lines from this \TT{min::\EOL file} when it finds
there is no line to return to its caller.
Set to \TT{min::\EOL NULL\_\EOL STUB} when the file is created.

Note that it is a programming error if \TT{istream != NULL}
\underline{and} \TT{ifile != NULL\_\EOL STUB}.

\item[\ttmkey{ostream}{in {\tt min::file}}]
If not \TT{NULL}, then the \TT{min::\EOL flush\_\EOL file} function
outputs buffer \TT{char} elements to this \TT{std::\EOL ostream} when it finds
there are elements not yet output.
Set to \TT{NULL} when the file is created.

\item[\ttmkey{printer}{in {\tt min::file}}]
If not \TT{min::NULL\_STUB}, then the \TT{min::\EOL flush\_\EOL file} function
outputs buffer \TT{char} elements
to this \TT{min::\EOL printer} when it finds
there are elements not yet output.
Non-NUL elements in a
line are output as per the \TT{min::\EOL verbatim}
printer operation (\pagref{MIN::VERBATIM}),
and the line-terminating
NUL elements are translated into sending \TT{min::eol} to the printer.
Note that \TT{line\_\EOL display} is \underline{not} used
when buffer elements are flushed to \TT{printer}.

Set to \TT{min::\EOL NULL\_\EOL STUB} when the file is created.

\item[\ttmkey{ofile}{in {\tt min::file}}]
If not \TT{min::NULL\_STUB}, then the \TT{min::\EOL flush\_\EOL file} function
outputs buffer \TT{char} elements to this \TT{min::\EOL file} when it finds
there are elements not yet output.
Non-NUL elements are simply appended to the end of the \TT{ofile}, and
line-terminating \TT{NUL} elements are translated into calls to
\TT{min::\EOL line\_\EOL end~(~ofile~)}.
Set to \TT{min::\EOL NULL\_\EOL STUB} when the file is created.

\item[\ttmkey{file\_name}{in {\tt min::file}}]
If not \TT{min::MISSING()}, this
is the name of this file used for printing error messages
concerning file lines, in particular by the
\TT{min::\EOL pline\_\EOL numbers} constructor
(\pagref{MIN::PLINE_NUMBERS}).
Set to \TT{min::\EOL MISSING()} when the file is created.

\end{itemlist}

Creation, initialization, and parametrization of files is
accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{init\RESIZE}
     \verb|( min::ref<min::file> file )|
\LABEL{MIN::INIT_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_line\_display\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display )|
\LABEL{MIN::INIT_PRINT_FLAGS_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_\EOL file\_\EOL name\REL}\ARGBREAK
	     \verb|( min::ref<min::file> file,|\ARGBREAK
             \verb|  min::gen file_name )|
\LABEL{MIN::INIT_FILE_NAME_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_ostream\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_ofile\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ofile )|
\LABEL{MIN::INIT_OFILE_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_printer\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::printer printer )|
\LABEL{MIN::INIT_PRINTER_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{ALL\_LINES}
				\TT{=} maximum \TT{min::uns32} value
\LABEL{MIN::ALL_LINES} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{init\_\EOL input\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_stream\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::istream & istream,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STREAM_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ifile,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::gen file_name,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_NAMED_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<const char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  const char * string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CHAR_PTR_OF_FILE} \\
\end{tabular}\end{indpar}

All these \TT{min::}\MINKEY{init\ldots} functions create a \TT{file}
and set their first argument if that argument initially
has the value \TT{min::\EOL NULL\_\EOL STUB}.

The non-\TT{init\_\EOL input\ldots} functions just do this and set
a file member.
For example, \TT{min::\EOL init\_\EOL line\_\EOL display} just
creates the file if necessary and sets \TT{line\_\EOL display},
while \TT{min::\EOL init\_\EOL ostream} just
creates the file if necessary and sets \TT{ostream}.
Used on an existing file, these functions do nothing but change
a file parameter.

The \TT{min::\EOL init\_\EOL input\ldots} functions
reinitialize all members except \TT{ostream}, \TT{ofile},
and \TT{printer}.  Like all file \TT{init} functions, these
create the file if necessary.
All these functions take arguments that initialize \TT{line\_\EOL display}
and \TT{spool\_\EOL lines}.

The \TT{min::init\_input} function assumes
input to the file will come from some outside source.  It empties the
\TT{buffer} and sets
\TT{istream} to \TT{NULL}, \TT{ifile} to \TT{min::\EOL NULL\_\EOL STUB},
and \TT{file\_\EOL name} to \TT{min::\EOL MISSING()}.
For example,\label{WRITING-FILE-BUFFER}
\begin{indpar}\begin{verbatim}
min::locatable_ptr<min::file> file;
init_input ( file );
...
const char * my_string = ...;
int length = ::strlen ( my_string );
min::push ( file->buffer, length, my_string );
min::end_line ( file );
...
\end{verbatim}\end{indpar}
Here \TT{min::push} is just the packed vector push function
(\pagref{MIN::PACKED_VEC_PUSH}) applied
to push character representatives
to the end of the file \TT{buffer}, and the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::END_LINE_FILE} \\
\end{tabular}\end{indpar}

pushes a line terminating \TT{NUL} character to the end of
\TT{buffer}, updates \TT{end\_\EOL offset} to equal the
new buffer length, and increments \TT{end\_\EOL count}.

When a file initialized by \TT{min::\EOL init\_\EOL input}
is complete, you should call the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{complete\_file} \verb|( min::file file )|
\LABEL{MIN::COMPLETE_FILE} \\
\end{tabular}\end{indpar}

to mark the file as being complete by copying \TT{end\_\EOL count}
to \TT{file\_\EOL lines}.  After doing this, you should
not push any more characters into the file's buffer or call
\TT{min::\EOL end\_\EOL line} for the file.

You can also append to a file initialized by \TT{min::\EOL init\_\EOL input}
by making it the \TT{ofile} of another file and flushing this other file
(see \TT{min::\EOL flush\_\EOL file}, \pagref{MIN::FLUSH_FILE}).
For example,
\begin{indpar}\begin{verbatim}
min::locatable_ptr<min::file> file1, file2;
init_input ( file1 );
init_input_... ( file2, ... );
init_ofile ( file2, file1 );
. . . . .
min::flush_file ( file2 );
\end{verbatim}\end{indpar}
Here \TT{min::\EOL flush\_\EOL file} copies any portion of
\TT{file2} not previously flushed to the end of \TT{file1}.
Also, it calls \TT{complete\_file} for \TT{file1} if \TT{file2}
is complete (this last behavior can be suppressed by
giving an extra argument to \TT{min::\EOL flush\_\EOL file}).

You \underline{cannot} push characters to a file initialized by any
\TT{min::\EOL init\_\EOL input\ldots} function other than
\TT{min::\EOL init\_\EOL input}.

You can append the contents of a string to a file initialized
with \TT{min::\EOL init\_\EOL input} by using one of the functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<const char> string )|\ARGBREAK
\LABEL{MIN::LOAD_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<char> string )|\ARGBREAK
\LABEL{MIN::LOAD_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  const char * string )|\ARGBREAK
\LABEL{MIN::LOAD_CHAR_PTR_OF_FILE} \\
\end{tabular}\end{indpar}

These copy the \TT{string} to the end of the file \TT{buffer} and replace any
`\TT{\textbackslash n}' line feeds in the copy with line terminating
\TT{NUL}'s.  When these functions are called, \TT{file}
must \underline{not} be complete.
Any \TT{const char * string} argument must
\underline{not} be a pointer to a relocatable string.

Similarly the contents of an operating system named file
can be copied to the end of a file \TT{buffer} by the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|bool min::|
    & \MINKEY{load\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::gen file_name )|\ARGBREAK
\LABEL{MIN::LOAD_NAMED_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

In this case, both
`\TT{\textbackslash n}' line feeds and \TT{NUL} characters in the copy
of the file contents are replaced by line terminating
\TT{NUL}'s.  Also, if there is any error reading the file,
an error message is written into \TT{min::\EOL error\_\EOL message}
(\pagref{ERROR_MESSAGE}) and \TT{false} is returned, whereas if
there is no read error \TT{true} is returned.
The file must have a well defined size; it cannot be a named stream.
When this function is called, \TT{file}
must \underline{not} be complete.

The \TT{min::init\_input\_string} function initializes the file
for input, loads that string into the file \TT{buffer}, and marks the file
complete.
Any \TT{const char * string} argument must
\underline{not} be a pointer to a relocatable string.

The \TT{min::init\_input\_named\_file} function
initializes the file for input,
sets the \TT{file\_\EOL name} member,
loads the contents of the operating system file this names into the
file \TT{buffer}, and marks the file complete.
The file must have a well defined size; it cannot be a named stream.
If no error occurs reading the file, \TT{true}
is returned.  Otherwise an error message is written into
into \TT{min::\EOL error\_\EOL message}
(\pagref{ERROR_MESSAGE}) and \TT{false} is returned.

The \TT{min::init\_input\_stream} function does not load data into
the file \TT{buffer}, but instead initializes the file as per
\TT{min::init\_input} with an empty \TT{buffer}
and sets the file \TT{istream} member
which causes the \TT{min::\EOL next\_\EOL line} function (see below)
to load lines to the end of
the file \TT{buffer}
from \TT{istream} as new lines are required.  Similarly
the \TT{min::\EOL init\_\EOL input\_\EOL file} function sets
\TT{ifile} which causes \TT{min::\EOL next\_\EOL line} to load lines
from \TT{ifile} as new lines are required.
In both cases, \TT{file\_lines} is initialized
to \TT{min::\EOL NO\_\EOL LINE}, and not changed until
an end of file is read from \TT{istream} or \TT{ifile}, at which time
\TT{file\_\EOL lines} is set to the number of lines in the file
thereby marking the file as complete.

Initializing a file with a \TT{min::\EOL init\_\EOL input\ldots} function
sets \TT{next\_\EOL line\_\EOL number}
and \TT{next\_\EOL line\_\EOL offset} to \TT{0}, thereby
setting up the \TT{min::\EOL next\_\EOL line} function to
sequence through file lines, beginning with the first line of the file:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{NO\_LINE}
\LABEL{MIN::NO_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{next\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::NEXT_LINE_OF_FILE} \\
\end{tabular}\end{indpar}

The \TT{min::\EOL next\_\EOL line} function returns an
\TT{offset} such that the file \TT{buffer[offset]} element
is the first character of the next \TT{NUL}-terminated line.
If there is no such line, because we are at the end of the \TT{buffer},
\TT{min::\EOL NO\_\EOL LINE} is returned instead.  In this case
there may still be a non-\TT{NUL}-terminated partial line at the end
of the file (see \pagref{PARTIAL-LINE}).

A file is complete, in the sense the no more characters will be
appended to its \TT{buffer}, if \TT{file\_\EOL lines} contains
the number of complete lines in the file, and is not equal to
\TT{min::\EOL NO\_\EOL LINE}.  This can be tested by

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|bool min::|
    & \MINKEY{file\_\EOL is\_\EOL complete} \verb|( min::file file )|
\LABEL{MIN::FILE_IS_COMPLETE} \\
\end{tabular}\end{indpar}

If \TT{istream} is not \TT{NULL}, then when
\TT{min::\EOL next\_\EOL line} encounters the
end of \TT{buffer} and the file is not complete,
\TT{min::\EOL next\_\EOL line}
reads from \TT{istream} and pushes the characters read to
the end of \TT{buffer}, until a linefeed, \TT{NUL}, or end of file
is read.  Both linefeeds and \TT{NUL}'s invoke \TT{min::\EOL end\_\EOL line}
to terminate the line.  If instead an end of file is read,
the file is completed by setting
\TT{file\_\EOL lines} to \TT{next\_\EOL line\_\EOL number},
and no further use of \TT{istream} is made on this or subsequent calls to
\TT{min::\EOL next\_\EOL line}.  In this case
a partial line may have been
produced at the end of \TT{buffer}.

If \TT{min::\EOL next\_\EOL line} returns
\TT{min::\EOL NO\_\EOL LINE}, the file may or may not be complete.
Certain files have the `\key{completeness property}', which means
that \TT{min::\EOL next\_\EOL line} returns
\TT{min::\EOL NO\_\EOL LINE} only if the file is complete.
A file with a non-\TT{NULL} \TT{istream} has the completeness property.

If the \TT{ifile} member of the file is not
\TT{min::\EOL NULL\_\EOL STUB}, instead of the \TT{istream} member
being non-\TT{NULL},
\TT{min::\EOL next\_\EOL line} gets
more characters by calling
\TT{min::\EOL next\_\EOL line(ifile)} instead of by using
\TT{istream}.  Characters in partial lines of \TT{ifile}
are also gotten when they become available,
and the file is completed when \TT{ifile} becomes complete.
The file has the completeness property only if \TT{ifile} has
this property.

The paritial line (\pagref{PARTIAL-LINE}) that may end the file when
\TT{min::\EOL next\_\EOL line} returns \TT{min::\EOL NO\_\EOL LINE}
can be returned by the functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::REMAINING_OFFSET} \\
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::REMAINING_LENGTH} \\
\end{tabular}\end{indpar}

The \TT{min::\EOL remaining\_\EOL length}
function returns \TT{ buffer->\EOL length - next\_\EOL offset},
the total number of partial line bytes, and
the \TT{min::\EOL remaining\_\EOL offset} function returns
\TT{next\_\EOL offset},
the offset in the file buffer of the first of these bytes.
Note that these bytes do \underline{not} end with \TT{NUL}.
After processing these bytes, the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{skip\_\EOL remaining} \verb|( min::file file )|
\LABEL{MIN::SKIP_REMAINING} \\
\end{tabular}\end{indpar}

can be used to set \TT{next\_\EOL offset}
to be equal to \TT{buffer->\EOL length} in order to
prevent reprocessing the bytes.

The \TT{min::skip\_remaining} function can have an undesirable
interaction with the use of the two argument \TT{min::\EOL end\_\EOL line}
function (see below) to
make an initial segment of a partial line into a complete line.
It also affects the next
call to \TT{min::\EOL next\_\EOL line}; specifically, if remaining
bytes are skipped, then added to and made into a complete line,
the next call to \TT{min::\EOL next\_\EOL line} will return that line as if
it consisted of only of the non-skipped characters that were added
after the call to \TT{min::\EOL skip\_\EOL remaining}.

At any time the complete partial line at the end of the file, including
bytes skipped over by \TT{min::\EOL skip\_\EOL remaining}, can be
accessed by the functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_OFFSET} \\
\end{tabular}\end{indpar}

The \TT{min::\EOL partial\_\EOL length}
function returns \TT{ buffer->\EOL length - end\_\EOL offset},
the total number of partial line bytes, and
the \TT{min::\EOL partial\_\EOL offset} function returns
\TT{end\_\EOL offset},
the offset in the file buffer of the first of these bytes.
Note that these bytes do \underline{not} end with \TT{NUL}.

If the end of the \TT{buffer} contains a partial line,
the following function may be used to split this into
a complete line possibly followed by a shorter partial line:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::END_LINE_FILE_WITH_OFFSET} \\
\end{tabular}\end{indpar}

This function sets \TT{buffer[offset]} to NUL, overwriting
any previous \TT{char} value of this buffer element, and
making this element the line-terminating \TT{NUL} for an initial segment
of the partial line at the end of the buffer.  The remainder of
the partial line, if there is any, becomes the new partial line at the
end of the buffer.

Note that a partial line \underline{cannot}\label{SKIP_REMAINING_END_LINE}
be split using the
last function if \TT{min::\EOL skip\_\EOL remaining}
(\pagref{MIN::SKIP_REMAINING}) has been used to skip past the
\TT{offset} point where the \TT{NUL} would be written.

A main reason why the \TT{min::file} type exists is to allow lines
previously returned by \TT{min::\EOL next\_\EOL line} to be retrieved
so they can be printed in error messages.
The following function does this:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{line}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number )|
\LABEL{MIN::LINE_OF_FILE} \\
\end{tabular}\end{indpar}

Here \TT{line\_number} is \TT{0} for the first line of the file,
\TT{line\_index} must exist (i.e., not be \TT{NULL\_\EOL STUB}),
and
\begin{center}\begin{tabular}{rl}
       & \tt file->next\_line\_number - file->line\_index->length \\
\tt <= & \tt line\_number \\
\tt < & \tt file->next\_line\_number
\end{tabular}\end{center}
is required.  If these conditions are not met, \TT{min::\EOL line}
returns \TT{min::\EOL NO\_\EOL LINE}.

Whether\label{LINE-INDEX-LENGTH}
the required conditions are met depends upon
the setting of \TT{spool\_\EOL lines}
and any use of the \TT{min::\EOL flush\_\EOL spool} or \TT{min::rewind}
functions which are described below.

If \TT{spool\_\EOL lines} equals \TT{0},
\TT{line\_\EOL index} does not exist, and \TT{min::\EOL line}
always returns \TT{min::\EOL NO\_\EOL LINE}.
 If \TT{spool\_\EOL lines} equals
\verb|min::|\MINKEY{ALL\_\EOL LINES}, the default argument setting
for all \TT{min::\EOL init\_\EOL input\ldots} functions,
then all lines
previously returned by \TT{min::\EOL next\_\EOL line} are always available,
\TT{line\_\EOL index->\EOL length} always equals
\TT{next\_\EOL line\_\EOL number},
and the above requirement reduces to
\begin{center}
\tt 0 <= line\_number < file->next\_line\_number
\end{center}

For other values of \TT{spool\_\EOL lines}, which are useful
if a very long input file is being read and some ability to
look back a short ways is desired,
\TT{line\_\EOL index} exists and
\TT{line\_\EOL index->\EOL length} is a function of the history
of calls to the \TT{min::rewind} function (see below)
and to the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{flush\_spool\RESIZE}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number = min::NO_LINE )|
\LABEL{MIN::FLUSH_SPOOL} \\
\end{tabular}\end{indpar}

Provided \TT{spool\_\EOL lines > 0},
this function deletes lines from the file buffer
if there are more than \TT{spool\_\EOL lines}
lines before the line of the given \TT{line\_\EOL number} in the buffer.
In this case all lines before the one with number
\begin{center}
\tt max ( line\_number - spool\_lines, 0 )
\end{center}
are deleted from \TT{file->\EOL buffer} and \TT{file->\EOL line\_\EOL index}.
If the \TT{line\_\EOL number}
argument is omitted or equivalently given as \TT{min::\EOL NO\_\EOL LINE},
it is replaced by \TT{next\_\EOL line\_\EOL number}.
It is required that
\begin{center}
\tt 0 <= line\_number <= file->next\_line\_number
\end{center}
but it is never a programming error if \TT{line\_\EOL number} is within
this range, even if no lines are deleted and even if \TT{spool\_\EOL lines}
is \TT{0} (and therefore \TT{line\_\EOL index} does not exist).

It is possible to `rewind' a file with the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{rewind}\ARGBREAK
	\verb|( min::file file,|\ARGBREAK
	\verb|  min::uns32 line_number = 0 )|
\LABEL{MIN::REWIND_FILE} \\
\end{tabular}\end{indpar}

This resets the next line that will be returned by
\TT{min::\EOL next\_\EOL line} to some previously
returned line.  The file \TT{buffer} is not changed, but
the file \TT{line\_\EOL index}, if it exists, may be truncated.

\TT{min::rewind(n)} is in error if
\TT{min::line(n)} would return \TT{min::\EOL NO\_\EOL LINE},
(so line number \TT{n} has no entry in the file \TT{line\_\EOL index}),
except for two special cases.
The first special case is when \TT{n == next\_\EOL line\_\EOL number},
in which case \TT{min::\EOL rewind(n)} does nothing.
The second special case is when \TT{n == 0} (the default)
and also \TT{spool\_\EOL lines == 0} (so that no lines have ever been
deleted from the file), in which case the file is reset so the next
line returned will be the first line of the file.

Normally rewind with \TT{n > 0} is only
used with files whose \TT{spool\_\EOL length == min::\EOL ALL\_\EOL LINES},
which eliminates the possibility of error.

The following function is used to copy or `flush' the lines in a file
to any \TT{ostream}, \TT{ofile}, and/or \TT{printer}
that the file has

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  bool copy_completion = true )|
\LABEL{MIN::FLUSH_FILE} \\
\end{tabular}\end{indpar}

This function first calls \TT{min::next\_line} repeatedly
for the file, and flushes each line returned by that function.
Then it flushes any partial line left over at the end of the
file, and calls \TT{min::\EOL skip\_\EOL remaining}
(\pagref{MIN::SKIP_REMAINING}) to skip over this partial line
(so it will be invisible to subsequent calls to
\TT{min::\EOL next\_\EOL line}).
Lastly, if the \TT{copy\_\EOL completion} argument is \TT{true},
if the file is complete, and
if the file has an \TT{ofile}, the \TT{min::\EOL complete\_\EOL file}
function is called for \TT{ofile} to mark that file as being complete.

The flushing sub-actions of \TT{min::flush\_file} are available by using
the following functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::FLUSH_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{flush\_remaining\RESIZE} \verb|( min::file file )|
\LABEL{MIN::FLUSH_REMAINING} \\
\end{tabular}\end{indpar}

\TT{min::flush\_line} copies the line beginning at the given offset
to any \TT{ostream}, \TT{ofile},
and/or \TT{printer},
while \TT{min::\EOL flush\_\EOL remaining} copies any remaining
bytes in the partial line
at the end of the file
to any \TT{ostream}, \TT{ofile}, and/or
\TT{printer}.
Note that neither of these functions calls \TT{min::\EOL next\_\EOL line},
\TT{min::\EOL skip\_\EOL remaining}, or \TT{min::\EOL complete\_\EOL file}.

\underline{None} of
the \TT{min::\EOL flush\_file/\EOL line/\EOL remaining}
functions call \TT{min::\EOL flush\_\EOL spool}.

The following \TT{<<} operators do the same thing as
\TT{min::\EOL flush\_\EOL file} with a \TT{false} \TT{copy\_\EOL complete}
argument, except that, instead of copying
to the file's \TT{ostream}, \TT{ofile}, and/or
\TT{printer}, they copy to their lefthand operand:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<<}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{OSTREAM_OPERATOR<<_OF_FILE} \\
\verb|min::file |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::file ofile,|\ARGBREAK
      \verb|  min::file ifile )|
\LABEL{FILE_OPERATOR<<_OF_FILE} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{PRINTER_OPERATOR<<_OF_FILE} \\
\end{tabular}\end{indpar}

Note that these \TT{<<} operators call the \TT{min::\EOL next\_\EOL line}
and \TT{min::\EOL skip\_\EOL remaining} functions in the same way as
\TT{min::\EOL flush\_\EOL file} does, and therefore
these \TT{<<} operators interact with each other and with the
\TT{min::\EOL flush\_\EOL file} function.  Generally such interaction
is avoided by using only one of the \TT{<<} operators or only
the \TT{min::\EOL flush\_\EOL file} function on a given file.
Also note that the \TT{<<} operators never
call \TT{min::\EOL complete\_\EOL file}.

\subsection{Identifier Maps}
\label{IDENTIFIER-MAPS}

\ikey{Identifier Maps}{identifier map} are used on input/output
to translate \TT{const min::\EOL stub~*} pointers to small unsigned
integer \smkey{identifier}s{in identifier map} that can be used
as surrogates for the pointers in external files.
A \TT{min::\EOL id\_\EOL map} is a packed vector with
\TT{const min::\EOL stub~*} elements such that index of an element
in the vector is the identifier of the element value.
This identifier may appear in files as \TT{@}{\em index}.

The stub pointers that can appear in an identifier map can point at
objects, packed structures, packed vectors, labels, and longer strings.
They may not point at strings with 8 or fewer bytes or at numbers,
because implementations are possible in which these do not have stubs.

Creation and use of id maps is accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_vec_ptr|\ARGBREAK
	  \verb|    < const min::stub *,|\ARGBREAK
	  \verb|      min::id_map_header<min::uns32> >|\ARGBREAK
	  \verb|min::|\MINKEY{id\_\EOL map}
\LABEL{MIN::ID_MAP} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::id_map min::| & \MINKEY{init\REL}
    \verb|( min::ref<min::id_map> map )|
\LABEL{MIN::INIT_OF_ID_MAP} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::stub * map| & \TTBMKEY{id}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_[]} \\
\verb|const min::uns32 map->| & \TTMKEY{length}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_LENGTH} \\
\verb|min::uns32 map->| & \TTMKEY{occupied}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_OCCUPIED} \\
\verb|min::uns32 map->| & \TTMKEY{next}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_NEXT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{find\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  const min::stub * s )|
\LABEL{MIN::FIND_OF_ID_MAP} \\
\verb|min::uns32 min::| & \MINKEY{find\_\EOL or\_\EOL add\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  const min::stub * s )|
\LABEL{MIN::FIND_OR_ADD_OF_ID_MAP} \\
\verb|void min::| & \MINKEY{insert\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  const min::stub * s,|\ARGBREAK
    \verb|  min::uns32 id )|
\LABEL{MIN::INSERT_OF_ID_MAP} \\
\end{tabular}\end{indpar}

An identifier map maintains a 1-1 correspondence between
\TT{const min::\EOL stub~*}
pointers and small strictly positive \TT{min::\EOL uns32} identifiers.
If \TT{map} is a \TT{min::\EOL id\_\EOL map},
and \TT{(s,id)} is a correspondence stored in \TT{map} between
a pointer \TT{s} and an identifier \TT{id}, then
\begin{center}
\tt
s == map[id] \\
id == min::find ( map, s )
\end{center}

If \TT{id >= map->length} or if \TT{map[id]} is
\TT{NULL\_\EOL STUB}, then \TT{id} is not in any correspondence
stored in the map.

The identifier value \TT{0} denotes a missing identifier,
and cannot be part of the
correspondence stored in an identifier map.
If \TT{min::\EOL find} returns \TT{0}, then \TT{s} is not
in any correspondence stored in the map.


The \TT{min::init} function may be used to create or reset a \TT{map}
so that \TT{map->length == 1}.  \TT{map[0]} is set to equal
\TT{min::\EOL NULL\_\EOL STUB}, and this \TT{map} element cannot
be changed.

If identifiers are being output, the \TT{min::find\_\EOL or\_\EOL add}
function can be used to find the identifier of a stub.  If \TT{s} is already
in the \TT{map}, its associated identifier is returned.  Otherwise \TT{s}
is pushed to the end of the \TT{map} vector and assigned an identifier which
is returned.  However, as a special case,
\TT{min::\EOL find\_\EOL or\_\EOL add} returns
\TT{0} if \TT{s} is \TT{min::\EOL NULL\_\EOL STUB}.

When a stub is to be output, \TT{min::\EOL find\_\EOL and\_\EOL add}
may assign it an identifier so it can be
output as `\TT{@}{\em identifier}', without the stub contents having been
output.  Then later the stub contents must be output, usually in a line of the
form
\begin{center}
\TT{@}{\em identifier} \TT{=} {\em stub-contents}
\end{center}
In this context stub contents are usually output by such lines in order of
their identifiers, smallest identifier first, with the identifier
map member \TT{next} recording the smallest identifier which has
not yet been output.  This member is writable and can be updated
when a stub's contents are printed.

If identifiers are being input, \TT{map[id]} can be used to find the stub
associated with \TT{id}, unless there is no such stub.
If there is no stub associated with \TT{id}, a stub \TT{s}
can be created and inserted into the map with the \TT{min::\EOL insert}
function, which will increase the length of the map if necessary to
accomodate \TT{id}.

The \TT{min::find} function is not needed for either input or output.
It merely returns the identifier associated with a stub \TT{s} if one exists,
or returns \TT{0} if no such identifier exists.
\TT{min::\EOL find} also returns
\TT{0} if \TT{s} is \TT{min::\EOL NULL\_\EOL STUB}.

Part of an identifier map is a hash table that permits
\TT{min::\EOL find\ldots} functions to work quickly.  This
hash table is created by the first call to a
\TT{min::\EOL find\ldots} function.
The hash table, if it exists, is maintained by \TT{min::\EOL insert}
and \TT{min::\EOL find\_\EOL and\_\EOL add},
unless the hash table has become too small to be efficient, in which case
these functions discard it so a larger hash table will be created
by the next call to a \TT{min::\EOL find\ldots} function.
The \TT{map->\EOL occupied} member of the map records the number of
\TT{map} vector elements that are not \TT{min::\EOL NULL\_\EOL STUB},
that is, the number of associations recorded in the map, and this is used
to determine the proper size of the hash table.

\subsection{Printers}
\label{PRINTERS}

A \key{printer} may be used to print general values, print graphics for
control characters, and break long lines to enforce line length.
Internally a \TT{min::\EOL printer} is
a packed structure that points at a \TT{min::\EOL file} and contains
additional information used to format lines put into the file.
Values are written to printers via the \TT{<<} operator, much like the
way values are written to \TT{std::\EOL ostream}'s.  A special
printer line end operation writes a line terminating \TT{NUL}
at the end of the printer file buffer, and optionally flushes the file.

The MIN system has a per-thread printer to hold error messages:
\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::locatable_var<min::printer> min::| & \MINKEY{error\_\EOL message}
\LABEL{MIN::ERROR_MESSAGE}%
\label{ERROR_MESSAGE} \\
\end{tabular}\end{indpar}

This functions like \TT{errno} in UNIX, but
holds multi-line error messages instead of an integer error
code.  The protocol for writing
an error message into this printer is to first apply
the 1-argument \TT{min::init} function to the printer to create the printer
if necessary, remove any previous message from the printer,
and put the printer into a default state,
and then write an error message consisting of one or more
complete lines to the printer.  The following code is often
used to do this:\label{ERROR_MESSAGE_EXAMPLE}
\begin{indpar}\begin{verbatim}
# define ERR min::init ( min::error_message )
...
if ( error-occurred )
{
    ERR << ... << min::eol;
    return value-indicating-error-occurred;
}
...
\end{verbatim}\end{indpar}

Creation and initialization of printers is
accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::printer_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{printer}
\LABEL{MIN::PRINTER} \\
\verb|min::printer min::| & \MINKEY{init\REL}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  min::file file = min::NULL_STUB )|
\LABEL{MIN::INIT_OF_PRINTER} \\
\verb|min::printer min::| & \MINKEY{init\_ostream\RESIZE}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_PRINTER} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::file printer->| & \TTMKEY{file}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_FILE} \\
\verb|std::ostream * printer->| & \TTMKEY{ostream}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_OSTREAM} \\
\end{tabular}\end{indpar}

The \TT{min::}\MINKEY{init} function both re-initializes existing
printers and creates new ones.  It takes a variable as its
first argument, and if the variable value is \TT{min::\EOL
NULL\_\EOL STUB}, then a new printer is created and the
variable is set to point at the new printer.
The second argument to \TT{min::init} supplies the \TT{min::file}
to which the printer is attached.  If this argument is
\TT{min::\EOL NULL\_\EOL STUB}, then \TT{min::\EOL init\_\EOL input}
is applied to \TT{printer->file} to create that file if necessary
and empty it if it already exists; but if the argument is
not \TT{min::\EOL NULL\_\EOL STUB} then \TT{printer->file} is set
to the argument and the file is \underline{not} emptied or changed.

The \TT{min::}\MINKEY{init\_\EOL ostream}
function just executes
\begin{indpar}\begin{verbatim}
min::init ( printer );
min::init_ostream ( printer->file, ostream );
printer << min::eol_flush;
\end{verbatim}\end{indpar}

which is a very common way of setting up a printer.

Both initialization functions return the printer, which is
sometimes convenient, as in the code often used 
with \TT{min::\EOL error\_\EOL message}: see \pagref{ERROR_MESSAGE_EXAMPLE}.

Parameterization of the printing process is accomplished using the
following printer parameters:

\begin{indpar}[1em]\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct    min::| & \MINKEY{line\_\EOL break}
\LABEL{MIN::LINE_BREAK_STRUCT} \\
\verb|{              | \\
\verb|    min::uns32 | & \TTMKEY{offset}{in {\tt min::line\_break}}
			   & \verb|// Default 0|
\LABEL{MIN::OFFSET_IN_LINE_BREAK} \\
\verb|    min::uns32 | & \TTMKEY{column}{in {\tt min::line\_break}}
			   & \verb|// Default 0|
\LABEL{MIN::COLUMN_IN_LINE_BREAK} \\
\verb|    min::uns32 | & \TTMKEY{line\_length}{in {\tt min::line\_break}}
			   & \verb|// Default 72|
\LABEL{MIN::LINE_LENGTH_IN_LINE_BREAK} \\
\verb|    min::uns32 | & \TTMKEY{indent}{in {\tt min::line\_break}}
			   & \verb|// Default 4|
\LABEL{MIN::INDENT_IN_LINE_BREAK} \\
\verb|}              | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 printer->| & \TTMKEY{column}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_COLUMN} \\
\verb|const min::line_break printer->|
    & \TTMKEY{line\_break}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK} \\
\verb|const min::line_break min::|
    & \TTKEY{default\_\EOL line\_\EOL break}
\LABEL{MIN::DEFAULT_LINE_BREAK} \\
\verb|const min::packed_vec_insptr<min::line_break>  | \\
\verb|printer->|
    & \TTMKEY{line\_break\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK_STACK} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rll}
\verb|struct              min::| & \MINKEY{print\_\EOL format}
	& \verb|// Defaults:|
\LABEL{MIN::PRINT_FORMAT_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns32   |
	& \TTMKEY{op\_flags}{in {\tt min::print\_format}}
	& \verb|// min::EXPAND_HT|
\LABEL{MIN::OP_FLAGS_IN_PRINT_FORMAT} \\
\verb|            min::uns32 * |
	& \TTMKEY{char\_flags}{in {\tt min::print\_format}}
	& \verb|// min::standard_| \\
      & & \verb|//   char_flags|
\LABEL{MIN::CHAR_FLAGS_IN_PRINT_FORMAT} \\
\verb|     min::support_control|
	& \TTMKEY{support\_control}{in {\tt min::print\_format}}
        & \verb|// min::latin1_| \\
      & & \verb|//   support_control|
\LABEL{MIN::SUPPORT_CONTROL_IN_PRINT_FORMAT} \\
\verb|     min::display_control|
	& \TTMKEY{display\_control}{in {\tt min::print\_format}}
        & \verb|// min::graphic_and_space| \\
      & & \verb|//   display_control|
\LABEL{MIN::DISPLAY_CONTROL_IN_PRINT_FORMAT} \\
\verb|       min::break_control|
	& \TTMKEY{break\_control}{in {\tt min::print\_format}}
        & \verb|// min::break_after_space| \\
      & & \verb|//   break_control|
\LABEL{MIN::BREAK_CONTROL_IN_PRINT_FORMAT} \\
\verb|  min::char_name_format *|
	& \TTMKEY{char\_name\_format}{in {\tt min::print\_format}}
        & \verb|// min::standard_| \\
      & & \verb|//   char_name_format|
\LABEL{MIN::CHAR_NAME_FORMAT_IN_PRINT_FORMAT} \\
\verb|        min::gen_format *|
	& \TTMKEY{gen\_format}{in {\tt min::print\_format}}
        & \verb|// min::top_gen_format|
\LABEL{MIN::GEN_FORMAT_IN_PRINT_FORMAT} \\
\verb|}                        | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::print_format printer->|
    & \TTMKEY{print\_format}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT} \\
\verb|const min::print_format min::|
    & \TTKEY{default\_\EOL print\_\EOL format}
\LABEL{MIN::DEFAULT_PRINT_FORMAT} \\
\verb|const min::packed_vec_insptr<min::print_format>  | \\
\verb|printer->|
    & \TTMKEY{print\_format\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT_STACK} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::id_map printer->|
    & \TTMKEY{\EOL id\_\EOL map}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP} \\
\verb|min::uns32 printer->|
    & \TTMKEY{\EOL id\_\EOL map->\EOL next}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP_NEXT} \\
\end{tabular}\end{indpar}

\TT{print\_format.op\_flags}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{EXPAND\_HT}
\LABEL{MIN::EXPAND_HT_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_EOL}
\LABEL{MIN::DISPLAY_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_PICTURE}
\LABEL{MIN::DISPLAY_PICTURE_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ON\_EOL}
\LABEL{MIN::FLUSH_ON_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ID\_MAP\_ON\_EOM}
\LABEL{MIN::FLUSH_ID_MAP_ON_EOM_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{NEXT\_IS\_LEADING}
\LABEL{MIN::NEXT_IS_LEADING_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{NEXT\_IS\_TRAILING}
\LABEL{MIN::NEXT_IS_TRAILING_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{AUTO\_SUPPRESS}
\LABEL{MIN::AUTO_SUPPRESS_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISABLE\_SUPPRESS}
\LABEL{MIN::DISABLE_SUPPRESS_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct              min::| & \MINKEY{support\_\EOL control}
\LABEL{MIN::SUPPORT_CONTROL_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns32   |
	& \TTMKEY{support\_mask}{in {\tt min::support\_control}}
\LABEL{MIN::SUPPORT_MASK_IN_SUPPORT_CONTROL} \\
\verb|            min::uns32   |
	& \TTMKEY{unsupport\_char\_flags}{in {\tt min::support\_control}}
\LABEL{MIN::UNSUPPORT_CHAR_FLAGS_IN_SUPPORT_CONTROL} \\
\verb|}                        | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|const min::support_control min::|%
    \MINKEY{ascii\_support\_control} \verb|=| \\
\verb|            { min::IS_ASCII, min::IS_UNSUPPORTED };|
\LABEL{MIN::ASCII_SUPPORT_CONTROL} \\
\verb|const min::support_control min::|%
    \MINKEY{latin1\_support\_control} \verb|=| \\
\verb|            { min::IS_LATIN1, min::IS_UNSUPPORTED };|
\LABEL{MIN::LATIN1_SUPPORT_CONTROL} \\
\verb|const min::support_control min::|%
    \MINKEY{support\_all\_support\_control} \verb|=| \\
\verb|            { 0xFFFF, min::IS_UNSUPPORTED };|
\LABEL{MIN::SUPPORT_ALL_SUPPORT_CONTROL} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct              min::| & \MINKEY{display\_\EOL control}
\LABEL{MIN::DISPLAY_CONTROL_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns16   |
	& \TTMKEY{display\_char}{in {\tt min::display\_control}}
\LABEL{MIN::DISPLAY_CHAR_IN_DISPLAY_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{display\_suppress}{in {\tt min::display\_control}}
\LABEL{MIN::DISPLAY_SUPPRESS_IN_DISPLAY_CONTROL} \\
\verb|}                        | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|const min::display_control min::|%
    \MINKEY{graphic\_and\_space\_display\_control} \verb|=| \\
\verb|            { min::IS_SP + min::IS_HT + min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_AND_SPACE_DISPLAY_CONTROL} \\
\verb|const min::display_control min::|%
    \MINKEY{graphic\_only\_display\_control} \verb|=| \\
\verb|            { HT + min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_ONLY_DISPLAY_CONTROL} \\
\verb|const min::display_control min::|%
    \MINKEY{graphic\_and\_vspace\_display\_control} \verb|=| \\
\verb|            { min::IS_SP + min::IS_HT + min::IS_GRAPHIC| \\
\verb|                         + min::IS_VSPACE, 0 };|
\LABEL{MIN::GRAPHIC_AND_VSPACE_DISPLAY_CONTROL} \\
\verb|const min::display_control min::|%
    \MINKEY{display\_all\_display\_control} \verb|=| \\
\verb|            { 0xFFFF, 0 };|
\LABEL{MIN::DISPLAY_ALL_DISPLAY_CONTROL} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct              min::| & \MINKEY{break\_\EOL control}
\LABEL{MIN::BREAK_CONTROL_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns16   |
	& \TTMKEY{break\_before}{in {\tt min::break\_control}}
\LABEL{MIN::BREAK_BEFORE_IN_BREAK_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{break\_after}{in {\tt min::break\_control}}
\LABEL{MIN::BREAK_AFTER_IN_BREAK_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{conditional\_break}{in {\tt min::break\_control}}
\LABEL{MIN::CONDITIONAL_BREAK_IN_BREAK_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{conditional\_columms}{in {\tt min::break\_control}}
\LABEL{MIN::CONDITIONAL_COLUMNS_IN_BREAK_CONTROL} \\
\verb|}                        | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|const min::break_control min::|%
    \MINKEY{no\_auto\_break\_break\_control} \verb|=| \\
\verb|            { 0, 0, 0, 0 };|
\LABEL{MIN::NO_AUTO_BREAK_BREAK_CONTROL} \\
\verb|const min::break_control min::|%
    \MINKEY{break\_after\_space\_break\_control} \verb|=| \\
\verb|            { min::IS_HSPACE, 0, 0, 0 };|
\LABEL{MIN::BREAK_AFTER_SPACE_BREAK_CONTROL} \\
\verb|const min::break_control min::|%
    \MINKEY{break\_before\_all\_break\_control} \verb|=| \\
\verb|            { 0, 0xFFFF, 0, 0 };|
\LABEL{MIN::BREAK_BEFORE_NON_SPACE_BREAK_CONTROL} \\
\verb|const min::break_control min::|%
    \MINKEY{break\_after\_hyphens\_break\_control} \verb|=| \\
\verb|            { min::IS_HSPACE, 0, min::BREAK_CONTROL, 4 };|
\LABEL{MIN::BREAK_AFTER_HYPHENS_BREAK_CONTROL} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct              min::|
    & \MINKEY{char\_\EOL name\_\EOL format}
\LABEL{MIN::CHAR_NAME_FORMAT_STRUCT} \\
\verb|{                        | \\
\verb|  const min::ustring *   |
	& \TTMKEY{char\_name\_prefix}{in {\tt min::char\_name\_format}}
\LABEL{MIN::CHAR_NAME_PREFIX_IN_CHAR_NAME_FORMAT} \\
\verb|  const min::ustring *   |
	& \TTMKEY{char\_name\_postfix}{in {\tt min::char\_name\_format}}
\LABEL{MIN::CHAR_NAME_POSTFIX_IN_CHAR_NAME_FORMAT} \\
\verb|}                        | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|const min::char_name_format min::|%
    \MINKEY{standard\_char\_name\_format} \verb|=| \\
\verb|            { (const min::ustring *) "\x01\x01<",| \\
\verb|              (const min::ustring *) "\x01\x01>" };|
\LABEL{MIN::STANDARD_CHAR_NAME_FORMAT} \\
\end{tabular}\end{indpar}

The basic algorithm for printing a UNICODE character \TT{c} is:

\begin{enumerate}

\item Compute character flags of \TT{c} (see \itemref{UNICODE-DATA-BASE}):%
\label{COMPUTE-CHARACTER-FLAGS}
\begin{indpar}\begin{verbatim}
min::uns16 cindex = min::Uindex ( c );
min::uns32 cflags = printer->print_format.char_flags[cindex];
\end{verbatim}\end{indpar}

\item Replace character flags \TT{cflags} if \TT{c} is unsupported:%
\label{REPLACE-CHARACTER-FLAGS}
\begin{indpar}\begin{verbatim}
min::support_control sc = printer->print_format.support_control;
if ( ( cflags & sc.support_mask ) == 0 )
    cflags = sc.unsupported_char_flags;
\end{verbatim}\end{indpar}

\item Compute printed representation of \TT{c}:%
\label{COMPUTE-PRINTED-REPRESENTATION}
\begin{indpar}\begin{verbatim}
min::display_control dc = printer->print_format.display_control;
if ( cflags & dc.display_char )
    // Character represents itself, but if c == '\t', c is
    // represented by a sequence of 8 - printer->column % 8
    // ' ' spaces if EXPAND_HT op_flag is on.
else if ( cflags & dc.display_suppress )
    // Ignore character and do not print it
else
    // Character is represented by min::unicode::picture[cindex]
    // if that is not NULL and DISPLAY_PICTURE op_flag is on;
    // else character is represented by <X> where < and > are
    // the printer->print_format.char_name_format prefix and
    // postfix, and X is min::unicode::name[cindex] if that is
    // not NULL, or is the character code in hexa-decimal with
    // a leading decimal digit (may be 0) otherwise.
\end{verbatim}\end{indpar}

Note that \TT{<FF>} represents the form feed character with (hex)
code \TT{0C}, while \TT{<0FF>} represents the
latin small letter y with diaeresis, with code \TT{FF}.

Note that only the low order 16 bits of \TT{cflags} are used
by a \TT{display\_control}.

\item Compute automatic break points for \TT{c}:%
\label{COMPUTE-AUTOMATIC-BREAK-POINTS}
\begin{indpar}\begin{verbatim}
min::break_control bc = printer->print_format.break_control;
if ( cflags & bc.break_after )
    set break after representative of c
if ( cflags & bc.break_before )
    set break before representative of c
if ( cflags & bc.conditional_break
     &&
        printer->column - printer->line_break.column
     >= bc.conditional_columns )
    set break after representative of c
\end{verbatim}\end{indpar}

Note that only the low order 16 bits of \TT{cflags} are used
by a \TT{break\_control}.

\end{enumerate}

The members of a printer may be read but \underline{not} written.
A complete list of these members follows:

\begin{itemlist}[0.8in]

\item[\ttmkey{file}{in {\tt min::printer}}]
The \TT{min::file} which contains the lines produced by the printer.
Initialized by the second argument of \TT{min::\EOL init}, if that is
not \TT{min::\EOL NULL\_\EOL STUB}, or otherwise created when the
printer is created.  Initialized by \TT{min::\EOL init(printer->\EOL file)}
except when 2-argument \TT{min::init} is called (see above).

\item[\ttmkey{column}{in {\tt min::printer}}]
The number of columns currently in the line being assembled,
which equals the column number of the next character to be input to the
printer.  The first column number is \TT{0}.  Initialized to \TT{0}.

\end{itemlist}

\begin{itemlist}[0.6in]

\item[\ttmkey{line\_\EOL break.column}{in {\tt min::printer}}]~\\
The column of the
first byte in the current line after the last break point in the line.
Initialized to \TT{0}.

\item[\ttmkey{line\_\EOL break.offset}{in {\tt min::printer}}]~\\
The \TT{file->buffer} index of the
first byte in the current line after the last break point in the line.
Initialized to \TT{0}.

\item[\ttmkey{line\_\EOL break.line\_length}{in {\tt min::printer}}]%
\label{LINE-LENGTH}~\\
Nominal maximum line length in columns.  Initialized to \TT{72}.

More specifically,
when a character representative other than a single space, a horizontal
tab, or a sequence of single spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed \TT{line\_\EOL break.line\_length}, then if
\begin{center}
\tt line\_break.column > line\_break.indent
\end{center}
a break, consisting of a line end followed by \TT{line\_break.indent}
spaces,
is inserted into the printer file buffer just after the break point
(i.e., is inserted at \TT{line\_\EOL break.offset}).

Single space and horizontal tab
characters immediately before the inserted line end are deleted.
After the break is inserted, \TT{line\_\EOL break.column} is reset to
the number of indentation spaces
and \TT{line\_\EOL break.offset} to the first position after
the inserted indentation spaces.

Break points may be inserted automatically by using
\TT{print\_format.break\_con\-trol}; see above.

If a non-empty \TT{line\_break\_stack} exists
because a \TT{min::\EOL save\_\EOL line\_\EOL break} or 
\TT{min::\EOL save\_\EOL indent} was executed,
then an element of the line break stack may provide overrides for the
\TT{column}, \TT{offset}, and
\TT{indent} members, but not the \TT{line\_\EOL length} member,
of \TT{printer->\EOL line\_\EOL break}.
See \pagref{LINE-BREAK-STACK} for details.

\item[\ttmkey{line\_\EOL break.indent}{in {\tt min::printer}}]~\\
Indention of a new line created by automatic break insertion.
Also used by the \TT{min::\EOL indent} operation (\pagref{MIN::INDENT}).
Initialized to \TT{4}.

Specifically, when
a line break is automatically pushed into a printer file buffer, the
break consists of a line end (\TT{NUL} character) followed by
\TT{line\_\EOL break.indent} single space characters.

\item[\ttmkey{line\_\EOL break\_\EOL stack}{in {\tt min::printer}}]~\\
Used with \TT{min::\EOL save\_\EOL line\_\EOL break} and
\TT{min::\EOL save\_\EOL indent} to set
multiple break points when printing nested lists.
See \pagref{LINE-BREAK-STACK} for details.
Initialized to an empty stack.

\end{itemlist}

\begin{itemlist}[0.6in]

\item[\ttmkey{print\_format.op\_flags}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_OP_FLAGS}~\\
These are printer \skey{operation flag}s that control printing.  When passed as
function arguments they are referred to as the
\TT{print\_\EOL op\_\EOL flags}.
The flags are listed immediately below.

\end{itemlist}

\begin{indpar}\begin{itemlist}[0.4in]

\item[\ttmkey{EXPAND\_HT}{in printer {\tt print\_\EOL format.op\_\EOL flags}}]
~\\
\TT{EXPAND\_HT} causes the character \TT{'\textbackslash t'}
to be represented by a sequence of single spaces when it is to be
displayed as `itself' (and not using its picture or name).
As tabs are set every 8 spaces, the number of single spaces is:
\begin{center}
\tt 8 - printer->column % 8
\end{center}

If \TT{EXPAND\_HT} is \underline{off} and the character \TT{'\textbackslash t'}
is to be displayed as `itself', the character represents itself, but its
width in columns is
\begin{center}
\tt 8 - printer->column % 8
\end{center}


\item[\ttmkey{DISPLAY\_EOL}%
               {in printer {\tt print\_\EOL format.op\_EOL flags}}]~\\
If this flag is on, the end of line prints as the
{\tiny $\stackrel{\textstyle N~}{~L}$}
picture character if
\TT{DISPLAY\_\EOL PICTURE} is on, and as the name \TT{NL} (e.g., in \TT{<NL>})
otherwise.

\item[\ttmkey{DISPLAY\_PICTURE}%
               {in printer {\tt print\_\EOL format.op\_EOL flags}}]~\\
If this flag is on, characters not displayed as themselves
are displayed as picture characters
using \TT{min::\EOL unicode::\EOL picture[cindex]} if this is not
\TT{NULL}, as per \pagref{COMPUTE-PRINTED-REPRESENTATION}.
Otherwise they are displayed using their name if that exists, or
using their hex code if no name exists.

\item[\ttmkey{FLUSH\_ON\_EOL}%
{in printer {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, a \TT{min::flush()} printer operation (\pagref{MIN::FLUSH})
is executed at the very end of each \TT{min::\EOL eol} operation.

\item[\ttmkey{FLUSH\_ID\_MAP\_ON\_EOM}%
    {in printer {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, a \TT{min::eom()} printer operation performs
a \TT{min::\EOL flush\_\EOL id\_\EOL map} operation
(\pagref{MIN::FLUSH_ID_MAP}) right after its
\TT{min::\EOL eol} operation.

\item[\ttmkey{NEXT\_IS\_LEADING}%
{in printer {\tt print\_\EOL format.op\_\EOL flags}}]
\item[\ttmkey{NEXT\_IS\_TRAILING}%
{in printer {\tt print\_\EOL format.op\_\EOL flags}}]%
\vspace{-1ex}~\\
These flags are set by the \TT{min::\EOL leading} and
\TT{min::\EOL trailing} printer operations to indicate the
the next string printed is a leading or trailing string,
repspectively.

\item[\ttmkey{AUTO\_SUPPRESS}%
    {in printer {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, each string output is checked to see if
it consists of nothing but characters with the \TT{min::\EOL IS\_\EOL LEADING}
character flag, and if yes, and if the last character output
to the printer is a single space, that single space is
in effect converted to a \TT{min::\EOL leading} printer
operation.  Similarly strings are
checked to see if they have nothing but characters with the
\TT{min::\EOL IS\_\EOL TRAILING} character flag, and if yes, and
if the last character output is a single space, 
the space is effectively converted to a
\TT{min::\EOL trailing} operation.

Note that a string containing a single space character will
not pass the checks: the whole string output by single printer
request is checked, and not just the part before the first
space character or after the last space character.

\item[\ttmkey{DISABLE\_SUPPRESS}%
    {in printer {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, \TT{min::leading} and \TT{min::trailing}
operations are disabled from their normal function and instead
simply output a single space character.

\end{itemlist}\end{indpar}

\begin{itemlist}[0.6in]

\item[\ttmkey{print\_format.char\_flags}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_CHAR_FLAGS}~\\
This is the vector of character flags indexed by UNICODE character
indices.
See `Compute character flags' above
(\pagref{COMPUTE-CHARACTER-FLAGS})
and Section~\itemref{COMPUTE-CHARACTER-FLAGS}.

\item[\ttmkey{print\_format.support\_control}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_SUPPORT_CONTROL}~\\
\label{SUPPORT-CONTROL}
This \TT{min::support\_control} controls which characters are supported
and which are not.  The \TT{support\_\EOL mask}
(e.g., \TT{min::\EOL IS\_\EOL LATIN1}) is bitwise AND'ed with
the character flags and if the result is zero, the character is unsupported
and its flags are replaced by the
\TT{unsupported\_\EOL char\_\EOL flags}
(e.g., \TT{min::\EOL IS\_\EOL UNSUPPORTED}).
See `Replace character flags \ldots{} if \ldots{} unsupported' above
(\pagref{REPLACE-CHARACTER-FLAGS}).

\item[\ttmkey{print\_format.display\_control}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_DISPLAY_CONTROL}~\\
This \TT{min::display\_control} controls which characters display as
themselves and which are suppressed (ignored and not printed).
The \TT{display\_\EOL char} mask
(e.g., \TT{min::\EOL IS\_\EOL SP + min::\EOL IS\_\EOL GRAPHIC})
is bitwise AND'ed with
the character flags and if the result is non-zero,
the character is displayed as itself.  Note however there may
be special processing in this case for the horizontal tab character.

If the character is \underline{not} to be displayed as itself, then
the \TT{display\_\EOL suppress} mask
(e.g., \TT{min::\EOL IS\_\EOL CONTROL})
is bitwise AND'ed with
the character flags and if the result is non-zero,
the character is suppressed (ignored).

If a character is not displayed as itself or suppressed, its picture
or name are used to represent it.

See `Compute character representation' above
(\pagref{COMPUTE-PRINTED-REPRESENTATION}) for details.

\item[\ttmkey{print\_format.break\_control}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_BREAK_CONTROL}~\\
This \TT{min::break\_control} controls when breaks are automatically
inserted into the output (see \TT{min::\EOL set\_\EOL break},
\pagref{MIN::SET_BREAK}).

The \TT{break\_\EOL after} mask
(e.g., \TT{min::\EOL IS\_\EOL SP + min::\EOL IS\_\EOL HT})
is bitwise AND'ed with
the character flags and if the result is non-zero,
a break is inserted `after the character representative', or
more precisely, a break is inserted before the representative
of the next character if that character is not having
a break automatically inserted after it..

The \TT{break\_\EOL before} mask
(e.g., \TT{0xFFFF})
is bitwise AND'ed with
the character flags and if the result is non-zero,
a break is inserted before the character representative.

The \TT{conditional\_\EOL break} mask\label{CONDITIONAL-BREAK}
(e.g., \TT{min::\EOL CONDITIONAL\_\EOL BREAK}, set for the hyphen \TT{'-'})
is bitwise AND'ed with
the character flags and if the result is non-zero,
\underline{and} if
\begin{center}
\tt printer->column - printer->line\_break.column >= condition\_columns
\end{center}
a break is inserted `after the character representative' in the
same manner as for \TT{break\_\EOL after}.

See `Compute automatic break points' above
(\pagref{COMPUTE-AUTOMATIC-BREAK-POINTS}) for details.

\item[\ttmkey{print\_format.char\_name\_format}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_CHAR_NAME_FORMAT}~\\
This defines the prefix and suffix on character names and
codes: e.g., provides the prefix \TT{<} and suffix \TT{>} for
the representative \TT{<FF>} of a form feed character.

\item[\ttmkey{print\_format.gen\_format}{in {\tt min::printer}}]~\\
This controls the printing of
\TT{min::gen} values as described in Section \itemref{PRINTING-GENERAL-VALUES}.

\item[\ttmkey{print\_\EOL format\_\EOL stack}{in {\tt min::printer}}]~\\
Used with \TT{min::save\_print\_format} and
\TT{min::\EOL restore\_\EOL print\_\EOL format} to save and
restore the \TT{print\_\EOL format} parameters.
See \pagref{PRINT-FORMAT-STACK} for details.
Initialized to an empty stack.

\item[\ttmkey{id\_\EOL map}{in {\tt min::printer}}]~\\
Used to find or create identifiers when printing values with stubs
and \TT{min::gen} values that contain stub pointers.
See \itemref{IDENTIFIER-MAPS} and
\TT{flush\_\EOL id\_\EOL map} (\pagref{MIN::FLUSH_ID_MAP}).

\end{itemlist}

Copying characters into a printer is done by the
\TT{<<} operator:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, const char * s )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR_*} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::ptr<const char> s )|
\LABEL{PRINTER_OPERATOR<<_OF_PTR_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::str_ptr const & s )|
\LABEL{PRINTER_OPERATOR<<_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, char c )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int32 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int64 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns32 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns64 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::float64 f )|
\LABEL{PRINTER_OPERATOR<<_OF_FLOAT64} \\
\end{tabular}\end{indpar}

A `\TT{const char *}' is interpreted as a UTF-8 encoded
string of UNICODE characters as per
\TT{min::\EOL utf8\_\EOL to\_\EOL unicode}, \pagref{MIN::UTF8_TO_UNICODE}.
However, a `\TT{const char *}' cannot be an unprotected body pointer,
as the body it points into may be relocated during the execution of the
\TT{<<\RESIZE} operator on a printer.
A `\TT{min::\EOL ptr<char>}' value can be used
instead as a pointer to a `\TT{const char *}' string inside a body.
And a `\TT{min::\EOL str\_\EOL ptr}' can be used instead to
point at the contents of a string \TT{min::gen} value.

\ikey{Horizontal tabs}{horizontal tab} are set every 8 columns.
When a horizontal tab is to be copied to the printer buffer, then if
the \TT{min::\EOL EXPAND\_\EOL HT} printer operation flag is on,
the horizontal tab is converted to between 1 and 8 single space characters.
But if the flag is off, the horizontal character itself is copied.
In either case the printer column is adjusted to the next multiple of 8.

When a \ttkey{NUL} is to be copied into a printer file buffer,
it is encoded as the overlong UTF-8 encoding \TT{0xC0},\TT{0x80}.

Values of types other than `\TT{const char *}'
which are presented to \TT{<<} are converted to `\TT{const char~*}' strings
as follows:
`\TT{char}' converts to a 1-\TT{char} string whose only element
is the \TT{char} value.  Numbers are converted by \TT{printf}
formats as follows:
\begin{center}
\tt
\begin{tabular}{l@{~~~~~~~~~~}l}
min::uns32	& "\%u" \\
min::uns64	& "\%llu" \\
min::int32	& "\%d" \\
min::int64	& "\%lld" \\
min::float64	& "\%.15g" \\
\end{tabular}
\end{center}

Operations can be performed on printers by applying the
\TT{<<} operator to a \TT{min::}\MINKEY{op}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}{of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::op const & op )|
\LABEL{OPERATOR<<_OF_PRINTER_OP} \\
\end{tabular}\end{indpar}

Operations behave for printers as \TT{iomanip}
C++ objects behave for \TT{iostreams}.  For example, the
printer analog of \TT{std::\EOL endl} is the \key{end of line}
operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{eol}
\LABEL{MIN::EOL} \\
\end{tabular}\end{indpar}

which inserts a line end into the output and then executes a
flush operation if the \TT{min::\EOL FLUSH\_\EOL ON\_\EOL EOL} printer
operation flag is set.

The flush operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{flush}
\LABEL{MIN::FLUSH} \\
\end{tabular}\end{indpar}

just executes
\begin{indpar}\begin{verbatim}
min::flush_file ( printer->file );
\end{verbatim}\end{indpar}

The \key{beginning of line} operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{bol}
\LABEL{MIN::BOL} \\
\end{tabular}\end{indpar}

executes \TT{min::eol} if and only if the printer is \underline{not}
already at the beginning of a line.

A {\ldots{} \tt << printer} operation can be used to
flush the contents of \TT{printer->\EOL file} into
an \TT{std::\EOL ostream}, a \TT{min::\EOL file}, or
into another \TT{min::\EOL printer}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<<}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{OSTREAM_OPERATOR<<_OF_PRINTER} \\
\verb|min::file |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{FILE_OPERATOR<<_OF_PRINTER} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer oprinter,|\ARGBREAK
      \verb|  min::printer iprinter )|
\LABEL{PRINTER_OPERATOR<<_OF_PRINTER} \\
\end{tabular}\end{indpar}

In general {\ldots{} \tt << printer} is equivalent to
{\ldots{} \tt << printer->file} (see \pagref{OSTREAM_OPERATOR<<_OF_FILE}).

A single UNICODE character \TT{c}, or a string of UNICODE characters
\TT{str} of a given \TT{length},
can be printed using the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{punicode} \verb|( min::Uchar c )|
\LABEL{MIN::PUNICODE} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  const min::Uchar * str )|
\LABEL{MIN::PUNICODE_BUFFER} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  min::ptr<const min::Uchar> str )|
\LABEL{MIN::PUNICODE_BUFFER_PTR} \\
\end{tabular}\end{indpar}

Here it must be remembered that a `\TT{const min::uns32~*}' pointer
\TT{str} must not be relocatable.

Numbers may be formatted by specified \TT{printf} formats and the results
printed by using the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{pint}\ARGBREAK
	  \verb|( min::int64 i,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PINT} \\
\verb|min::op min::|
    & \MINKEY{puns}\ARGBREAK
	  \verb|( min::uns64 u,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PUNS} \\
\verb|min::op min::|
    & \MINKEY{pfloat}\ARGBREAK
	  \verb|( min::float64 f,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PFLOAT} \\
\end{tabular}\end{indpar}

\TT{min::gen} values may be printed under the control of a
\TT{min::\EOL gen\_\EOL format}.  As printing objects
can be complex, printing \TT{min::gen} values is
described in the separate Section~\itemref{PRINTING-GENERAL-VALUES}.

Sometimes it is desirable to find out how many columns a
Modified UTF-8 string would take if printed.
For the horizontal tab character,
this depends upon the column the character is printed in.
So the following function updates a \TT{column} variable
whose initial value is that of \TT{printer->column}
before the string is printed
and whose final value is \TT{printer->\EOL column}
after the string is printed.

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{pwidth}\ARGBREAK
         \verb|( min::uns32 & column,|\ARGBREAK
         \verb|  const char * s, min::unsptr n,|\ARGBREAK
         \verb|  min::uns32 print_op_flags,|\ARGBREAK
         \verb|  const min::print_format & print_format )|
\LABEL{MIN::PWIDTH_OF_STRING} \\
\end{tabular}\end{indpar}

This function updates `\TT{column}' to what it would be if
the \TT{n} byte string \TT{s} were printed with the given
\TT{print\_\EOL format} modified by replacing
\TT{print\_\EOL format.op\_\EOL flags}
by the \TT{print\_\EOL op\_\EOL flags} argument value.
Here \TT{s} may be relocatable, as the \TT{min::\EOL pwidth}
function does not allocate or resize objects.

\subsubsection{Adjusting Printer Parameters}
\label{ADJUSTING-PRINTER-PARAMETERS}

The format parameters of a printer may be saved in the
\ttmkey{print\_\EOL format\_\EOL stack}{in {\tt min::printer}}%
\label{PRINT-FORMAT-STACK}
of the printer, and restored from that stack.
This may be done by the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{save\_print\_format}
\LABEL{MIN::SAVE_PRINT_FORMAT} \\
\verb|const min::op min::|
    & \MINKEY{restore\_print\_format}
\LABEL{MIN::RESTORE_PRINT_FORMAT} \\
\end{tabular}\end{indpar}

\TT{min::save\_print\_format}
pushes into the format stack a new element containing
the current \TT{print\_\EOL format}, while
\TT{min::\EOL restore\_\EOL print\_\EOL format}
resets \TT{print\_\EOL format} from the top format stack element and then
pops this element from the stack.

Some printer parameters may be set
by the following printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{set\_\EOL line\_length} \verb|( min::uns32 line_length )|
\LABEL{MIN::SET_LINE_LENGTH} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL indent} \verb|( min::uns32 indent )|
\LABEL{MIN::SET_INDENT} \\
\verb|min::op min::|
    & \MINKEY{set\_print\_op\_flags} \verb|( min::uns32 print_op_flags )|
\LABEL{MIN::SET_PRINT_OP_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{clear\_print\_op\_flags} \verb|( min::uns32 print_op_flags )|
\LABEL{MIN::CLEAR_PRINT_OP_FLAGS} \\
\end{tabular}\end{indpar}

\TT{min::\EOL set\_\EOL print\_\EOL op\_\EOL flags} logically OR's
its argument into \TT{print\_\EOL format.op\_\EOL flags} and
\TT{min::\EOL clear\_\EOL print\_\EOL op\_\EOL flags} logically AND's
the bitwise complement of its argument into
\TT{print\_\EOL format.op\_\EOL flags}
(recall that \TT{print\_\EOL format.op\_\EOL flags} are referred to as
\TT{print\_\EOL op\_\EOL flags} when used as arguments to functions).
For example, 
\begin{center}
\tt printer<<min::set\_print\_op\_flags(min::DISPLAY\_PICTURE)
\end{center}
sets the \TT{min::DISPLAY\_PICTURE} flag of
\TT{printer->\EOL print\_\EOL format.op\_\EOL flags}.

Particular \TT{print\_format.op\_flags} may be set and cleared by the
following printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{expand\_ht}
\LABEL{MIN::EXPAND_HT} \\
\verb|const min::op min::| & \MINKEY{noexpand\_ht}
\LABEL{MIN::NOEXPAND_HT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{display\_eol}
\LABEL{MIN::DISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_eol}
\LABEL{MIN::NODISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{display\_picture}
\LABEL{MIN::DISPLAY_PICTURE} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_picture}
\LABEL{MIN::NODISPLAY_PICTURE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{flush\_on\_eol}
\LABEL{MIN::FLUSH_ON_EOL} \\
\verb|const min::op min::| & \MINKEY{noflush\_on\_eol}
\LABEL{MIN::NOFLUSH_ON_EOL} \\
\verb|const min::op min::| & \MINKEY{flush\_id\_map\_on\_eom}
\LABEL{MIN::FLUSH_ID_MAP_ON_EOM} \\
\verb|const min::op min::| & \MINKEY{noflush\_id\_map\_on\_eom}
\LABEL{MIN::NOFLUSH_ID_MAP_ON_EOM} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{auto\_suppress}
\LABEL{MIN::AUTO_SUPPRESS} \\
\verb|const min::op min::| & \MINKEY{noauto\_suppress}
\LABEL{MIN::NOAUTO_SUPPRESS} \\
\verb|const min::op min::| & \MINKEY{disable\_suppress}
\LABEL{MIN::DISABLE_SUPPRESS} \\
\verb|const min::op min::| & \MINKEY{nodisable\_suppress}
\LABEL{MIN::NODISABLE_SUPPRESS} \\
\end{tabular}\end{indpar}

Here the \TT{min::display\_picture} operation sets the
\TT{min::\EOL DISPLAY\_\EOL PICTURE} prin\-ter operation flag in
\TT{printer->\EOL print\_\EOL format.op\_\EOL flags},
while the \TT{min::\EOL nodisplay\_\EOL picture} operation clears this flag.
The other operations similarly set or clear their associated flags.

The \TT{printer\_format.support\_control} can be set by the following
printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{ascii}
\LABEL{MIN::ASCII} \\
\verb|const min::op min::| & \MINKEY{latin1}
\LABEL{MIN::LATIN1} \\
\verb|const min::op min::| & \MINKEY{support\_all}
\LABEL{MIN::SUPPORT_ALL} \\
\verb|min::op min::|
    & \MINKEY{set\_support\_control}\ARGBREAK
          \verb|( const min::support_control & sc )|
\LABEL{MIN::SET_SUPPORT_CONTROL} \\
\end{tabular}\end{indpar}

Here \TT{min::ascii} is equivalent to
\begin{center}
\verb|min::set_support_control ( min::ascii_support_control )|
\end{center}
and similarly for \TT{min::latin1} and \TT{min::support\_all}.

The \TT{printer\_format.display\_control} can be set by the following
printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{graphic\_and\_space}
\LABEL{MIN::GRAPHIC_AND_SPACE} \\
\verb|const min::op min::| & \MINKEY{graphic\_only}
\LABEL{MIN::GRAPHIC_ONLY} \\
\verb|const min::op min::| & \MINKEY{graphic\_and\_vspace}
\LABEL{MIN::GRAPHIC_AND_VSPACE} \\
\verb|min::op min::|
    & \MINKEY{set\_display\_control}\ARGBREAK
          \verb|( const min::display_control & dc )|
\LABEL{MIN::SET_DISPLAY_CONTROL} \\
\end{tabular}\end{indpar}

Here \TT{min::graphic\_and\_space} is equivalent to
\begin{center}
\verb|min::set_display_control ( min::graphic_and_space_display_control )|
\end{center}
and similarly for \TT{min::\EOL graphic\_\EOL only},
\TT{min::\EOL graphic\_\EOL and\_vspace}, and \TT{min::\EOL display\_\EOL all}.

The \TT{printer\_format.break\_control} can be set by the following
printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{no\_auto\_break}
\LABEL{MIN::NO_AUTO_BREAK} \\
\verb|const min::op min::| & \MINKEY{break\_after\_space}
\LABEL{MIN::BREAK_AFTER_SPACE} \\
\verb|const min::op min::| & \MINKEY{break\_before\_all}
\LABEL{MIN::BREAK_BEFORE_ALL} \\
\verb|const min::op min::| & \MINKEY{break\_after\_hyphens}
\LABEL{MIN::BREAK_AFTER_HYPHENS} \\
\verb|min::op min::|
    & \MINKEY{set\_break\_control}\ARGBREAK
          \verb|( const min::break_control & bc )|
\LABEL{MIN::SET_BREAK_CONTROL} \\
\end{tabular}\end{indpar}

Here \TT{min::no\_auto\_break} is equivalent to
\begin{center}
\verb|min::set_break_control ( min::no_auto_break_break_control )|
\end{center}
and similarly for \TT{min::break\_\EOL after\_\EOL space},
\TT{min::break\_\EOL before\_\EOL all},
and \TT{min::break\_\EOL after\_\EOL hyphens}.

The printer operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{verbatim}
\LABEL{MIN::VERBATIM} \\
\end{tabular}\end{indpar}

is used when it is desired to copy characters verbatim to the
printer buffer.  \TT{printer << min::\EOL verbatim} is equivalent to:

\begin{indpar}\begin{verbatim}
printer << min::noexpand_ht
        << min::noauto_suppress
        << min::support_all
        << min::display_all
        << min::no_auto_break
\end{verbatim}\end{indpar}

This permits characters in a \TT{printer->file} line to be copied
to another printer verbatim.  Note that
the \TT{min::\EOL DISPLAY\_\EOL EOL} printer operation flag
is not affected, as when copying to a printer from
from some \TT{printer->\EOL file}
line terminating NULs are translated to \TT{min::\EOL eol}
operations on the target printer and may or may not be
displayed according to the setting of
\TT{min::\EOL DISPLAY\_\EOL EOL} on the target printer.
Also note that the operation to undo the results
of \TT{min::\EOL verbatim} does not exist (you must save and restore
\TT{print\_\EOL format}).

The printer operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{set\_line\_display} \verb|( min::uns32 line_display )|
\LABEL{MIN::SET_LINE_DISPLAY} \\
\end{tabular}\end{indpar}

is used when it is desired print a line in a file as part of an
error message, and is used, for example, by the
\TT{min::\EOL print\_\EOL line} function, \pagref{MIN::PRINT_LINE}.
\TT{printer << min::\EOL set\_\EOL line\_\EOL display ( line\_\EOL display )}
is equivalent to:

\begin{indpar}\begin{verbatim}
min::uns32 flags = ( min::DISPLAY_EOL + min::DISPLAY_PICTURE );

printer << min::clear_op_flags ( flags )
        << min::set_op_flags ( flags & line_display )
        << min::expand_ht
        << min::noauto_suppress
        << min::set_display_control
               ( flags & min::DISPLAY_PICTURE ?
                 min::graphic_only_display_control :
                 min::graphic_and_space_display_control )
        << min::no_auto_break
\end{verbatim}\end{indpar}

\subsubsection{Line Breaks}
\label{LINE-BREAKS}

The \TT{min::set\_\EOL break} printer operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{set\_\EOL break}
\LABEL{MIN::SET_BREAK} \\
\end{tabular}\end{indpar}

can be used to explicitly set a break point:
More specifically, \TT{printer<<min::set\_\EOL break} sets a break point after
the last character in the printer file buffer by executing:
\begin{indpar}\begin{verbatim}
printer->line_break.offset = printer->buffer->length;
printer->line_break.column = printer->column;
\end{verbatim}\end{indpar}

Recall from the description of \TT{line\_\EOL break.line\_\EOL length} on
\pagref{LINE-LENGTH}
that when a character representative other than single space, horizontal
tab, or spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed \TT{line\_\EOL break.line\_\EOL length},
then if
\begin{center}
\tt line\_break.column > line\_break.indent
\end{center}
a break, consisting of a line end followed by \TT{line\_\EOL break.indent}
spaces,
is inserted into the printer file buffer just after the break point
(i.e., at \TT{line\_\EOL break.offset}).  Also
single space and horizontal tab
characters immediately before the inserted line end are deleted.

One typically sets a break point just before printing text that one wants
to appear all on one line.  Then if
a character representative other than single space, horizontal
tab, or spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed the \TT{line\_\EOL break.line\_\EOL length},
a line end will be inserted at the break point.

For example, if \TT{line\_\EOL break.line\_\EOL length} is 72 one might
print
\begin{center}
\tt [ aaa, bbb, ccc, ddd, eee, fff, ggg ]
\end{center}
in which \TT{min::\EOL set\_\EOL break} was called after every single space
character (which could be done automatically using
\TT{break\_\EOL control.break\_\EOL after}).
If instead \TT{line\_\EOL break.line\_\EOL length}
was just 14 and \TT{line\_\EOL break.indent} was 2,
the same output would
print as
\begin{center}
\tt
\begin{tabular}{l}
[~aaa,~bbb, \\
~~ccc,~ddd, \\
~~eee,~fff, \\
~~ggg~] \\
\end{tabular}
\end{center}

In particular, after `\TT{[~aaa,~bbb,~}' a break point would be set,
and then when the third `\TT{c}' is about to be printed in column 15,
after `\TT{[~aaa,~bbb,~cc}' has already been printed, this
break point would be changed to a line end with 2 following single
spaces and the single space preceding the line end would be deleted.  Similarly
a break point would be set after `\TT{\ldots~ddd,~}' and changed
when `\TT{e}' is about to be printed in column 15, and a break
point would be set after `\TT{\ldots~fff,~}' and changed
when `\TT{g}' is about to be printed in column 15.  Break points
would also be set after `\TT{[~}', `\TT{\ldots~aaa,~}', etc. but
these would never be used.

The break point is said to be `\mkey{enabled}{break point}' whenever
\begin{center}
\tt line\_break.column > line\_break.indent
\end{center}
and `\mkey{disabled}{break point}' whenever
\begin{center}
\tt line\_break.column <= line\_break.indent
\end{center}
A break point must be enabled to be used.
Whenever a line end is inserted, the break point is
disabled by either setting it to be at the beginning of the line
(so \TT{line\_\EOL break.column} is \TT{0}) or setting it to
just after the \TT{line\_\EOL break.indent} spaces
if these are inserted after the line end.
Thus \TT{min::\EOL eol} and the \TT{min::\EOL indent} operation
(see \pagref{MIN::INDENT}) both end by executing
an implied \TT{min::\EOL set\_\EOL break},
and an implied \TT{min::\EOL set\_\EOL break}
is also executed just after inserting a line end
and \TT{line\_\EOL break.indent} spaces at a break point.

The \TT{min::left} and \TT{min::right} operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{left} \verb|( min::uns32 width )|
\LABEL{MIN::LEFT} \\
\verb|const min::op min::| & \MINKEY{right} \verb|( min::uns32 width )|
\LABEL{MIN::RIGHT} \\
\end{tabular}\end{indpar}

can be used to left or right adjust text in a line.
These operations add spaces to make the current printer column
equal to \TT{line\_\EOL break.column + width}.
The \TT{min::\EOL left} operation simply appends spaces to the
current line.  The \TT{min::\EOL right} operation inserts spaces
at the last break point.  Both operations end with an implicit
\TT{min::\EOL set\_\EOL break} that resets the breakpoint.
Both operations behave exactly as if spaces were inserted at the
appropriate point by \TT{printer << "~"}, except that
\TT{min::right} will give undefined results if a horizontal
tab has been output since the last break point (which can only
happen if the horizontal tab is to represent itself and the
\TT{min::\EOL EXPAND\_\EOL HT} printer operation flag is off).

The \TT{min::reserve} operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{reserve} \verb|( min::uns32 width )|
\LABEL{MIN::RESERVE} \\
\end{tabular}\end{indpar}

can be used to force a line break if there are fewer than \TT{width}
columns remaining in a line.
Here the line break consists of a \TT{min::eol} end of line followed
by \TT{line\_\EOL break.indent} single spaces followed by setting a break
as per \TT{min::\EOL set\_\EOL break}.

The \TT{min::indent} operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{indent}
\LABEL{MIN::INDENT} \\
\end{tabular}\end{indpar}

produces a line break if the current printer
column is greater than \TT{line\_\EOL break.indent}, and then (always) inserts
single spaces until the current printer column is equal to
\TT{line\_\EOL break.indent} (whether or not a line break was inserted).
The operation
ends by setting a break point as per \TT{min::\EOL set\_\EOL break}.

Several operations are conditioned on the relative values of
\TT{printer->\EOL line\_\EOL break.indent}, the printer indent,
and \TT{printer->\EOL column}, the printer column:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{eol\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::EOL_IF_AFTER_INDENT} \\
\verb|const min::op min::| & \MINKEY{spaces\_\EOL if\_\EOL before\_\EOL indent}
\LABEL{MIN::SPACES_IF_BEFORE_INDENT} \\
\verb|const min::op min::| & \MINKEY{space\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::SPACE_IF_AFTER_INDENT} \\
\end{tabular}\end{indpar}

The \TT{min::eol\_\EOL if\_\EOL after\_\EOL indent} operation performs
an \TT{min::eol} operation if and only if the printer column is after
the printer indent.
The \TT{min::spaces\_\EOL if\_\EOL before\_\EOL indent} operation performs
an \TT{min::indent} operation if and only if the printer column is before
the printer indent, inserting single space characters to make the
column equal to the indent in this case.
The \TT{min::space\_\EOL if\_\EOL after\_\EOL indent} operation outputs
a single space character if and only if the printer column is after
the printer indent.

The line break parameters of a printer
may be saved in the
\ttmkey{line\_\EOL break\_\EOL stack}{in {\tt min::printer}}%
\label{LINE-BREAK-STACK}
of the printer, and restored from that stack.
This may be done by the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{save\_line\_break}
\LABEL{MIN::SAVE_LINE_BREAK} \\
\verb|const min::op min::|
    & \MINKEY{restore\_line\_break}
\LABEL{MIN::RESTORE_LINE_BREAK} \\
\end{tabular}\end{indpar}

\TT{min::save\_line\_break}
pushes into the line break stack a new element containing
the current value of \TT{line\_\EOL break}, while
\TT{min::\EOL restore\_\EOL line\_\EOL break}
resets \TT{line\_\EOL break} from the top line break stack element and then
pops this element from the stack.

In addition, a non-empty line break stack modifies break point
behavior in the following way.
When a character representative other than single space, horizontal
tab, or spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed
the printer \TT{line\_\EOL break.line\_\EOL length} parameter,
then if any break stack entry is enabled, the first such entry's
\TT{offset}, \TT{column}, and \TT{indent},
are used in place of the printer
\TT{line\_\EOL break.offset},
\TT{line\_\EOL break.column}, and
\TT{line\_\EOL break.indent} parameters.
If this happens, then all later line break stack entries
and the printer \TT{line\_\EOL break}
are adjusted by adding to offsets
the change in offset of the character following the break and adding to
columns and indents the change in column of this character.

To be more specific, we say that a line break stack
entry \TT{break\_\EOL stack[i]} is `\key{enabled}' if
\begin{center}
\tt break\_stack[i].column > break\_stack[i].indent
\end{center}
and `\key{disabled}' otherwise.  The entries are ordered by \TT{i},
so the `first enabled entry' means the enabled entry with lowest \TT{i},
which is the bottommost (not topmost) enabled element of the line break stack.
The `later entries' are entries with larger \TT{i}.  Note that
after using an entry to insert a line end, that entry's
\TT{line\_\EOL break.offset}
and \TT{line\_\EOL break.column} are reset to make its break point
be just after the indentation spaces that are inserted after the line end.
This sets \TT{break\_\EOL stack[i].column}
equal to \TT{break\_\EOL stack[i].indent},
and thus disables \TT{break\_\EOL stack[i]} so it will not be reused.
Note also that if \underline{no} line break stack entry is enabled,
break point operation proceeds using the printer \TT{line\_\EOL break}
as if the line break stack did not exist.
Lastly note that \TT{break\_\EOL stack[i].line\_\EOL length} is never
used during these operations; its only use is to restore 
\TT{line\_\EOL break.line\_\EOL length} when the \TT{break\_\EOL stack}
is popped.


Management of nested list indentation can be done with the help of
the \TT{line\_\EOL break\_\EOL stack} using the operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{save\_indent}
\LABEL{MIN::SAVE_INDENT} \\
\verb|const min::op min::|
    & \MINKEY{restore\_indent}
\LABEL{MIN::RESTORE_INDENT} \\
\end{tabular}\end{indpar}

It is intended that a list header will be printed by first
executing a \TT{min::\EOL set\_\EOL break}, then printing the
header (e.g.~\TT{"[ "}), then executing
\TT{min::save\_indent}, while the list trailer will be printed
by first \underline{not} executing \TT{min::\EOL set\_\EOL break},
then printing the trailer (e.g.~\TT{" ]"}), then executing
\TT{min::\EOL restore\_\EOL indent}.

\TT{min::save\_indent} executes
\TT{min::\EOL save\_\EOL line\_\EOL break} and then
sets \TT{line\_\EOL break.indent} to equal the printer
\TT{column}.
~\TT{min::restore\_\EOL indent} just
executes \TT{min::\EOL restore\_\EOL line\_\EOL break}.

For example, suppose we print the following
with \TT{line\_\EOL length} equal to 72:
\begin{center}
\tt \{~aaa,~bbb,~[~ccc,~ddd,~eee,~(~fff,~ggg~),~hhh~],~iii,~jjj~\}
\end{center}
by using code equivalent to the statement:
\begin{indpar}\begin{verbatim}
    printer << min::set_break << "{ " << min::save_indent
            << min::set_break << "aaa, "
            << min::set_break << "bbb, "
            << min::set_break << "[ " << min::save_indent 
            << min::set_break << "ccc, "
            << min::set_break << "ddd, "
            << min::set_break << "eee, "
            << min::set_break << "( " << min::save_indent 
            << min::set_break << "fff, "
            << min::set_break << "ggg "
            << " ), " << min::restore_indent 
            << min::set_break << "hhh "
            << " ], " << min::restore_indent 
            << min::set_break << "iii, "
            << min::set_break << "jjj "
            << " }" << min::restore_indent 
            << min::eol;
\end{verbatim}\end{indpar}
Then if instead \TT{line\_\EOL length} was just 34 the same output would
print as
\begin{center}
\tt
\begin{tabular}{l}
\{~aaa,~bbb, \\
~~[~ccc,~ddd,~eee,~(~fff,~ggg~), \\
~~~~hhh~],~iii,~jjj~\} \\
\end{tabular}
\end{center}

After printing the 34 characters
\begin{center}
\tt \{~aaa,~bbb,~[~ccc,~ddd,~eee,~(~fff
\end{center}
a line break is triggered just before printing the `\TT{,}' following
`\TT{fff}'.  The first element in the line break stack was pushed
just after printing `\TT{\{~}'% }
and is disabled as it is at the beginning of the line.
The second element, pushed just after printing `\TT{[~}', has
\TT{column} just after `\TT{bbb,~}', and \TT{indent}
just after `\TT{\{~}', and so it is
enabled and used, and in the process it is disabled.
At this point the output is
\begin{center}
\tt
\begin{tabular}{l}
\{~aaa,~bbb, \\
~~[~ccc,~ddd,~eee,~(~fff \\
\end{tabular}
\end{center}
The third element was pushed after printing `\TT{(~}' and it
is updated when the second element is used so it still faithfully
reflects the point just after `\TT{(~}'.
Next this third element is popped after printing `\TT{~),~}'.
Then when the second `\TT{h}' is about to be printed, neither of the
two break points left in the line break stack are enabled, so the non-stack
break point before the first `\TT{h}' is used.  At this point the
current \TT{indent} is that which was saved in and restore from the
second element, and this indent is just after `{\tt[~}'.

The \key{begin message} and \TT{end message} operations can be used
to surround the body of an error message or other message:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{bom}
\LABEL{MIN::BOM} \\
\verb|const min::op min::| & \MINKEY{eom}
\LABEL{MIN::EOM} \\
\end{tabular}\end{indpar}

\TT{min::bom} executes both
a \TT{min::\EOL save\_\EOL indent}
and a \TT{min::\EOL save\_\EOL print\_\EOL format} operation.
\TT{min::\EOL eom} executes in order a
\TT{min::\EOL restore\_\EOL indent},
a \TT{min::\EOL eol},
a \TT{min::\EOL flush\_\EOL id\_\EOL map} (\pagref{MIN::FLUSH_ID_MAP})
if the printer operation flag
\TT{FLUSH\_ID\_MAP\_ON\_EOM} printer operation flag is on, and lastly
a \TT{min::\EOL restore\_\EOL print\_\EOL format}.
Note that the print format and its operation flags
in effect just before \TT{min::\EOL eom}
is executed govern all the operations executed by
\TT{min::\EOL eom}.

For example, the following might be used to print an error message:
\begin{indpar}\begin{verbatim}
    printer << "ERROR: " << min::bom;
    . . . . . .
    // Print contents of error message
    . . . . . .
    printer << min::eom;
\end{verbatim}\end{indpar}

Here the error message will be indented by the number of columns
consumed by `\TT{ERROR:~}', and any format parameters changed
while printing the error message body will be restored at the end
of the message by the \TT{min::\EOL eom}.

\TT{min::bom} will set \TT{line\_\EOL break.indent}
to the current value of \TT{column},
but if a different indent is desired, it can be set by following
\TT{min::\EOL bom} with \TT{min::\EOL set\_\EOL indent}
(\pagref{MIN::SET_INDENT}) or one of the operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{place\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::PLACE_INDENT} \\
\verb|min::op min::|
    & \MINKEY{adjust\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::ADJUST_INDENT} \\
\end{tabular}\end{indpar}

These operations set the indent in \TT{line\_\EOL break.indent}
to the sum of `\TT{offset}' and either
the printer `\TT{column}' for \TT{min::\EOL place\_\EOL indent}
or the indent itself for \TT{min::\EOL adjust\_\EOL indent}.
If the indent would be set to a negative value,
\TT{0} is used instead.

\subsubsection{Leading and Trailing Separators}
\label{LEADING-AND-TRAILING-SEPARATORS}

Consider a lexical scanner in which proto-lexemes that contain
no space characters are first scanned, and then `\skey{leading separator}s'
such as the opening single quote (\TT{`}) and dollar sign (\TT{\$})
are removed from the beginning of the proto-lexeme,
`\skey{trailing separator}s' such as closing single quote (\TT{'})
and comma are removed from the end of the proto-lexeme,
and anything left over of the proto-lexeme is designated to be a
`\key{middle lexeme}'.  So the proto-lexeme \TT{\$10,000,} translates
to the three lexemes TT{\$}, \TT{10,000}, and comma (\TT{,}).  Note
that the first comma is part of the middle lexeme and the last is
a trailing separator by itself.

The same effect can be achieved by a different kind of scanner
that declares a \TT{\$} character to be a separator only if it is
followed by a digit and a comma to be a separator unless
it is surrounded by digits.

Suppose you want to print the 3 element list of strings,
\TT{\$} \TT{10,000} comma (\TT{,}), and you know the first string
may be a leading separator, the second may be middle, and the last
may be trailing.  But maybe not.

You can do this with the code
\begin{center}
\verb|printer << "$" << min::leading << "10,000" << min::trailing ",";|
\end{center}

Here we have used the printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::| & \MINKEY{leading}
\LABEL{MIN::LEADING} \\
\verb|min::op min::| & \MINKEY{trailing}
\LABEL{MIN::TRAILING} \\
\end{tabular}\end{indpar}

Each of these denotes a space character with may be output or
not according to its context.

To give as second example, consider the code:
\begin{indpar}\begin{verbatim}
printer << "100" << min::trailing << "," << " " << "200";
printer << "100" << min::trailing << "#" << " " << "200";
\end{verbatim}\end{indpar}

We want the first line to output `\TT{100, 200}' in which
\TT{min::\EOL trailing} does \underline{not} output a space,
while we want the second line to output `\TT{100 \# 200}'
in which \TT{min::\EOL trailing} \underline{does} output a space.

And to consider one last example, consider the code:
\begin{indpar}\begin{verbatim}
printer << "("   << min::leading << "100" << min::trailing <<  ")";
printer << "(+"  << min::leading << "100" << min::trailing << "+)";
\end{verbatim}\end{indpar}

We want the first line to output `\TT{(100)}' in which there are
\underline{no} spaces,
while we want the second line to output `\TT{(+ 100 +)}'
in which there are \underline{two} spaces.

So how to we compute the context?

First, we classify characters into leading, trailing, middling, or other
using the character flags:
\begin{center}
\TT{min::IS\_LEADING ~~~~~ min::IS\_TRAILING ~~~~~ min::IS\_MIDDLING}
\end{center}
See \pagref{LEADING/MIDDLING/TRAILING-CHAR-FLAGS} for details.

Then we classify each string as `\mkey{leading}{string}' if it contains only
\TT{IS\_\EOL LEADING} characters, `\mkey{trailing}{string}' if it contains
only \TT{IS\_\EOL TRAILING} characters, and `other'.  Note there
are no middling strings.

Now the rough idea of \TT{min::leading}
is that it will output a space \underline{unless}
it is part of a sequence of leading strings each followed by an
\TT{min::leading} operation, with the sequence being
prefaced by whitespace and followed
by either whitespace or a middling character.

Similarly the rough idea of \TT{min::trailing}
is that it will output a space \underline{unless}
it is part of a sequence of trailing strings each preceeded by a
\TT{min::trailing} operation, with the sequence
being followed by whitespace and preceded
by either whitespace or a middling character.

In the above examples these ideas succeed because
\TT{\$} and \TT{(} have the \TT{IS\_\EOL LEADING} flag,
comma and \TT{)} have the \TT{IS\_\EOL TRAILING} flag,
while \TT{\#}, \TT{+}, and digits have the \TT{IS\_\EOL MIDDLING} flag.

The precise implementation is as follows.

The printer may or may not be in the leading state according to whether
the \TT{min::\EOL LEADING\_\EOL STATE} printer operation flag is set or not.
The rules regarding leading state are:
\begin{enumerate}
\item The printer is initially in the leading state.
\item The \TT{min::eol} operation enters the leading state.
\item Outputting a single space or horizontal tab enters the leading state.
(This does not apply to outputting a picture or name of these characters.)
\item Outputting a non-leading string that does not end in
a single space or horizontal tab leaves the leading state.
\item \TT{min::leading} outputs a single space unless the printer
is in the leading state, the \TT{min::\EOL DISABLE\_\EOL SUPPRESS}
printer operation flag is off, and the next thing output is one of:
\begin{enumerate}
\item a leading string
\item a string beginning with a middling character
\item a string beginning with a single space or horizontal tab character
\item the \TT{min::eol} operation or equivalent
\end{enumerate}
\end{enumerate}

This works provided every leading string output in the leading state
is followed by a \TT{min::\EOL leading} operation.

Note that the leading state only affects whether \TT{min::\EOL leading}
operations output spaces.

The printer may or may not be in the trailing state according to whether
the \TT{min::\EOL TRAILING\_\EOL STATE} printer operation flag is set or not.
The rules regarding trailing state are:
\begin{enumerate}
\item The printer is initially in the trailing state.
\item The \TT{min::eol} operation enters the trailing state.
\item Outputting a single space or horizontal tab enters the trailing state.
(This does not apply to outputting a picture or name of these characters.)
\item Outputting a string that ends in a middling character enters
the trailing state.
\item Outputting a non-trailing string that does not end in a middling
character, single space, or horizontal tab leaves the trailing state.
\item \TT{min::trailing} outputs a single space unless the printer
is in the trailing state, the \TT{min::\EOL DISABLE\_\EOL SUPPRESS}
printer operation flag is off, and the next thing output is one of:
\begin{enumerate}
\item a trailing string
\item a string beginning with a single space or horizontal tab character
\item the \TT{min::eol} operation or equivalent
\end{enumerate}
\end{enumerate}

This works provided every trailing string output in the trailing state
is preceded by a \TT{min::\EOL trailing} operation.

Note that the trailing state only affects whether \TT{min::\EOL trailing}
operations output spaces.



\subsubsection{Printing File Lines and Phrases}
\label{PRINTING-FILE-LINES-AND-PHRASES}

The following function uses \TT{min::line} to print a line as part of
an error message:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE} \\
\end{tabular}\end{indpar}

The \TT{file} line with the given \TT{line\_number}
is printed on a single \TT{printer} line.  \TT{file->\EOL line\_\EOL display}
(\pagref{FILE_LINE_DISPLAY})
is used to print this line, and the number of columns in the result,
including any end of line representation printed by the
\TT{min::\EOL DISPLAY\_\EOL EOL}, is returned.

If a line is
unavailable (i.e., \TT{min::\EOL line} returns \TT{min::\EOL NO\_\EOL LINE},
see \pagref{MIN::LINE_OF_FILE})
and \TT{line\_\EOL number} is not equal \TT{file->\EOL file\_\EOL lines},
then \TT{unavailable\_\EOL line} is printed on a line by itself instead, and
\TT{0} is returned, if \TT{unavailable\_\EOL line} is not \TT{NULL}.
But if \TT{unavailable\_\EOL line} is \TT{NULL}, nothing is done except
to return \TT{min::\EOL NO\_\EOL LINE}.

If a line would print as blank, and if
\TT{blank\_\EOL line} is not \TT{NULL},
\TT{blank\_\EOL line} is printed instead of the line, and \TT{0} is returned.
More specifically, a line is deemed to print as blank if it only contains
ASCII control characters or single spaces which when printed
represent themselves or are suppressed.

If there is no line
because \TT{line\_\EOL number == file->\EOL file\_\EOL lines},
then any partial line at the end of the file buffer is printed,
immediately followed by \TT{end\_\EOL of\_\EOL file}, all on one line,
and the number of columns used to print the partial line is returned.
However, if \TT{end\_\EOL of\_\EOL file} is \TT{NULL}, then
if there is a partial line, only that is printed, on a single line
without any visible ending line feed, and if there is no partial line,
nothing is printed and \TT{NO\_\EOL LINE} is returned.

Note that
\TT{file->\EOL line\_\EOL display} is not used to print
\TT{unavailable\_\EOL line}, \TT{blank\_\EOL line}, or
\TT{end\_\EOL of\_\EOL line} or any following line feed,
and it is best if these special strings consist of nothing but
graphic ASCII characters and single spaces.
Also, these ASCII strings may not be unprotected body pointers,
as printing may relocate bodies.

In all cases where anything is printed, exactly one complete print line is
printed.

Error messages typically consist of a description of the error
followed by the lines involved printed with the above function
(often the portions of the lines involved are marked by printing
`\TT{\^{ }}' characters under them).  The error description before
the lines typically ends with the name of the file containing
the lines and the numbers of the lines.  This can be produced
by the code:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  min::uns32 first, min::uns32 last )|
\LABEL{MIN::PLINE_NUMBERS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::pline_numbers const & pline_numbers )|
\LABEL{PRINTER_OPERATOR<<_OF_PLINE_NUMBERS} \\
\end{tabular}\end{indpar}

An example use is

\begin{indpar}\begin{verbatim}
    printer << ... error description ...
            << min::pline_numbers ( file, first, last )
            << min::eol;
    for ( min::uns32 line_number = first;
          line_number <= last,
          ++ line_number )
        min::print_line ( printer, file, line_number );
\end{verbatim}\end{indpar}

The line numbers printed by \TT{min::\EOL pline\_\EOL number}
are \TT{1} greater than the line numbers given in the arguments,
so the line number of the first line of a file is denoted by a
\TT{0} argument which is printed as \TT{1}.

There is a better way to print the lines of a file within an
error message if the positions of the erroneous text in the file
are known and are encoded in
\TT{min::position} structures:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::uns32 line;|\ARGBREAK
    \verb|  min::uns32 offset;|\ARGBREAK
    \verb|};|
\ttmindex{line}{in {\tt min::position}}
\ttmindex{offset}{in {\tt min::position}}
\ttmindex{column}{in {\tt min::position}}
\LABEL{MIN::POSITION_STRUCT} \\
\end{tabular}\end{indpar}

Here \TT{line} is the number of full lines before the line
containing the position and \TT{offset} is the
number of bytes before the position in the line.

Two \TT{min::position} structures are needed to encode the boundaries
of a piece of text in a file.  Such a piece of text is called
a `\key{phrase}', and its positions are encoded in a
\TT{min::\EOL phrase\_\EOL position} structure:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{phrase\_\EOL position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::position begin;|\ARGBREAK
    \verb|  min::position end;|\ARGBREAK
    \verb|};|
\ttmindex{begin}{in {\tt min::phrase\_position}}
\ttmindex{end}{in {\tt min::phrase\_position}}
\LABEL{MIN::PHRASE_POSITION_STRUCT} \\
\end{tabular}\end{indpar}

Here `\TT{begin}' encodes the position of the first character
of the phrase in the file, and `\TT{end}' encodes the position
of the first character \underline{after} the phrase in the file.
If the phrase is empty, \TT{begin == end}, and the position
referenced by both `\TT{begin}' and `\TT{end}'
is the position of the empty phrase in the file.

To print the line numbers of a phrase one can use the constructor:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  min::phrase_position const & position )|
\LABEL{MIN::PLINE_NUMBERS_OF_PHRASE_POSITION} \\
\end{tabular}\end{indpar}

which uses \TT{position.begin.line} and
\TT{position.end.line} as
line numbers, except that when
\begin{center}
\TT{position.end.offset == 0} \\
and \\
\TT{position.end.line > position.begin.line}
\end{center}
then \TT{position.end.line - 1} is used in place of
\TT{position.end.line}.

To print a phrase one can use the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES} \\
\end{tabular}\end{indpar}

The lines containing the phrase are printed, and under each phrase
character a \TT{mark} is printed.  The lines are printed
as per \TT{min::\EOL print\_\EOL line} using the
\TT{blank\_\EOL line},
\TT{end\_\EOL of\_\EOL file}, and
\TT{unavailable\_\EOL line} arguments.
An empty phrase is marked as if it were 1-column wide, that column
being at the empty phrase position.

If the \TT{mark} argument is given as \TT{0}, the marking lines
will be omitted.  This permits just printing the lines containing
a phrase, without marking the phrase.

An example using a \TT{phrase\_position} is

\begin{indpar}\begin{verbatim}
    printer << ... error description ...
            << min::pline_numbers ( file, phrase_position )
            << min::eol;
    min::print_phrase_lines ( printer, file, phrase_position );
\end{verbatim}\end{indpar}

Internally \TT{min::\EOL print\_\EOL phrase\_\EOL lines}
uses the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\_\EOL column\RESIZE}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position )|
\LABEL{MIN::PRINT_LINE_COLUMN} \\
\end{tabular}\end{indpar}

which, given a file and a position within that file, returns the number of
columns before the position in a \TT{min::\EOL print\_\EOL line}
printout of the line specified by the position.

Some of the above functions use \TT{file->line\_display}
to control how lines are printed and therefore which column
a position corresponds to.  Specifically, if \TT{min::\EOL DISPLAY\_\EOL EOL}
is on in \TT{file->line\_display}, \TT{<NL>} 
will print at the end of a line if
\TT{min::\EOL DISPLAY\_\EOL PICTURE} is off, and
{\tiny $\stackrel{\textstyle N~}{~L}$} will print if
\TT{min::\EOL DISPLAY\_\EOL PICTURE} is on.  Also, if
\TT{min::\EOL DISPLAY\_\EOL PICTURE} is on, ASCII control
characters and single spaces will print as UNICODE picture characters
(e.g., {\tiny $\stackrel{\textstyle H~}{~T}$}
and {\tiny $\stackrel{\textstyle F~}{~F}$}),
but if \TT{min::\EOL DISPLAY\_\EOL PICTURE} is off,
ASCII control characters except horizontal tab will
print as their names with prefix and postfix determined by
\TT{printer->\EOL print\_\EOL format.char\_\EOL name\_\EOL format}
(e.g., \TT{<FF>}),
horizontal tab will
be expanded to a sequence of single spaces, and single space will
print as itself.

The following are alternatives to the above functions that take
an extra \TT{line\_\EOL display} argument and use that in place of
\TT{file->\EOL line\_\EOL display}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE_WITH_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES_WITH_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\_\EOL column\RESIZE}\ARGBREAK
      \verb|( min::uns32 line_display,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position )|
\LABEL{MIN::PRINT_LINE_COLUMN_WITH_FLAGS} \\
\end{tabular}\end{indpar}

There is a type of packed vector, the `\key{phrase position vector}\,',
that is specialized to
record the phrase positions of elements of any linear vector:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_vec_ptr<min::phrase_position_vec_header,|\\&
	  \verb|               min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec}
\LABEL{MIN::PHRASE_POSITION_VEC} \\
\verb|typedef min::|
	& \verb|packed_vec_insptr<min::phrase_position_vec_header,|\\&
	  \verb|                  min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec\_insptr}
\LABEL{MIN::PHRASE_POSITION_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::| 
  & \verb|phrase_position_vec_insptr min::|\MINKEY{init\RESIZE}\ARGBREAK
    \verb|( min::ref<min::phrase_position_vec_insptr> vec,|\ARGBREAK
    \verb|  min::file file,|\ARGBREAK
    \verb|  min::phrase_position const & position,|\ARGBREAK
    \verb|  min::uns32 max_length )|
\LABEL{MIN::INIT_OF_PHRASE_POSITION_VEC} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 vpp| & \TTARMKEY{length}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_LENGTH} \\
\verb|const min::file vpp| & \TTARMKEY{file}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_FILE} \\
\verb|min::phrase_position vpp| & \TTARMKEY{position}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_POSITION} \\
\verb|min::phrase_position vpp| & \TTBMKEY{i}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_ELEMENT} \\
\end{tabular}\end{indpar}

A phrase position vector is associated with some other data vector.
For example, a phrase position vector may be the value of the
\TT{.position} attribute of an object
(see below), in which case it will be associated with
the attribute vector of the object.
If \TT{vpp} is a phrase position vector pointer, \TT{vpp->\EOL position}
is the position of the phrase that is encoded in the data vector,
\TT{vp[i]} is the position of the phrase that is encoded in
the \TT{i+1}'st element of the data vector, and
\TT{vpp->\EOL file} is the file containing these phrases.
\TT{vpp->\EOL length} is, as per the definition of packed vectors,
the number of elements in the phrase position vector, and should
match the number of elements in the data vector.
The \TT{min::\EOL init} function above can be used to create or
reinitialize a \TT{min::\EOL phrase\_\EOL position\_\EOL vec},
and sets the \TT{file}, \TT{position}, and initial maximum length
of the phrase position vector.

A MIN object may have a \TT{.position} attribute equal to a
phrase position vector.  If an object does, the phrase position
pointer is returned by the following function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::phrase_position_vec min::| & \MINKEY{position\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::POSITION_OF_OBJECT_VEC_PTR} \\
\end{tabular}\end{indpar}

Here the object is identified by the \TT{min::\EOL obj\_\EOL vec\_\EOL ptr}
which is being used to access the object elements.  If the
object has no \TT{.position} attribute, or if the attribute is
not a \TT{min::\EOL phrase\_\EOL position\_\EOL vec} value,
\TT{min::\EOL NULL\_\EOL STUB} is returned.

\subsection{Printing General Values}
\label{PRINTING-GENERAL-VALUES}

\TT{min::gen} values are printed using the \TT{min::\EOL pgen} printer
operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::| & \MINKEY{pgen} \verb|( min::gen v )|
\LABEL{MIN::PGEN} \\
\verb|min::op min::|
    & \MINKEY{pgen}\ARGBREAK
	  \verb|( min::gen v,|\ARGBREAK
	  \verb|  const min::gen_format * gen_format )|
\LABEL{MIN::PGEN_WITH_GEN_FLAGS} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::gen v )|
\LABEL{PRINTER_OPERATOR<<_OF_GEN} \\
\end{tabular}\end{indpar}

The expression `\TT{printer\,<<\,min::pgen(v)}'
prints the \TT{min::gen} value \TT{v} to the
\TT{printer} using the \TT{printer}'s \TT{gen\_\EOL format} value
\begin{center}
\TT{printer->\EOL print\_\EOL format.gen\_\EOL format} \\
\end{center}
to control the printing.
The expression `\TT{printer\,<<\,min::pgen(v,f)}' is similar but
uses \TT{f} as the \TT{gen\_\EOL format} value.

`\TT{printer\,<<\,v}' can be used as the equivalent of
`\TT{printer\,<<\,min::pgen(v)}'

TBD

{\tt Pgen} calls itself recursively, and when it does, it uses different
elements of {\tt context\_\EOL gen\_\EOL flags} as the {\tt gen\_\EOL flags}
value that controls printing.  The index to
{\tt context\_\EOL gen\_\EOL flags} is called the \key{pgen context}.
The data structure for {\tt pgen} contexts is:

{\tt PGEN\_}\ldots{} contexts:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{PGEN\_TOP}
\LABEL{MIN::PGEN_TOP_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_INDENT}
\LABEL{MIN::PGEN_INDENT_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_PUNCTUATION}
\LABEL{MIN::PGEN_PUNCTUATION_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_NAME}
\LABEL{MIN::PGEN_NAME_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_VALUE}
\LABEL{MIN::PGEN_VALUE_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_ELEMENT}
\LABEL{MIN::PGEN_ELEMENT_CONTEXT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::uns32 min::|
    & \MINKEY{context\_gen\_flags}\verb|[|$n$\verb|]| \\
    & \tt ~~~~~ // $n$ is number of PGEN\_...~contexts
\LABEL{MIN::CONTEXT_GEN_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]
\begin{tabular}{l}
\verb|const min::context_gen_flags min::|%
    \MINKEY{default\_\EOL context\_\EOL gen\_\EOL flags}
\LABEL{MIN::DEFAULT_CONTEXT_GEN_FLAGS} \\
\verb|    // default_context_gen_flags[PGEN_TOP]:| \\
\verb|    //    min::GRAPHIC_STR_FLAG| \\
\verb|    //  + min::BRACKET_STR_FLAG| \\
\verb|    //  + min::BRACKET_LAB_FLAG| \\
\verb|    //  + min::BRACKET_IMPLICIT_FLAG| \\
\verb|    //  + min::OBJ_EXP_FLAG| \\
\end{tabular}
\\
\begin{tabular}{l}
\verb|    // default_context_gen_flags[PGEN_INDENT]:| \\
\verb|    //    min::GRAPHIC_STR_FLAG| \\
\verb|    //  + min::BRACKET_STR_FLAG| \\
\verb|    //  + min::BRACKET_LAB_FLAG| \\
\verb|    //  + min::BRACKET_IMPLICIT_FLAG| \\
\verb|    //  + min::OBJ_EXP_FLAG| \\
\verb|    //  + min::OBJ_INDENT_FLAG| \\
\end{tabular}
\\
\begin{tabular}{l}
\verb|    // default_context_gen_flags[PGEN_PUNCTUATION]:| \\
\verb|    //    min::GRAPHIC_STR_FLAG| \\
\verb|    //  + min::SUPPRESS_LAB_SPACE_FLAG| \\
\verb|    //  + min::BRACKET_IMPLICIT_FLAG| \\
\verb|    //  + min::OBJ_EXP_FLAG| \\
\verb|    //  + min::OBJ_ID_FLAG| \\
\end{tabular}
\\
\begin{tabular}{l}
\verb|    // default_context_gen_flags[PGEN_NAME]:| \\
\verb|    //    min::GRAPHIC_STR_FLAG| \\
\verb|    //  + min::SUPPRESS_LAB_SPACE_FLAG| \\
\verb|    //  + min::BRACKET_IMPLICIT_FLAG| \\
\verb|    //  + min::OBJ_EXP_FLAG| \\
\verb|    //  + min::OBJ_ID_FLAG| \\
\end{tabular}
\\
\begin{tabular}{l}
\verb|    // default_context_gen_flags[PGEN_VALUE]:| \\
\verb|    //    min::GRAPHIC_STR_FLAG| \\
\verb|    //  + min::BRACKET_STR_FLAG| \\
\verb|    //  + min::BRACKET_LAB_FLAG| \\
\verb|    //  + min::BRACKET_IMPLICIT_FLAG| \\
\verb|    //  + min::OBJ_EXP_FLAG| \\
\end{tabular}
\\
\begin{tabular}{l}
\verb|    // default_context_gen_flags[PGEN_ELEMENT]:| \\
\verb|    //    min::GRAPHIC_STR_FLAG| \\
\verb|    //  + min::SUPPRESS_LAB_SPACE_FLAG| \\
\verb|    //  + min::BRACKET_IMPLICIT_FLAG| \\
\verb|    //  + min::OBJ_EXP_FLAG| \\
\verb|    //  + min::OBJ_ID_FLAG| \\
\end{tabular}
\end{indpar}

\begin{indpar}[1em]
\begin{tabular}{l}
\verb|const min::context_gen_flags min::|%
    \MINKEY{no\_\EOL exp\_\EOL context\_\EOL gen\_\EOL flags}
\LABEL{MIN::NO_EXP_CONTEXT_GEN_FLAGS} \\
\verb|    // Same as default_context_gen_flags| \\
\verb|    // but without any min::OBJ_EXP_FLAGs.| \\
\end{tabular}
\end{indpar}

The uses of the various {\tt pgen} contexts are:

\begin{itemlist}[0.4in]

\item[\ttkey{PGEN\_TOP}]
This is for printing the top level {\tt min::gen} values.

\item[\ttkey{PGEN\_INDENT}]
\label{PGEN_INDENT}
This is for printing the top level value in the context of
{\tt flush\_\EOL id\_\EOL map} (\pagref{MIN::FLUSH_ID_MAP}).

\item[\ttkey{PGEN\_PUNCTUATION}]
This is for printing punctuation including
{\tt .initiator}'s, {\tt .separa\-tor}'s, and {\tt .terminator}'s,
and also including {\tt .type}'s when these are printed as marks.

\item[\ttkey{PGEN\_NAME}]
This is for printing attribute labels, {\tt .type}'s not printed as marks,
and names in general.

\item[\ttkey{PGEN\_VALUE}]
This is for printing non-double-arrow, non-vector-element attribute
values.

\item[\ttkey{PGEN\_ELEMENT}]
This is for printing vector element values.

\end{itemlist}

Neither {\tt min::context\_\EOL gen\_\EOL flags} or
{\tt min::gen\_\EOL format} can be stored in a
relocatable body, and they are intended to be a static C++ structures.
In making new versions, one must copy
{\tt min::\EOL default\_\EOL context\_\EOL gen\_\EOL flags} or
{\tt min::\EOL default\_\EOL gen\_\EOL format}
and then change particular members in the copy, because one cannot
count on all the members being organized in a particular way.
Copies can be made in the stack.

The detailed structure and meaning of general value printing flags 
is as follows:

\ldots{\tt \_gen\_flags} Flags:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{GRAPHIC\_STR\_FLAG}
\LABEL{MIN::GRAPHIC_STR_FLAG} \\
\end{tabular}\end{indpar}
\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_STR\_FLAG}
\LABEL{MIN::BRACKET_STR_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_LAB\_FLAG}
\LABEL{MIN::BRACKET_LAB_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_SPECIAL\_FLAG}
\LABEL{MIN::BRACKET_SPECIAL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_IMPLICIT\_FLAG}
\LABEL{MIN::BRACKET_IMPLICIT_FLAG} \\
\end{tabular}\end{indpar}
\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{SUPPRESS\_SPECIAL\_NAME\_FLAG}
\LABEL{MIN::SUPPRESS_SPECIAL_NAME_FLAG} \\
\end{tabular}\end{indpar}
\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{SUPPRESS\_LAB\_SPACE\_FLAG}
\LABEL{MIN::SUPPRESS_LAB_SPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{SUPPRESS\_EXP\_SPACE\_FLAG}
\LABEL{MIN::SUPPRESS_EXP_SPACE_FLAG} \\
\end{tabular}\end{indpar}
\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{OBJ\_EXP\_FLAG}
\LABEL{MIN::OBJ_EXP_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{OBJ\_ID\_FLAG}
\LABEL{MIN::OBJ_ID_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{OBJ\_INDENT\_FLAG}
\LABEL{MIN::OBJ_INDENT} \\
\verb|const min::uns32 min::| & \MINKEY{STR\_ID\_FLAG}
\LABEL{MIN::STR_ID_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{itemlist}[0.4in]

\item[\ttmkey{GRAPHIC\_STR\_FLAG}{{\tt min::gen\_format} flag}]~\\
This flag causes {\tt min::gen} string value characters to be printed
in graphic mode, as per the {\tt min::graphic} printer operation
(\pagref{MIN::GRAPHIC}).  This flag does \underline{not} affect the
printing of {\tt str\_\EOL pre\-fix/\EOL post\-fix/\EOL quote} (see below).

\item[\ttkey{BRACKET\_STR\_FLAG}]
\item[\ttkey{BRACKET\_LAB\_FLAG}]\vspace{-1ex}
\item[\ttkey{BRACKET\_SPECIAL\_FLAG}]\vspace{-1ex}
\item[\ttkey{BRACKET\_IMPLICIT\_FLAG}]\vspace{-1ex}~\\
These flags enable use of the following {\tt gen\_\EOL format}
members which are described below:
\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}l}
{\tt BRACKET\_STR\_FLAG}	& {\tt str\_prefix},
				  {\tt str\_postfix},
				  {\tt str\_quote}
\\
{\tt BRACKET\_LAB\_FLAG}	& {\tt lab\_prefix},
				  {\tt lab\_postfix}
\\
{\tt BRACKET\_SPECIAL\_FLAG}	& {\tt special\_prefix},
				  {\tt special\_postfix}
\\
{\tt BRACKET\_IMPLICIT\_FLAG}	& {\tt implicit\_prefix},
				  {\tt implicit\_postfix}

\end{tabular}
\end{center}

\item[\ttkey{SUPPRESS\_SPECIAL\_NAME\_FLAG}]~\\
This flag suppresses use of the
{\tt special\_\EOL names} member
of {\tt gen\_\EOL format}, described below, to
print a {\tt min::\EOL new\_\EOL special\_\EOL gen(i)} value.

If the flag is \underline{off}, if {\tt special\_\EOL names}
is not {\tt min::\EOL NULL\_\EOL STUB}, and if
{\tt 0 <= i < special\_\EOL names->\EOL length}, then
the value prints as {\tt special\_\EOL names[i]}.

If the flag is \underline{off} and
\begin{center}
\tt 0 <= 0xFFFFFF\,-\,i\,<\,min::\EOL standard\_\EOL special\_\EOL
names->\EOL length
\end{center}
then the value prints as
{\tt min::\EOL standard\_\EOL special\_\EOL names[0xFFFFFF\,-\,i]}.

Otherwise the value prints as `{\tt SPECIAL(i)}'.

\item[\ttkey{SUPPRESS\_LAB\_SPACE\_FLAG}]
\item[\ttkey{SUPPRESS\_EXP\_SPACE\_FLAG}]\vspace{-1ex}~\\
See {\tt surpress\_matrix} below.

\item[\ttmkey{OBJ\_EXP\_FLAG}{{\tt min::gen\_format} flag}]~\\
If set and if all attributes of an object have names listed in
{\tt exp\_\EOL ok\_\EOL attrs} (see below), then the object is
printed as an expression.  In this case attributes other than
 \ttdkey{initiator}, \ttdkey{separator}, \ttdkey{terminator},
\ttdkey{middle}, \ttdkey{name}, \ttdkey{arguments}, and \ttdkey{keys}
are ignored.

Note that objects with the {\tt .initiator}'s `{\tt \#}' and `{\tt "}' are
printed unwrapped; for example,
\begin{center}
\verb/"foo" {| .initiator "<Q>" |}/
\end{center}
prints as
\TT{"foo"}.

\item[\ttmkey{OBJ\_ID\_FLAG}{{\tt min::gen\_format} flag}]~\\
If set, and if an object is not being printed as an expression as
per the {\tt OBJ\_\EOL EXP\_\EOL FLAG},
then an identifier i will be allocated for the object
in {\tt printer->\EOL id\_\EOL map} and the object will be
printed as `{\tt @}i'.

\item[\ttmkey{OBJ\_INDENT\_FLAG}{{\tt min::gen\_format} flag}]~\\
This flag controls how an object is printed if the
{\tt OBJ\_\EOL EXP\_\EOL FLAG} and
{\tt OBJ\_\EOL ID\_\EOL FLAG} do not apply.  Then if this flag
is \underline{off}
the object will be printed in the general form:
\begin{center}
\begin{tabular}{ll}
\TT{\{|} {\em element} & \{ \TT{;} {\em attribute-name-and-values}
                          \}$^\star$ \\
                        & \{ \TT{;} {\em reverse-attribute-name-and-values}
                          \}$^\star$  \TT{|\}}
\end{tabular}
\end{center}
and if this flag is \underline{on} the object will be printed in the
general form:
\begin{center}
\begin{tabular}{r@{}l}
XXX	& {\em element}$^\star$\TT{:|} \\
	& {\em attribute-name-and-values}\\
	& \ldots\ldots\ldots\\
	& {\em reverse-attribute-name-and-values}\\
	& \ldots\ldots\ldots\\
\end{tabular}
\end{center}

The two forms are is similar, with semi-colons in the first being
replaced by line ends, indentation, and the indentation mark
\TT{:|} in the second, and the
surrounding \TT{\{|} \TT{|\}} of the first being omitted in the second.
The indentation is the column position when the value is output; in
the above XXX is printed before the value is output and the indent is
at the end of the XXX.

See \pagref{GEN-OBJ-FORM} for more details.

\item[\ttmkey{STR\_ID\_FLAG}{{\tt min::gen\_format} flag}]~\\
If set, {\tt min::gen} string values that have length greater
than {\tt str\_\EOL max\_\EOL length} (see below)
have an identifier i allocated
in {\tt printer->\EOL id\_\EOL map} and are printed as `{\tt @}i'.
Otherwise string values are printed normally.

\end{itemlist}\end{indpar}

The detailed structure and meaning of the general value format
is as follows:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{gen\_format}}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::printer ( * pgen )|\ARGBREAK
    \verb|       ( min::printer printer,|\ARGBREAK
    \verb|         min::uns32 gen_flags,|\ARGBREAK
    \verb|         min::gen v,|\ARGBREAK
    \verb|         const min::context_gen_flags * context_gen_flags,|\ARGBREAK
    \verb|         const min::gen_format * g );|\ARGBREAK
\ttmindex{pgen}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  // Members beyond this point may be moved and|\ARGBREAK
    \verb|  // new members may be added.|\ARGBREAK
    \verb||\ARGBREAK
    \verb|  const char *             number_format;|\ARGBREAK
\ttmindex{number\_format}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const min::Ustring *     str_prefix;|\ARGBREAK
    \verb|  const min::Ustring *     str_postfix;|\ARGBREAK
    \verb|  const min::Ustring *     str_postfix_name;|\ARGBREAK
    \verb|  const min::Ustring *     str_char_name_prefix;|\ARGBREAK
    \verb|  const min::Ustring *     str_char_name_postfix;|\ARGBREAK
    \verb|  const min::Ustring *     str_concatenator;|\ARGBREAK
    \verb|  min::uns32         	     str_max_length;|\ARGBREAK
\ttmindex{str\_prefix}{in {\tt min::gen\_format}}
\ttmindex{str\_postfix}{in {\tt min::gen\_format}}
\ttmindex{str\_char\_names}{in {\tt min::gen\_format}}
\ttmindex{str\_char\_name\_prefix}{in {\tt min::gen\_format}}
\ttmindex{str\_char\_name\_postfix}{in {\tt min::gen\_format}}
\ttmindex{str\_concatenator}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const char *             lab_prefix;|\ARGBREAK
    \verb|  const char *             lab_separator;|\ARGBREAK
    \verb|  const char *             lab_postfix;|\ARGBREAK
\ttmindex{lab\_prefix}{in {\tt min::gen\_format}}
\ttmindex{lab\_separator}{in {\tt min::gen\_format}}
\ttmindex{lab\_postfix}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const char *             special_prefix;|\ARGBREAK
    \verb|  const char *             special_postfix;|\ARGBREAK
    \verb|  min::packed_vec_ptr<const char *>|\ARGBREAK
    \verb|                           special_names;|\ARGBREAK
\ttmindex{special\_prefix}{in {\tt min::gen\_format}}
\ttmindex{special\_postfix}{in {\tt min::gen\_format}}
\ttmindex{special\_names}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const char *             implicit_prefix;|\ARGBREAK
    \verb|  const char *             implicit_postfix;|\ARGBREAK
\ttmindex{implicit\_prefix}{in {\tt min::gen\_format}}
\ttmindex{implicit\_postfix}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const min::suppress_matrix *|\ARGBREAK
    \verb|                           suppress_matrix;|\ARGBREAK
\ttmindex{suppress\_matrix}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  min::packed_vec_ptr<min::gen>|\ARGBREAK
    \verb|                           exp_ok_attrs;|\ARGBREAK
\ttmindex{str\_max\_length}{in {\tt min::gen\_format}}
\ttmindex{exp\_ok\_attrs}{in {\tt min::gen\_format}}
    \verb||\\[-5ex]\ARGBREAK
    \verb|  min::packed_vec_ptr<const char *>|\ARGBREAK
    \verb|                           flag_names;|\ARGBREAK
    \verb|};|
\ttmindex{flag\_names}{in {\tt min::gen\_format}}
\LABEL{MIN::GEN_FORMAT}
\end{tabular}
\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format
                       min::\MINKEY{default\_gen\_format} =}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::default_pgen,|\ARGBREAK
    \verb|  "%.15g",             // number_format|\ARGBREAK
    \verb|  U"\"", U"\"",        // str_prefix/postfix|\ARGBREAK
    \verb|  U"<Q>",              // str_postfix_name|\ARGBREAK
    \verb|  U"<", U">",          // str_char_name_prefix/postfix|\ARGBREAK
    \verb|  U"#", 8,             // str_concatenate/str_max_length|\ARGBREAK
    \verb|  "[: "," "," :]",     // lab_prefix/separator/postfix|\ARGBREAK
    \verb|  "[$ "," $]",         // special_prefix/postfix|\ARGBREAK
    \verb|  min::NULL_STUB,      // special_names|\ARGBREAK
    \verb|  "[. "," .]",         // implicit_prefix/postfix|\ARGBREAK
    \verb|  & min::default_suppress_matrix,|\ARGBREAK
    \verb|  min::default_exp_ok_attrs|\ARGBREAK
    \verb|  min::default_flag_names|\ARGBREAK
    \verb|};|
\LABEL{MIN::DEFAULT_GEN_FORMAT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{default\_pgen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::uns32 gen_flags,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  min::context_gen_flags * context_gen_flags,|\ARGBREAK
    \verb|  const min::gen_format * g );|
\LABEL{MIN::DEFAULT_PGEN} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|min::packed_vec_ptr<const char *> min::|%
    \MINKEY{standard\_\EOL special\_\EOL names}
\LABEL{MIN::STANDARD_SPECIAL_NAMES} \\
\verb|    //     [0 .. 7] == |\\
\verb|    //        "MISSING", "NONE", "ANY", "MULTI_VALUED",|\\
\verb|    //        "UNDEFINED", "SUCCESS", "FAILURE", "ERROR"|\\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef const char * min::|
    & \MINKEY{char\_names}\verb|[256]|
\LABEL{MIN::CHAR_NAMES} \\
\verb|typedef min::uns32 * min::|
    & \MINKEY{char\_flags}\verb|[256]|
\LABEL{MIN::CHAR_FLAGS} \\
\verb|typedef bool min::| & \MINKEY{suppress\_matrix}\verb|[256][256]|
\LABEL{MIN::SUPPRESS_MATRIX} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|const min::char_names min::|%
    \MINKEY{default\_\EOL char\_\EOL names}
\LABEL{MIN::DEFAULT_CHAR_NAMES} \\
\verb|    // All entries NULL except:|\\
\verb|    //     [0x00 .. 0x20] ==|\\
\verb|    //       "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",|\\
\verb|    //       "BS",  "HT",  "LF",  "VT",  "FF",  "CR",  "SO",  "SI",|\\
\verb|    //       "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",|\\
\verb|    //       "CAN", "EM",  "SUB", "ESC", "FS",  "GS",  "FS",  "US",|\\
\verb|    //       "SP"|\\
\verb|    //     [0x22] == "Q"   // Quote "|\\
\verb|    //     [0x7F] == "DEL"|\\
\verb|    //     [0x82 .. 0xA0] ==|\\
\verb|    //                     "BPH", "NBH", "IND", "NEL", "SSA", "ESA",|\\
\verb|    //       "HTS", "HTJ", "VTS", "PLD", "PLU", "RI",  "SS2", "SS3",|\\
\verb|    //       "DCS", "PU1", "PU2", "STS", "CCH", "MW",  "SPA", "EPA",|\\
\verb|    //       "SOS", NULL,  "SCI", "CSI", "ST",  "OSC", "PM",  "APC",|\\
\verb|    //       "NBSP"|\\
\verb|    //     [0xAD] == "SHY"|\\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|const min::suppress_matrix min::|%
    \MINKEY{default\_\EOL suppress\_\EOL matrix}
\LABEL{MIN::DEFAULT_SUPPRESS_MATRIX} \\
\verb|    // All entries false except:|\\
\verb|    //     [B][.] for B == '(', '[', '{', '|\TT{\`~}
                                       \verb|', 0xA8 (|\LAQUOTE\verb|)| \\
\verb|    //     [.][C] for C == ')', ']', '}', 0xB8 (|\RAQUOTE
				       \verb|), 0xB4 (|\TT{\'~}
				       \verb|),| \\
\verb|    //                     ',', ';'| \\
\verb|    //     [B]['\''] for B not a letter| \\
\verb|    //     [B][C] and [C][B]| \\
\verb|    //        for B a letter and C not a letter or '\'',| \\
\verb|    //     or for B a digit and C not a digit or|%
			\verb| ',', '.', ':', '/'|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|min::packed_vec_ptr<min::gen> min::|%
    \MINKEY{default\_\EOL exp\_\EOL ok\_\EOL attrs}
\LABEL{MIN::DEFAULT_EXP_OK_ATTRS} \\
\verb|    // 2 element (first element ".") min::gen labels for:| \\
\verb|    //     .initiator, .separator, .terminator, .middle,| \\
\verb|    //     .name, .arguments, .keys, .operator, .position|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|min::packed_vec_ptr<const char *> min::|%
    \MINKEY{default\_\EOL flag\_\EOL names}
\LABEL{MIN::DEFAULT_FLAG_NAMES} \\
\verb|    // Names of flags numbered 0, 1, 2, ... 255 are:| \\
\verb|    //     ! # $ % & * + - / = ? @ a ... z A ... Z| \\
\verb|    //     ~! ~# ~$ ~% ~& ~* ~+ ~- ~/ ~= ~? ~@ ~a ... ~z ~A ... ~Z| \\
\verb|    //     ^! ^# ^$ ^% ^& ^* ^+ ^- ^/ ^= ^? ^@ ^a ... ^z ^A ... ^Z| \\
\verb|    //     \! \# \$ \% \& \* \+ \- \/ \= \? \@ \a ... \z \A ... \Z| \\
\end{tabular}\end{indpar}

In the above, \ttkey{U"\ldots"} denotes the ASCII character string \TT{"\ldots"}
converted to a \TT{const min::\EOL Uchar *} vector with initial header
element: see \pagref{USTRING}.

The {\tt min::gen\_format} members are:

\begin{itemlist}[0.4in]

\item[\ttmkey{pgen}{in {\tt min::gen\_format}}]
The {\tt pgen} function is called to by {\tt min::pgen} to print
the general value {\tt v} on the given {\tt printer} using
the given {\tt gen\_\EOL flags}, {\tt context\_\EOL gen\_\EOL flags}
and {\tt gen\_\EOL format}.
The function must return the {\tt printer}.  The description of
{\tt gen\_\EOL flags}, {\tt context\_\EOL gen\_\EOL flags},
and {\tt gen\_\EOL format} members in
this section apply only to {\tt min::\EOL default\_\EOL pgen},
the default value of this {\tt pgen} member.

\item[\ttmkey{number\_format}{in {\tt min::gen\_format}}]~\\
The {\tt number\_format} member is used as a {\tt printf} format
for printing {\tt min::gen} numbers converted to {\tt min::\EOL float64} values.

\item[\ttmkey{str\_prefix}{in {\tt min::gen\_format}}]
\item[\ttmkey{str\_postfix}{in {\tt min::gen\_format}}]\vspace{-2ex}
\item[\ttmkey{str\_quote}{in {\tt min::gen\_format}}]\vspace{-2ex}~\\
These members are only enabled if {\tt BRACKET\_\EOL STR\_\EOL FLAG} is on
and none of these three members is {\tt NULL}.

The {\tt str\_\EOL \{pre,post\} fix} members are printed just before and
just after the string of characters in a {\tt min::gen} string value
(which is itself a UTF-8 encoded UNICODE character string).

Any {\tt min::gen} string
subsequence of characters equal to {\tt str\_\EOL post\-fix} is replaced
by the characters of {\tt str\_\EOL quote}.

For example, if
{\tt str\_\EOL postfix} is \TT{"\textbackslash""}, and
{\tt str\_\EOL quote} is \TT{"<Q>"}, then \TT{<Q>} replaces
each \TT{"} in the {\tt min::gen} string that is being printed
(but of course not in {\tt str\_\EOL postfix}
when that is printed just after the {\tt min::gen} string is printed).

\item[\ttmkey{lab\_prefix}{in {\tt min::gen\_format}}]
\item[\ttmkey{lab\_separator}{in {\tt min::gen\_format}}]\vspace{-2ex}
\item[\ttmkey{lab\_postfix}{in {\tt min::gen\_format}}]\vspace{-2ex}~\\
These members are only enabled if {\tt BRACKET\_\EOL LAB\_\EOL FLAG} is on
and none of these three members is {\tt NULL}.

The {\tt lab\_\EOL \{pre,post\} fix} members are printed just before and
just after the elements of a label {\tt min::gen} value,
and the {\tt lab\_\EOL separa\-tor} member
is printed between elements.  Note that the {\tt lab\_\EOL sep\-ara\-tor}
member must include any single space characters that are to be placed between
elements.

\item[\ttmkey{special\_prefix}{in {\tt min::gen\_format}}]
\item[\ttmkey{special\_postfix}{in {\tt min::gen\_format}}]\vspace{-2ex}~\\
These members are only enabled if {\tt BRACKET\_\EOL SPECIAL\_\EOL FLAG} is on
and neither of these two members is {\tt NULL}.

The {\tt special\_\EOL \{pre,post\} fix}
members are printed just before and
just after special {\tt min::gen} values (such as `{\tt MISSING()}').

\item[\ttmkey{implicit\_prefix}{in {\tt min::gen\_format}}]
\item[\ttmkey{implicit\_postfix}{in {\tt min::gen\_format}}]\vspace{-2ex}~\\
These members are only enabled if both the
{\tt BRACKET\_\EOL IMPLICIT\_\EOL FLAG} and {\tt OBJ\_\EOL EXP\_\EOL FLAG}
are on and neither of these two members is {\tt NULL}.

The {\tt implicit\_\EOL prefix/postfix} members surround an object being
printed as an expression per the {\tt OBJ\_\EOL EXP\_\EOL FLAG}, provided that
the object has \underline{neither}
an {\tt .initia\-tor} or a {\tt .ter\-min\-ator} attribute.

\item[\ttmkey{special\_names}{in {\tt min::gen\_format}}]
This member is only enabled if
{\tt SUPPRESS\_\EOL SPECIAL\_\EOL NAMES\_\EOL FLAG} is \underline{off}
and {\tt spec\-ial\_\EOL names} is not {\tt min::\EOL NULL\_\EOL STUB}.
See
{\tt SUPPRESS\_\EOL SPECIAL\_\EOL NAMES\_\EOL FLAG} above for usage.

WARNING: The {\tt special\_\EOL names} member of a {\tt min::gen\_format} is
\underline{not} locatable by the ACC, and its value must therefore be
stored elsewhere in a locatable variable.  It is expected that values of
{\tt special\_\EOL names} will never be garbage collected and
will be pointed at by {\tt static min::\EOL locatable\_\EOL var} or
{\tt min::\EOL locatable\_\EOL gen} variables.

\item[\ttmkey{suppress\_matrix}{in {\tt min::gen\_format}}]~\\
This member controls the {\tt min::suppressible\_space} operation, which
may or may not output a single space character, and which is used
to put the space between label elements
if {\tt SUP\-PRESS\_\EOL LAB\_\EOL SPACE\_\EOL FLAG} is on
and {\tt BRACKET\_\EOL LAB\_\EOL FLAG} is \underline{off},
and which is also used to put the space between object vector elements
being printed in an expression as per the {\tt OBJ\_\EOL EXP\_\EOL FLAG}
if {\tt SUPPRESS\_\EOL EXP\_\EOL SPACE\_\EOL FLAG} is on.
If the flags are not set as indicated,
{\tt min::\EOL suppressible\_\EOL space} is not used for printing labels or
object expression vector elements.

If {\tt suppress\_\EOL matrix} is {\tt NULL},
{\tt min::\EOL suppressible\_\EOL space} outputs a single space character.
Otherwise it outputs a single space character if and only if
\begin{center}
\tt ! suppress\_space[B][C]
\end{center}
where
\begin{center}
\tt
\begin{tabular}{l}
B = min::unicode\_category ( b ) \\
C = min::unicode\_category ( c ) \\
b = {\rm the previous printed UNICODE character} \\
c = {\rm the following printed UNICODE character} \\
\end{tabular}
\end{center}

If we are at the beginning of printing, or if we are at the beginning
of a line, the previous printed UNICODE character
is assumed to be a newline character.  A space is
never output if it would be at the end of a line.

{\tt suppress\_matrix} must be a pointer to a matrix of
{\tt min::\EOL suppress\_\EOL matrix} type (see \pagref{MIN::SUPPRESS_MATRIX})
stored in {\tt static} memory or in the stack.  If stored in the stack,
printer commands that might reference it must not be executed after
it is deallocated.

\item[\ttmkey{str\_max\_length}{in {\tt min::gen\_format}}]~\\
This member is only enabled if {\tt STR\_\EOL ID\_\EOL FLAG} is on.
In this case {\tt min::gen} string values that have length greater
than {\tt str\_\EOL max\_\EOL length} have an identifier i allocated
in {\tt printer->\EOL id\_\EOL map} and are printed as `{\tt @}i'.

\item[\ttmkey{exp\_ok\_attrs}{in {\tt min::gen\_format}}]~\\
This member is only enabled if {\tt OBJ\_\EOL EXP\_\EOL FLAG} is on.
Then if an object is to be printed that all of whose attributes have
names that are elements of {\tt exp\_\EOL ok\_\EOL attrs}, that object
is printed as an expression.  See {\tt OBJ\_\EOL EXP\_\EOL FLAG} below.

WARNING: The {\tt exp\_ok\_attrs} member of a {\tt min::gen\_format} is
\underline{not} locatable by the ACC, and its value must therefore be
stored elsewhere in a locatable variable.  It is expected that values of
{\tt exp\_\EOL ok\_\EOL attrs} will never be garbage collected and
will be pointed at by {\tt static min::\EOL locatable\_\EOL var} or
{\tt min::\EOL locatable\_\EOL gen} variables.

\item[\ttmkey{flag\_names}{in {\tt min::gen\_format}}]
This member is only enabled if it
is not {\tt min::\EOL NULL\_\EOL STUB}.

{\tt flag\_names[i]} is printed as the representation of
control flag {\tt 1 << i} of an attribute.

WARNING: The {\tt flag\_\EOL names} member of a {\tt min::gen\_format} is
\underline{not} locatable by the ACC, and its value must therefore be
stored elsewhere in a locatable variable.  It is expected that values of
{\tt flag\_\EOL names} will never be garbage collected and
will be pointed at by {\tt static min::\EOL locatable\_\EOL var} or
{\tt min::\EOL locatable\_\EOL gen} variables.



\end{itemlist}

Objects, packed structures and vectors, and long strings can be
output as an identifier of the form \TT{@<}{\em id}\TT{>} by using
the printer \key{object ID map}.

A printer's \TT{id\_map} member is initialized automatically when
needed.  However, it can also be set by:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::obj_id_map min::|
    & \MINKEY{set\_\EOL id\_\EOL map\RESIZE}\ARGBREAK
    \verb|( <min::printer printer,|\ARGBREAK
    \verb|  min::id_map map = min::NULL_STUB )|
\LABEL{MIN::SET_ID_MAP_OF_PRINTER} \\
\end{tabular}\end{indpar}

which permits maps to be shared among printers.  If no second argument
is given, an identifier map is created for the printer if none previously
exists.  This can then be shared with other printers.  The final
\TT{id\_\EOL map} member of the printer is returned, and this
is never \TT{min::\EOL NULL\_\EOL STUB}.

When a datum with a stub is printed as
`{\tt @}i', it is recorded in {\tt printer->\EOL id\_\EOL map}
so it may be printed on separate lines.  This may be done by
the printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::| & \MINKEY{flush\_\EOL one\_\EOL id}
\LABEL{MIN::FLUSH_ONE_ID} \\
\verb|min::op min::| & \MINKEY{flush\_\EOL id\_\EOL map}
\LABEL{MIN::FLUSH_ID_MAP} \\
\end{tabular}\end{indpar}

The first operation prints the datum at {\tt printer->\EOL id\_\EOL map[i]}
where {\tt i} equals {\tt printer->\EOL id\_\EOL map->\EOL next}, and then
increments {\tt printer->\EOL id\_\EOL map->\EOL next}.  The second operation
simply repeats the first operation as long as
{\tt printer->\EOL id\_\EOL map->\EOL next}
is less than {\tt printer->\EOL id\_\EOL map->\EOL length}.
The {\tt min::\EOL flush\_\EOL id\_\EOL map} operation is also
performed by the {\tt min::\EOL eom} end-of-message operation
if the print format
{\tt FLUSH\_\EOL ID\_\EOL MAP\_\EOL FLAG} flag is on.

These {\tt id\_map} flushing operations use the
{\tt context\_\EOL gen\_\EOL flags[PGEN\_INDENT]} gen flags
(\pagref{PGEN_INDENT}) with {\tt min::\EOL pgen}
to print the {\em values} in lines of the form:
\begin{center}
\TT{@}i \TT{=} {\em value}
\end{center}
If a line is too long, it may be broken into multiple lines
as specified by the printer parameters.

If the {\em value} is an object not being printed as per
{\tt OBJ\_\EOL EXP\_\EOL FLAG}, then the {\tt OBJ\_\EOL INDENT} flag
will cause the object will be printed on
multiple lines whose form will be:\label{GEN-OBJ-FORM}
\begin{center}
\begin{tabular}{l}
\TT{@}i \TT{=} {\em element}$^\star$\TT{:} \\
~~~~{\em attribute-name-and-values}\\
~~~~\ldots\ldots\ldots\\
~~~~{\em reverse-attribute-name-and-values}\\
~~~~\ldots\ldots\ldots\\
\end{tabular}
\end{center}

where:

\begin{tabular}{rrl}\hspace*{3in}\\[-2ex]
{\em attribute-name-and-values} & ::= &
    {\em attribute-name}\TT{[}{\em attribute-flags}\TT{]} \\
    	&  & \TT{~~~~=} {\em attribute-values}
\\[1ex]
{\em attribute-values} & ::= & {\em attribute-value} \\
                       & $|$ & \TT{\{|} {\em attribute-value} \ldots
		               \TT{|\}}
\\[1ex]
{\em attribute-value} & ::= & printed representation of value
\end{tabular}

\begin{tabular}{rrl}\hspace*{3in}\\[-2ex]
{\em reverse-attribute-name-and-values} & ::= &
    {\em attribute-name}\TT{[}{\em attribute-flags}\TT{]} \\
    	&  & \TT{~~~~=} {\em reverse-attribute-values} \\
	&  & \TT{~~~~=} {\em reverse-attribute-name}
\\[1ex]
{\em reverse-attribute-values} & ::= & {\em reverse-attribute-value} \\
                       & $|$ & \TT{\{|} {\em reverse-attribute-value} \ldots
		               \TT{|\}}
\\[1ex]
{\em reverse-attribute-value} & ::= & \TT{@}{\em natural-number}
\end{tabular}

Note that a {\em reverse-attribute-value} is always an object and is
always printed as per the {\tt OBJ\_\EOL ID\_\EOL FLAG}, even when
that flag is off.

The {\em attribute-flags} have the form:

\newcommand{\TTBS}[1]{\TT{\textbackslash#1}}
\begin{tabular}{rrl}
{\em attribute-flags}
    & ::= & \TT{[}{\em attribute-flag-name}$^\star$\TT{]} \\
    & $|$ & {\em empty} \hspace*{2in}if no flags \\
{\em attribute-flag-name} & ::= &
        \TT{!} $|$ \TT{\#} $|$ \TT{\$} $|$ \TT{\%} $|$ \TT{\&}
    $|$ \TT{*} $|$ \TT{+} $|$ \TT{-} $|$ \TT{/} $|$ \TT{=}
    $|$ \TT{?} $|$ \TT{@} \\
& $|$ & \TT{a} $|$ \ldots{} $|$ \TT{z} $|$ \TT{A} $|$ \ldots{} $|$ \TT{Z} \\
& $|$ & \TT{\~{ }!} $|$ \TT{\~{ }\#} $|$ \TT{\~{ }\$} $|$ \TT{\~{ }\%}
  $|$ \TT{\~{ }\&} $|$ \TT{\~{ }*} $|$ \TT{\~{ }+} $|$ \TT{\~{ }-}
  $|$ \TT{\~{ }/} $|$ \TT{\~{ }=} $|$ \TT{\~{ }?} $|$ \TT{\~{ }@} \\
& $|$ & \TT{\~{ }a} $|$ \ldots{} $|$ \TT{\~{ }z}
  $|$ \TT{\~{ }A} $|$ \ldots{} $|$ \TT{\~{ }Z} \\
& $|$ & \TT{\^{ }!} $|$ \TT{\^{ }\#} $|$ \TT{\^{ }\$} $|$ \TT{\^{ }\%}
  $|$ \TT{\^{ }\&} $|$ \TT{\^{ }*} $|$ \TT{\^{ }+} $|$ \TT{\^{ }-}
  $|$ \TT{\^{ }/} $|$ \TT{\^{ }=} $|$ \TT{\^{ }?} $|$ \TT{\^{ }@} \\
& $|$ & \TT{\^{ }a} $|$ \ldots{} $|$ \TT{\^{ }z} $|$ \TT{\^{ }A}
  $|$ \ldots{} $|$ \TT{\^{ }Z} \\
& $|$ & \TTBS{!} $|$ \TTBS{\#} $|$ \TTBS{\$} $|$ \TTBS{\%} $|$ \TTBS{\&}
  $|$ \TTBS{*} $|$ \TTBS{+} $|$ \TTBS{-} $|$ \TTBS{/} $|$ \TTBS{=}
  $|$ \TTBS{?} $|$ \TTBS{@} \\
& $|$ & \TTBS{a} $|$ \ldots{} $|$ \TTBS{z}
  $|$ \TTBS{A} $|$ \ldots{} $|$ \TTBS{Z} \\
& $|$ & \TT{,}{\em flag-number}
\end{tabular}

Here {\em attribute-flag-names} are listed in the order of their flag number,
where the default correspondence is
\begin{center}
\begin{tabular}{r@{~correspond to flag numbers~}l}
\TT{!} \ldots{} \TT{Z} & \TT{0} \ldots{} \TT{63} \\
\TT{\~{ }!} \ldots{} \TT{\~{ }Z} & \TT{64} \ldots{} \TT{127} \\
\TT{\^{ }!} \ldots{} \TT{\^{ }Z} & \TT{128} \ldots{} \TT{191} \\
\TTBS{!} \ldots{} \TTBS{Z} & \TT{192} \ldots{} \TT{255} \\
\end{tabular}
\end{center}
The {\tt flag\_names} member of the effective {\tt gen\_format}
is used to produce flag names, and the correspondence just
given is that of {\tt min::\EOL default\_\EOL flag\_\EOL names}.

The {\tt context\_gen\_flags} or {\tt gen\_format} of a printer
may be changed by the printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{set\_\EOL context\_\EOL gen\_\EOL flags}\ARGBREAK
      \verb|( min::context_gen_flags * context_gen_flags )|
\LABEL{MIN::SET_CONTEXT_GEN_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL gen\_\EOL format}\ARGBREAK
      \verb|( min::gen_format * gen_format )|
\LABEL{MIN::SET_GEN_FORMAT} \\
\end{tabular}\end{indpar}

New {\em context\_gen\_flags} and {\tt gen\_formats} should be made
by copying a default value into static memory or the stack and then making
specific changes to it, as members may be added to or reordered in
the value.  If the stack is used, old values must be restored
before the stack memory is deallocated.

Strictly for testing purposes, in situations where \TT{min::printer}'s
are not working, general values can be printed to \TT{std::ostreams}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<<}{of {\tt std::ostream \&}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::gen g )|
\LABEL{OPERATOR<<_OF_OSTREAM_AND_GEN} \\
\end{tabular}\end{indpar}

Objects print as `\TT{new\_stub\_gen (} {\em address} \TT{)}',
but other \TT{min::gen} values print in a reasonable way.

\subsection{Objects}
\label{OBJECTS}

An \key{object} is conceptually a hash table that maps
\skey{attribute name}s to \skey{attribute value}s.
An attribute name is a sequence of name components, which
are numbers, strings, and labels.
The part of the hash table that maps attribute names that are equal to
or begin with small unsigned integers is actually a vector.
An attribute value is a \verb|min::gen| datum.

Each attribute name-value pair in an object map represents an
\ikey{arrow}{attribute} in the data base.
The \ikey{source}{of attribute arrow} of the arrow is the object
which is the map,
the \ikey{label}{of attribute arrow} of the arrow is the attribute name,
and the \ikey{destination}{of attribute arrow}
of the arrow is the attribute value.
Some arrows can be \skey{double arrow}s pointing
both to and from the arrow destination.
If the arrow is a double arrow,
a reverse direction label, called the \key{reverse attribute name}
is attached to the arrow, and the object at the destination end of the
arrow is the source of the reversed arrow, whose label is the
reverse attribute name and whose destination is the unreversed arrow's
source.

There can be several arrows with the same attribute name,
and even several arrows with both the same attribute name and the
same value.
There can be several double arrows with the same attribute name and
the same reverse attribute name, and even several double arrows with
the same names and destination object.

Therefore an attribute name and reverse attribute name together name a
multi-set of values, where the reverse attribute name can be missing to
indicate that only single arrows are to be considered, and is present to
indicate that only double arrows are to be considered.
For single arrows the values are any \verb|min::gen| values, but for
double arrows the values are always other objects.
It is possible to add a value to one of these multi-sets
or delete a value from a
multi-set.  It is possible to delete an entire multi-set.
It is possible to treat a multi-set as a set, by adding a value
to it only if the value does not already occur in the multi-set.
When testing for value equality, {\tt ==} is normally used, as this tests for
equality of both name components and objects.

Flags, called \key{attribute flags}, can be attached to an attribute name.
Note that flags are attached to object attribute names, and not to arrows,
values, or reverse attribute names.

There are also typed objects, each of which is a pair of objects,
one called the type that is constant, is shared among many typed objects,
and contains attribute labels, and one called the
context, which contains a vector of \skey{variable}s that hold attribute
values.  Typed objects are described in more detail in
\itemref{TYPED-OBJECTS}.

\subsubsection{Object Bodies}
\label{OBJECT-BODIES}

An object has a body that consists of the following 6 parts in
the order given:

\begin{center}
\begin{tabular}{l}
header \\
variable vector \\
hash table \\
attribute vector \\
unused area\\
auxiliary area
\end{tabular}
\end{center}

The \mkey{header}{of object} contains object flags
(including {\tt min::OBJ\_\EOL PRIVATE}, {\tt min::OBJ\_\EOL PUBLIC},
and {\tt min::OBJ\_\EOL TYPED})
and the sizes of the other 5 parts.
The \mkey{variable vector}{of object} stores the object's variables.
The \mkey{hash table}{of object}
stores attribute name/value pairs, for attributes whose names do not
begin with small unsigned integers.
The \mkey{attribute vector}{of object} stores attribute values
for attributes whose names begin with small unsigned integers.
The \mkey{auxiliary area}{of object}
stores elements of lists headed by hash table and attribute vector
elements, and any other data that would overflow a single
\verb|min::gen| value.
The \mkey{unused area}{of object}
provides for growth of the attribute vector and auxiliary area.

The variable vector and hash table are of fixed size;
their size can only be changed by resizing, reorganizing, and often relocating
the object body.  The attribute vector
grows up from the end of the hash table into the unused
area, and the auxiliary storage grows down from the end of the body into
the unused area.

A variable vector, hash table, and attribute vector element is accessed
using an index relative to the beginning of the vector or table that
contains the element.  Auxiliary area elements are accessed by
\skey{auxiliary pointer}s\label{OBJECT-BODY-AUXILIARY-POINTER}
that give the index of the element relative to the end of the
object body.  Auxiliary pointers with zero index do not address
a body vector element.
For more details see the {\tt var/\EOL hash/\EOL attr/\EOL aux}
functions on \pagref{MIN::VAR_OF_OBJ_VEC_PTR}, and their equivalents on
\pagref{OBJECT-VECTOR-EQUIVALENTS}.

An object may be grown or compacted by relocating and reorganizing its body.
It may be
grown to expand its unused area or hash table, or, less commonly,
its variable vector.  An object may be compacted to eliminate, or less
commonly to shrink, its unused area, and possibly to shrink its hash
table.

There are four kinds of objects: tiny, short, long, and huge.
These have respectively 4, 8, 16, and 32 byte headers, and are capable
of storing information for successively larger objects.
There is no essential difference between these headers and their
internal structure is not visible.  There is no practical limit on
the size of an object%
\footnote{Currently the maximum virtual address space size is $2^{48}$ bytes.}.

An object body may be \smkey{relocate}d{object body}, which means the
body is simply copied to a new address, or
\smkey{reorganize}d{object body}, which means the object body is reformatted,
and possibly converted from one header size to another.  Frequently an
object whose attribute labels and number of values for each label are no
longer subject to change will be compacted, to make it as small as possible,
and this is one kind of object body reorganization.
Objects are compacted by the `{\tt min::\EOL publish\REORG}'
function that sets the
object {\tt OBJ\_\EOL PUBLIC} flag which prevents changes to the
attribute labels, attribute label flags, and number of attribute values
of an object.
Reorganization can also occur whenever an object is relocated by the
compactor, provided that the {\tt OBJ\_\EOL PRIVATE} and
{\tt OBJ\_\EOL PUBLIC} object flags are not set.

The data structure of an object body can be viewed at any of three levels:
vector level (\itemref{OBJECT-VECTOR-LEVEL}),
list level (\itemref{OBJECT-LIST-LEVEL}),
and attribute level (\itemref{OBJECT-ATTRIBUTE-LEVEL}).
The interfaces to all of these levels is protected.  In addition
there is an unprotected vector level interface
(\itemref{OBJECT-UNPROTECTED-VECTOR-LEVEL}) and a
typed object interface (\itemref{TYPED-OBJECTS}).

\subsubsection{Object Creation}
\label{OBJECT-CREATION}

An object can be created by the protected function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}\ARGBREAK
    \verb|( min::unsptr unused_size,|\ARGBREAK
    \verb|  min::unsptr hash_size = 0,|\ARGBREAK
    \verb|  min::unsptr variable_size = 0,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::NEW_OBJ_GEN} \\
\end{tabular}\end{indpar}

The new object has a zero length attribute vector, but this can be
expanded by growing the attribute vector upward into the unused area.
Similarly the auxiliary area is zero length, but can be expanded by
growing downward into the unused area.

The sizes of parts of an object may be changed after the object has
been created by the object maintenance functions
described in Section~\itemref{OBJECT-MAINTENANCE-FUNCTIONS}.

Allocators often maintain sets of free memory blocks of particular
sizes, often powers of two, and allocate new object bodies to one
of these blocks.  In such a case the block may be larger than the
requested body size.  If the `{\tt expand}' argument is {\tt true},
{\tt min::\EOL new\_\EOL obj\_\EOL gen} will round the unused area
size of the new object up so that the new object body fills the
free block to which it is allocated.

On the flip side, the compactor part of the
allocator/\EOL collector/\EOL compactor
may reduce the size of the unused
area.  For an object that has been around a long enough time, the
compactor may eliminate the unused area completely, and may reorganize
the object to downsize its hash table and compact its auxiliary area.

The hash table of the returned object is filled with \verb|min::LIST_END()|
values (\pagref{MIN::LIST_END}), and is therefore an empty hash table.
The variable vector is filled with \verb|min::UNDEFINED()| values.
Unused area elements are initialized to some implementation defined
value like \verb|0|.
The attribute vector and auxiliary areas of the returned object are
zero length, and all space not used by the header, hash table, and
variable vector is allocated to the unused area.
The attribute vector and auxiliary area can be
filled by `push' instructions described below
(\pagref{OBJECT_PUSH_FUNCTIONS}).

A \verb|min::gen| value may be tested to see if it points at an
object by the function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_obj} \verb|( min::gen v )|
\LABEL{MIN::IS_OBJ} \\
\end{tabular}\end{indpar}

The {\tt min::type\_of} function (\pagref{MIN::TYPE_OF_GEN})
applied to an object returns one of the following:

\begin{center}
\begin{tabular}{l}
\ttkey{TINY\_OBJ}\LABEL{MIN::TINY_OBJ} \\
\ttkey{SHORT\_OBJ}\LABEL{MIN::SHORT_OBJ} \\
\ttkey{LONG\_OBJ}\LABEL{MIN::LONG_OBJ} \\
\ttkey{HUGE\_OBJ}\LABEL{MIN::HUGE_OBJ} \\
\end{tabular}
\end{center}

\subsubsection{Object Maintenance Functions}
\label{OBJECT-MAINTENANCE-FUNCTIONS}

Object maintenance functions are used to change the sizes of
object components and compact objects.  The most basic of
these functions do nothing but change the size of the unused
area and variable area:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND} \\
\end{tabular}\end{indpar}

The 4-argument {\tt min::resize} function can change
the size of both the variables vector and unused area at the same
time.  The object body is reallocated, and the function's
`{\tt expand}' argument, if `{\tt true}', will increase
the size of the requested unused area until the object fills
the actual allocated block.  This is useful because allocators
typically allocate blocks whose size is a power of two or
a bit less, so if the requested size is not just right, some
memory will be wasted.

The 2-argument {\tt min::resize} function and the {\tt min::\EOL expand}
function are both equivalent to {\tt min::\EOL resize} with no change
in variables vector size.  The 2-argument {\tt min::\EOL resize}
has implied {\tt false} `{\tt expand}' argument, and the
{\tt min::\EOL expand} function has implied {\tt true} `{\tt expand}'
argument.

The {\tt min::expand} function is the one implicitly used when an object simply
needs more memory for its attribute vector or auxiliary area to grow into.
In this case the argument is just the memory required, and extra unused
area is allocated to fill the next real allocated size block.  Repeated
uses of {\tt min::expand} on the same object will more or less keep
doubling the actual size of the object.

The {\tt min::resize} and {\tt min::expand} functions with object arguments
are called `\skey{resizing function}s'\label{RESIZING-FUNCTIONS}
because they change the size of the object.  They also change
the offset of some elements within the object, and usually
relocate the object.
The names of such functions are marked with the subscript
\subsmkey{S}{of function}.  A resizing funciton is also
a relocating function (\pagref{RELOCATING-FUNCTIONS}).

The remaining maintenance functions assume objects are organized
as per Section~\itemref{OBJECT-LIST-LEVEL}, Object List Level.
These functions all \ikey{reorganize}{object}
an object so it has no discontinuities
in its lists, and therefore no unnecessary invisible jumps (auxiliary
list pointers, actually) within its lists, and makes no use of
auxiliary stubs (\itemref{OBJECT-AUXILIARY-STUBS}).  So in this
sense these functions clean up and compactify the object.  Object
reorganization involves changing auxiliary pointers in the object and
changing the locations of list elements in the object auxiliary area.
It also involves resizing the object.

A function that changes the size of an object hash table further
assumes that hash table elements are {\em attribute/node-name-descriptor-pairs}
as per Section~\itemref{OBJECT-ATTRIBUTE-LEVEL}, Object Attribute Level.
More specifically, it is assumed just that hash table entries are lists
whose elements are grouped into pairs and the first element of each
pair is a hashable {\tt min::gen} value such that if the hash of this
element is $H$, then the pair is put into the list of the $H$\verb|%|$S+1$'st
hash table element, where $S$ is the size of the hash table.

With all this in mind, the following function can be used to
reorganize and object and change the sizes of its variable vector, hash table,
and unused area.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE} \\
\end{tabular}\end{indpar}

The `{\tt expand}' argument to this function works to increase the
size of the unused area in the same was as the
the `{\tt expand}' argument to the {\tt min::resize} function above.
If the hash table size is not actually changed, the Object Attribute Level
assumptions made above do not apply, but the Object List Level assumptions
do apply to all object reorganizations.

After all an object's attributes have been set, the number of
{\em attribute/node-name-descriptor-pairs} in the object hash table
will cease to change, and the hash table size an be optimized
to about twice this number.  The following functions use this idea:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE} \\
\verb|void min::| & \MINKEY{compact\REORG}
    \verb|( min::gen object )| \\
\LABEL{MIN::COMPACT} \\
\verb|void min::| & \MINKEY{publish\REORG}
    \verb|( min::gen object )|
\LABEL{MIN::PUBLISH} \\
\end{tabular}\end{indpar}

These functions are like the {\tt min::reorganize} function
but they pick the size of the hash table automatically as
follows.  If $N$ is the number of
{\em attribute/node-name-descriptor-pairs} in the hash table
and $S$ is the size of the hash table, the hash table size
is left unchanged if $2N/3\leq S\leq 3N$.  Otherwise the
hash table size is reset to $2N$.

The 1-argument {min::compact} function does not change the
size of the variables vector and forces the unused area size
to be zero.  Its goal is to compact the object under the assumption
the object will not change any of its sizes in the future.

The {min::publish} function just executes a
1-argument {min::compact} function and then sets
the object {\tt OBJ\_\EOL PUBLIC} flag which prevents further changes to the
to the object sizes or organization (but not to attribute values).

The {\tt min::reorganize}, {\tt min::compact}, and {\tt min::\EOL publish}
functions with object arguments
are called `\skey{reorganizing function}s'\label{REORGANIZING-FUNCTIONS},
because they move elements around inside the object.
The names of such functions are marked with the subscript
\subsmkey{O}{of function}.
A reorganizing function is also a resizing function
(\pagref{RESIZING-FUNCTIONS}) and
a relocating function (\pagref{RELOCATING-FUNCTIONS}).

It is sometimes useful to discover the values of an object's
{\tt OBJ\_\EOL PRIVATE} and {\tt OBJ\_\EOL PUBLIC} flags.
This can be done by the functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{private\_flag\_of}
    \verb|( min::gen object )| \\
\LABEL{MIN::PRIVATE_FLAG_OF} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}
    \verb|( min::gen object )| \\
\LABEL{MIN::PUBLIC_FLAG_OF} \\
\end{tabular}\end{indpar}

All of the above maintenance functions except the last two
flag reading functions work by creating
vector pointers and using versions of the functions in which the
{\tt min::gen} object argument is replaced by a vector pointer argument.
The functions that actually change the object use a
{\tt min::\EOL obj\_\EOL vec\_\EOL insptr} insertable object
vector pointer and therefore will not work if the object's
{\tt min::\EOL OBJ\_\EOL PUBLIC} flag as already been set.  The
The {\tt min::hash\_count\_of} function will work, as it just uses a
{\tt min::\EOL obj\_\EOL vec\_\EOL ptr} read-only object vector pointer,
as long as there is no other vector pointer pointing at the object.

If you want to build your own compactification function implementing
a different algorithm for choosing hash table size, you may use
the vector pointer version of {\tt min::reorganize} and the following:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{hash\_count\_of}
    \verb|( min::obj_vec_ptr & vp )| \\
\LABEL{MIN::HASH_COUNT_OF} \\
\verb|void min::| & \MINKEY{set\_public\_flag\_of}
    \verb|( min::obj_vec_insptr & vp )| \\
\LABEL{MIN::SET_PUBLIC_FLAG_OF} \\
\end{tabular}\end{indpar}

The {\tt min::hash\_count\_of} function just returns the number of
{\em attribute/node-name-descrip\-tor-pairs} in the object's hash table,
and the {\tt min::\EOL set\_\EOL publish\_\EOL flag} function just sets
the object's {\tt min::\EOL OBJ\_\EOL PUBLIC} flag.

\subsubsection{Object Vector Level}
\label{OBJECT-VECTOR-LEVEL}

At the \key{vector level}, the object body is viewed as
a \key{body vector} of \verb|min::gen| values.
The entire body vector, except
for the header, consists of \verb|min::gen| elements of the
body vector.
A \key{body vector index} is an index of an element in this vector,
and ranges from 0
to one less than the total size of the object,
which is the size of the body vector in {\tt min::\EOL gen} units.
The index 0 cannot be used, as it corresponds to the
header, which does not contain \verb|min::gen| values.
0 can be used as a form of null pointer.

An auxiliary pointer index \verb|i| corresponds to the
body vector index total size {\tt - i}, so \verb|i=1| corresponds
to the last element of the auxiliary area.
The 0 auxiliary pointer index corresponds to the location just
beyond the body vector and is not
usable as the index of an auxiliary area element, so it
can also be used as a form of null pointer.  By indexing auxiliary
area elements in this way, the unused area size can be changed without
changing any auxiliary pointers.

There are three kinds of vector level protected object pointers.
A read-only {\tt min::\EOL obj\_\EOL vec\_\EOL ptr} pointer
permits read-only access to body
vector elements.
A read-write or updatable
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr} pointer
permits read-write access to body vector elements,
but does not permit pushing or popping elements from the
object's attribute vector or auxiliary area.
An insertable {\tt min::\EOL obj\_\EOL vec\_\EOL insptr} pointer
does permit these pushes and pops, in addition to permitting
read-write access to body vector elements.

An object has two flags that regulate the creation of vector level
pointers: \minkey{OBJ\_PRIVATE} and \minkey{OBJ\_PUBLIC}.
If an object has neither of these flags, an object vector pointer
to the object may be created, and this will set the \verb|min::OBJ_PRIVATE|
flag.  When the object vector pointer is destructed, this flag will be cleared.
While this flag is set, no other vector pointer to the object may be
created.  The object is therefore private to the code possessing the
vector pointer.

If an object has neither flag, its \verb|min::OBJ_PUBLIC| flag may be set
by calling the {\tt min::\EOL publish\REORG} function
(\pagref{MIN::PUBLISH}).
When this is set, any number of read-only and read-write (updatable) vector
pointers to the object may be created, but no insertable vector pointers
to the object may be created.  Constructing and destructing
pointers in this case does not set or clear object flags.
The \verb|min::OBJ_PUBLIC| flag may not be cleared by
protected functions.  The idea here is that setting the \verb|min::OBJ_PUBLIC|
flag fixes the attribute label structure of the object, the flags attached
to attribute labels, and the size of
the value multiset of each attribute, but permits the existing values of an
attribute to be read or written.  This permits read-only
sharing of the object and read-write sharing of attribute values of the
object, but does not permit attribute values to be added to or deleted
from the object.

An object with its {\tt min::OBJ\_PUBLIC} flag set is said to be a
\ikey{public}{object} object.

Note that object bodies can be relocated whenever a
relocating function (\pagref{RELOCATING-FUNCTIONS}) is called.
However object bodies may be reorganized by a relocating
function only if neither the
\verb|min::OBJ_PRIVATE| or \verb|min::OBJ_PUBLIC| flags are set.
Object bodies may also be reorganization when insertions are made
using the {\tt min::\EOL insert\_\EOL reserve\RESIZE} function
(\pagref{MIN::INSERT_RESERVE}) on an insertable pointer,
and object bodies are usually reorganized
when the {\tt min::\EOL OBJ\_\EOL PUBLIC} flag is set on an object
by the {\tt min::\EOL publish\REORG} function
(\pagref{MIN::PUBLISH}).

\subsubsubsection{Protected Object Vector Pointers}
\label{PROTECTED-OBJECT-VECTOR-POINTERS}

An \key{object vector pointer} points at the stub of an object
and caches information derived from the header of the object,
so that the differences between different sized object headers are
hidden.  A non-public object can have at most one object vector
pointer pointing at it.  A public object can have any number of
read-only or read-write (update) object vector pointers pointing
at it, but may not change the sizes of its various parts
(like the attribute vector or auxiliary area), so that the
information cached in the object vector pointers never changes.

A \minkey{obj\_\EOL vec\_\EOL ptr} read-only object vector pointer
may be created by the following functions:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}\verb| vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( void )|
\LABEL{MIN::OBJ_VEC_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb|( min::obj_vec_ptr const & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_MIN_STUB} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_GEN} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_STUB} \\
\end{tabular}\end{indpar}

Here if \verb|v| or \verb|s| do not point at the stub of an object
the new object vector pointer is set to {\tt min::\EOL NULL\_\EOL STUB},
which gives undefined results, but usually a memory fault, if
used to access the parts of a object.
The case where \verb|s| equals {\tt min::\EOL NULL\_\EOL STUB}
also sets the object vector pointer to {\tt min::\EOL NULL\_\EOL STUB},
as does the no-argument object vector pointer constructor.
An {\tt =} operator
sets an object vector pointer just as if the pointer
had just been constructed by a constructor whose argument
was the right-side argument of the {\tt =} operator.

Because an object vector pointer can be converted to a
{\tt const min::\EOL stub~*} value, it is possible to check whether
an object vector pointer equals {\tt min::\EOL NULL\_\EOL STUB}
by using the {\tt == function}.  It is also possible to set one
vector pointer from another, as the latter will be converted to a
{\tt const min::\EOL stub~*} value, but note that the object
must be public in order for more than one object vector pointer to
point at it.

Unlike label, packed structure, or packed vector pointers,
object vector pointers cache information about the object, and must always
be writable, and never {\tt const}.

The following protected functions may be used to discover information
about the object pointed at by a read-only {\tt min::obj\_vec\_ptr}:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr min::| & \MINKEY{var\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::VAR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::AUX_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}\label{OBJECT_SIZE_FUNCTIONS}

Here the sizes are in \verb|min::gen| units.  When an object
body is reorganized, some of these sizes may change, but simply
relocating the object body does not change these sizes.  The
automatic resizing of the object that may occur when new elements
are pushed into the attribute vector or auxiliary area only changes
the unused size.

The following functions can be used for \underline{read-only}
access to object elements:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|const min::gen & | & \MINKEY{var}
     \verb|( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_PTR} \\
\verb|const min::gen & | & \MINKEY{hash}
     \verb|( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_PTR} \\
\verb|const min::gen & | & \MINKEY{attr}
     \verb|( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_PTR} \\
\verb|const min::gen & | & \MINKEY{aux}
     \verb|( min::obj_vec_ptr & vp, min::unsptr aux_ptr )|
\LABEL{MIN::AUX_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

Given a vector pointer \verb|vp|, \verb|min::var(vp,i)| can be used
to read the \verb|i+1|'st variable in the object pointed at
by \verb|vp|, for $0\leq i<\mbox{\tt min::var\_size\_of(vp)}$.
Similarly, \verb|min::hash(vp,i)| can be used
to read the \verb|i+1|'st hash table entry
for $0\leq i<\mbox{\tt min::hash\_size\_of(vp)}$,
\verb|min::attr(vp,i)| can be used
to read the \verb|i+1|'st attribute vector entry
for $0\leq i<\mbox{\tt min::attr\_size\_of(vp)}$.
\verb|min::aux(vp,p)| differs slightly in that it reads
the \verb|i|'th auxiliary area element ordering the
elements from the end of the auxiliary area to its beginning,
for $1\leq i\leq\mbox{\tt min::attr\_size\_of(vp)}$.
Auxiliary area indices are defined in this manner
so that an object body may be resized by simply
expanding or contracting its unused area, without modifying
the contents of the other parts of the object body.

The operations

\begin{indpar}\begin{tabular}{r@{}l@{\hspace*{1.4in}}l}
\verb|const min::gen & |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj\_vec\_ptr}}
	& [same as {\tt min::attr}]\\&
	  \multicolumn{2}{l}{~(~min::obj\_vec\_ptr const \& vp,}\\&
	  \multicolumn{2}{l}{~~~min::unsptr index )}
\LABEL{MIN::[]_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{size\_of}
	& [same as {\tt min::attr\_size\_of}]\\&
          \multicolumn{2}{l}{~( min::obj\_vec\_ptr \& vp )}
\LABEL{MIN::SIZE_OF_OBJ_VEC_PTR} \\
\end{tabular}\end{indpar}

are can be used as alternatives that make the attribute
vector part of an object look like a simple vector.

Note that addresses such as {\tt \&min::\EOL var(vp,i)} and
{\tt \&vp[i]} are relocatable addresses, and as such should only
be passed to a non-relocating function like {\tt memcpy},
and never saved in a local variable.
Both {\tt vp[i]} and {\tt min::\EOL attr(vp,i)} include a 
{\tt MIN\_\EOL ASSERT} check that
$0\leq i<\mbox{\tt min::\EOL attr\_\EOL size\_\EOL of(vp)}$.

Also in this vein, the operations

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<const min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINKEY{begin\_ptr\_of} \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINKEY{end\_ptr\_of} \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_PTR} \\
\end{tabular}\end{indpar}

can be used to return {\tt min::ptr<const min::gen>} pointers
to elements of the attribute vector.  {\tt vp + i} returns a
pointer to the {\tt i}+1'st element, and includes a
{\tt MIN\_\EOL ASSERT} check that {\tt i} is less than the
size of the attribute vector.  The {\tt min::\EOL begin\_\EOL ptr\_\EOL of}
and {\tt min::\EOL end\_\EOL ptr\_\EOL of} functions are the same as
{\tt vp + 0} and {\tt vp + min::\EOL size\_\EOL of(vp)} but do
not include this {\tt MIN\_\EOL ASSERT} check, so that, for
example, {\tt min::\EOL begin\_\EOL ptr\_\EOL of} can be used when
the attribute vector has zero length.

A \minkey{obj\_vec\_updptr} read-write (update) object vector
pointer is like a {\tt min::\EOL obj\_\EOL vec\_\EOL ptr}
read-only object vector pointer,
but has element access functions that have been modified
to permit writing elements.  Its functions are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}
    \verb|vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}
    \verb|vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}
    \verb|vp ( void )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_updptr}}\ARGBREAK
          \verb|( min::obj_vec_updptr const & vp )|
\LABEL{MIN::OBJ_VEC_UPDPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::ref<min::gen> | & \MINKEY{var}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{hash}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{attr}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{aux}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::AUX_OF_OBJ_VEC_UPDPTR} \\

\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<min::gen> |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::[]_OF_OBJ_VEC_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINKEY{begin\_ptr\_of} \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINKEY{end\_ptr\_of} \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_UPDPTR} \\
\end{tabular}\end{indpar}

Updatable pointer read-write element access
functions return {\tt min::\EOL ref<min::gen>}%
\label{OBJ_VEC_UPDPTR_REF}
or {\tt min::\EOL ptr<min::gen>} values while read-only pointer
element access functions return
`{\tt const min::\EOL gen~\&}' or
{\tt min::\EOL ptr<const min::gen>} values.

A {\tt min::\EOL obj\_\EOL vec\_\EOL updptr} read-write pointer
may be automatically
downcast to a {\tt min::\EOL obj\_\EOL vec\_\EOL ptr} read-only pointer.
This means that
the non-constructor functions not redefined above that are applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL ptr}'s are applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr}'s.

A \minkey{obj\_vec\_insptr} insertable object vector pointer is like a
{\tt min::obj\_\EOL vec\_\EOL updptr} read-write object vector pointer
but has additional functions which support pushing or popping elements
from the end of the object body attribute vector or the beginning
of the object body auxiliary area and resizing the unused area and
variable vector portions of the object body.
The additional functions for this type of pointer are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK
    \verb|( min::gen v )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK
    \verb|( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK
    \verb|( void )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_insptr}}\ARGBREAK
          \verb|( min::obj_vec_insptr const & vp )|
\LABEL{MIN::OBJ_VEC_INSPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_GEN} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::ref<min::gen> min::| & \MINKEY{attr\_push}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_PUSH_OF_VEC_INSPTR} \\
\verb|void min::ref<min::gen> min::| & \MINKEY{aux\_push}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_PUSH_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}\label{OBJECT_PUSH_FUNCTIONS}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, const min::gen * p = NULL )|
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, const min::gen * p = NULL )|
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_POP_OF_VEC_INSPTR} \\
\verb|min::gen min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_POP_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::AUX_POP_MULTIPLE_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}

The push functions push values to the end of the attribute vector
and the beginning of the unused area.  The pop functions pop values
from the end of the attribute vector and the beginning of the unused
area.

There are two versions of each push or pop: one that
returns {\tt min::\EOL ref<min::gen>} reference to
a single {\tt min::gen} value,%
\label{OBJ_VEC_UPDPTR_PUSH_REF}
and one that handles
{\tt n} values stored in a C/C++ vector pointed at by {\tt p}.
These latter push and pop functions preserve the order of the values in memory,
so \verb|p[0]| is pushed into or popped from a body vector location immediately
before the location into which \verb|p[1]| is pushed into or popped from, etc.
Thus the attribute vector push function pushes
in the order \verb|p[0]|, \verb|p[1]|, \verb|p[2]|, \ldots; while the
auxiliary vector push function pushes
in the order \verb|p[n-1]|, \verb|p[n-2]|, \verb|p[n-3]|, \ldots.
The order of the elements of {\tt p} in memory is the same
as the order of the elements in the object body.

If the push functions are called with argument {\tt p = NULL},
they set the elements pushed to zero.
If the pop functions are called with argument {\tt p = NULL},
they discard the values of the popped elements.

If the push functions are called when the unused
area size is smaller by $k$ elements
than the number of {\tt min::gen} values being pushed, these
functions call the {\tt min::\EOL expand} function (see below)
to add $k$ elements to the unused area before the push is executed.

A {\tt min::\EOL obj\_\EOL vec\_\EOL insptr} may be automatically
downcast to either a {\tt min::\EOL obj\_\EOL vec\_\EOL updptr}
or a {\tt min::\EOL obj\_\EOL vec\_\EOL ptr}.  This means that
all the non-constructor functions applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr}'s or
{\tt min::\EOL obj\_\EOL vec\_\EOL ptr}'s are applicable to
{\tt min::\EOL obj\_\EOL vec\_\EOL insptr}'s.

\subsubsubsection{Vector Level Object Maintenance}
\label{VECTOR-LEVEL-OBJECT-MAINTENANCE}

The object maintenance functions of
Section~\itemref{OBJECT-MAINTENANCE-FUNCTIONS}
which operate on {\tt min::\EOL gen} values have counterparts
that operate on object vector pointers.  These last are merely listed
here, and are as described in the section
just mentioned, with the exception that
the two functions that set the {\tt min::\EOL PUBLIC} flag,
{\tt min::\EOL set\_\EOL public\_\EOL flag\_\EOL of} and
{\tt min::\EOL publish}, end by setting the insertable object vector pointer
they use to {\tt min::\EOL NULL\_\EOL STUB}, as an insertable object vector
pointer is not allowed to point at a public object.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}


\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::COMPACT_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{publish\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::PUBLISH_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}


\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{private\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PRIVATE_FLAG_OF_OBJ_VEC_PTR} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PUBLIC_FLAG_OF_OBJ_VEC_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{hash\_count\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_COUNT_OF_OBJ_VEC_PTR} \\
\verb|void min::| & \MINKEY{set\_public\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::SET_PUBLIC_FLAG_OF_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\subsubsubsection{Unprotected Object Vector Level}
\label{OBJECT-UNPROTECTED-VECTOR-LEVEL}

Using unprotected functions, an object body can be treated
as a simple C/C++ vector of {\tt min::gen} values.  The
required functions are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|const min::gen * & MUP::| & \MUPKEY{base}
    \verb|( min::obj_vec_ptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_PTR} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}
    \verb|( min::obj_vec_updptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_UPDPTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::stub * MUP::| & \MUPKEY{stub\_of} \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::STUB_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::VAR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_INSPTR} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_INSPTR} \\

\end{tabular}\end{indpar}

The offset values returned by the above are those of the
variable vector({\tt var}), hash table({\tt hash}),
attribute vector({\tt attr}), unused area ({\tt unused}), 
and auxiliary area({\tt aux}).  These offsets are in \verb|min::gen|
units, and these offsets and the sizes returned by the functions
on page \pagref{OBJECT_SIZE_FUNCTIONS} are related by

\begin{center}
\begin{tabular}{rcl}
variable vector offset	& = & header size \\
hash table offset       & = & variable vector offset + variable vector size \\
attribute vector offset & = & hash table offset + hash table size \\
unused area offset      & = & attribute vector offset + attribute vector size \\
auxiliary area offset   & = & unused area offset + unused area size \\
total size              & = & auxiliary area offset + auxiliary area size \\
\end{tabular}
\end{center}

Note that when an object is reorganized all these values may
change, including the header size.

Note that the {\tt min::\EOL unused\_\EOL offset\_\EOL of} and
{\tt min::\EOL aux\_\EOL offset\_\EOL of} functions for a
{\tt min::\EOL obj\_\EOL vec\_\EOL insptr} return an
lvalue.  For insertable pointers these offsets change when
values are pushed into or popped from the attribute vector or
auxiliary area.  Using these unprotected functions it is possible
to write your own push and pop functions.

The following are equivalences except for
the omission of {\tt MIN\_\EOL ASSERT} checks that the index \verb|i|
is not too large or too small (auxiliary area indices may not be 0),
calls to {\tt min::\EOL expand} when the unused area is too small
for a push, {\tt MIN\_\EOL ASSERT} checks that elements to be popped
actually exist,
conversions to \verb|min::ref<min::gen>|
values for appropriate element access functions, and
calls to {\tt MUP::\EOL acc\_\EOL write\_\EOL update}
for push operations
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}):

\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|var ( vp, i )| & $\equiv$
    & \verb|return base(vp)[var_offset_of(vp) + i]| \\
\verb|hash ( vp, i )| & $\equiv$
    & \verb|return base(vp)[hash_offset_of(vp) + i]| \\
\verb|attr ( vp, i )| & $\equiv$
    & \verb|return base(vp)[attr_offset_of(vp) + i]| \\
\verb|aux ( vp, i )| & $\equiv$
    & \verb|return base(vp)[total_size_of(vp) - i]| \\
\end{tabular}\end{indpar}\label{OBJECT-VECTOR-EQUIVALENTS}
\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|attr_push ( vp ) = v| & $\equiv$
    & \verb|base(vp)[unused_offset_of(vp)++] = v| \\
\verb|v = attr_pop ( vp )| & $\equiv$
    & \verb|v = base(vp)[--unused_offset_of(vp)]| \\
\verb|aux_push ( vp ) = v| & $\equiv$
    & \verb|base(vp)[--aux_offset_of(vp)] = v| \\
\verb|v = aux_pop ( vp )| & $\equiv$
    & \verb|v = base(vp)[aux_offset_of(vp)++]| \\
\end{tabular}\end{indpar}



The header is the only part of an object body that is
\underline{not} \verb|min::gen| values.  Even so it is
sized in \verb|min::gen| units; e.g., a short object header size
is {\tt 2} for a compact implementation and {\tt 1}
for a loose implementation (\pagref{COMPACT-OR-LOOSE}).

The header may contain implementation dependent information used
for optimization.
For example, objects which have auxiliary stubs
(\pagref{OBJECT-AUXILIARY-STUBS})
may be flagged, thereby identifying objects that need extra work
when deallocated or reorganized.

\subsubsection{Object List Level}
\label{OBJECT-LIST-LEVEL}

At the \key{list level},\label{LIST-LEVEL}
the body consists of two vectors whose
elements are lists.  The two vectors are the hash table, and the
attribute vector (the variable vector is ignored).
The elements of the lists are
\verb|min::gen| values other than the list or sublist auxiliary
pointers, and sublists.  The lists are constructed with
the help of the list and sublist auxiliary pointers:

\begin{center}
\begin{tabular}{lp{3in}}
\key{list auxiliary pointer} &
The list is \underline{continued} at the target of the list auxiliary pointer.
\\[2ex]
\key{sublist auxiliary pointer}	&
A sublist \underline{starts} at the target of the sublist auxiliary pointer.
\end{tabular}
\end{center}

Lists also make use of two constant values:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::gen min::}\MINKEY{LIST\_END()}]~\LABEL{MIN::LIST_END}\\
The list ends here.
This actually equals a list auxiliary pointer with zero index.
\item[{\tt const min::gen min::}\MINKEY{EMPTY\_SUBLIST()}]~%
	\LABEL{MIN::EMPTY_SUBLIST}\\
A list element value that represents an empty sublist.
This actually equals a sublist auxiliary pointer with zero index.
\end{list}
\end{indpar}

Each hash table or attribute vector element is a \key{list head}.
Each list head is a \key{list continuation}, which is an element of the
body vector that has a particular interpretation, described below.
However, not all list continuations are list heads.

A list continuation represents a final segment of a list.
If it has the value \verb|min::LIST_END()|, the final segment is empty.
If the list continuation has a list auxiliary pointer value,
that pointer points at another list continuation that continues the list.
Otherwise the list continuation represents an element of the list,
and is called a \key{list element}.

A list element is an element of the list, and cannot be a list auxiliary
pointer or the special value \verb|min::LIST_END()|.  But it can be
a sublist auxiliary pointer, or the special value \verb|min::EMPTY_SUBLIST()|,
both of which denote a list element that is a sublist.

Given a list element, the rest of the list after the element begins with
a list continuation that has an index one less than that of the list
element within the object body vector, unless the list element is a
list head, in which case there is no next element, and the list has only
one element.  All list heads lie in the hash table or attribute vector,
so testing whether a list element is a list head can be done if just the
index of the list element in the body vector is known.
As a consequence of all this,
zero and one element lists with heads in the hash table
or attribute vector are represented by either {\tt min::\EOL LIST\_\EOL END()}
or by the single list element, stored in the hash table or attribute
vector entry, without any part of the list being stored in the
auxiliary area.

A list element
that is a sublist auxiliary pointer or the value \verb|min::EMPTY_SUBLIST()|
represents a sublist, and is the \key{sublist head} of that sublist.  A
sublist head is a list element of the list containing a sublist,
but cannot be a list element of the sublist.
If it is a sublist auxiliary pointer,
it points at a list continuation of the sublist.  If it is the
value \verb|min::EMPTY_SUBLIST()|, it represents an empty sublist.

There are several rules that the list level obeys that lead to
some efficiencies:

\begin{indpar}
{\bf No Superfluous {\tt \bf min::LIST\_END()}'s}.%
\index{superfluous LIST_END()@superfluous {\tt LIST\_END()}}%
\label{NO-SUPERFLUOUS-LIST}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a \verb|min::LIST_END()| value.

{\bf No Superfluous List Auxiliary Pointers}.%
\index{superfluous list auxiliary pointers}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a list auxiliary pointer.

{\bf No List Sharing}.%
\index{list sharing}
Parts of lists may not be shared with other lists.  In other words,
there is only one way to reach any element of the auxiliary area.

Or more specifically, list and sublist
auxiliary pointers must point at elements of the auxiliary area,
two list or sublist auxiliary pointers are not permitted to point
at the same auxiliary
area element, and an auxiliary area element that is followed
in the auxiliary area by a list element may not be pointed at by
a list or sublist auxiliary pointer (because the following list element
in effect points at the auxiliary area element as being the
continuation of the list containing the following list element).
\end{indpar}

Thus if the one way to reach an element of
the auxiliary area is deleted, the element may be put on a list of
free elements for the auxiliary area.  As an optimization,
an implementation may use the unused area or space in the object's header
to hold a count of the freed elements as an aid to determine when to
reorganize the object.  It is even possible to establish a list of
free elements for reuse, but due to auxiliary area fragmentation this
may not be efficient.

As an optimization, \skey{auxiliary stub}s can be used in place of object
auxiliary area elements.  When this is done, the description of this
section must be modified as explained in \itemref{OBJECT-AUXILIARY-STUBS}.

\subsubsubsection{List Pointers}
\label{LIST-POINTERS}

A \key{list pointer} can be used to move around in a object at
the list level.
There are three kinds of list pointers.
A \verb|min::list_ptr| read-only list pointer permits read-only access to list
elements.
A {\tt min::\EOL list\_\EOL updptr} read-write or updatable list pointer
permits read-write access to list elements, but does not permit
adding or removing list elements.
A {\tt min::\EOL list\_\EOL insptr} insertable list pointer
permits adding and removing elements, in addition to permitting
read-write access to elements.

Note that unlike vector pointers, you \underline{cannot} downcast more capable
list pointers to less capable list pointers.  E.g., a
{\tt min::\EOL obj\_\EOL vec\_\EOL insptr} object vector pointer may be
explicitly or implicitly downcast to a
{\tt min::\EOL obj\_\EOL vec\_\EOL updptr}
or {\tt min::\EOL obj\_\EOL vec\_\EOL ptr} object vector pointer, but 
a {\tt min::\EOL list\_\EOL insptr} list pointer may \underline{not} be
explicitly or implicitly downcast to an
{\tt min::\EOL list\_\EOL updptr}
or {\tt min::\EOL list\_\EOL ptr} list pointer.

The functions for using a \minkey{list\_\EOL ptr} read-only list pointer
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_ptr} \verb|lp ( min::obj_vec_ptr & vp )|
\LABEL{MIN::LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINKEY{obj\_vec\_ptr\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist} \verb|( min::list_ptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_ptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_ptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_ptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_ptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_ptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_PTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{is\_list\_end} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{tabular}\end{indpar}

A list pointer is created to move around in a particular object.
Once created it can be started on a new list by one of the
\skey{start list function}s:
{\tt min::\EOL start\_\EOL hash}, {\tt min::\EOL start\_\EOL attr},
{\tt min::\EOL start\_\EOL copy}, or
the 2-argument {\tt min::\EOL start\_\EOL sublist}.
The {\tt min::\EOL next} function moves forward one element
in the current list,
while the {\tt min::\EOL peek} function returns the next element without
moving to it.
The list pointer is always pointing at a current element, or at
the end of the list.
The {\tt min::\EOL current} function returns the current element
or {\tt min::\EOL LIST\_\EOL END()}.

Determining whether a list pointer current element value
represents a sublist requires
the {\tt min::\EOL is\_\EOL sublist} function, which must check whether the
value is a sublist auxiliary pointer,
is the value {\tt min::\EOL EMPTY\_\EOL SUBLIST()},
or is a pointer to a sublist auxiliary stub as described in
\itemref{OBJECT-AUXILIARY-STUBS}.
The {\tt min::\EOL is\_\EOL empty\_\EOL sublist}
function, on the other hand, merely checks whether the value is
{\tt min::\EOL EMPTY\_\EOL SUBLIST()}.

Determining whether a list pointer current element value
represents the end of a list can be done by
simply checking whether the value equals {\tt min::\EOL LIST\_\EOL END()},
or can be done equivalently
with the {\tt min::\EOL is\_\EOL list\_\EOL end} function.

If the current element
is updated using {\tt min::\EOL update}
on another updatable or insertable list pointer,
the {\tt min::\EOL update\_\EOL refresh} function
must be used to reestablish the
current element's value,
which is \ikey{cached}{cache!list pointer}\label{LIST-POINTER-CACHE}
in the list pointer.
Similarly one of the {\tt min::\EOL\ldots\_refresh} functions may
need to be used when another pointer is used to insert elements into
or remove elements
from the object, though in some situations this is
not adequate and the list pointer must be restarted
with a {\tt min::\EOL start\_\dots} function
(see \pagref{RESTARTING_LIST_PTR}).

A list pointer that has been created but not started by one of the
list start functions appears to be
at the end of an immutable empty list.

The {\tt min::\EOL start\_\EOL hash} function positions
a list pointer at the beginning of the
list whose head is at the given index within the hash table, treating the
hash table as a vector.  This function mods the index by the hash table
size, so the index can be, and usually should be, a hash value returned
by {\tt min::\EOL hash} (\pagref{MIN::HASH}).
Index 0 refers to the first element of the hash table,
and the size of the hash table minus 1 refers to the last element.
The size of the hash table may be obtained from the
{\tt min::\EOL hash\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index.
This function returns the value of the first
element of the list, or returns {\tt min::\EOL LIST\_\EOL END()}
if the list is empty.

The {\tt min::\EOL start\_\EOL attr} function is analogous except it is given
an index within the object attribute vector and positions the list pointer
at the beginning of the list whose head is the attribute vector element
at that index.  Index 0 refers to the first element of the attribute vector,
and the maximum index is the size of the attribute vector minus 1.
The size of the attribute vector may be obtained from the
{\tt min::\EOL attr\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index.

The {\tt min::\EOL start\_\EOL copy} function
positions a list pointer ({\tt lp})
to the same place as another list pointer ({\tt lp2}).
The two list pointers must have been constructed from the \underline{same}
object vector pointer.
Also note that the list pointer {\tt lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before {\tt min::\EOL start\_\EOL copy} is executed.

The value of a list element can represent a sublist
(see the {\tt min::\EOL is\_\EOL sublist} function described below).
The 2-argument {\tt min::\EOL start\_\EOL sublist} function
positions a list pointer ({\tt lp})
to the first element of the sublist represented by the current
element of another list pointer ({\tt lp2}).
The current element of the second pointer must represent a sublist.
This function returns the value of the first element of
the sublist, or returns {\tt min::\EOL LIST\_\EOL END()}
if the sublist is empty.
The two list pointers must have been constructed from the \underline{same}
object vector pointer.
Also note that the list pointer {\tt lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before {\tt min::\EOL start\_\EOL sublist} is executed.

The 1-argument {\tt min::\EOL start\_\EOL sublist} function
positions a list pointer
to the first element of the sublist represented by the current
element of the pointer (it is equivalent to 2-argument
{\tt min::\EOL start\_\EOL sublist} with \verb|lp2|$\equiv$\verb|lp|).
Again the list pointer must be valid before this function is executed.

The {\tt min::\EOL next} function moves the list pointer
to the next list element of the
list the pointer points at, and returns the value of that
list element.  It returns {\tt min::\EOL LIST\_\EOL END()} if there is
no next list element because the end of the list has been reached.
After the end of a list has been reached, additional
calls to {\tt min::next}
will do nothing but return {\tt min::\EOL LIST\_\EOL END()}.

The {\tt min::\EOL peek} function returns the next element of the
list, i.e., the
same value as the {\tt min::\EOL next} function would return, but does not
change the element the list pointer is pointing at, i.e., does not
modify the list pointer.

The {\tt min::current} function just returns the value of the list
element the list pointer currently points at, or returns
{\tt min::\EOL LIST\_\EOL END()}
if there is no such element because the pointer is at the end of a list.
This function does not modify the list pointer.

The {\tt min::update\_\EOL refresh}
function must be called for
a pointer that points at an element if the {\tt min::\EOL update} function
is used with \underline{another} pointer to the same object to update
the element, or if the element is a sublist head and a function is used
to remove the first element of the sublist or insert elements at the
beginning of the sublist or after the first element of the sublist.

The {\tt min::\EOL insert\_\EOL refresh} function must be called if the
{\tt min::\EOL insert\_\EOL reserve} function is used with \underline{another}
pointer to the same object and that function returned \verb|true| indicating
that it resized the object, or if a resizing function is called
for the object (\pagref{RESIZING-FUNCTIONS}).  The 
{\tt min::\EOL insert\_\EOL refresh} function also does what the
{\tt min::\EOL update\_\EOL refresh} function does, and therefore it is
never necessary to call both functions.
There are also situations detailed on \pagref{RESTARTING_LIST_PTR}
in which use of {\tt min::\EOL insert\_\EOL before},
{\tt min::\EOL insert\_\EOL after}, or
{\tt min::\EOL remove} with \underline{another} pointer to the same object
absolutely requires that the current pointer be
restarted by a {\tt min::\EOL start\_\ldots} function.

A \minkey{list\_\EOL updptr} updatable list pointer allows read-write access to
list elements without permitting insertion or removal of elements
from lists.  The functions for using this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_updptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::LIST_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_updptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_updptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_updptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_updptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_updptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_UPDPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_updptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}

Functions defined for read-only list pointers are also
applicable to updatable (read-write) list pointers with the
same results.  However, updatable list pointers
can\underline{not} be converted to be read-only list pointers
(unlike the situation with vector pointers).
Also note that {\tt min::start\_\EOL sublist} works when
\verb|lp2| is a read-only list pointer, but {\tt min::start\_\EOL copy}
does not.

The {\tt min::update} function can be used to replace the
value of the current element of a list.
Neither the previous value of the element nor the
new value of the element may be {\tt min::\EOL LIST\_\EOL END()},
and neither may represent a sublist (even an empty sublist).

If a list pointer {\tt lp2} points at a element that is
{\tt min::update}'ed using a different updatable list pointer {\tt lp1},
then {\tt lp2} will be invalid until
{\tt min::\EOL update\_\EOL refresh(lp2)},
{\tt min::\EOL insert\_\EOL refresh(lp2)}, or
{\tt min::\EOL start\_\ldots(lp2,\ldots)}
has been executed.

Inserting and removing elements from a list requires yet another
kind of list pointer,
a \minkey{list\_\EOL insptr} insertable list pointer.
The functions defined for this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_insptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::LIST_INSPTR_OF_VEC_INSPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_insptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_insptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_insptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_insptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_insptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_INSPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_insptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{insert\_reserve\RESIZE}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr insertions,|\ARGBREAK
	  \verb|  min::unsptr elements = 0,|\ARGBREAK
	  \verb|  bool use_obj_aux_stubs =|\ARGBREAK
	  \verb|      min::use_obj_aux_stubs )|
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_AFTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{remove}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr n = 1 )|
\LABEL{MIN::REMOVE_FROM_LIST_INSPTR} \\
\end{tabular}\end{indpar}

Functions defined for updatable (and read-only) list pointers are also
applicable to insertable list pointers with the
same results.  However, insertable list pointers
can\underline{not} be converted to be updatable or read-only list pointers
(unlike the situation with vector pointers).
Note that {\tt min::start\_\EOL sublist} works when
\verb|lp2| is a read-only or updatable
list pointer, but {\tt min::start\_\EOL copy}
does not.

Also, there is one function, {\tt min::update}, that can do more for
an insertable list pointer than it can for an updatable list pointer.  For
an insertable list pointer (but not for an updatable list pointer)
the current value replaced by {\tt min::update}
may be a sublist, and/or the replacing value may be
{\tt min::\EOL EMPTY\_\EOL SUBLIST()}.  Thus {\tt min::update} can be used
to remove a sublist or to create an empty sublist.

Making insertions in object lists requires reservation of the necessary
space first, in order to be sure that a sequence of insertions will
all succeed.
The {\tt min::insert\_reserve} function reserves space for the given number
of insertion function calls and the given total number of list elements
to be inserted.  If the later is {\tt 0}, the default, it is taken to
be equal to the number of insertion function calls.  If space is not
reserved for insertion function calls in this way, the calls will be
in error.

Only one pointer at a time
for a given object may have an effective reservation.
Each call to {\tt min::\EOL insert\_reserve} for a list pointer
to an object invalidates all previous calls to
{\tt min::\EOL insert\_reserve} for any other list pointer
to the same object.  Errors in this regard involving two different
list pointers will be detected if insufficient memory is reserved,
but not otherwise.

The {\tt min::insert\_reserve\RESIZE} function may expand the body of
the object in which space is being reserved
(using {\tt min::\EOL expand\RESIZE},
\pagref{MIN::EXPAND_OBJ_VEC_INSPTR}).
It returns \verb|true| if it expands the
object's body, and \verb|false| if it does not.

Importantly {\tt min::\EOL insert\_reserve\RESIZE} is the only list pointer
function that may cause a resizing of
the object pointed at, and if a resizing occurs (i.e., if \verb|true|
is returned),
all other list pointers to the same object
become invalid and must be refreshed by
a call to {\tt min::\EOL insert\_\EOL refresh}.

The {\tt min::\EOL insert\_reserve\RESIZE} function can expand the object
if it's size is insufficient, or instead it can depend upon using
object auxiliary stubs (\itemref{OBJECT-AUXILIARY-STUBS}) if the object
runs out of space, in which case {\tt min::\EOL insert\_reserve\RESIZE}
must be sure
there are sufficient free stubs to satisfy the insertion calls.  The
last argument to {\tt min::\EOL insert\_reserve\RESIZE}
determines which strategy is
used.  It defaults to the value of \minkey{use\_obj\_aux\_stubs}
(see \pagref{MIN::USE_OBJ_AUX_STUBS}).%
\footnote{But if the auxiliary stub code is not compiled in, the last
argument is treated as if it was always {\tt false}:
see {\tt MIN\_\EOL USE\_\EOL OBJECT\_\EOL AUX\_\EOL STUBS} on
\pagref{MIN_USE_OBJ_AUX_STUBS}.}

The {\tt min::\EOL insert\_before} function inserts list elements
just before the current position of a list pointer and positions the
list pointer to the first element inserted.
The {\tt min::\EOL insert\_after} function inserts list elements just after the
current position and leaves the pointer position unchanged (pointing at
the element before the first inserted element).
If the list pointer is at the end of list,
{\tt min::\EOL insert\_before} inserts the elements at the end of the list, and
{\tt min::\EOL insert\_after} is in error.
The elements are specified by a length {\tt n}
vector {\tt p} of {\tt min::gen} values.
\verb|p[0]| is inserted into the list before \verb|p[1]|, etc.
If \verb|n=0| elements are to be inserted, both insert
functions are no-operations.

To insert a sublist, first insert {\tt min::\EOL EMPTY\_SUBLIST()}, then
position the pointer to the sublist and use
{\tt min::\EOL start\_sublist} to enter the sublist, and then use
{\tt min::\EOL insert\_before} to insert the elements of the sublist.
Also, as noted above, you can use {\tt min::\EOL update} with an
insertable pointer to change
the current element to {\tt min::\EOL EMPTY\_\EOL SUBLIST()}.

A sequence of instructions that begins with a
call to {\tt min::\EOL insert\_reserve\RESIZE} and ends with the last
list insertion function for which the beginning call made a reservation
is called a `\key{list insertion sequence}'.  A list insertion sequence
must not contain any call to a resizing function
(\RESIZE, \pagref{RESIZING-FUNCTIONS}) or reorganizing function
(\REORG, \pagref{REORGANIZING-FUNCTIONS}), aside from
the beginning call to {\tt min::\EOL insert\_reserve\RESIZE}.
In particular, there can be no
second call to {\tt min::\EOL insert\_reserve\RESIZE}.  There can be calls to
create and position list pointers, and to read, update, and remove
list elements.

If {\tt min::\EOL insert\_\EOL before}
or {\tt min::\EOL insert\_\EOL after}
are used to insert elements at the beginning of a sublist or elements
just after the first element of a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to {\tt min::\EOL update\_\EOL refresh} or
{\tt min::\EOL insert\_\EOL refresh} or restarted with a call to a
{\tt min::\EOL start\_\ldots} function.

The {\tt min::\EOL remove} function can be used to remove
{\tt n} consecutive elements
of a list, the first of which is the element currently pointed at by
the list pointer.
After removal, the list pointer points at the first element after the
elements removed, or at the end of the list if there is no such element.
If there are fewer than {\tt n} elements in the list at and after
the list pointer current element, then there is no error, but all the
elements at and after the current element are removed, and the list
pointer is pointed at the end of the list.  The returned value is the
number of elements actually removed (and is less than {\tt n} if the
list was too short).  Element removal requires no reservation.

If {\tt min::\EOL remove} is used to remove the first element of
a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to {\tt min::\EOL update\_\EOL refresh} or
{\tt min::\EOL insert\_\EOL refresh} or restarted with a call to a
{\tt min::\EOL start\_\ldots} function.

If an insertable list pointer {\tt lp2} is used to add or remove
elements or remove sublists, and there is another list pointer {\tt lp1}
pointing at the same object, then {\tt lp1} is invalidated and must
be restarted with a
{\tt min::\EOL start\_}\,\ldots function\label{RESTARTING_LIST_PTR}
if {\tt lp1} is pointing at:

\begin{enumerate}
\item an element that is removed
\item an element in a removed sublist
\item the end of a removed sublist
\item an element adjacent to an element that is inserted or removed
\item the end of a list whose last element is inserted or removed
\item the first element of a sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\item the end of an empty sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\end{enumerate}

The effects can be subtle
and not obvious: for example, using {\tt lp2} to insert before or after
a list element that is an empty sublist can invalidate {\tt lp1}
if {\tt lp1} points at the end of that empty sublist.

If the insertable vector pointer of an insertable list pointer
{\tt lp1} is used as an argument to
a resizing function (\pagref{RESIZING-FUNCTIONS}) or
a reorganizing function (\pagref{REORGANIZING-FUNCTIONS}) to resize
or reorganize the object {\tt lp1} points to, then
{\tt lp1} must be restarted with a
{\tt min::\EOL start\_}\,\ldots function.

The invalidation of {\tt lp1} in the above situations
is \underline{not} a detectable error.

\begin{quote}
\key{List Implementation Note}:\label{LIST-IMPLEMENTATION-NOTE}
In order to enforce the `No Superfluous' rules on 
\pagref{NO-SUPERFLUOUS-LIST}, {\tt MUP::list\_insptr}'s keep
track of the location of any auxiliary pointer
(or equivalent as per \itemref{OBJECT-AUXILIARY-STUBS})
pointing a the current
element.  Insertions before or after the current element may change
this auxiliary pointer, and may move the current element to another
location.  Otherwise insertions replace the current element
by an auxiliary pointer (or equivalent)
pointing at a vector of elements (or equivalent),
one of which is a copy of the replaced element.
This last is done for insertions after the single element of a one
element list headed in the hash table or attribute vector.
Any insertion before the end of a list of such a single element list
is transformed into an insertion after the list's single element.
\end{quote}

An object can be resized with its lists reorganized so as to
compact the auxiliary area, and also to move information out
of any auxiliary stubs attached to the object and into the
auxiliary area.  This can be done by the functions:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
      \verb|( min::list_insptr & lp,|\ARGBREAK
      \verb|  min::unsptr unused_size,|\ARGBREAK
      \verb|  min::unsptr var_size )|
\LABEL{MIN::RESIZE_OF_LIST_INSPTR} \\
\verb|bool min::| & \MINKEY{resize\RESIZE}\ARGBREAK
      \verb|( min::list_insptr & lp,|\ARGBREAK
      \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}

The size of the unused area is changed by these functions, and
the size of the variable area is also changed by the first of these
functions.

The various list pointer types are instances of
\verb|MUP::|\MUPKEY{list\_ptr\_type} defined as follows:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_ptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_ptr}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_updptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_updptr}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_insptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_insptr}\verb|;| \\
\end{tabular}\end{indpar}

It is important not to instantiate {\tt MUP::list\_ptr\_type}
with any parameter that is not a vector pointer type (which is why
it is unprotected).

\subsubsubsection{Object Auxiliary Stubs}
\label{OBJECT-AUXILIARY-STUBS}

As an optimization, \skey{object auxiliary stub}s\index{auxiliary stub!object}
can be used instead of object
auxiliary area elements.  Object auxiliary stubs are a way of adding
list elements to
an object whose unused area has been exhausted, without relocating the
object.  Object auxiliary stubs
are considered to be \skey{extension}s of the object.
If the object is later reorganized,
use of any object auxiliary stubs that extend the object may be eliminated
by moving information from these into a new larger object auxiliary area.

The code implementing object auxiliary stubs can be compiled into a program
or left out of a program according to the setting of the macro:


\begin{indpar}
\begin{tabular}{l}
\TTKEY{MIN\_USE\_OBJ\_AUX\_STUBS} \\
~~~~~ 1 if code to use object auxiliary stubs is to be compiled; \\
~~~~~ 0 if this code is not to be compiled; the default.
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\end{tabular}
\end{indpar}

If compiled, the code can be enabled or disabled by setting the
following variable:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs} \\
& ~~~~\verb|true| to enable use of object auxiliary stubs; the default \\
& ~~~~\verb|false| to disable use of object auxiliary stubs
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{tabular}\end{indpar}

The value of an object
auxiliary stub is treated like an auxiliary area element value that is
always a list element, and is never a list auxiliary pointer
or a \verb|min::LIST_END()| value.  However, as a list element,
the value may be a sublist auxiliary pointer (or equivalent, see below)
or a \verb|min::EMPTY_SUBLIST()| value.

The control of an object auxiliary stub is treated like an auxiliary
area element value that is always a list auxiliary pointer
or a \verb|min::LIST_END()| value, and is never a list element.

The value and control of an object auxiliary stub are treated like
consecutive elements of the object auxiliary area, with the control
preceding the value in the area, and therefore
following the value in list order.

An object auxiliary stub has one of the following two uncollectable stub type
codes:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const int min::}\MINKEY{LIST\_AUX}]~%
	\LABEL{MIN::LIST_AUX}\\
A \verb|min::gen| value or stub control
pointing at this stub behaves like a list pointer.
\item[{\tt const int min::}\MINKEY{SUBLIST\_AUX}]~%
	\LABEL{MIN::SUBLIST_AUX}\\
A \verb|min::gen| value pointing at this stub behaves like a sublist pointer.
\end{list}
\end{indpar}

Any stub pointer to an object auxiliary stub of type \minkey{LIST\_AUX}
is treated as a list auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \verb|min::gen| values or in auxiliary stub controls.

Any stub pointer to an object auxiliary stub of type \minkey{SUBLIST\_AUX}
is treated as a sublist auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \verb|min::gen| values or in auxiliary stub \verb|min::gen|
values.

Thus the following rules are obeyed:

\begin{indpar}

{\bf \minkey{LIST\_AUX} stubs}.
A \verb|min::gen| value that points at a stub $S$
of type {\tt min::\EOL LIST\_\EOL AUX} is the equivalent of a list auxiliary
pointer pointing at the list element that is stub $S$'s value.

Similarly,
if the control of an object auxiliary stub holds a stub pointer, that pointer
must point at an object auxiliary stub $S$ of type \verb|min::LIST_AUX| and the
control is the equivalent of a list auxiliary pointer pointing at
the list element that is stub $S$'s value.

{\bf \minkey{SUBLIST\_AUX} stubs}.
A \verb|min::gen| value that points at
a stub $S$ of type {\tt min::\EOL SUBLIST\_\EOL AUX}
is the equivalent of a sublist auxiliary
pointer pointing at the list element that is stub $S$'s value.

{\bf Values of Object Auxiliary Stubs}.%
\index{value!of object auxiliary stub}
An object auxiliary stub value is always a list element, and can never
be a list auxiliary pointer value, a \verb|min::gen| value pointing at
a stub of type \verb|min::LIST_AUX|, or a \verb|min::LIST_END()| value.

However, it can be a sublist auxiliary pointer value, a \verb|min::gen|
value pointing at a stub of type \verb|min::SUBLIST_AUX|, or a
\verb|min::EMPTY_SUBLIST()| value.

{\bf Controls of Object Auxiliary Stubs}.%
\index{control!of object auxiliary stub}
An object auxiliary stub control is never a list element, and must
be a list auxiliary pointer value, a stub pointer value pointing at
a stub of type \verb|min::LIST_AUX|, or a \verb|min::LIST_END()| value.

{\bf Pointers to Object Auxiliary Stubs}.%
\index{pointer!to object auxiliary stub}
Every object auxiliary stub is pointed at by a \verb|min::gen|
value or by the control of another object auxiliary stub.  There is
only one such pointer pointing at each object auxiliary stub.
A \verb|min::gen| value pointing at an object auxiliary stub $S$
must be one of the following:
\begin{center}
\begin{tabular}{l@{~~~}l}
Location of \verb|min::gen| & Type of auxiliary stub
\\[2ex]
value of auxiliary area element & \verb|LIST_AUX| or \verb|SUBLIST_AUX|
\\[1ex]
value of auxiliary stub & \verb|SUBLIST_AUX|
\\[1ex]
value of hash table element & \verb|LIST_AUX|
\\[1ex]
value of attribute vector element & \verb|LIST_AUX|
\end{tabular}
\end{center}

\end{indpar}

Object auxiliary stubs
must obey the object list level rules on \pagref{NO-SUPERFLUOUS-LIST}.
This means, for example, that a list auxiliary pointer cannot point
at an auxiliary area element that holds a \verb|min::gen| value
pointing at an object auxiliary stub of type \verb|min::LIST_AUX|,
as this would be equivalent to a list auxiliary pointer pointing at an
element holding another list auxiliary pointer.

The use of object auxiliary stubs by an implementation is hidden from
the user of MIN by object list level functions.  There are no functions
for dealing explicitly with object auxiliary stubs.  There are, however,
unprotected functions to read and write stubs of all kinds in
\itemref{STUB-CONTROL-FUNCTIONS} and
\itemref{STUB-VALUE-READ-WRITE-FUNCTIONS},
though the only use of these functions on
object auxiliary stubs would be for debugging.

\subsubsection{Object Attribute Level}
\label{OBJECT-ATTRIBUTE-LEVEL}

At the \key{attribute level}\,, the object is a map from attribute-names to
flags and multi-sets of values and from attribute-name/reverse-attribute-name
pairs to multi-sets of values.
Here names are sequences of name components, which are
numbers, strings, or labels.  The object map is stored in a set of lists which
are entries in the hash table or attribute vector.  These lists have
one of two syntaxes depending upon the setting of the following macro:

\begin{indpar}
\begin{tabular}{l}
\TTKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS} \\
~~~~~ 1 if partial attribute labels are supported; \\
~~~~~ 0 if partial attribute labels are not supported.
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}
\end{indpar}

If partial attribute labels are supported, the attribute name given to
a function that locates an attribute may be too long,
and the function will use only an initial segment of that name,
returning the length of that segment.

If partial attribute names are \underline{not} supported
the object lists have the syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em hash-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em attribute-descriptor}
\\[1ex]
\emkey{hash-list} ::= {\em attribute-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{attribute-name-descriptor-pair} ::=
    {\em attribute-name } {\em attribute-descriptor}
\\[1ex]
\emkey{attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{attribute-descriptor} ::= {\em value} $|$ {\em attribute-sublist}
\\[1ex]
\emkey{attribute-sublist} ::=
    {\em value}$\,^\star$ {\em double-arrow-sublist-option} {\em flag-set}
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{atom} ::= {\em string} $|$ {\em number}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

Here the syntactic categories represent \verb|min::gen| values
or lists or sublists
of \verb|min::gen| values in the sense of the object list level.

An {\em X-list} is a list, in the sense of the object list level.  Thus
a {\em hash-list} and {\em vector-list} are lists.

An {\em X-sublist} is a sublist, in the sense of the object list level, which
is to say it is a list that is an element of another list.  Thus
{\em attribute-sublists} and {\em double-arrow-sublists} are sublists.

An {\em X-option} is an optional element of a list that is an {\em X} if
it is not omitted.

Everything else is a single list element or
a sequence of elements in some list or sublist.
{\em X-pairs} are sequences of two elements.
{\em Flag-sets} are sequences of {\em control-codes}.

An {\em atom} is a \verb|min::gen| number or string.
An {\em label} is a \verb|min::gen| label.
An {\em object} is a \verb|min::gen| value pointing at an object stub.
A {\em control-code} is a \verb|min::gen| control code value.
An {\em index} is a \verb|min::gen| index value.
An {\em indirect-auxiliary} is a \verb|min::gen| indirect auxiliary value.

The above form of object map maps an {\em attribute-name} to a list of
{\em values}, a list of flag {\em control codes}, and a optional
{\em double-arrow-sublist}.  This last maps {\em reverse-attribute-names}
to lists of values.

The lists of {\em values} here represent multisets of {\em values}.
That is, the
order of the {\em values} in the list is not meaningful.
Similarly the order of {\em attribute-name-descriptor-pairs}
in a {\em hash-list}
or the order of {\em double-arrow-name-descriptor-pairs}
in a {\em double-arrow-sublist} is not meaningful.
On the other hand, a {\em flag-set} is actually an ordered list
of {\em control-codes}; here order matters.

A {\em hash-list} is simply a list of alternating {\em attribute-names}
and {\em attribute-descriptors}.
The long form of an {\em attribute-descriptor} is an
{\em attribute-sublist} that gives  a possibly empty list of {\em values},
an optional {\em double-arrow-sublist}, and a possibly empty
list of flag control codes.
An {\em attribute-sublist} may be empty.
The short form of an {\em attribute-descriptor} is just a single
{\em value}, and is equivalent to an {\em attribute-sublist}
that contains nothing but that {\em value}.
This is a common case, and is optimized to conserve memory.

An empty {\em attribute-sublist} is equivalent to a missing
{\em attribute-name-descriptor-pair}.
{\em Attri\-bute-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

An {\em attribute-vector-entry} is just an {\em attribute-descriptor}
stored in an attribute vector element whose index is the
{\em attribute-name} associated with the {\em attribute-descriptor}.

{\em Attribute-names} can be either {\em atoms} or {\em labels}.
If an {\em attribute-name} is an integer {\em atom}
that is in the range of a legal
attribute vector index then the associated
{\em attribute-descriptor} is put in the attribute vector element
indexed by the integer.
Otherwise an {\em attribute-name-descriptor-pair} containing
the {\em attribute-name} is put
in the {\em hash-list} of the object's hash table entry whose index
in the hash table
equals the hash of the {\em attribute-name} modulo the length of the
hash table.

A {\em double-arrow-sublist} is 
simply a sublist of alternating {\em reverse-attribute-names}
and {\em value-multisets}.  The former are just like {\em attribute-names}
and the latter are just like {\em attribute-descriptors} that have no
flag control codes or {\em double-arrow-sublists}.

An empty {\em value-multiset} is equivalent to a missing
{\em double-arrow-name-descriptor-pair}.
{\em Dou\-ble-arrow-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are \underline{not} supported, multi-component
attribute names are represented in object data lists as labels.
Thus an {\em attribute-name} is an {\em atom} if it represents a 1-component
attribute name, and a {\em label} if it represents a several component
attribute name, or if it represents a 1-component name whose one component
is itself a label.

In the interests of compatibility with the case where partial attribute
names are supported, {\em attribute-names} and {\em reverse-attribute-names}
that are {\em labels} whose sole element is an {\em atom} are not
permitted in the object data lists, and when functions are presented with
such names, the functions replace them with their sole element, namely the
{\em atom}.  In addition, {\em attribute-names} that are labels with no elements
are forbidden, for reasons of compatibility.

If partial attribute names \underline{are} supported
the object lists have the following alternative syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em node-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em node-descriptor}
\\[1ex]
\emkey{node-list} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{node-name-descriptor-pair} ::=
    {\em attribute-name-component } {\em node-descriptor}
\\[1ex]
\emkey{attribute-name-component} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{node-descriptor} ::= {\em value} $|$ {\em node-sublist}
\\[1ex]
\emkey{node-sublist}
    \begin{tabular}[t]{@{}r@{~}l@{}}
    ::= & {\em value}$\,^\star$
          {\em flag-set} \\
    $|$ & {\em value}$\,^\star$
          {\em child-sublist}
	  {\em double-arrow-sublist-option}
	  {\em flag-set}
    \end{tabular}
\\[1ex]
\emkey{child-sublist} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{atom} ::= {\em string} $|$ {\em number}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

This differs from the previous representation in that the object map
is represented by a tree of nodes,
where each node is labeled by an {\em attribute-name-component}.
An {\em attribute-name} is viewed as a sequence of
{\em attribute-name-components}, so the {\em attribute-name}
defines a path in the tree from the root to a node.
Each node has an associated {\em node-descriptor} that
contains the node {\em values},
optional {\em double-arrow-sublist}, and flag control codes,
which are associated
with the {\em attribute-name} that names the path from the root to the
node.  The {\em node-descriptor} also may contain
an optional {\em child-sublist}
which describes the children of the node in the tree.

A {\em hash-table-entry} is a {\em node-list} that gives alternating
{\em attribute-name-component}/\EOL {\em node-\EOL de\-scrip\-tor} pairs for
children of the object root node.  A {\em attribute-vector-entry}
is just a {\em node-descriptor} whose associated {\em attribute-name-component}
is the index of the attribute vector element that contains the
{\em attribute-vector-entry}.
For a node that is a child of the object root,
if the child node's {\em attribute-name-component} is an integer in the legal
range of the object's attribute vector indices, then the child node's
{\em node-descriptor} is stored in
the indexed vector element.
If a vector index is not the first component of
any of the object's attribute names, then the corresponding
{\em attribute-vector-entry} must be an empty {\em node-sublist}.

For a child of the root whose name component is not a legal attribute
vector index, its {\em attribute-name-component}/{\em node-descriptor}
pair is placed in the {\em hash-table-entry}
whose index in the object's hash table equals the hash of the
{\em attribute-name-component} modulo the length of the hash table.

A {\em node-descriptor} that consists of nothing but a single {\em value}
can be represented by just that {\em value}; otherwise it is represented
by a {\em node-sublist}.  If this last contains a sublist, the first
such sublist must
be the {\em child-sublist}, which has the same structure as a {\em node-list}
and describes the children of the node.  Otherwise neither the
{\em child-sublist} nor the {\em double-arrow-sublist} can be present.
Note that to avoid ambiguity it is not permitted to omit the
{\em child-sublist} without also omitting
the {\em double-arrow-sublist}, but the
{\em child-sublist} can be empty.  Except for these details
the {\em node-descriptor} structure is the same was as that of the
{\em attribute-descriptor} in the case where partial attribute names are
not allowed.  The {\em double-arrow-sublist} structure is exactly
the same.

An empty {\em node-sublist} is equivalent to a missing
{\em node-name-descriptor-pair}.
{\em Node-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are supported, an attribute name is viewed
as a sequence of {\em attribute-name-components}.  If this sequence is
a single {\em atom}, function arguments representing the name can be
either this {\em atom} or a {\em label} whose only element is the {\em atom}.
Otherwise function arguments must be non-empty
{\em labels} whose elements are the {\em attribute-name-components}.
Note that zero length labels may not be used as attribute names.

\ikey{Attribute flags}{attribute flag!representation}\label{ATTRIBUTE-FLAGS}
are represented by a {\em flag-set} in an {\em attribute-sublist} or
{\em node-sublist}.
The {\em flag-set} is a sequence of \verb|min::gen|
control codes.

The flags are numbered 0, 1, 2, \ldots.  Flag $N$ corresponds to
the bit in the $I+1$'st control code
selected by the mask $2^K$ where $I=\mbox{floor}(N/\mbox{\tt VSIZE})$,
$K=N~\mbox{mod}~\mbox{\tt VSIZE}$, where {\tt VSIZE},
the number of bits in a control code integer,
is the value of the \verb|min::VSIZE| constant (\pagref{MIN::VSIZE}),
which is 24 if \verb|min::gen|
values are 32-bits, and 40 if \verb|min::gen| values are 64-bits.
A flag is set for an attribute name if and only if its corresponding
bit is present and set and in the attribute's {\em flag-set}.
If a flag's bit is not present in the {\em flag-set}, the flag is
treated as if its bit were present and cleared.

\subsubsubsection{Attribute Pointers}
\label{ATTRIBUTE-POINTERS}

An \key{attribute pointer} can be used to access attribute
flags and values
in an object.
An attribute pointer stores an attribute name
and a reverse attribute name.  The latter can take the special
values {\tt min::NONE()} and {\tt min::ANY()}.  The attribute name designates
the object attribute pointed at by the attribute pointer.
The flag set pointed at is always
the flag set of this attribute, regardless of the setting of the
reverse attribute name.  The attribute name and
reverse attribute name together designate the
value multiset pointed at.  If the reverse attribute name
is {\tt min::NONE()}, the value multiset pointed at is the set of all values
\underline{not} associated with any reverse attribute name.  If the
reverse attribute name is {\tt min::ANY()},
the value multiset is the set of all
values that are associated with any reverse attribute name.
Otherwise the value multiset pointed at is the set of values
associated with the reverse attribute name stored in the pointer.

There are three kinds of attribute pointers.
A read-only {\tt min::\EOL attr\_\EOL ptr}
permits read-only access to attribute values and flags.
An updatable {\tt min::\EOL attr\_\EOL updptr}
permits read-write access to attribute values, and read-only access
to flags, but does not permit values to be added or removed from attributes.
An insertable {\tt min::\EOL attr\_\EOL insptr}
permits read-write access to attribute values and flags
and also permits values to be added or removed from attributes.

The functions for using a read-only {\tt min::\EOL attr\_\EOL ptr}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_ptr} \verb|ap ( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_PTR_OF_OBJ_VEC_PTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_ptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_ptr & ap, int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_ptr & ap, min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_ptr & ap )| \\
\LABEL{MIN::RELOCATE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_OF_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}
    \verb|( min::attr_ptr ap )|
\LABEL{MIN::GET1_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_ptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::gen    flags;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|  min::unsptr flag_count;|\ARGBREAK
    \verb|  min::unsptr reverse_attr_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::ATTR_INFO} \\
\ttmindex{name}{in {\tt min::attr\_info}}
\ttmindex{value}{in {\tt min::attr\_info}}
\ttmindex{flags}{in {\tt min::attr\_info}}
\ttmindex{value\_count}{in {\tt min::attr\_info}}
\ttmindex{flag\_count}{in {\tt min::attr\_info}}
\ttmindex{reverse\_attr\_count}{in {\tt min::attr\_info}}
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_attr\_info}\ARGBREAK
    \verb|( min::attr_info * out, min::unsptr n )|
\LABEL{MIN::SORT_ATTR_INFO} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{reverse\_attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::REVERSE_ATTR_INFO} \\
\ttmindex{name}{in {\tt min::reverse\_attr\_info}}
\ttmindex{value\_count}{in {\tt min::reverse\_attr\_info}}
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_reverse\_attr\_info}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n )|
\LABEL{MIN::SORT_REVERSE_ATTR_INFO} \\
\end{tabular}\end{indpar}

Attribute pointers are tied to an object, which is specified by
giving a vector pointer to the object to the constructor of the
attribute pointer.  The {\tt min::\EOL obj\_\EOL vec\_\EOL ptr\_\EOL of}
function can be used to retrieve the vector pointer used by
an attribute pointer.

\ikey{Locator functions}{locator function}
find attributes within an object and set the current
attribute name and reverse attribute name of an attribute pointer.
The {\tt min::\EOL locate} function sets the attribute name of the pointer.
If the `{\tt length}' argument is \underline{not} given, {\tt min::\EOL locate}
uses the complete attribute name.
The {\tt min::\EOL locatei} function does the
same thing as {\tt min::\EOL locate}
but is optimized for the case where the attribute
name has a single component that is an integer.\footnote{
In some implementations {\tt min::gen} is defined to be {\tt min::uns64},
and in these implementations {\tt int} and {\tt min::unsptr} are
incorrectly convertible to the
{\tt min::gen} type by a C++ implicit conversion.  As a consequence of this
the {\tt min::\EOL locatei} function must have a different name from the
{\tt min::\EOL locate} function.}

The form of the {\tt min::\EOL locate} function that takes a `{\tt length}'
argument exists only if the
{\tt MIN\_\EOL ALLOW\_\EOL PARTIAL\_\EOL ATTR\_\EOL LABELS}
(\pagref{MIN_ALLOW_PARTIAL_ATTR_LABELS}) macro is set to {\tt 1}.
This form of {\tt min::\EOL locate} uses the longest initial segment of the
attribute name that locates an attribute that has a non-empty
multiset of values.  The
length of this initial segment is returned in the `\verb|length|'
argument.  If \verb|0| is returned in `\verb|length|',
no initial segment having a non-empty multiset of values was found.

The {\tt min::\EOL locate\_reverse} function sets the reverse attribute name of
a pointer.  This can take the special value {\tt min::NONE()} or
{\tt min::ANY()}, as noted above.  A call to {\tt min::\EOL locate} or
{\tt min::\EOL locatei} sets the
reverse attribute name to {\tt min::NONE()}.

Both the {\tt min::\EOL locate} and {\tt min::\EOL locate\_reverse}
functions take name
arguments that are labels (\itemref{LABELS}).  If an atom (number or
string) is given instead, this is treated as the equivalent of
a label whose only element is the atom.

If an insertable attribute pointer {\tt ap1} is used
to add or remove attribute values or set or clear attribute flags,
every other attribute pointer {\tt ap2}
to the object will become invalid until a {\tt min::\EOL locate} or
{\tt min::\EOL relocate} function is called for {\tt ap2}.  The later
function is equivalent to repeating the calls to {\tt min::\EOL locate},
and if necessary {\tt min::\EOL reverse\_\EOL locate}, that positioned
{\tt ap2} to where it was before {\tt ap1} was used to modify the object.
Note that simply calling {\tt min::\EOL locate}
and {\tt min::\EOL reverse\_\EOL locate} on {\tt ap1} will
\underline{not} add or remove attribute values or set or clear attribute flags.

Note that \underline{no} special functions need to be called when an attribute
value is updated using {\tt min::\EOL update} on
an updatable attribute pointer.

\ikey{Accessor functions}{accessor function}
can be used for reading attribute values and flags.
For the purposes of describing these functions,
an attribute pointer is considered to point at the attribute
named by the pointer's attribute name, and the reverse attribute
pointed at by the pointer's attribute and reverse attribute names,
unless the latter are \verb|min::NONE()| or \verb|min::ANY()|.
If the {\tt min::\EOL locate} function has never been called to set
these names it is an error to call an accessor
function for the pointer.

The value multiset pointed at by a pointer is that of the attribute pointed
at if the reverse attribute name is \verb|min::NONE()|, or is that of
the reverse attribute pointed at if the reverse attribute name is not
\verb|min::NONE()| or \verb|min::ANY()|.
If the reverse attribute name is \verb|min::ANY()| the value multiset is
the set of all values associated with any reverse attribute name, but
this \verb|min::ANY()|
value set can only be read by the 3-argument \verb|min::get|
function, and made empty by the {\tt min::\EOL set\RESIZE}
function with 0 new values (see \pagref{MIN::SET_DELETE_ANY}).
It is an error to attempt any other access to this \verb|min::ANY()| value set.

The flag set pointed at by a pointer is that of the attribute pointed
at regardless of the setting of the reverse attribute name.
If there are $N$ control codes in a flag set, $N${\tt *VSIZE} flags are
represented by the set, and any flag with number $\geq N${\tt *VSIZE} is
read as zero.  `High order' control codes may contain all zero flags,
and such zero high order control code may be removed when an object
is reorganized.

Attributes whose value and flag sets have never been set are treated
as if they have empty value multisets and flag control code lists.
Similarly reverse attributes
whose value multisets have never been set are treated as having empty value
multisets.

The 3-argument {\tt min::\EOL get} function gets the values in the value
multiset pointed at and stores them in the `{\tt out}' vector.
The total number of values in the value
multiset is returned (regardless of the value of {\tt n}).
The argument {\tt n}, the length of `{\tt out}',
is the maximum number of values that may be returned in `{\tt out}'.
If there are more then {\tt n} values, only the first {\tt n}
are returned in `{\tt out}'.
If {\tt n==0} the function just returns
the number of values in the value multiset.

The 1-argument {\tt min::\EOL get} function assumes that there is exactly
one value in the value multiset
and returns that value, or returns the special value
\verb|min::NONE()| (\pagref{MIN::NONE}) if the value multiset is empty,
or returns the special value
\verb|min::MULTI_VALUED| (\pagref{MIN::MULTI_VALUED}) if the value multiset
has more than one value.

The {\tt min::\EOL get\_\EOL flags}
function returns the control codes in the flag set pointed at and stores
these in the \verb|min::gen| vector `{\tt out}'.
The total number of control codes in the flag set is returned
(regardless of the value of {\tt n}).
The argument {\tt n}, the length of `{\tt out}',
is the maximum number of control codes that may be returned in `{\tt out}'.
If there are more then {\tt n} control codes, only the first {\tt n}
are returned in `{\tt out}'.
If {\tt n==0} the function just returns
the number of control codes in the flag set.

In all of this, high order zero control codes are treated as if
they did not exist (control codes are stored lowest order first
in `{\tt out}').  If there are no non-zero flags, no control codes
are stored in `{\tt out}', and {\tt 0} is returned as the number of
control codes.

In the `{\tt out}' vector, flag $N$ is the bit selected by mask $2^K$
in the vector element with index $I$, where $K=N~\mbox{mod}~\mbox{\tt VSIZE}$
and $I=\mbox{floor}(N/\mbox{\tt VSIZE})$.
If there are $J$ control codes
in the flag set, and $N\geq J*\mbox{\tt VSIZE}$, then
flag $N$ is zero.

The {\tt min::\EOL test\_\EOL flag} function returns the value
of flag {\tt n}.

The attribute names for an object form a list ordered in an implementation
dependent fashion.  
The {\tt min::\EOL get\_\EOL attrs} function gets information about each
attribute in this list.  The information about an attribute is stored in a
{\tt min::\EOL attr\_\EOL info} structure and includes the attribute
name in the {\tt name} member,
the number of values in the attribute value multiset in the {\tt value\_count}
member, the number of control codes in the attribute flag set in
the {\tt flag\_count} member, and the number of associated
reverse attribute names which have non-empty value multisets in the
{\tt reverse\_attr\_count} member.

In addition, the {\tt value} member is set to the attribute value if there
is exactly one value, or to {\tt min::\EOL NONE()} if there is no value,
or to {\tt min::\EOL MULTI\_\EOL VALUED()} if there is more than one value,
and the {\tt flags} member is set to the low order 64 bits of the flags
(or to {\tt 0} if there are no flags).

If a name has only one component that is an {\em atom}, the name is returned
as that {\em atom}; all other names are returned as {\em labels}.

At least one of the three counts must be
non-zero for an attribute, or else the attribute is treated as if it
were not in the list of all attribute names.  In computing
{\tt flag\_count}, high order zero control codes are treated as if they
did not exist, and the value of {\tt flag\_count} is the
same as the value that would be returned by {\tt min::\EOL get\_\EOL flags}.

Attributes accessed through the attribute vector are not returned unless
the {\tt include\_\EOL attr\_\EOL vec} argument is {\tt true}.  These are
just the attributes whose name is a small integer
{\tt i} with {\tt 0 <= i < m}, where {\tt m} is the size of the object
attribute vector.
If the {\tt MIN\_\EOL ALLOW\_\EOL PARTIAL\_\EOL ATTR\_\EOL LABELS}
macro is set to {\tt 1}, any attribute whose name is a label beginning
with such an integer is also not returned.

The {\tt min::\EOL attr\_\EOL info} structs are stored in an {\tt n}
element vector `{\tt out}'
that should be allocated to the stack.  If there are more than
{\tt n} structs, only the first {\tt n}
are returned, but the total number available is returned as the value of
the {\tt min::\EOL get\_\EOL attrs} function, and this should be used
to retry with a larger `{\tt out}' vector.

The implementation dependent order of the \verb|attr_info|
values returned by {\tt min::\EOL get\_\EOL attrs} may change if attribute
values are added to or removed from the object or
attribute flags are set or cleared, or if the object is reorganized.
The {\tt min::\EOL sort\_\EOL attr\_\EOL info} function can be used
to sort by attribute name the
vector returned by {\tt min::\EOL get\_\EOL attrs}.

The {\tt min::\EOL get\_\EOL reverse\_\EOL attrs}
function is analogous but involves the list of
reverse attribute names associated
with a particular object and attribute name stored in the attribute
pointer.
{\tt min::locate\ldots} must be used to set the attribute name to be used.
There is a {\tt min::\EOL reverse\_\EOL
attr\_\EOL info} struct for each reverse attribute name, and there is only
one count member in this, the {\tt value\_count} member that is the number
of values in the value multiset of the reverse attribute pointed at.
A reverse attribute name with an empty value multiset is treated as if it
were not in the list of reverse attribute names.
The {\tt value} member is the reverse attribute value if there is only one
value, or is {\tt min::\EOL MULTI\_\EOL VALUED()} otherwise.

Updatable attribute pointers can set existing values as well as perform
the operations of read-only attribute pointers.
The functions for using a
{\tt min::\EOL attr\_\EOL updptr}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_updptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::ATTR_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_updptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_OF_ATTR_UPDPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_updptr ap )|
\LABEL{MIN::GET1_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_UPDPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_UPDPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

Functions defined for read-only attribute pointers are also
applicable to updatable list pointers with the
same results.  However, updatable list pointers
can\underline{not} be converted to be read-only list pointers
(unlike the situation with vector pointers).

The {\tt min::\EOL update} function requires that the current
value multiset have a single value and that it be the value multiset
of an attribute, and not a reverse attribute.
This function replaces the single value, returning the previous value.
It is an error if the value multiset is empty or has more than one
value, or if the attribute pointer
reverse attribute name is not \verb|min::NONE()|.

Insertable attribute pointers can remove and insert values and
set and clear flags,
as well as perform the operations of updatable attribute pointers.
The functions for using a
{\tt min::\EOL attr\_\EOL insptr}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_insptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_INSPTR_OF_VEC_INSPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_insptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_OF_ATTR_INSPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_insptr ap )|
\LABEL{MIN::GET1_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_INSPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_INSPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::SET1_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ONE1} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ALL1} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{set\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::SET_FLAG} \\
\verb|bool min::| & \MINKEY{clear\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::CLEAR_FLAG} \\
\verb|bool min::| & \MINKEY{flip\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::FLIP_FLAG} \\
\end{tabular}\end{indpar}

Functions defined for updatable attribute pointers are also
applicable to insertable list pointers with the
same results.  However, insertable list pointers
can\underline{not} be converted to be updatable or read-only list pointers
(unlike the situation with vector pointers).

The {\tt min::\EOL set\RESIZE}
function sets all the values in the value multiset the
attribute pointer is pointing at, deleting any previous values.
For 3-argument {\tt min::\EOL set\RESIZE}
the new values are given in the `{\tt in}' vector, and
the number of values is given in {\tt n}.  If {\tt n} is zero, all
values are deleted.
For 2-argument {\tt min::\EOL set\RESIZE} there is one new value given as an
argument, unless {\tt v} is \verb|min::NONE()|,
in which case there are no new values and all previous values are simply
deleted.

For the {\tt min::\EOL set\RESIZE} function
\label{MIN::SET_DELETE_ANY}
the pointer's reverse attribute name can be \verb|min::NONE()|
but cannot be \verb|min::ANY()|, with the exception of the case
where all values are being deleted.  If the reverse attribute name
is \verb|min:ANY()| and the {\tt min::\EOL set\RESIZE} function is called to
delete all previous values,
all double arrows with the current attribute name and any
reverse attribute name are deleted.

The {\tt min::\EOL add\_\EOL to\_\EOL set\RESIZE} function
adds values to the multiset set of values,
but adds each value if and only if the value is not already in the multiset,
using {\tt ==} to compare values for equality.
The {\tt min::\EOL add\_\EOL to\_\EOL multiset\RESIZE} function
adds values even if they are already in the multiset.
Both functions have a 3-argument version with a vector of new values,
and a 2-argument version with a single new value.  In the latter case
if {\tt v} is \verb|min::NONE()| there is no new value and the function
is a no-operation.
For these functions the pointer's reverse attribute name
can be \verb|min::NONE()|
but cannot be \verb|min::ANY()|.

The {\tt min::\EOL remove\_\EOL one} function
removes values from the multiset set of values, removing only one copy of
each value,
using {\tt ==} to compare values for equality.
The {\tt min::\EOL remove\_\EOL all} function
removes all copies of each value  
from the multiset of values (it may be less efficient if
the multiset is actually a set).
Both functions have a 3-argument version with a vector of values to remove,
and a 2-argument version with a single value to remove.  In the latter case
if {\tt v} is \verb|min::NONE()| there is no value to remove and the function
is a no-operation.  These functions return the number of values actually
removed from the multiset of values.
For these functions the pointer's reverse attribute name
can be \verb|min::NONE()| but cannot be \verb|min::ANY()|.

Note that attribute values cannot be control codes, and reverse attribute
values must be pointers to objects.

If the attribute pointer is pointing at a multiset of values
associated with a reverse attribute name,
the values represent double arrows.
In this case, let the object whose attribute value is being set or removed
be $O_1$, the pointer attribute name be $N$, the pointer reverse
attribute name be $R$, and the object being pointed at by the value
being set or removed be $O_2$.
Then when the value is set or removed, the corresponding value that is
an attribute value of $O_2$ with name $R$, reverse name $N$, and target $O_1$
will be set or removed.
That is, the other end of the double arrow will also be set or removed.
In the unusual special case where $O_1=O_2$ and also $N=R$, only one value
is set or removed, so the value will not be duplicated when set and is
assumed to be unduplicated when removed.

The {\tt min::\EOL set\_\EOL flags\RESIZE} function sets the control codes
of the flag set the attribute pointer points at.
The new control codes are given in the `{\tt in}' vector which
has length {\tt n}: see the discussion of
{\tt min::\EOL get\_\EOL flags} on \pagref{MIN::GET_FLAGS_OF_ATTR}
for the format of this vector.
If the previous flag set had more control codes that the new flag
set, the extra control codes will be retained but will be zeroed.
If {\tt n} is zero, all existing control codes are zeroed.
When the object is reorganized, high order zero control codes will
be deleted.

The {\tt min::\EOL set\_\EOL some\_\EOL flags\RESIZE},
{\tt min::\EOL clear\_\EOL some\_\EOL flags},
and {\tt min::\EOL flip\_\EOL some\_\EOL flags}
functions can be used to alter flags.  If the bit corresponding
to the flag is on in the `{\tt in}' vector, it is set, cleared,
or flipped, respectively.

The {\tt min::\EOL set\_\EOL flag\RESIZE},
{\tt min::\EOL clear\_\EOL flag},
and {\tt min::\EOL flip\_\EOL flag}
functions can be used to alter a single flag whose number is
given as the argument {\tt n}.  The flag is set, cleared,
or flipped, respectively.  The previous value of the flag is
returned.

\subsubsection{Typed Objects}
\label{TYPED-OBJECTS}

[Typed objects are not yet implemented and are not discussed outside
this section.  Implementation is likely to consist merely of special
functions to get and set attribute values respecting indirection of
these values while augmenting attribute pointers to hold the
equivalent of {\tt min::\EOL TYPED\_\EOL OBJECT}s
as pointers in place of the equivalent of {\tt min::\EOL gen}
object pointers.  In addition an acyclic unification algorithm
will be provided (cyclic algorithms do not work if only variable
nodes can be forwarded).]

A \key{typed object} is a pair of objects: the \mkey{type}{of typed object}
which provides attribute labels, and the \mkey{context}{of typed object}
which provides variables that give attribute values.  The type
contains variable indices that act as indirect pointers to the
variables in the context.  By abuse of language the context may be
called the `typed object'.

Typed objects may be introduced in two different ways.  In the first
method the context is given the {\tt min::\EOL OBJ\_\EOL TYPED} flag
and its first variable points at the type.  In the second method
the typed object is represented by a stub of {\tt min::\EOL TYPED\_\EOL OBJECT}
type which in turn points at an auxiliary stub that holds two pointers
to stubs: one pointing at the type and the second pointing at the context.
The type is pointed at by the control of the auxiliary stub, the context
is pointed at by the value of the auxiliary stub.

Typed objects make use of two kinds of indirect pointer.  The first is
just a single index \verb|min::gen| value that holds the index of a
variable vector element.  This always refers to a variable in the context.
The second is an indirect \verb|min::gen| value that points at a pair
of values in an auxiliary area: the first being an index \verb|min::gen|
value and the second a pointer-to-object-stub \verb|min::gen| value.
This refers the the variable vector element of the object pointed to
that is indexed by the given index.  If an attribute value is an indirect
pointer, the indirection is taken to the variable element referred to.
If that in turn has an indirect pointer value, that indirection is also
taken, to any depth.

\section{Code and Execution}

\subsection{Execution Flags}
\label{EXECUTION-FLAGS}

TBD: relocation flag

\section{TBD Implementation Ideas}


\subsection{Stack and not Ephemeral}

Instead of ephemeral, we use stack objects.  A stack stub is a stub that
is only reachable from pointers in the stack.   When a stack stub
pointer (as a general value) is stored in a non-stack object, the price
of tracing what it points at to make its target non-stack is paid.
This is a logical time to pay this cost.

\section{To Do}

\clearpage

\appendix

\centerline{\Large \bf Appendices}

\section{C/C++ Interface}
\label{C/C++-Interface}

{
\renewcommand{\LABEL}[1]{\dotfill~\pagref{#1}}
\renewcommand{\TTKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\TTMKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\TTBMKEY}[2]{{\tt ~~[#1]~~}}
\renewcommand{\TTDMKEY}[2]{{\tt ~~.#1~~}}
\renewcommand{\TTOMKEY}[3]{{\tt ~~operator~~#2~~}}
\renewcommand{\TTMOKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\TTARMKEY}[2]{{\tt ~~->#1~~}}
\renewcommand{\MINKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MINIKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\MUPKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\ttkey}[1]{{\tt ~~#1~~}}

\newcommand{\INDEXHEADER}[1]{{\bf #1}:\vspace{1ex}}
\newlength{\TABULARLEN}
\newenvironment{TABULAR}[1]%
  {\setlength{\TABULARLEN}{6.2in}
   \addtolength{\TABULARLEN}{-#1}
   \begin{tabular}{@{}r@{}l@{}}
   \hspace*{#1} & \hspace*{\TABULARLEN} \\[-4ex]}%
  {\end{tabular}}

Unless otherwise noted, this interface is defined by \verb|min.h|.

\INDEXHEADER{Abbreviations}

These are to be included in user's code, and are \underline{not}
in \verb|min|\ldots\verb|.h| files.

\begin{indpar}[0.2in]
\begin{tabular}{@{}p{6.2in}@{}}
\verb|#define MUP  min::unprotected|
\LABEL{MUP} \\
\verb|#define MOS  min::os|
\LABEL{MOS} \\
\verb|#define MACC min::acc|
\LABEL{MACC} \\
\verb|#define MINT min::internal|
\LABEL{MINT} \\
\end{tabular}
\end{indpar}

\INDEXHEADER{Compilation Macros}

These are in \verb|min_parameters.h|.

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_IS\_COMPACT}
\LABEL{MIN_IS_COMPACT} \\
\TTKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\TTKEY{MIN\_IS\_LOOSE}
\LABEL{MIN_IS_LOOSE}	 \\
\TTKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
\LABEL{MIN_MAX_NUMBER_OF_STUBS} \\
\TTKEY{MIN\_STUB\_BASE}
\LABEL{MIN_STUB_BASE} \\
\TTKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS} \\
\TTKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS} \\
\TTKEY{MIN\_PROTECT}
\LABEL{MIN_PROTECT} \\
\TTKEY{MIN\_ASSERT($e$)}
\LABEL{MIN_ASSERT} \\
\TTKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\TTKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS}
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}

\end{indpar}

\INDEXHEADER{Numeric Types}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{uns8}
\LABEL{MIN::UNS8} \\
\verb|min::| & \MINKEY{int8}
\LABEL{MIN::INT8} \\
\verb|min::| & \MINKEY{uns16}
\LABEL{MIN::UNS16} \\
\verb|min::| & \MINKEY{int16}
\LABEL{MIN::INT16} \\
\verb|min::| & \MINKEY{uns32}
\LABEL{MIN::UNS32} \\
\verb|min::| & \MINKEY{int32}
\LABEL{MIN::INT32} \\
\verb|min::| & \MINKEY{float32}
\LABEL{MIN::FLOAT32} \\
\verb|min::| & \MINKEY{uns64}
\LABEL{MIN::UNS64} \\
\verb|min::| & \MINKEY{int64}
\LABEL{MIN::INT64} \\
\verb|min::| & \MINKEY{float64}
\LABEL{MIN::FLOAT64} \\
\verb|min::| & \MINKEY{unsptr}
\LABEL{MIN::UNSPTR} \\
\verb|min::| & \MINKEY{intptr}
\LABEL{MIN::INTPTR} \\
\verb|min::| & \MINKEY{unsgen}
\LABEL{MIN::UNSGEN} \\
\verb|min::| & \MINKEY{Uchar}
\LABEL{MIN::UCHAR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{General Value Types and Constants}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{stub}
\LABEL{MIN::STUB} \\
\verb|min::| & \MINKEY{gen}
\LABEL{MIN::GEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.0in}
\verb|typedef |
	& \verb|min::uns32|
	  \verb|min::|\MINKEY{unsgen}\COMPACT
\LABEL{MIN::COMPACT_UNSGEN} \\
\verb|typedef |
	& \verb|min::uns64|
	  \verb|min::|\MINKEY{unsgen}\LOOSE
\LABEL{MIN::LOOSE_UNSGEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.0in}
\verb|const unsigned min::| & \MINKEY{TSIZE}
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
\LABEL{MIN::VSIZE}
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Stub Type Codes}\label{STUB-TYPE-CODE-LIST}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|const int min::| & \MINKEY{DEALLOCATED}
\LABEL{MIN::DEALLOCATED} \\
\verb|const int min::| & \MINKEY{NUMBER}
\LABEL{MIN::NUMBER} \\
\verb|const int min::| & \MINKEY{SHORT\_STR}
\LABEL{MIN::SHORT_STR} \\
\verb|const int min::| & \MINKEY{LONG\_STR}
\LABEL{MIN::LONG_STR} \\
\verb|const int min::| & \MINKEY{LABEL}
\LABEL{MIN::LABEL} \\
\verb|const int min::| & \MINKEY{PACKED\_STRUCT}
\LABEL{MIN::PACKED_STRUCT} \\
\verb|const int min::| & \MINKEY{PACKED\_VEC}
\LABEL{MIN::PACKED_VEC} \\
\verb|const int min::| & \MINKEY{TINY\_OBJ}
\LABEL{MIN::TINY_OBJ} \\
\verb|const int min::| & \MINKEY{SHORT\_OBJ}
\LABEL{MIN::SHORT_OBJ} \\
\verb|const int min::| & \MINKEY{LONG\_OBJ}
\LABEL{MIN::LONG_OBJ} \\
\verb|const int min::| & \MINKEY{HUGE\_OBJ}
\LABEL{MIN::HUGE_OBJ} \\
\verb|const int min::| & \MINKEY{LIST\_AUX}
\LABEL{MIN::LIST_AUX} \\
\verb|const int min::| & \MINKEY{SUBLIST\_AUX}
\LABEL{MIN::SUBLIST_AUX} \\
\end{TABULAR}
\end{indpar}

\INDEXHEADER{Stub Related Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|int min::| & \MINKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MIN::TYPE_OF} \\
\verb|int MUP::| & \MUPKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MUP::TYPE_OF} \\
\verb|int min::| & \MINKEY{type\_of} \verb|( min::gen v )|
\LABEL{MIN::TYPE_OF_GEN} \\
\verb|bool min::| & \MINKEY{is\_collectible} \verb|( int type )|
\LABEL{MIN::IS_COLLECTIBLE} \\[1ex]
\verb|void min::| & \MINKEY{interrupt\REL} \verb|( void )|
\LABEL{MIN::INTERRUPT} \\
\verb|void min::| & \MINKEY{deallocate\REL} \verb|( const min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\verb|bool min::| & \MINKEY{is\_deallocated} \verb|( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{gen} \verb|( void )|
\LABEL{MIN::GEN_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::==_OF_GEN} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::!=_OF_GEN} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_stub} \verb|( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::| & \MINKEY{is\_direct\_float\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::| & \MINKEY{is\_direct\_int\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::| & \MINKEY{is\_direct\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::| & \MINKEY{is\_index} \verb|( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::| & \MINKEY{is\_control\_code} \verb|( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::| & \MINKEY{is\_special} \verb|( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::| & \MINKEY{is\_list\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_sublist\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_indirect\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::| & \MINKEY{is\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_AUX} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|const min::stub * | & \MINKEY{NULL\_STUB}
\LABEL{MIN::NULL_STUB} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * min::| & \MINKEY{stub\_of}\ARGBREAK
                        \verb|( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of} \verb|( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen min::| & \MINKEY{new\_stub\_gen} \verb|( const min::stub * s )|
\LABEL{MIN::NEW_STUB_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE} \verb|( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen} \verb|( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen\COMPACT} \verb|( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int min::| & \MINKEY{gen\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::| & \MUPKEY{new\_gen} \verb|( min::unsgen value )|
\LABEL{MUP::NEW_GEN} \\
\verb|min::unsgen MUP::| & \MUPKEY{value\_of} \verb|( min::gen value )|
\LABEL{MUP::VALUE_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of} \verb|( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::|
    & \MUPKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of} \verb|( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of} \verb|( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::| & \MUPKEY{new\_stub\_gen} \verb|( const min::stub * s )|
\LABEL{MUP::NEW_STUB_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_float\_gen\LOOSE} \verb|( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_int\_gen\COMPACT} \verb|( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen} \verb|( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::| & \MUPKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen} \verb|( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\

\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Subtype Codes}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_INT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_FLOAT}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::| & \MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::| & \MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_PACKED\_AUX}
\LABEL{MIN::GEN_PACKED_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::| & \MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Special Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{MISSING()}
\LABEL{MIN::MISSING} \\
\verb|min::gen min::| & \MINKEY{NONE()}
\LABEL{MIN::NONE} \\
\verb|min::gen min::| & \MINKEY{ANY()}
\LABEL{MIN::ANY} \\
\verb|min::gen min::| & \MINKEY{MULTI\_VALUED()}
\LABEL{MIN::MULTI_VALUED} \\
\verb|min::gen min::| & \MINKEY{UNDEFINED()}
\LABEL{MIN::UNDEFINED} \\
\verb|min::gen min::| & \MINKEY{SUCCESS()}
\LABEL{MIN::SUCCESS} \\
\verb|min::gen min::| & \MINKEY{FAILURE()}
\LABEL{MIN::FAILURE} \\
\verb|min::gen min::| & \MINKEY{ERROR()}
\LABEL{MIN::ERROR} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Body References}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T & const location )|
\LABEL{MUP::NEW_REF_OF_LOCATION} \\
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_REF_OF_OFFSET} \\
\verb|min::|\MINKEY{ref<T>}\verb| min::| & \MINKEY{new\_ref}\ARGBREAK
    \verb|( T & location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_REF} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * MUP::| & \MUPKEY{ZERO\_STUB}
\LABEL{MUP::ZERO_STUB} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * const r| & \TTDMKEY{s}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_STUB} \\
\verb|min::unsptr const r| & \TTDMKEY{offset}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T const & value )| \\
\LABEL{MIN::=REF_OF_T} \\
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  min::ref<T> const & r2 )|
\LABEL{MIN::=REF_OF_REF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|T |
    & \TTOMKEY{T}{{\tt T}}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_TO_T} \\
\verb|T |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::ref<T>}}\ARGBREAK
	  \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_->} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::==REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( T v, min::ref<T> const & r )|
\LABEL{MIN::==T_AND_REF} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::!=REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( T v, min::ref<T> &const  r )|
\LABEL{MIN::!=T_AND_REF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  const min::stub * s )|
\LABEL{MIN::==REF_AND_STUB} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  const min::stub * s )|
\LABEL{MIN::!=REF_AND_STUB} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Body Pointers}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{ptr<T>} \verb| p|
\LABEL{MIN::PTR_OF_T} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T * location )|
\LABEL{MUP::NEW_PTR_OF_LOCATION} \\
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_PTR_OF_OFFSET} \\
\verb|min::|\MINKEY{ptr<T>}\verb| min::| & \MINKEY{new\_ptr}\ARGBREAK
    \verb|( T * location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_PTR} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * const p| & \TTDMKEY{s}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_STUB} \\
\verb|min::unsptr const p| & \TTDMKEY{offset}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ptr<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ptr<T> & p,|\ARGBREAK
      \verb|  min::ptr<T> const & p2 )|
\LABEL{MIN::=PTR_OF_PTR}
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|T * |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::ptr<T>}}\ARGBREAK
	  \verb|( min::ptr<T> const & p )|
\LABEL{MIN::PTR_->} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::=AMPERSAND_OF_REF_OF_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{*}{*}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p )|
\LABEL{MIN::=*_OF_PTR_OF_T} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<T> p| & \TTBMKEY{i}{of {\tt min::ptr}}
\LABEL{MIN::PTR_[]} \\
\verb|min::ptr<T> p|
    & \TTMOKEY{+}{of {\tt min::ptr}}\verb|i|
\LABEL{MIN::PTR_+} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|T * |
	& \TTOMKEY{!}{!}{of {\tt min::ptr<T>}}\ARGBREAK
	  \verb|( min::ptr<T> const & p )| ~ [unprotected]
\LABEL{MIN::!_OF_PTR} \\
\verb|min::ptr<T> |
	& \MINKEY{ptr<T>}\ARGBREAK
	  \verb|( min::ptr<S> const & p )| ~ [unprotected]
\LABEL{MIN::PTR_OF_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{<}{<}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1,|\ARGBREAK
      \verb|  min::ptr<T> const & p2 )|
\LABEL{MIN::<_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{++}{++}{of {\tt min::ptr<T>}}%
    \hspace*{1.3in} [postfix {\tt ++}]\ARGBREAK
      \verb|( min::ptr<T> & r, int )|
\LABEL{MIN::POSTFIX_++_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{--}{-{}-}{of {\tt min::ptr<T>}}%
    \hspace*{1.3in} [prefix {\tt --}]\ARGBREAK
      \verb|( min::ptr<T> & r )|
\LABEL{MIN::PREFIX_--_OF_PTR_OF_T} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::==_OF_PTR_OF_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::!=_OF_PTR_OF_T} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Body Copy Macros}

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_STACK\_COPY} \verb|( type, name, length, source )|
\LABEL{MIN_STACK_COPY}
\end{tabular}

\end{indpar}


\INDEXHEADER{ACC Locatable Types}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|class min::| & \MINKEY{locatable\_var<T>} \TT{: public T} \\
    & use \TT{min::stub\_ptr} for \TT{T} instead of \TT{const min::stub *}
\LABEL{MIN::LOCATABLE_VAR_BASECLASS} \\
\end{TABULAR}

\begin{TABULAR}{3.7in}
\verb|typedef min::locatable<min::gen> min::| & \MINKEY{locatable\_gen}
\LABEL{MIN::LOCATABLE_GEN} \\
\verb|typedef min::locatable<min::stub_ptr> min::|
    & \MINKEY{locatable\_stub\_ptr}
\LABEL{MIN::LOCATABLE_STUB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{3.2in}
\multicolumn{2}{l}{In compact implementation:} \\
~~~~\verb|typedef min::locatable_gen  min::| & \MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\multicolumn{2}{l}{In loose implementation:} \\
~~~~\verb|typedef min::gen  min::| & \MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb| var ( void )|
\LABEL{MIN::LOCATABLE_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( min::locatable_var<T> const & var )|
\LABEL{MIN::LOCATABLE_VAR_OF_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( T const & value )|
\LABEL{MIN::LOCATABLE_VAR_OF_VALUE} \\
\end{TABULAR}

\begin{TABULAR}{2.1in}
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  min::locatable_var<T> const & var2 )|
\LABEL{MIN::=LOCATABLE_VAR_OF_LOCATABLE_VAR} \\
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  T const & value )|
\LABEL{MIN::=LOCATABLE_VAR_OF_VALUE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<T const> |
    & \TTOMKEY{min::ref<T const>}{min::ref<T const>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::CONST_LOCATABLE_VAR_TO_REF_CONST_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{min::ref<T>}{min::ref<T>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::LOCATABLE_VAR_TO_REF_T} \\
\verb|min::ptr<T const> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::AMPERSAND_CONST_LOCATABLE_VAR} \\
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::AMPERSAND_LOCATABLE_VAR} \\
\end{TABULAR}

\bigskip

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_REF} \verb|( type, name, ctype )|
\LABEL{MIN_REF}
\end{tabular}

\end{indpar}


\INDEXHEADER{ACC Stub Pointer Write Update Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * s2 )|
\LABEL{MUP::ACC_WRITE_STUB_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_GEN_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_UPDATE} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * const * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_STUB_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_GEN_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_VEC_UPDATE} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Unprotected Stub Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub} \verb|( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub} \verb|( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\verb|void MUP::| & \MUPKEY{free\_aux\_stub} \verb|( min::stub * s )|
\LABEL{MUP::FREE_AUX_STUB} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Read/Write Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of} \verb|( const min::stub * s )|
\LABEL{MUP::VALUE_OF_STUB} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of} \verb|( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{ptr\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PTR_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_value\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of}\ARGBREAK
      \verb|( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of}\ARGBREAK
      \verb|( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_ptr\_of}\ARGBREAK
      \verb|( min::stub * s, void * p )|
\LABEL{MUP::SET_PTR_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Control Functions}

\begin{indpar}[0.2in]


\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of} \verb|( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}\ARGBREAK
      \verb|( const min::stub * s, min::uns64 flags )|
\LABEL{MUP::TEST_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_control\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of}\ARGBREAK
      \verb|( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator}\ARGBREAK
      \verb|( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value}\ARGBREAK
      \verb|( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub}\ARGBREAK
      \verb|( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int MUP::| & \MUPKEY{locator\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub}\ARGBREAK
      \verb|( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
[1ex]
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type}\ARGBREAK
      \verb|( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Control Flags}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|const min::uns64 MUP::| & \MUPKEY{STUB\_ADDRESS}
\LABEL{MIN::STUB_ADDRESS}\\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Body Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|void MUP::|
    & \MUPKEY{new\_body} \verb|( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body}\ARGBREAK
      \verb|    ( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of} \verb|( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\verb|void * & MUP::| & \MUPKEY{ptr\_ref\_of}
	      \verb|( min::stub * s )| 
\LABEL{MUP::PTR_REF_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\ARGBREAK
    \verb|    ( min::stub * s,|\ARGBREAK
    \verb|      min::unsptr new_size,|\ARGBREAK
    \verb|      min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_ptr\_ref}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_PTR_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\verb|void MUP::| & \MUPKEY{retype\_resize\_body}\ARGBREAK
	     \verb|( MUP::resize_body & rb,|\ARGBREAK
	     \verb|  int new_type )| 
\LABEL{MUP::RETYPE_RESIZE_BODY} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT} \verb|( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_num} \verb|( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of} \verb|( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of} \verb|( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash} \verb|( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{floathash} \verb|( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{String Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb|( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb|( min::ptr<const char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
	\verb|( min::ptr<const char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb|( min::ptr<char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
	\verb|( min::ptr<char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( const min::Uchar * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<const min::Uchar> p,|\ARGBREAK
      \verb|  min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_CONST_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<min::Uchar> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_UNICODE} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|const min::Uchar min::|
    & \MINKEY{UNKNOWN\_UCHAR}
\LABEL{MIN::UNKNOWN_UCHAR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::Uchar min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( const char * & s )|
\LABEL{MIN::UTF8_TO_UNICODE} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb|( char * & s, min::Uchar c )|
\LABEL{MIN::UNICODE_TO_UTF8} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( min::Uchar * & u, const min::Uchar * endu,|\ARGBREAK
      \verb|  const char * & s, const char * ends )|
\LABEL{MIN::UTF8_STR_TO_UNICODE_STR} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb| ( char * & s, const char * ends,|\ARGBREAK
      \verb|   const min::Uchar * & u,|\ARGBREAK
      \verb|   const min::Uchar * endu )|
\LABEL{MIN::UNICODE_STR_TO_UTF8_STR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns8 min::| & \MINKEY{unicode\_category} \verb|( min::Uchar c )|
\LABEL{MIN::UNICODE_CATEGORY}
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|typedef min::Uchar min::| & \MINKEY{Ustring}
\LABEL{MIN::USTRING} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::unsptr min::|
    & \MINKEY{unicode\_length} \ARGBREAK
      \verb|( const min::Ustring * p )|
\LABEL{MIN::UNICODE_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{unicode\_columns}\ARGBREAK
      \verb|( const min::Ustring * p )|
\LABEL{MIN::UNICODE_COLUMNS} \\
\verb|const min::Uchar * min::|
    & \MINKEY{unicode\_string} \ARGBREAK
      \verb|( const min::Ustring * p )|
\LABEL{MIN::UNICODE_STRING} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|int min::| & \MINKEY{is\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\
\verb|char * min::| & \MINKEY{strcpy} \verb|( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::| & \MINKEY{strncpy}\ARGBREAK
                      \verb|( char * p,|\ARGBREAK
		      \verb|  min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\
\verb|int min::| & \MINKEY{strcmp} \verb|( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::| & \MINKEY{strncmp}\ARGBREAK
                   \verb|( const char * p,|\ARGBREAK
		   \verb|  min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns64 min::| & \MINKEY{strhead} \verb|( min::gen v )|
\LABEL{MIN::STRHEAD_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int32 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int64 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT64} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns32 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns64 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS64} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float32 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT32} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float64 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT64} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{String Pointers}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MIN::STR_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MIN::STR_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.3in}
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp, min::gen v )|
\LABEL{MIN::=_STR_PTR_OF_GEN} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1,|\ARGBREAK
      \verb|  min::str_ptr const & sp2 )|
\LABEL{MIN::=_STR_PTR_OF_STR_PTR} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1, const min::stub * s )|
\LABEL{MIN::=_STR_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|operator |
    & \MINKEY{bool} \verb|( min::str_ptr const & sp )|
\LABEL{BOOL_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|char sp|
    & \TTBMKEY{i}{of {\tt min::str\_ptr}}
\LABEL{MIN::[]_OF_STR_PTR} \\
\verb|min::ptr<const char> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::str_ptr const & sp )|
\LABEL{MIN::BEGIN_PTR_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::gen v )|
\LABEL{MIN::STRLEN_OF_STR_PTR} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::str_ptr const & sp )|
\LABEL{MIN::STRHASH_OF_STR_PTR} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\ARGBREAK
      \verb|( char * p, min::str_ptr const & sp )|
\LABEL{MIN::STRCPY_OF_STR_PTR} \\
\verb|char * min::|
    & \MINKEY{strncpy}\ARGBREAK
      \verb|( char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp,|\ARGBREAK
      \verb|  min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_STR_PTR} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp )|
\LABEL{MIN::STRCMP_OF_STR_PTR} \\
\verb|int min::|
    & \MINKEY{strncmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp,|\ARGBREAK
      \verb|  min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_STR_PTR} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT64_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS64_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i )|
\LABEL{MIN::STRTO_FLOAT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, int & i )|
\LABEL{MIN::STRTO_FLOAT64_OF_STR_PTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{String Unprotected Functions}

\begin{indpar}[0.2in]


\begin{TABULAR}{1.8in}
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( min::str_ptr const & sp )|
\LABEL{MUP::STR_OF_STR_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of} \verb|( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Labels}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MIN::LAB_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( min::stub * s )|
\LABEL{MIN::LAB_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MIN::LAB_PTR_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt min::lab\_ptr}}\ARGBREAK
          \verb|( min::lab_ptr const & labp )|
\LABEL{MIN::LAB_PTR_TO_MIN_STUB} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp, min::gen v )|
\LABEL{MIN::=_LAB_PTR_OF_GEN} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_LAB_PTR_OF_STUB} \\
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr const & labp,|\ARGBREAK
	  \verb|  min::uns32 i )|
\LABEL{MIN::[]_OF_LAB_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.6in}
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{begin\_ptr\_of}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{end\_ptr\_of}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_LAB_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_LAB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\ARGBREAK
    \verb|( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|const min::uns32 min::| & \MINKEY{labhash\_initial} \verb|= 1009|
\LABEL{MIN::LABHASH_INITIAL} \\
\verb|const min::uns32 min::| & \MINKEY{labhash\_factor}
    \verb|= 65599**10 (mod 2**32)|
\LABEL{MIN::LABHASH_FACTOR} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\ARGBREAK
    \verb|( min::uns32 hash, min::uns32 h )|
\LABEL{MIN::LABHASH_INCREMENTAL} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  const min::stub * s, min::uns32 n )|
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  min::gen v, min::uns32 n )|
\LABEL{MIN::LAB_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( const min::gen * p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<const min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR_CONST} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2 )|
\LABEL{MIN::NEW_LAB_GEN_OF_2_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3 )|
\LABEL{MIN::NEW_LAB_GEN_OF_3_STRS} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_lab} \verb|( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\verb|min::int32 min::| & \MINKEY{is\_subsequence}\ARGBREAK
    \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::IS_SUBSEQUENCE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MUP::LAB_PTR_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::stub * s )|
\LABEL{MUP::LAB_PTR_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MUP::LAB_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::lab\_ptr}}\ARGBREAK
          \verb|( MUP::lab_ptr const & labp )|
\LABEL{MUP::LAB_PTR_TO_MIN_STUB} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, min::gen v )|
\LABEL{MUP::=_LAB_PTR_OF_GEN} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, const min::stub * s )|
\LABEL{MUP::=_LAB_PTR_OF_STUB} \\
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr const & labp,|\ARGBREAK
	  \verb|  min::uns32 i )|
\LABEL{MUP::[]_OF_LAB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{2.6in}
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{begin\_ptr\_of}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_MUP_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{end\_ptr\_of}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_MUP_LAB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_MUP_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_MUP_LAB_PTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Names}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_name} \verb|( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash} \verb|( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare} \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Structures}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct<S>} \verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_with\_base<S,B>}
		\verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE_WITH_BASE} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::| & \MINKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{TABULAR}

\begin{TABULAR}{3.0in}
\verb|min::gen pstype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\verb|const min::stub * pstype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_STUB} \\
\verb|min::uns32 pstype|
    & \TTDMKEY{subtype}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_SUBTYPE} \\
\verb|const char * const pstype.|
    & \TTDMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{gen\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISP} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{stub\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_DISP} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype}\ARGBREAK
	  \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_SUBTYPE} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	  \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
          \verb|( min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_TO_MIN_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::ptr<S const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_->} \\
\verb|min::ref<S const> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_*} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::ptr<S> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_udpptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_->} \\
\verb|min::ref<S> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_updptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_*} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Vectors}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|struct min::| & \MINKEY{packed\_vec\_header<L>}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const min::uns32 control;|\ARGBREAK
    \verb|  const L length;|\ARGBREAK
    \verb|  const L max_length;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PACKED_VEC_HEADER} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_with\_base<E,H,B,L>}
		\verb|pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE_WITH_BASE} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_STUB_VOID} \\
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_STUB_MAX_LENGTH} \\
\end{TABULAR}

\begin{TABULAR}{3.0in}
\verb|const char * const pvtype| & \TTDMKEY{subtype}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_SUBTYPE} \\
\verb|const char * const pvtype| & \TTDMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_DISP} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::uns32 pvtype| & \TTDMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 pvtype| & \TTDMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 pvtype| & \TTDMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype}\ARGBREAK
	  \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_VEC_SUBTYPE} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\verb|min::| & \verb|packed_vec<char>| \ARGBREAK
	\verb|min::| \MINKEY{char\_packed\_vec\_type}
\LABEL{MIN::CHAR_PACKED_VEC_TYPE} \\
\verb|min::| & \verb|packed_vec<min::uns32>| \ARGBREAK
	\verb|min::| \MINKEY{uns32\_packed\_vec\_type}
\LABEL{MIN::UNS32_PACKED_VEC_TYPE} \\
\verb|min::| & \verb|packed_vec<const char *>| \ARGBREAK
	\verb|min::| \MINKEY{const\_char\_ptr\_packed\_vec\_type}
\LABEL{MIN::CONST_CHAR_PTR_PACKED_VEC_TYPE} \\
\verb|min::| & \verb|packed_vec<min::gen>| \ARGBREAK
	\verb|min::| \MINKEY{gen\_packed\_vec\_type}
\LABEL{MIN::GEN_PACKED_VEC_TYPE} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
          \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_TO_MIN_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::ptr<H const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_->} \\
\verb|min::ref<H const> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_*} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|const min::uns32 pvp| & \TTARMKEY{length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_LENGTH} \\
\verb|const L pvp| & \TTARMKEY{max\_length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_MAX_LENGTH} \\
\verb|min::ref<E const> pvp| & \TTBMKEY{i}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_[]} \\
\verb|min::ptr<E const> pvp|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_ptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_PTR_+} \\
\verb|min::ptr<E const> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_PTR} \\
\verb|min::ptr<E const> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_PTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::ptr<H> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_->} \\
\verb|min::ref<H> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_*} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<E> pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_[]} \\
\verb|min::ptr<E> pvup|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_updptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_UPDPTR_+} \\
\verb|min::ptr<E>  min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_UPDPTR} \\
\verb|min::ptr<E> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&\
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::ref<E> min::|
	& \MINKEY{push\RESIZE} \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_PUSH} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E const * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<const E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR_CONST} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|E min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_POP_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{resize\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Files}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::file_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{file}
\LABEL{MIN::FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{3.4in}
\verb|min::packed_vec_insprt<char> file| & \TTARMKEY{buffer}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER} \\
\verb|min::uns32 file| & \TTARMKEY{buffer->length}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER_LENGTH} \\
\verb|min::uns32 file| & \TTARMKEY{end\_offset}{in {\tt min::file}}
\LABEL{MIN::FILE_END_OFFSET} \\
\verb|min::uns32 file| & \TTARMKEY{end\_count}{in {\tt min::file}}
\LABEL{MIN::FILE_END_COUNT} \\
\verb|min::uns32 file| & \TTARMKEY{file\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_FILE_LINES} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL line\_\EOL number}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_NUMBER} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL offset}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_OFFSET} \\
\verb|min::packed_vec_insptr<min::uns32> file|
    & \TTARMKEY{line\_index}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_INDEX} \\
\end{TABULAR}

\begin{TABULAR}{3.4in}
\verb|min::uns32 file| & \TTARMKEY{spool\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_SPOOL_LINES} \\
\verb|min::uns32 file| & \TTARMKEY{line\_display}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_DISPLAY} \\
\end{TABULAR}

\begin{TABULAR}{3.4in}
\verb|std::istream * file| & \TTARMKEY{istream}{in {\tt min::file}}
\LABEL{MIN::FILE_ISTREAM} \\
\verb|min::file file| & \TTARMKEY{ifile}{in {\tt min::file}}
\LABEL{MIN::FILE_IFILE} \\
\verb|std::ostream * file| & \TTARMKEY{ostream}{in {\tt min::file}}
\LABEL{MIN::FILE_OSTREAM} \\
\verb|min::printer file| & \TTARMKEY{printer}{in {\tt min::file}}
\LABEL{MIN::FILE_PRINTER} \\
\verb|min::file file| & \TTARMKEY{ofile}{in {\tt min::file}}
\LABEL{MIN::FILE_OFILE} \\
\verb|min::gen file| & \TTARMKEY{file\_name}{in {\tt min::file}}
\LABEL{MIN::FILE_FILENAME} \\
\end{TABULAR}


\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{init\RESIZE}\ARGBREAK
    \verb|( min::ref<min::file> file )|
\LABEL{MIN::INIT_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_line\_display\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display )|
\LABEL{MIN::INIT_PRINT_FLAGS_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_\EOL file\_\EOL name\REL}\ARGBREAK
	     \verb|( min::ref<min::file> file,|\ARGBREAK
             \verb|  min::gen file_name )|
\LABEL{MIN::INIT_FILE_NAME_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_ostream\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_ofile\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ofile )|
\LABEL{MIN::INIT_OFILE_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_printer\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::printer printer )|
\LABEL{MIN::INIT_PRINTER_OF_FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{ALL\_LINES}
\LABEL{MIN::ALL_LINES} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{init\_\EOL input\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_stream\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::istream & istream,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STREAM_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ifile,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_FILE_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<const char> string )|\ARGBREAK
\LABEL{MIN::LOAD_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<char> string )|\ARGBREAK
\LABEL{MIN::LOAD_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  const char * string )|\ARGBREAK
\LABEL{MIN::LOAD_CHAR_PTR_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::|
    & \MINKEY{load\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::gen file_name )|\ARGBREAK
\LABEL{MIN::LOAD_NAMED_FILE_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<const char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  const char * string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CHAR_PTR_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::gen file_name,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_NAMED_FILE_OF_FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{NO\_LINE}
\LABEL{MIN::NO_LINE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{next\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::NEXT_LINE_OF_FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::REMAINING_OFFSET} \\
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::REMAINING_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{skip\_\EOL remaining} \verb|( min::file file )|
\LABEL{MIN::SKIP_REMAINING} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{file\_\EOL is\_\EOL complete} \verb|( min::file file )|
\LABEL{MIN::FILE_IS_COMPLETE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{line}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number )|
\LABEL{MIN::LINE_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{flush\_spool\RESIZE}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number =|\ARGBREAK
	  \verb|      min::NO_LINE )|
\LABEL{MIN::FLUSH_SPOOL} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{rewind}\ARGBREAK
	\verb|( min::file file,|\ARGBREAK
	\verb|  min::uns32 line_number = 0 )|
\LABEL{MIN::REWIND_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::END_LINE_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{complete\_file} \verb|( min::file file )|
\LABEL{MIN::COMPLETE_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::END_LINE_FILE_WITH_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  bool copy_completion = true )|
\LABEL{MIN::FLUSH_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::FLUSH_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{flush\_remaining\RESIZE} \verb|( min::file file )|
\LABEL{MIN::FLUSH_REMAINING} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<<}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{OSTREAM_OPERATOR<<_OF_FILE} \\
\verb|min::file |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::file ofile,|\ARGBREAK
      \verb|  min::file ifile )|
\LABEL{FILE_OPERATOR<<_OF_FILE} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{PRINTER_OPERATOR<<_OF_FILE} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Identifier Maps}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|typedef min::|
	& \verb|packed_vec_ptr|\ARGBREAK
	  \verb|    < const min::stub *,|\ARGBREAK
	  \verb|      min::id_map_header<min::uns32> >|\ARGBREAK
	  \verb|min::|\MINKEY{id\_\EOL map}
\LABEL{MIN::ID_MAP} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::id_map min::| & \MINKEY{init\REL}
    \verb|( min::ref<min::id_map> map )|
\LABEL{MIN::INIT_OF_ID_MAP} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|const min::stub * map| & \TTBMKEY{id}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_[]} \\
\verb|const min::uns32 map->| & \TTMKEY{length}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_LENGTH} \\
\verb|min::uns32 map->| & \TTMKEY{occupied}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_OCCUPIED} \\
\verb|min::uns32 map->| & \TTMKEY{next}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_NEXT} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::uns32 min::| & \MINKEY{find\REL}\ARGBREAK
    \verb|( min::ref<min::id_map> map,|\ARGBREAK
    \verb|  const min::stub * s )|
\LABEL{MIN::FIND_OF_ID_MAP} \\
\verb|min::uns32 min::| & \MINKEY{find\_\EOL or\_\EOL add\REL}\ARGBREAK
    \verb|( min::ref<min::id_map> map,|\ARGBREAK
    \verb|  const min::stub * s )|
\LABEL{MIN::FIND_OR_ADD_OF_ID_MAP} \\
\verb|void min::| & \MINKEY{insert\REL}\ARGBREAK
    \verb|( min::ref<min::id_map> map,|\ARGBREAK
    \verb|  const min::stub * s,|\ARGBREAK
    \verb|  min::uns32 id )|
\LABEL{MIN::INSERT_OF_ID_MAP} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Printers}

\begin{indpar}[0.2in]

\begin{TABULAR}{3.4in}
\verb|min::locatable_var<min::printer> min::| & \MINKEY{error\_\EOL message}
\LABEL{MIN::ERROR_MESSAGE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::printer_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{printer}
\LABEL{MIN::PRINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::printer min::| & \MINKEY{init\REL}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  min::file file = min::NULL_STUB )|
\LABEL{MIN::INIT_OF_PRINTER} \\
\verb|min::printer min::| & \MINKEY{init\_ostream\RESIZE}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_PRINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|min::file printer->| & \TTMKEY{file}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_FILE} \\
\verb|std::ostream * printer->| & \TTMKEY{ostream}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_OSTREAM} \\
\verb|const min::uns32 printer->| & \TTMKEY{column}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_COLUMN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|struct    min::| & \MINKEY{line\_\EOL break}
\LABEL{MIN::LINE_BREAK_STRUCT} \\
\verb|{              | \\
\verb|    min::uns32 | & \TTMKEY{offset}{in {\tt min::line\_break}}
\LABEL{MIN::OFFSET_IN_LINE_BREAK} \\
\verb|    min::uns32 | & \TTMKEY{column}{in {\tt min::line\_break}}
\LABEL{MIN::COLUMN_IN_LINE_BREAK} \\
\verb|    min::uns32 | & \TTMKEY{line\_length}{in {\tt min::line\_break}}
\LABEL{MIN::LINE_LENGTH_IN_LINE_BREAK} \\
\verb|    min::uns32 | & \TTMKEY{indent}{in {\tt min::line\_break}}
\LABEL{MIN::INDENT_IN_LINE_BREAK} \\
\verb|}              | \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{4.0in}
\verb|const min::line_break printer->|
    & \TTMKEY{line\_break}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK} \\
\verb|const min::packed_vec_insptr<min::line_break>  | \\
\verb|printer->|
    & \TTMKEY{line\_break\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK_STACK} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|const min::line_break min::|
    & \TTKEY{default\_\EOL line\_\EOL break}
\LABEL{MIN::DEFAULT_LINE_BREAK} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.8in}
\verb|struct                 min::| & \MINKEY{print\_\EOL format}
\LABEL{MIN::PRINT_FORMAT_STRUCT} \\
\verb|{                           | \\
\verb|               min::uns32   |
	& \TTMKEY{op\_flags}{in {\tt min::print\_format}}
\LABEL{MIN::OP_FLAGS_IN_PRINT_FORMAT} \\
\verb|               min::uns32 * |
	& \TTMKEY{char\_flags}{in {\tt min::print\_format}}
\LABEL{MIN::CHAR_FLAGS_IN_PRINT_FORMAT} \\
\verb|       min::support_control|
	& \TTMKEY{support\_control}{in {\tt min::print\_format}}
\LABEL{MIN::SUPPORT_CONTROL_IN_PRINT_FORMAT} \\
\verb|       min::display_control|
	& \TTMKEY{display\_control}{in {\tt min::print\_format}}
\LABEL{MIN::DISPLAY_CONTROL_IN_PRINT_FORMAT} \\
\verb|         min::break_control|
	& \TTMKEY{break\_control}{in {\tt min::print\_format}}
\LABEL{MIN::BREAK_CONTROL_IN_PRINT_FORMAT} \\
\verb|   min::char_name_format *|
	& \TTMKEY{char\_name\_format}{in {\tt min::print\_format}}
\LABEL{MIN::CHAR_NAME_FORMAT_IN_PRINT_FORMAT} \\
\verb|          min::gen_format *|
	& \TTMKEY{gen\_format}{in {\tt min::print\_format}}
\LABEL{MIN::GEN_FORMAT_IN_PRINT_FORMAT} \\
\verb|}                           | \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{3.2in}
\verb|const min::print_format printer->|
    & \TTMKEY{print\_format}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT} \\
\verb|const min::packed_vec_insptr    | \\
\verb|<min::print_format>  | \\
\verb|printer->|
    & \TTMKEY{print\_format\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT_STACK} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.8in}
\verb|const min::print_format min::|
    & \TTKEY{default\_\EOL print\_\EOL format}
\LABEL{MIN::DEFAULT_PRINT_FORMAT} \\
\end{TABULAR}

\bigskip

{\tt print\_format.op\_flags}:

\medskip

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{EXPAND\_HT}
\LABEL{MIN::EXPAND_HT_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_EOL}
\LABEL{MIN::DISPLAY_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_PICTURE}
\LABEL{MIN::DISPLAY_PICTURE_FLAG} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ON\_EOL}
\LABEL{MIN::FLUSH_ON_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ID\_MAP\_ON\_EOM}
\LABEL{MIN::FLUSH_ID_MAP_ON_EOM_FLAG} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{NEXT\_IS\_LEADING}
\LABEL{MIN::NEXT_IS_LEADING_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{NEXT\_IS\_TRAILING}
\LABEL{MIN::NEXT_IS_TRAILING_FLAG} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{AUTO\_SUPPRESS}
\LABEL{MIN::AUTO_SUPPRESS_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISABLE\_SUPPRESS}
\LABEL{MIN::DISABLE_SUPPRESS_FLAG} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.8in}
\verb|struct              min::| & \MINKEY{support\_\EOL control}
\LABEL{MIN::SUPPORT_CONTROL_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns32   |
	& \TTMKEY{support\_mask}{in {\tt min::support\_control}}
\LABEL{MIN::SUPPORT_MASK_IN_SUPPORT_CONTROL} \\
\verb|            min::uns32   |
	& \TTMKEY{unsupport\_char\_flags}{in {\tt min::support\_control}}
\LABEL{MIN::UNSUPPORT_CHAR_FLAGS_IN_SUPPORT_CONTROL} \\
\verb|}                        | \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.8in}
\verb|struct              min::| & \MINKEY{display\_\EOL control}
\LABEL{MIN::DISPLAY_CONTROL_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns16   |
	& \TTMKEY{display\_char}{in {\tt min::display\_control}}
\LABEL{MIN::DISPLAY_CHAR_IN_DISPLAY_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{display\_suppress}{in {\tt min::display\_control}}
\LABEL{MIN::DISPLAY_SUPPRESS_IN_DISPLAY_CONTROL} \\
\verb|}                        | \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.8in}
\verb|struct              min::| & \MINKEY{break\_\EOL control}
\LABEL{MIN::BREAK_CONTROL_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns16   |
	& \TTMKEY{break\_before}{in {\tt min::break\_control}}
\LABEL{MIN::BREAK_BEFORE_IN_BREAK_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{break\_after}{in {\tt min::break\_control}}
\LABEL{MIN::BREAK_AFTER_IN_BREAK_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{conditional\_break}{in {\tt min::break\_control}}
\LABEL{MIN::CONDITIONAL_BREAK_IN_BREAK_CONTROL} \\
\verb|            min::uns16   |
	& \TTMKEY{conditional\_columms}{in {\tt min::break\_control}}
\LABEL{MIN::CONDITIONAL_COLUMNS_IN_BREAK_CONTROL} \\
\verb|}                        | \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.8in}
\verb|struct              min::|
    & \MINKEY{char\_\EOL name\_\EOL format}
\LABEL{MIN::CHAR_NAME_FORMAT_STRUCT} \\
\verb|{                        | \\
\verb|  const min::ustring *   |
	& \TTMKEY{char\_name\_prefix}{in {\tt min::char\_name\_format}}
\LABEL{MIN::CHAR_NAME_PREFIX_IN_CHAR_NAME_FORMAT} \\
\verb|  const min::ustring *   |
	& \TTMKEY{char\_name\_postfix}{in {\tt min::char\_name\_format}}
\LABEL{MIN::CHAR_NAME_POSTFIX_IN_CHAR_NAME_FORMAT} \\
\verb|}                        | \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.8in}
\verb|min::file printer->|
    & \TTMKEY{id\_\EOL map}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP} \\
\verb|min::uns32 printer->|
    & \TTMKEY{\EOL id\_\EOL map->\EOL next}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP_NEXT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, const char * s )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR_*} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::ptr<const char> s )|
\LABEL{PRINTER_OPERATOR<<_OF_PTR_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::str_ptr const & s )|
\LABEL{PRINTER_OPERATOR<<_OF_STR_PTR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, char c )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int32 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int64 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns32 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns64 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::float64 f )|
\LABEL{PRINTER_OPERATOR<<_OF_FLOAT64} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}{of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::op const & op )|
\LABEL{OPERATOR<<_OF_PRINTER_OP} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{eol}
\LABEL{MIN::EOL} \\
\verb|const min::op min::| & \MINKEY{flush}
\LABEL{MIN::FLUSH} \\
\verb|const min::op min::| & \MINKEY{bol}
\LABEL{MIN::BOL} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<<}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{OSTREAM_OPERATOR<<_OF_PRINTER} \\
\verb|min::file |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{FILE_OPERATOR<<_OF_PRINTER} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer oprinter,|\ARGBREAK
      \verb|  min::printer iprinter )|
\LABEL{PRINTER_OPERATOR<<_OF_PRINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{set\_\EOL break}
\LABEL{MIN::SET_BREAK} \\
\verb|const min::op min::| & \MINKEY{left} \verb|( min::uns32 width )|
\LABEL{MIN::LEFT} \\
\verb|const min::op min::| & \MINKEY{right} \verb|( min::uns32 width )|
\LABEL{MIN::RIGHT} \\
\verb|const min::op min::| & \MINKEY{reserve} \verb|( min::uns32 width )|
\LABEL{MIN::RESERVE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{indent}
\LABEL{MIN::INDENT} \\
\verb|const min::op min::| & \MINKEY{eol\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::EOL_IF_AFTER_INDENT} \\
\verb|const min::op min::| & \MINKEY{spaces\_\EOL if\_\EOL before\_\EOL indent}
\LABEL{MIN::SPACES_IF_BEFORE_INDENT} \\
\verb|const min::op min::| & \MINKEY{space\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::SPACE_IF_AFTER_INDENT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::|
    & \MINKEY{save\_print\_format}
\LABEL{MIN::SAVE_PRINT_FORMAT} \\
\verb|const min::op min::|
    & \MINKEY{restore\_print\_format}
\LABEL{MIN::RESTORE_PRINT_FORMAT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{bom}
\LABEL{MIN::BOM} \\
\verb|const min::op min::| & \MINKEY{eom}
\LABEL{MIN::EOM} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::op min::|
    & \MINKEY{place\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::PLACE_INDENT} \\
\verb|min::op min::|
    & \MINKEY{adjust\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::ADJUST_INDENT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::op min::|
    & \MINKEY{punicode}\verb|( min::Uchar c )|
\LABEL{MIN::PUNICODE} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  const min::Uchar * str )|
\LABEL{MIN::PUNICODE_BUFFER} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  min::ptr<const min::Uchar> str )|
\LABEL{MIN::PUNICODE_BUFFER_PTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{pwidth}\ARGBREAK
         \verb|( min::uns32 & column,|\ARGBREAK
         \verb|  min::Uchar c,|\ARGBREAK
         \verb|  min::uns32 flags )|
\LABEL{MIN::PWIDTH} \\
\verb|void min::|
    & \MINKEY{pwidth}\ARGBREAK
         \verb|( min::uns32 & column,|\ARGBREAK
         \verb|  const char * s, min::unsptr n,|\ARGBREAK
         \verb|  min::uns32 flags )|
\LABEL{MIN::PWIDTH_OF_STRING} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::op min::|
    & \MINKEY{pint}\ARGBREAK
	  \verb|( min::int64 i,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PINT} \\
\verb|min::op min::|
    & \MINKEY{puns}\ARGBREAK
	  \verb|( min::uns64 u,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PUNS} \\
\verb|min::op min::|
    & \MINKEY{pfloat}\ARGBREAK
	  \verb|( min::float64 f,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PFLOAT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|min::op min::|
    & \MINKEY{set\_\EOL line\_length} \verb|( min::uns32 line_length )|
\LABEL{MIN::SET_LINE_LENGTH} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL indent} \verb|( min::uns32 indent )|
\LABEL{MIN::SET_INDENT} \\
\verb|min::op min::|
    & \MINKEY{set\_print\_flags} \verb|( min::uns32 print_flags )|
\LABEL{MIN::SET_PRINT_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{clear\_print\_flags} \verb|( min::uns32 print_flags )|
\LABEL{MIN::CLEAR_PRINT_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{ascii}
\LABEL{MIN::ASCII} \\
\verb|const min::op min::| & \MINKEY{noascii}
\LABEL{MIN::NOASCII} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{graphic\_hspace}
\LABEL{MIN::GRAPHIC_HSPACE} \\
\verb|const min::op min::| & \MINKEY{nographic\_hspace}
\LABEL{MIN::NOGRAPHIC_HSPACE} \\
\verb|const min::op min::| & \MINKEY{graphic\_vspace}
\LABEL{MIN::GRAPHIC_VSPACE} \\
\verb|const min::op min::| & \MINKEY{nographic\_vspace}
\LABEL{MIN::NOGRAPHIC_VSPACE} \\
\verb|const min::op min::| & \MINKEY{graphic\_nspace}
\LABEL{MIN::GRAPHIC_NSPACE} \\
\verb|const min::op min::| & \MINKEY{nographic\_nspace}
\LABEL{MIN::NOGRAPHIC_NSPACE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{allow\_hspace}
\LABEL{MIN::ALLOW_HSPACE} \\
\verb|const min::op min::| & \MINKEY{noallow\_hspace}
\LABEL{MIN::NOALLOW_HSPACE} \\
\verb|const min::op min::| & \MINKEY{allow\_vspace}
\LABEL{MIN::ALLOW_VSPACE} \\
\verb|const min::op min::| & \MINKEY{noallow\_vspace}
\LABEL{MIN::NOALLOW_VSPACE} \\
\verb|const min::op min::| & \MINKEY{allow\_nspace}
\LABEL{MIN::ALLOW_NSPACE} \\
\verb|const min::op min::| & \MINKEY{noallow\_nspace}
\LABEL{MIN::NOALLOW_NSPACE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{display\_eol}
\LABEL{MIN::DISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_eol}
\LABEL{MIN::NODISPLAY_EOL} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{hbreak}
\LABEL{MIN::HBREAK} \\
\verb|const min::op min::| & \MINKEY{nohbreak}
\LABEL{MIN::NOHBREAK} \\
\verb|const min::op min::| & \MINKEY{gbreak}
\LABEL{MIN::GBREAK} \\
\verb|const min::op min::| & \MINKEY{nogbreak}
\LABEL{MIN::NOGBREAK} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{eol\_flush}
\LABEL{MIN::EOL_FLUSH} \\
\verb|const min::op min::| & \MINKEY{noeol\_flush}
\LABEL{MIN::NOEOL_FLUSH} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{graphic}
\LABEL{MIN::GRAPHIC} \\
\verb|const min::op min::| & \MINKEY{nographic}
\LABEL{MIN::NOGRAPHIC} \\
\verb|const min::op min::| & \MINKEY{verbatim}
\LABEL{MIN::VERBATIM} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<<}{of {\tt std::ostream \&}}\ARGBREAK
      \verb| ( std::ostream & out,|\ARGBREAK
      \verb|   min::op const & op )|
\LABEL{OPERATOR<<_OF_OSTREAM_AND_PRINTER_OP} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.8in}
\multicolumn{2}{l}{\tt min::print\_format
                       min::\MINKEY{ostream\_print\_format}}
\LABEL{MIN::OSTREAM_PRINT_FORMAT} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Printing General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|min::op min::|
    & \MINKEY{pgen}\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PGEN} \\
\verb|min::op min::|
    & \MINKEY{pgen}\ARGBREAK
	  \verb|( min::gen v,|\ARGBREAK
	  \verb|  min::uns32 gen_flags )|
\LABEL{MIN::PGEN_WITH_GEN_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{pgen}\ARGBREAK
            \verb|( min::gen v,|\ARGBREAK
            \verb|  min::uns32 gen_flags,|\ARGBREAK
            \verb|  const min::context_gen_flags *|\ARGBREAK
	    \verb|            context_gen_flags )|
\LABEL{MIN::PGEN_WITH_CONTEXT_GEN_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::gen v )|
\LABEL{PRINTER_OPERATOR<<_OF_GEN} \\
\end{TABULAR}

\bigskip

\ldots{\tt \_gen\_flags}:
\\[2ex]
\begin{TABULAR}{2.2in}
\verb|const min::uns32 min::| & \MINKEY{GRAPHIC\_STR\_FLAG}
\LABEL{MIN::GRAPHIC_STR_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_STR\_FLAG}
\LABEL{MIN::BRACKET_STR_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_LAB\_FLAG}
\LABEL{MIN::BRACKET_LAB_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_SPECIAL\_FLAG}
\LABEL{MIN::BRACKET_SPECIAL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{BRACKET\_IMPLICIT\_FLAG}
\LABEL{MIN::BRACKET_IMPLICIT_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{SUPPRESS\_SPECIAL\_NAME\_FLAG}
\LABEL{MIN::SUPPRESS_SPECIAL_NAME_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{SUPPRESS\_LAB\_SPACE\_FLAG}
\LABEL{MIN::SUPPRESS_LAB_SPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{SUPPRESS\_EXP\_SPACE\_FLAG}
\LABEL{MIN::SUPPRESS_EXP_SPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{OBJ\_EXP\_FLAG}
\LABEL{MIN::OBJ_EXP_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{OBJ\_ID\_FLAG}
\LABEL{MIN::OBJ_ID_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{OBJ\_INDENT\_FLAG}
\LABEL{MIN::OBJ_INDENT} \\
\verb|const min::uns32 min::| & \MINKEY{STR\_ID\_FLAG}
\LABEL{MIN::STR_ID_FLAG} \\
\end{TABULAR}

\bigskip

{\tt PGEN\_}\ldots contexts:
\\[2ex]
\begin{TABULAR}{2.2in}
\verb|const min::uns32 min::| & \MINKEY{PGEN\_TOP}
\LABEL{MIN::PGEN_TOP_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_INDENT}
\LABEL{MIN::PGEN_INDENT_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_PUNCTUATION}
\LABEL{MIN::PGEN_PUNCTUATION_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_NAME}
\LABEL{MIN::PGEN_NAME_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_VALUE}
\LABEL{MIN::PGEN_VALUE_CONTEXT} \\
\verb|const min::uns32 min::| & \MINKEY{PGEN\_ELEMENT}
\LABEL{MIN::PGEN_ELEMENT_CONTEXT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.2in}
\verb|typedef min::uns32 min::|
    & \MINKEY{context\_gen\_flags}\verb|[|$n$\verb|]| \\
    & \tt ~~ // $n$ is number of PGEN\_...~contexts
\LABEL{MIN::CONTEXT_GEN_FLAGS} \\
\multicolumn{2}{l}{\tt const min::context\_gen\_flags} \\
\verb|min::| & \MINKEY{default\_\EOL context\_\EOL gen\_\EOL flags}
\LABEL{MIN::DEFAULT_CONTEXT_GEN_FLAGS} \\
\multicolumn{2}{l}{\tt const min::context\_gen\_flags} \\
\verb|min::| & \MINKEY{no\_\EOL exp\_\EOL context\_\EOL gen\_\EOL flags}
\LABEL{MIN::NO_EXP_CONTEXT_GEN_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|struct min::| & \MINKEY{gen\_format}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::printer ( * pgen )|\ARGBREAK
    \verb|       ( min::printer printer,|\ARGBREAK
    \verb|         min::uns32 gen_flags,|\ARGBREAK
    \verb|         min::gen v,|\ARGBREAK
    \verb|         min::context_gen_flags * context_gen_flags,|\ARGBREAK
    \verb|         const min::gen_format * g );|\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  // Members beyond this point may be moved and|\ARGBREAK
    \verb|  // new members may be added.|\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const char *             number_format;|\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const min::Ustring *     str_prefix;|\ARGBREAK
    \verb|  const min::Ustring *     str_postfix;|\ARGBREAK
    \verb|  const min::Ustring *     str_postfix_name;|\ARGBREAK
    \verb|  const min::Ustring *     str_char_name_prefix;|\ARGBREAK
    \verb|  const min::Ustring *     str_char_name_postfix;|\ARGBREAK
    \verb|  const min::Ustring *     str_concatenator;|\ARGBREAK
    \verb|  min::uns32         	     str_max_length;|\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const char *             lab_prefix;|\ARGBREAK
    \verb|  const char *             lab_separator;|\ARGBREAK
    \verb|  const char *             lab_postfix;|\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const char *             special_prefix;|\ARGBREAK
    \verb|  const char *             special_postfix;|\ARGBREAK
    \verb|  min::packed_vec_ptr<const char *>|\ARGBREAK
    \verb|                           special_names;|\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const char *             implicit_prefix;|\ARGBREAK
    \verb|  const char *             implicit_postfix;|\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  const min::suppress_matrix *|\ARGBREAK
    \verb|                           suppress_matrix;|\ARGBREAK
    \verb|  min::packed_vec_ptr<min::gen>|\ARGBREAK
    \verb|                           exp_ok_attrs;|\ARGBREAK
    \verb|  min::packed_vec_ptr<const char *>|\ARGBREAK
    \verb|                           flag_names;|\ARGBREAK
    \verb|};|
\LABEL{MIN::GEN_FORMAT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{default\_pgen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::uns32 gen_flags,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  min::context_gen_flags * context_gen_flags,|\ARGBREAK
    \verb|  const min::gen_format * g );|
\LABEL{MIN::DEFAULT_PGEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<const char \&>} \\
\verb|min::| & \MINKEY{standard\_\EOL special\_\EOL names}
\LABEL{MIN::STANDARD_SPECIAL_NAMES} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|typedef const char * min::|
    & \MINKEY{char\_names}\verb|[256]|
\LABEL{MIN::CHAR_NAMES} \\
\multicolumn{2}{l}{\tt const min::char\_names} \\
\verb|min::| & \MINKEY{default\_\EOL char\_\EOL names}
\LABEL{MIN::DEFAULT_CHAR_NAMES} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|typedef min::uns32 * min::|
    & \MINKEY{char\_flags}\verb|[256]|
\LABEL{MIN::CHAR_FLAGS} \\
\multicolumn{2}{l}{\tt const min::char\_flags} \\
\verb|min::| & \MINKEY{default\_\EOL char\_\EOL flags}
\LABEL{MIN::DEFAULT_CHAR_FLAGS} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|typedef bool min::| & \MINKEY{suppress\_matrix}\verb|[256][256]|
\LABEL{MIN::SUPPRESS_MATRIX} \\
\multicolumn{2}{l}{\tt const min::suppress\_matrix} \\
\verb|min::| & \MINKEY{default\_\EOL suppress\_\EOL matrix}
\LABEL{MIN::DEFAULT_SUPPRESS_MATRIX} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<min::gen>} \\
\verb|min::| & \MINKEY{default\_\EOL exp\_\EOL ok\_\EOL attrs}
\LABEL{MIN::DEFAULT_EXP_OK_ATTRS} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<const char \&>} \\
\verb|min::| & \MINKEY{default\_\EOL flag\_\EOL names}
\LABEL{MIN::DEFAULT_FLAG_NAMES} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb| min::gen_format min::| & \MINKEY{default\_gen\_format}
\LABEL{MIN::DEFAULT_GEN_FORMAT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::op min::| & \MINKEY{flush\_\EOL one\_\EOL id}
\LABEL{MIN::FLUSH_ONE_ID} \\
\verb|min::op min::| & \MINKEY{flush\_\EOL id\_\EOL map}
\LABEL{MIN::FLUSH_ID_MAP} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::op min::|
    & \MINKEY{set\_\EOL context\_\EOL gen\_\EOL flags}\ARGBREAK
      \verb|( min::context_gen_flags *|\ARGBREAK
      \verb|      context_gen_flags )|
\LABEL{MIN::SET_CONTEXT_GEN_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL gen\_\EOL format}\ARGBREAK
      \verb|( min::gen_format * gen_format )|
\LABEL{MIN::SET_GEN_FORMAT} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Printing File Lines and Phrases}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  min::uns32 first, min::uns32 last )|
\LABEL{MIN::PLINE_NUMBERS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|min::printer |
    & \TTOMKEY{<<}{<<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::pline_numbers const & pline_numbers )|
\LABEL{PRINTER_OPERATOR<<_OF_PLINE_NUMBERS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|struct min::| & \MINKEY{position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::uns32 line;|\ARGBREAK
    \verb|  min::uns32 offset;|\ARGBREAK
    \verb|};|
\LABEL{MIN::POSITION_STRUCT} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|struct min::| & \MINKEY{phrase\_\EOL position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::position begin;|\ARGBREAK
    \verb|  min::position end;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PHRASE_POSITION_STRUCT} \\
\end{TABULAR}

\begin{TABULAR}{1.7in}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  const min::phrase_position|\ARGBREAK
    \verb|        & position )|
\LABEL{MIN::PLINE_NUMBERS_OF_PHRASE_POSITION} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|void min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\_\EOL column\RESIZE}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  const min::phrase_position|\ARGBREAK
      \verb|        & position )|
\LABEL{MIN::PRINT_LINE_COLUMN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 print_flags,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE_WITH_FLAGS} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 print_flags,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES_WITH_FLAGS} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\_\EOL column\RESIZE}\ARGBREAK
      \verb|( min::uns32 print_flags,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position )|
\LABEL{MIN::PRINT_LINE_COLUMN_WITH_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|typedef min::|
	& \verb|packed_vec_ptr<min::phrase_position_vec_header,|\\&
	  \verb|               min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec}
\LABEL{MIN::PHRASE_POSITION_VEC} \\
\verb|typedef min::|
	& \verb|packed_vec_insptr<min::phrase_position_vec_header,|\\&
	  \verb|                  min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec\_insptr}
\LABEL{MIN::PHRASE_POSITION_VEC_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.8in}
\verb|min::| 
  & \verb|phrase_position_vec_insptr min::|\MINKEY{init\RESIZE}\ARGBREAK
    \verb|( min::ref<min::phrase_position_vec_insptr> vec,|\ARGBREAK
    \verb|  min::file file,|\ARGBREAK
    \verb|  min::phrase_position const & position,|\ARGBREAK
    \verb|  min::uns32 max_length )|
\LABEL{MIN::INIT_OF_PHRASE_POSITION_VEC} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.6in}
\verb|const min::uns32 vpp| & \TTARMKEY{length}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_LENGTH} \\
\verb|const min::file vpp| & \TTARMKEY{file}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_FILE} \\
\verb|min::phrase_position vpp| & \TTARMKEY{position}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_POSITION} \\
\verb|min::phrase_position vpp| & \TTBMKEY{i}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_ELEMENT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.6in}
\verb|min::phrase_position_vec min::| & \MINKEY{position\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::POSITION_OF_OBJECT_VEC_PTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Object Creation}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}\ARGBREAK
    \verb|( min::unsptr unused_size,|\ARGBREAK
    \verb|  min::unsptr hash_size = 0,|\ARGBREAK
    \verb|  min::unsptr variables_size = 0 )|
\LABEL{MIN::NEW_OBJ_GEN} \\
\verb|bool min::| & \MINKEY{is\_obj} \verb|( min::gen v )|
\LABEL{MIN::IS_OBJ} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Object Maintenance}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE} \\
\verb|void min::| & \MINKEY{compact\REORG}
    \verb|( min::gen object )|
\LABEL{MIN::COMPACT} \\
\verb|void min::| & \MINKEY{publish\REORG}
    \verb|( min::gen object )|
\LABEL{MIN::PUBLISH} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::| & \MINKEY{private\_flag\_of}
    \verb|( min::gen object )|
\LABEL{MIN::PRIVATE_FLAG_OF} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}
    \verb|( min::gen object )|
\LABEL{MIN::PUBLIC_FLAG_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Protected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.9in}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr} \verb|vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}
       \verb|vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}
       \verb|vp ( void )|
\LABEL{MIN::OBJ_VEC_PTR_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb|( min::obj_vec_ptr const & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_MIN_STUB} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_GEN} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
\verb|min::unsptr min::| & \MINKEY{var\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::VAR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::AUX_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
\verb|min::gen | & \MINKEY{var}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{hash}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{attr}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{aux}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr aux_ptr )|
\LABEL{MIN::AUX_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::[]_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{size\_of}
          \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::SIZE_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::ptr<const min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.9in}
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|
    \verb|( min::gen v )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|
    \verb|( min::stub * s )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|
    \verb|( void )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_updptr}}\ARGBREAK
          \verb|( min::obj_vec_updptr const & vp )|
\LABEL{MIN::OBJ_VEC_UPDPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
\verb|min::ref<min::gen> | & \MINKEY{var}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{hash}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{attr}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{aux}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::AUX_OF_OBJ_VEC_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|min::ref<min::gen> |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::[]_OF_OBJ_VEC_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|min::ptr<min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.9in}
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|
    \verb|( min::gen v )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|
    \verb|( min::stub * s )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|
    \verb|( void )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_VOID} \\
\end{TABULAR}


\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_insptr}}\ARGBREAK
          \verb|( min::obj_vec_insptr const & vp )|
\LABEL{MIN::OBJ_VEC_INSPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_GEN} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.6in}
\verb|void min::ref<min::gen> min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_PUSH_OF_VEC_INSPTR} \\
\verb|void min::ref<min::gen> min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_PUSH_OF_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n,|\ARGBREAK
      \verb|  const min::gen * p = NULL )|
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n,|\ARGBREAK
      \verb|  const min::gen * p = NULL )|
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|min::gen min::| & \MINKEY{attr\_pop}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_POP_OF_VEC_INSPTR} \\
\verb|min::gen min::| & \MINKEY{aux\_pop}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_POP_OF_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::AUX_POP_MULTIPLE_OF_VEC_INSPTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Vector Level Object Maintenance}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND_OBJ_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE_OBJ_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{compact\REORG}
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::COMPACT_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{publish\REORG}
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::PUBLISH_OBJ_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{private\_flag\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PRIVATE_FLAG_OF_OBJ_VEC_PTR} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PUBLIC_FLAG_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::| & \MINKEY{hash\_count\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_COUNT_OF} \\
\verb|void min::| & \MINKEY{set\_public\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::SET_PUBLIC_FLAG_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|const min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb|( min::obj_vec_ptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_PTR} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb|( min::obj_vec_updptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::STUB_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::VAR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_INSPTR} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_INSPTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Object List Level}

\begin{indpar}[0.2in]
\begin{TABULAR}{2.2in}
(macro) & \TTKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs}
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{TABULAR}
\end{indpar}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|const min::gen min::| & \MINKEY{LIST\_END()}
\LABEL{MIN::LIST_END} \\
\verb|const min::gen min::|
    & \MINKEY{EMPTY\_SUBLIST()}
\LABEL{MIN::EMPTY_SUBLIST} \\
\end{TABULAR}

\end{indpar}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
(constructor)~\verb|min::|
	& \MINKEY{list\_ptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::list_ptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist} \verb|( min::list_ptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_ptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_ptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_ptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh} \verb|( min::list_ptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh} \verb|( min::list_ptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_PTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|bool min::|
	& \MINKEY{is\_list\_end} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
(constructor)~\verb|min::|
	& \MINKEY{list\_updptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::LIST_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_updptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_UPDPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
(constructor)~\verb|min::|
	& \MINKEY{list\_insptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::LIST_INSPTR_OF_VEC_INSPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_insptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_INSPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|bool min::|
	& \MINKEY{insert\_reserve\RESIZE}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr insertions,|\ARGBREAK
	  \verb|  min::unsptr elements = 0,|\ARGBREAK
	  \verb|  bool use_obj_aux_stubs =|\ARGBREAK
	  \verb|      min::use_obj_aux_stubs )|
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_AFTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{remove}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr n = 1 )|
\LABEL{MIN::REMOVE_FROM_LIST_INSPTR} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Object Attribute Level}

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS}
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}

\bigskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{attr\_ptr} \verb|ap ( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_PTR_OF_OBJ_VEC_PTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_ptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}
	  \verb|( min::attr_ptr & ap, int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_ATTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::RELOCATE_ATTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_OF_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_ptr ap )|
\LABEL{MIN::GET1_OF_ATTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_ptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|struct min::| & \MINKEY{attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::gen    flags;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|  min::unsptr flag_count;|\ARGBREAK
    \verb|  min::unsptr reverse_attr_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_attr\_info}\ARGBREAK
    \verb|( min::attr_info * out, min::unsptr n )|
\LABEL{MIN::SORT_ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|struct min::| & \MINKEY{reverse\_attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::REVERSE_ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_reverse\_attr\_info}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n )|
\LABEL{MIN::SORT_REVERSE_ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
(constructor)~\verb|min::|
	& \MINKEY{attr\_updptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::ATTR_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_updptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_OF_ATTR_UPDPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_updptr ap )|
\LABEL{MIN::GET1_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_UPDPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_UPDPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
(constructor)~\verb|min::|
	& \MINKEY{attr\_insptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_INSPTR_OF_VEC_INSPTR} \\
\multicolumn{2}{@{}l}{\tt min::obj\_vec\_insptr \&} \\
\verb|min::|
	& \MINKEY{obj\_vec\_ptr\_of}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_OF_ATTR_INSPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_insptr ap )|
\LABEL{MIN::GET1_OF_ATTR_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_INSPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_INSPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::SET1_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ONE1} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ALL1} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{set\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{set\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::SET_FLAG} \\
\verb|bool min::| & \MINKEY{clear\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::CLEAR_FLAG} \\
\verb|bool min::| & \MINKEY{flip\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::FLIP_FLAG} \\
\end{TABULAR}

\end{indpar}


} % end of renewcommand for \LABEL, \{TT,MIN,MUP}KEY, etc.

\section{Operating System Interface}
\label{OPERATING-SYSTEM-INTERFACE}

The interface between MIN implementation code and the operating system
consists of standard C++/C functions available on all operating
systems, such as \verb|iostreams|, plus \ttkey{min::os}
namespace interface functions that are
declared in \verb|min_os.h| and defined in \verb|src/min_os.cc|.
This code division is intended to make it easy to port MIN to different
operating systems by placing all the code that must be
changed in the small \verb|src/min_os.cc| file.
\verb|min::os| is commonly abbreviated to
`\ttmkey{MOS}{abbreviates {\tt min::os}}'\label{MOS}
by including the following definition in code that accesses
the interface:

\begin{center}
\verb|#define  MOS  min::os|
\end{center}

Details of the \verb|min::os| interface are in \verb|min_os.h|.  The
following is an overview.

\subsection{Configuration Parameters}
\label{CONFIGURATION-PARAMETERS}

In UNIX the \ttkey{MIN\_CONFIG} environment variable value consists
of whitespace separated entries of the form `{\em name}\verb|=|{\em value}'
that specify configuration parameters, most of which control the
Allocator/Collector/Compactor.

\subsection{Memory Pools}

A memory pool is a contiguous block of pages of \underline{virtual}
memory.  Memory pools may be allocated, and it is possible to
specify that a pool being allocated has its starting address in
a particular range (e.g., so stub addresses can be limited to
44 bits).  Segments of memory pools may be freed, may be made
into inaccessible virtual memory, and may be made reaccessible.
Segments of memory pools may be moved by copying page table entries,
which is faster than copying bytes.

\section{Allocator/Collector/Compactor}
\label{ALLOCATOR/COLLECTOR/COMPACTOR}\label{ACC}

The \key{Allocator/Collector/Compactor}, or \ttkey{acc}, 
is a replaceable component of the MIN code, which should not
normally be accessed directly.  It can be controlled by parameters
passed to the program (see Configuration Parameters,
\pagref{CONFIGURATION-PARAMETERS}), or by defaults for these
provided at compile time in \verb|min_acc_parameters.h|.
Documentation for these parameters is in this last file.
The acc code is in the 
\verb|min::acc| namespace which is abbreviated to
`\ttmkey{MACC}{abbreviates {\tt min::acc}}'\label{MACC}
by including the following definition in acc code:

\begin{center}
\verb|#define  MACC  min::acc|
\end{center}

Details of the acc code are in \verb|min_acc.h|.  The
following is an overview.

TBD

\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}
