% Minimal Descriptive Programming System Design
%
% File:         min-design.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{makeidx}
% \usepackage{pictex} (obsolete? not available under CentOS 7)
\usepackage{upquote} % (imported to local directory
                     % ; not available under CentOS 7)
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newsavebox{\LAQUOTEBOX}
\begin{lrbox}{\LAQUOTEBOX}
{\tt \guillemotleft}
\end{lrbox}
\newcommand{\LAQUOTE}{\usebox{\LAQUOTEBOX}}

\newsavebox{\RAQUOTEBOX}
\begin{lrbox}{\RAQUOTEBOX}
{\tt \guillemotright}
\end{lrbox}
\newcommand{\RAQUOTE}{\usebox{\RAQUOTEBOX}}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\lmkey}[3]{{\bf \em #1 #2}\index{#1!#2!#3}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttlindex}[2]{\index{#1#2@{\tt #1}!{\tt #2}}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \vspace*{-15ex}
	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MINKEY}[1]%
	   {\TT{#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\MINLKEY}[2]%
           {\TT{#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                     \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\MINIKEY}[2]%
           {\TT{#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\MINMKEY}[2]%
           {\TT{#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPKEY}[1]%
	   {\TT{#1}\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Internal Design\\[2ex]of the\\[2ex]
       Minimal\\Descriptive Programming\\System\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton}

\date{November 18, 2017}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the internal design of MIN,
the Minimal Descriptive Programming System.
This document is written for readers who wish to add C++ code
to a MIN implementation, or who wish to maintain an implementation.

A programming system provides run time and compile time support
for programming languages.
A programming system, such as MIN, is
built on top of an underlying programming system provided by the
implementation language, in this case C++.
MIN consists of a data store, of the single-thread execution system
inherited from C++, and of MIN compatible threads.
Other programming language specific
programming systems can be built on top of MIN.

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{center}
\begin{tabular}{ll}
\ttmkey{acc}{abbreviation}	& allocator/collector/compactor
			          (\itemref{ACC-INTERFACE},\itemref{ACC}) \\
\ttmkey{aux}{abbreviation}	& auxiliary (\itemref{AUXILIARY}) \\
\ttmkey{attr}{abbreviation}	& attribute (\itemref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{bra}{abbreviation}	& opening bracket (\pagref{OBJ_BRA}) \\
\ttmkey{DISP}{abbreviation}	& displacement (\pagref{MIN::DISP}) \\
\ttmkey{gen}{abbreviation}	& general value (\itemref{GENERAL-VALUES}) \\
\ttmkey{gtyped}{abbreviation}	& graph typed (\itemref{GRAPH-TYPED-OBJECTS}) \\
\ttmkey{insptr}{abbreviation}	& insertable pointer
				  (read-write, push, pop pointer) \\
\ttmkey{int}{abbreviation}	& signed integer (\pagref{INT}) \\
\ttmkey{ket}{abbreviation}	& closing bracket (\pagref{OBJ_KET}) \\
\ttmkey{lab}{abbreviation}	& label (\itemref{LABELS}) \\
\ttmkey{min}{abbreviation}	& the `\TT{min}' namespace (\pagref{min::}) \\
\ttmkey{MACC}{abbreviation}	& \TT{min::acc} (\pagref{MACC}) \\
\ttmkey{MIN\_}{abbreviation}	& the \TT{MIN\_} macro preface
				  (\pagref{MIN_}) \\
\ttmkey{MINT}{abbreviation}	& \TT{min::internal} (\pagref{MINT}) \\
\ttmkey{MOS}{abbreviation}	& \TT{min::os} (\pagref{MOS}) \\
\ttmkey{MUP}{abbreviation}	& \TT{min::unprotected} (\pagref{MUP}) \\
\ttmkey{num}{abbreviation}	& number (\pagref{NUMBERS}) \\
\ttmkey{obj}{abbreviation}	& object (\pagref{OBJECTS}) \\
\ttmkey{ptr}{abbreviation}	& pointer (often read-only, see updptr and
                                  insptr) \\
\ttmkey{ref}{abbreviation}	& reference 
    (\pagref{BODY-REFERENCES-AND-POINTERS}) \\
\ttmkey{sep}{abbreviation}	& separator (\pagref{OBJ_SEP}) \\
\ttmkey{str}{abbreviation}	& string (\pagref{STRINGS}) \\
\ttmkey{uns}{abbreviation}	& unsigned integer (\pagref{UNS}) \\
\ttmkey{updptr}{abbreviation}	& updatable pointer
                                  (i.e., read-write pointer) \\
\ttmkey{var}{abbreviation}	& variable (\itemref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{vec}{abbreviation}	& vector (\itemref{OBJECT-VECTOR-LEVEL}) \\
\end{tabular}
\end{center}

Also one of a small number of \skey{subscript}s may be attached to a
function name to indicate that the function is of a certain class
of functions:

\begin{center}
\begin{tabular}{ll}
\subsmkey{C}{function qualifier}	& compact function
                                          (\pagref{COMPACT-FUNCTIONS}) \\
\subsmkey{L}{function qualifier}	& loose function
                                          (\pagref{LOOSE-FUNCTIONS}) \\
\subsmkey{R}{function qualifier}	& relocating function
                                          (\pagref{RELOCATING-FUNCTIONS}) \\
\subsmkey{S}{function qualifier}	& resizing function
                                          (\pagref{RESIZING-FUNCTIONS}) \\
\subsmkey{O}{function qualifier}	& reorganizing function
                                          (\pagref{REORGANIZING-FUNCTIONS}) \\

\end{tabular}
\end{center}

\section{Interfaces}
\label{INTERFACES}

MIN code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{min/include} & \TT{*.h} files such as \TT{min.h}
\\[1ex]
\ldots\TT{/}\ttkey{min/unicode} & UNICODE data base files such as
				  \TT{unicode\_data.h} \\
				& (independent of the rest of MIN)
\\[1ex]
\ldots\TT{/}\ttkey{min/src} & \TT{*.cc} files such as \TT{min.cc}
\\[1ex]
\ldots\TT{/}\ttkey{min/test} & test scripts such as \TT{min\_interface\_test.cc}
\\[1ex]
\ldots\TT{/}\ttkey{min/doc} & documentation files such as \TT{min-design.tex}
\end{tabular}
\end{center}



The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}
\verb|#include  <min.h>|
\end{center}

External MIN data and functions are placed in the
\ttmkey{min}{namespace}\label{min::} namespace.
There are some macros that can be defined to control compilation, and
these have names beginning with \ttkey{MIN\_}\label{MIN_}.

MIN has two interfaces:
the \key{protected interface}, which can be used
by C++ code to access MIN while maintaining the integrity
of MIN data, and the \key{unprotected interface}, which provides
more efficient access to MIN data but requires the user to
follow certain protocols to be sure that data are not damaged.

From the syntactic point of view the
only distinction between these interfaces is that the unprotected
interface is in the with \minkey{unprotected} namespace, whereas
the protected interface is in the \ttkey{min} namespace.  User code
that accesses the unprotected interface typically abbreviates the long
`\TT{min::unprotected::}' prefix to
`\ttmkey{MUP}{abbreviates {\tt min::unprotected}}\TT{::}'\label{MUP}
by including the following definition:
\begin{center}
\verb|#define  MUP  min::unprotected|
\end{center}

In this document we will use the abbreviation `\TT{MUP}' for
`\TT{min::unprotected}'.
Note that namespace \TT{\#define}'s such as the above are \underline{not}
included in \TT{min.h} or other MIN \TT{.h} files; they must
be included explicitly in \TT{.cc} files.

Most \TT{MUP} functions `produce \key{undefined results}' when their arguments
are out of legal range.
This means that when the arguments are out of range,
function execution may lose control and crash, or may produce result
values that are wrong or out of legal range.
When documentation of a \TT{MUP} function
states that particular argument range checks are not performed,
then the \TT{MUP} function always produces undefined results when its
arguments would not pass these checks,
unless the documentation explicitly says otherwise.

The protection provided by the protected interface
is obtained by the functions of that interface using the
\TT{MIN\_\EOL ASSERT}, \TT{MIN\_\EOL REQUIRE}, or \TT{MIN\_\EOL ABORT}
macros of Section~\itemref{ASSERT_MACROS}.

The following are the most commonly used compiler options that
redefine \TT{MIN\_} macros:

\begin{indpar}
\begin{tabular}{lll}
Macro Name		& Meaning	& Page Reference \\[1ex]
\TT{-DMIN\_IS\_COMPACT=1}
			& make implementation compact
					& \pagref{MIN_IS_COMPACT} \\
\TT{-DMIN\_NO\_PROTECTION=1}	& suppress integrity checks
					& \pagref{MIN_NO_PROTECTION} \\
\end{tabular}
\end{indpar}

The other compilation parameters involve technical details of
memory management.  For specifics see the file
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

Protected functions are in the \ttmkey{min}{namespace} namespace
and have names beginning with
`\ttmkey{min::}{in function name}', while
unprotected MIN functions are in the \ttmkey{min::unprotected}{namespace}
namespace and have names beginning with
`\ttmkey{min::unprotected::}{in function name}'.
The \TT{min} and \TT{min::unprotected} namespaces hold \underline{all}
the stable interfaces of the MIN implementation.

Code in \TT{min.h} that is not meant to be accessed
by users is in the following namespaces:

\begin{indpar}[0.1in]
\begin{tabular}{llp{4.0in}}
	    & Abbre- \\
Namespace   & viation   & Use
\\[1ex]
\minkey{os} & \ttkey{MOS}
			& Operating system independent interface to
			  operating system functions
			  not covered by C++ standards.
			  See Appendix \itemref{MOS}.
\\[1ex]
\minkey{acc} & \ttkey{MACC}
			& The part of the interface to the
			  Allocator/\EOL Collector/\EOL Compactor
			  that can be
			  changed when the acc is changed.
			  See Appendix \itemref{ACC}.
\\[1ex]
\minkey{internal} & \ttkey{MINT}\label{MINT}
		        & Interface to internal MIN code that can
			  be changed without notice at any time.
			  Not described in this document; see
			  \TT{.h} files.
\\[1ex]
\minkey{unicode} & \ttkey{UNI}
		        & Interface to UNICODE data base.
\end{tabular}
\end{indpar}

\section{Assert Macros}
\label{ASSERT_MACROS}

Protected functions use the following macro to enforce protection:

\begin{indpar}\begin{tabular}{lp{4.0in}}
\TTKEY{MIN\_ASSERT}\TT{(}$e$\TT{,...)}
	& By default, defined to evaluate $e$, and if the value is
	  false, call the \TT{min::\EOL assert\_\EOL hook} function which
	  by default prints an error message that includes the
	  character string generated by a call to
	  \TT{printf(...)} and then calls \TT{abort()}.
	  \TT{printf} is not called if \TT{...} is \TT{NULL}.
\LABEL{MIN_ASSERT} \\
\end{tabular}\end{indpar}

\TT{MIN\_ASSERT} is actually defined to be one of the following:
\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTKEY{MIN\_ASSERT\_CALL\_ON\_FAIL}\TT{(}$e$\TT{,...)}
	& The default value of \TT{MIN\_ASSERT}
	  if \TT{MIN\_\EOL NO\_\EOL PROTECTION == 0}.
	  Evaluates $e$, and if the value is
	  false, calls the \TT{min::\EOL assert\_\EOL hook} function.
\LABEL{MIN_ASSERT_CALL_ON_FAIL} \\
\TTKEY{MIN\_ASSERT\_CALL\_ALWAYS}\TT{(}$e$\TT{,...)}
	& Just always calls the \TT{min::\EOL assert\_\EOL hook} function.
	  By default,
	  that function just returns if $e$ evaluates to \TT{true}.
\LABEL{MIN_ASSERT_CALL_ALWAYS} \\
\TTKEY{MIN\_ASSERT\_CALL\_NEVER}\TT{(}$e$\TT{,...)}
	& Does nothing.  Does not even evaluate $e$.
	  The default value of \TT{MIN\_ASSERT}
	  if \TT{MIN\_\EOL NO\_\EOL PROTECTION == 1}.
\LABEL{MIN_ASSERT_CALL_NEVER} \\
\end{tabular}\end{indpar}

Thus by default \TT{MIN\_ASSERT} is defined by
\begin{center}
\TT{\# define MIN\_ASSERT MIN\_ASSERT\_CALL\_ON\_FAIL}
\end{center}
and it can be disabled by
\begin{center}
\TT{\# define MIN\_ASSERT MIN\_ASSERT\_CALL\_NEVER}
\end{center}
or set for debugging by
\begin{center}
\TT{\# define MIN\_ASSERT MIN\_ASSERT\_CALL\_ALWAYS}
\end{center}

If not defined by a compiler option or a definition preceeding
\TT{\#include} statements, the definition of
\TT{MIN\_ASSERT} is controlled by:

\begin{indpar}[0.2in]\begin{tabular}{p{2.1in}p{3.5in}}
\TTKEY{MIN\_NO\_PROTECTION}	& 1 to suppress integrity checks,
                                  such as \TT{MIN\_\EOL ASSERT}'s,
                                  \TT{MIN\_\EOL REQUIRES}'s,
                                  and code that initializes
				  variables that should never
				  be use.  Defaults to 0.  
\LABEL{MIN_NO_PROTECTION}
\end{tabular}\end{indpar}

Three alternatives to \TT{MIN\_ASSERT} are:

\begin{indpar}\begin{tabular}{lp{4.5in}}
\TTKEY{MIN\_REQUIRE}\TT{(}$e$\TT{)}
	& Defined to always be the equivalent of
	  \TT{MIN\_\EOL ASSERT(}$e$\TT{,NULL)}.
	  Used for system integrity checks.
\LABEL{MIN_REQUIRE} \\
\TTKEY{MIN\_CHECK}\TT{(}$e$\TT{)}
	& Defined to always be the equivalent of
	  \TT{MIN\_\EOL ASSERT\_\EOL CALL\_\EOL ALWAYS(}$e$\TT{,NULL)},
	  except that \TT{MIN\_\EOL CHECK} always passes a \TT{NULL}
	  \TT{function\_\EOL name} argument to
	  \TT{min::\EOL assert\_\EOL hook} so printed messages will
	  have less clutter.  Used by diagnostic programs.
\LABEL{MIN_CHECK} \\
\TTKEY{MIN\_ABORT}\TT{(...)}
	& Defined to always be the equivalent of
	  \TT{MIN\_\EOL ASSERT\_\EOL CALL\_\EOL ALWAYS(false,...)}.
	  Used when code transfers to a place it
	  should never transfer to.
\LABEL{MIN_ABORT} \\
\end{tabular}\end{indpar}

\TT{min::assert\_hook} is actually a pointer-to-function variable
that can be modified to change the function called by 
the \TT{MIN\_\EOL ASSERT}, \TT{MIN\_\EOL REQUIRE}, and \TT{MIN\_\EOL ABORT}
macros.  The interface is:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void ( * min::| & \MINKEY{assert\_hook} \verb|)|\ARGBREAK
    \verb|( bool value,|\ARGBREAK
    \verb|  const char * expression,|\ARGBREAK
    \verb|  const char * file_name, unsigned line_number,|\ARGBREAK
    \verb|  const char * function_name,|\ARGBREAK
    \verb|  const char * message_format, ... )|
\LABEL{MIN::ASSERT_HOOK} \\
\end{tabular}\end{indpar}

The \TT{value} argument to \TT{min::\EOL assert\_\EOL hook} is the
value of the $e$ argument to \TT{MIN\_\EOL ASSERT}.
The \TT{expression} argument is the expression $e$ that is evaluated
to produce the \TT{value} argument, and is used for printing messages.
It is \TT{NULL} only on a call from \TT{MIN\_ABORT}, and is not
used in this case.
The \TT{file\_\EOL name} and \TT{line\_\EOL number} arguments
identify the file and line containing the \TT{MIN\_\EOL ASSERT}, and
are used in printing messages.
The \TT{function\_\EOL name} argument identifies the function inside
of which \TT{MIN\_\EOL ASSERT} was executed, and is used for printing
messages, but may be \TT{NULL} if the function name is not known.
The \TT{message\_\EOL format} argument
to \TT{min::\EOL assert\_\EOL hook}, and the arguments following it, are the
values of the \TT{...} arguments to \TT{MIN\_\EOL ASSERT}, and are
used as \TT{printf} arguments to print messages, unless
\TT{message\_\EOL format} is \TT{NULL}.

The default value of \TT{min::assert\_hook} and data
used by this default are:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{standard\_assert}\ARGBREAK
    \verb|( bool value,|\ARGBREAK
    \verb|  const char * expression,|\ARGBREAK
    \verb|  const char * file_name, unsigned line_number,|\ARGBREAK
    \verb|  const char * function_name,|\ARGBREAK
    \verb|  const char * message_format, ... )|
\LABEL{MIN::STANDARD_ASSERT} \\
\verb|bool min::| & \MINKEY{assert\_print} \verb|= false|
\LABEL{MIN::ASSERT_PRINT} \\
\verb|bool min::| & \MINKEY{assert\_throw} \verb|= false|
\LABEL{MIN::ASSERT_THROW} \\
\verb|bool min::| & \MINKEY{assert\_abort} \verb|= true|
\LABEL{MIN::ASSERT_ABORT} \\
\verb|struct min::| & \MINKEY{assert\_exception} \verb|{ }|
\LABEL{MIN::ASSERT_EXCEPTION} \\
\end{tabular}\end{indpar}

If \TT{min::assert\_print} is \TT{true}, or if
\TT{value} is \TT{false} and \TT{min::\EOL assert\_\EOL throw}
is false, this function prints a message containing
\TT{file\_\EOL name} and \TT{line\_\EOL number},
\TT{function\_\EOL name} if that is not \TT{NULL},
\TT{expression} and \TT{value} if \TT{expression} is not \TT{NULL}
or the word `\TT{abort}' if \TT{expression} is \TT{NULL},
and \TT{message\_\EOL format} and subsequent arguments
as per \TT{printf} if \TT{message\_\EOL format} is not \TT{NULL}.

Then if \TT{value} is \TT{false} this function throws a
\TT{min::\EOL assert\_\EOL exception} if 
\TT{min::\EOL assert\_\EOL throw} is \TT{true}, else
calls \TT{abort()} if \TT{min::\EOL assert\_\EOL abort} is \TT{true},
else just returns.

On a call from \TT{MIN\_ABORT}, \TT{value} is \TT{false} and
\TT{expression} is \TT{NULL}.  On a call from any non-\TT{ABORT}
function, \TT{expression} is \underline{not} \TT{NULL}.


\section{Initialization}

Because C++ compilers are inconsistent in the order in which they
call constructors for \TT{static} data, MIN initialization is
not done until after \TT{main()} begins execution.  \TT{main()}
should begin with either
\begin{center}
\tt min::initialize();
\end{center}
or
\begin{center}
\tt min::interrupt\REL();
\end{center}

Either will initialize MIN.

Generally MIN out-of-line functions \underline{cannot} be called
by constructors of \TT{static} or \TT{extern} data, because
MIN is not initialized when these constructors execute.
MIN constructors designed to be used by such data do not call
MIN out-of-line functions or depend upon other MIN data being
constructed.  The following are some of the MIN constructors
and \TT{inline} functions that can be invoked during construction
of \TT{static} and \TT{extern} data:
\begin{center}
\tt
\begin{tabular}{l}
min::gen; \\
min::MISSING(); \\
min::NONE(); \\
min::locatable\_gen; \\
min::locatable\_var<T>; \\
min::ptr<T>; \\
min::packed\_struct<S>; \\
min::packed\_vector<E>; \\
min::packed\_vector<E,H,L>; \\
\end{tabular}
\end{center}

After MIN initializes itself it calls initializers that are
declared by including the following in a translation unit:

\begin{center}
\tt
\begin{tabular}{l}
static void my\_initialize ( void ) \{~...~\} \\
static min::initializer my\_initializer ( ::my\_initialize ); \\
\end{tabular}
\end{center}

Immediately after MIN performs its own initialization
it calls \TT{my\_initialize()} and other functions specified by
\TT{min::\EOL initializer}'s.  The order in which these
are called is indeterminate.  These functions can call any
MIN function and can finish initialization of \TT{static} or
\TT{extern} data.

\section{Data}

In defining MIN data the following number types are used to be sure
the size of each number is clear:
\begin{center}
\begin{tabular}{l@{~~~~~}p{4.5in}}
\minkey{uns8}	& unsigned 8-bit integer \\
\minkey{int8}	& signed 8-bit integer \\
\minkey{uns16}	& unsigned 16-bit integer \\
\minkey{int16}	& signed 16-bit integer \\
\minkey{uns32}	& unsigned 32-bit integer \\
\minkey{int32}	& signed 32-bit integer \\
\minkey{float32}	& 32-bit IEEE floating point number \\
\minkey{uns64}	& unsigned 64-bit integer \\
\minkey{int64}	& signed 64-bit integer \\
\minkey{float64}	& 64-bit IEEE floating point number \\
\minkey{unsptr}	& unsigned integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{intptr}	& signed integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{unsgen}	& unsigned integer of same length as a general value
                  (32 or 64 bits, see \itemref{GENERAL-VALUES})
                  \\
\minkey{Uchar}	& unsigned 32-bit integer (used as UNICODE character) \\
\end{tabular}
\end{center}%
\LABEL{MIN::UNS8}%
\LABEL{MIN::INT8}%
\LABEL{MIN::UNS16}%
\LABEL{MIN::INT16}%
\LABEL{MIN::UNS32}%
\LABEL{MIN::INT32}%
\LABEL{MIN::FLOAT32}%
\LABEL{MIN::UNS64}%
\LABEL{MIN::INT64}%
\LABEL{MIN::FLOAT64}%
\LABEL{MIN::UNSPTR}%
\LABEL{MIN::INTPTR}%
\LABEL{MIN::UNSGEN}%
%\LABEL{MIN::UCHAR}%
\label{INT}%
\label{UNS}

Current implementations of MIN assume a compiler that has
direct support for 64 bit integers.  It is possible, but not recommended,
to modify the implementations to use compilers without such support.

MIN depends upon certain undocumented C++ conventions.

First, it is assumed that classes will not have hidden
padding that is not required to align member offsets.
It is assumed that the compiler will allocate class members
in order without any hidden padding if this will lead to
an allocation in which each member of a number type above or
of any pointer type has an offset in class instances
that is a multiple of the member length.

Second, it is assumed that the contents of a base class are
allocated is if the class contained an unnamed first member
whose type is the base class.

Care is taken to use these first two assumptions when defining
MIN data this may be input or output in binary form.
Some checks on these assumptions are programmed into MIN
initialization routines using C++ `\TT{assert}' statements.

Third, it is assumed that a class containing just one element
that is a number or pointer is just as efficient in optimized
code as a number or pointer not in a class.  In particular,
such a one-element class used as an argument or return value
should be passed in a register.

All these assumptions seem to be satisfied by the GNU C++
compiler.

\subsection{Stubs and Bodies}

MIN data memory consists of regions that contain stubs and regions
that contain bodies.  A region is a contiguous block
of memory, typically consisting of an integral number of hardware
pages.

\ikey{Stubs}{stub}
are small fixed size units of memory that cannot be relocated:
the usual stub size for MIN is 16 bytes.
Each object has a stub, and the address of the stub is in effect
the internal name of the object.  Some atoms (e.g., numbers, strings)
have stubs, and some (e.g., integers that are not large, and very short
strings) do not.

A stub is divided into an 8 byte \key{stub value}
and an 8 byte \key{stub control}.
The stub value can be a 64-bit IEEE floating point number,
an 8 \TT{char} string, or, as we will soon see, a pointer to a body.
It is also possible for a stub value to hold any other 8 bytes of information.

The stub control holds a 1 byte \key{type code} and other information used,
for example, by the allocator/collector/compactor (acc).

The type name of a stub is `\minkey{stub}', and a pointer to a stub
has type `\TT{min::stub *}'.\LABEL{MIN::STUB}
Protected functions can return `\TT{const min::stub *}' values,
but only unprotected functions can return `\TT{min::stub *}' values.

A \key{body} is a variable sized
\ttmkey{relocatable}{body}\label{RELOCATABLE-BODY}
block of memory
attached to a particular stub.  A stub may have a body attached to
it, in which case the stub value is a pointer to that body.
When certain functions are called,
any body can be moved and its corresponding stub value reset to
point at the new location of the body.
Functions with this property are called
`\key{relocating functions}'\label{RELOCATING-FUNCTIONS}
and their names are marked by the superscript
\subsmkey{R}{of function} in this document.  Included
are functions that allocate objects.
Obtaining a C++ pointer into a body is an unprotected operation, because
the pointer must be updated if a relocating function is called.

\ikey{Interrupts}{interrupt!and relocation} can relocate bodies.
Therefore interrupts are only allowed
at specific points in the code.  The inline function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{interrupt\REL} \verb|( void )|
\LABEL{MIN::INTERRUPT} \\
\end{tabular}\end{indpar}%
\index{interrupt!relocating}

checks an interrupt
flag, and if that is set, calls an out-of-line function to process
the interrupt.  The function returns \TT{true} if and only if
there was actually an interrupt (this should be used only
for optimization).

A body may be \mkey{deallocated}{by moving}
by moving it to unimplemented memory.  When this is done the
stub \mkey{type code}{reset on deallocation}
is reset to the value \minkey{DEALLOCATED}\LABEL{MIN::DEALLOCATED},
which indicates the body is deallocated.
Deallocation is considered to be a variant of relocation.
Relocating functions, those marked marked by {\REL} in documentation,
may also deallocate objects.

Deallocation is done by the \TT{min::\EOL deallocate\REL}
function (\pagref{MIN::DEALLOCATE}) and testing to see if a 
a body has been deallocated is done by the
\TT{min::is\_deallocated} function
(\pagref{MIN::IS_DEALLOCATED}).

Bodies are always some multiple
of 8 bytes long, and are allocated on 8 byte boundaries.

\ikey{Protected functions}{protected function!using {\tt MIN\_ASSERT}}
that take a stub pointer as argument use
\ttmkey{MIN\_ASSERT}{in protected function} macros
(\pagref{MIN_ASSERT}) to check
the \mkey{type code}{checked by {\tt MIN\_ASSERT}}
of the stub and various lengths.  Unprotected functions
contain no such checks.

Memory consisting of unrelocatable stubs pointing at relocatable
bodies is called a `\key{stub/\EOL body memory}'.
Thus MIN has a stub/body memory.
The main advantages of stub/body memory are that relocation of bodies
can happen independently of other program activity, and bodies can be
deallocated by program command at any time.\footnote{
Stub/body memories are certainly not new.  For example, Kyoto COMMONLISP
used a stub/body implementation of arrays, and the author has heard about
implementations that go back to the late 1950's or early 60's: see
p33 of the author's thesis, R-CODE, A Very Capable Virtual Computer.}


\subsection{General Values}
\label{GENERAL-VALUES}

A general value can store any of:

\begin{center}
\begin{tabular}{l}
a direct atom value \\
a pointer to a stub \\
an auxiliary pointer \\
an index \\
a control code \\
a special value
\end{tabular}
\end{center}

General values are used as attribute names and values in
objects and as function arguments and return values.

General values that represent numbers or character strings
are called \skey{atom}s, because they have no subcomponents.
There are two kinds of atoms: \skey{direct atom}s that
are stored completely in a general value, and
\skey{indirect atom}s that are stored in a stub or in
a body pointed at by a stub, with the stub being pointed
at by a general value.

Efficiency aside, it does not matter
whether a general value stores a direct atom value or a pointer
to a stub holding an indirect atom value,
as atom values are immutable and cannot be changed.  Of course not all
atom values will fit into a general value, and those that do not must
be stored in stubs or in bodies pointed at by stubs.

An \key{auxiliary pointer} is an integer that is used by a general value
stored inside a body to point at some part, called an
\key{auxiliary},\label{AUXILIARY} of the same body.
There are several subtypes of auxiliary pointers storable in bodies.
See~\pagref{OBJECT-BODY-AUXILIARY-POINTER}.

An \key{index}
is an integer that is used to give the index of a variable
that is an element of an object body.
See~\pagref{INDEX}.

A \key{control code} is an integer that represents flags and codes
stored in a general value.  Control codes can have different
interpretations in different contexts.
For example, see `Attribute Flags', \pagref{ATTRIBUTE-FLAGS}.

A \key{special value} is a unique value that has some
special meaning.  \TT{min::MISSING()}, for example, is a special
value that may be input or output to indicate that data is missing,
and \TT{min::NONE()} is a special value used only to
indicate that a function argument or result does not exist.
See \itemref{SPECIAL-VALUES}.

The \TT{min::}\MINKEY{gen}\LABEL{MIN::GEN}
type is defined as a C++ class that
consists of a single \TT{private} element of type
\TT{min::}\MINKEY{unsgen}, which is an unsigned integer.
From the point of view of C++ type checking, a \TT{min::\EOL gen}
value is a class, but from the computational point of view it is
an unsigned integer.

Because \TT{min::gen} is a class type, it is not possible to
present \TT{min::\EOL gen} constants to the compiler for use in
optimized code in a completely straightforward way.  To get the
desired effect, \TT{min::\EOL gen} constants are represented by
\TT{inline} functions, which allows the optimizing compiler 
to insert the constants directly into instructions.  Thus
we have the constant \TT{min::\EOL MISSING()}, a function call
with no arguments, \underline{instead of} \TT{min::\EOL MISSING}, a datum.

There are two kinds of MIN implementation: `\key{compact}' and
`\key{loose}'.\label{COMPACT}\label{LOOSE}\label{COMPACT-OR-LOOSE}
A compact implementation uses 32-bit general values, while
a loose implementation uses 64-bit general values.
An implementation cannot use both 32-bit and 64-bit general values;
the implementation must use one or the other.

The 64-bit loose implementation formats a \TT{min::\EOL gen}
value as an IEEE floating point number, using the NaN (Not-a-Number)
values to encode non-numeric \TT{min::\EOL gen} values, such as
pointers to stubs.  Thus
in the loose implementation \TT{min::\EOL float64} values are
stored verbatim in \TT{min::\EOL gen} values.

Some functions and constants are defined only for compact implementations,
and some only for loose implementations.  Those defined only for
compact implementations are called
`\skey{compact function}s'\label{COMPACT-FUNCTIONS} and their
names are marked with the superscript \subsmkey{C}{of function}
in this document.
Those defined only for
loose implementations are similarly called
`\skey{loose function}s'\label{LOOSE-FUNCTIONS} and their
names are marked with the superscript \subsmkey{L}{of function}.

The value of a compact implementation is that it uses less memory%
\footnote{However, double precision floating point numbers only
use less memory if each is replicated several times.},
but there may be a speed penalty.
The value of a loose implementation is that it may run faster, but
there is a memory penalty.  It is not clear what the speed difference
between the two implementations really is, so both implementations
are offered in order to decide the issue by experiment.

Also compact implementations do not permit more than
about $2^{32}$ objects to exist in memory at one time, whereas
loose implementations permit up to about $2^{44}$ objects.

\subsubsection{General Value Subtypes}
\label{GENERAL-VALUE-SUBTYPES}

A \key{general value} has type \minkey{gen} and
is a 32 or 64 bit aligned value that can be of one of the following
subtypes;

\begin{indpar}[3em]
a pointer to a stub \\
a 64-bit IEEE floating point direct number atom\LOOSE \\
a 28-bit direct integer atom\COMPACT \\
a 0-5 \TT{char} direct string atom\LOOSE \\
a 0-3 \TT{char} direct string atom\COMPACT \\
a VSIZE-bit index \\
a VSIZE-bit control code \\
a VSIZE-bit special value \\
a VSIZE-bit list auxiliary pointer \\
a VSIZE-bit sublist auxiliary pointer \\
a VSIZE-bit indirect auxiliary pointer
\end{indpar}
\hspace*{1in}\begin{minipage}{4.5in}
where \key{VSIZE} equals 24 for a compact implementation
and 40 for a loose implementation
\end{minipage}

Here {\COMPACT} subtypes are only implemented by compact
implementations, and {\LOOSE} subtypes are only implemented by
loose implementations (\pagref{COMPACT-OR-LOOSE}).

Numbers and character strings stored inside a \TT{min::gen} value are
called `\skey{direct atom}s\,'.  Numbers and character strings
stored in stubs or bodies which are pointed at by a
\TT{min::gen} value are called `\skey{indirect atom}s'.  An atom is
always stored in only one way by an implementation.  If a number will fit
into a direct atom, it is stored as a direct atom, and never as an
indirect atom.  Similarly if a character string will fit into a direct atom,
it is stored as a direct atom, and never as an indirect atom.

Analogously indirect atoms are stored in only one place in memory, so
two indirect numbers are equal if and only the \TT{min::gen} values
pointing at them point at the same place, and similarly
two indirect character strings are equal if and only
the \TT{min::gen} values pointing at them point at the same place.

Therefore two atoms are equal if and only if the \TT{min::gen} values
designating them are \TT{==} as 32-bit or 64-bit values.

General values that point at stubs hold stub addresses in a
packed format.  44 bits are available to store a stub address in a
64-bit general value, and 32 bits are available to store a stub address
in a 32-bit general value, but in the latter case the packed address must be
less than $2^{32}-2^{29}$ (the $2^{29}$ other 32 bit values are used to store
direct integers, direct strings,
auxiliary pointers, indices, control codes, and special
values).  There are three
\skey{stub address packing scheme}s,\label{STUB-ADDRESS-PACKING} and the fastest
is selected for each type of general value according to the settings of
the following `\skey{stub address packing parameter}\,' macros:

\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTKEY{MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum absolute address of any stub as an unsigned integer
	  constant.  See \pagref{MIN_MAX_ABSOLUTE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTKEY{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum address of any stub relative to a constant
	  stub base address, as an unsigned integer
	  constant.  See \pagref{MIN_MAX_RELATIVE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}

The fastest scheme is the \key{absolute stub address} scheme,
where the absolute stub
address is stored.  For 64 bit general values this is
just a matter of inserting the stub address into the low order 44 bits
of the value.  For 32 bit general values this is just a matter of
using the stub address as the general value.
This scheme can be used if
\TT{MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The second fastest scheme is the \key{relative stub address}
\label{RELATIVE-STUB-ADDRESS} scheme, where the
stub address relative to a constant \key{stub base}
address is stored.
The relation between the absolute and relative stub addresses is:

\begin{center}
stub absolute address = stub base + stub relative address
\end{center}

where `stub base' is a constant determined when the program is
initialized.
This scheme can be used if
\TT{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The slowest scheme is the \key{stub index} scheme, where the
relative stub address divided by the stub length is stored.
The stub length is chosen to be a power of 2 so that this
scheme will be efficient.  Again, this scheme can be used
if the relative address of the stub is not too large, but since
the stub length is 16, the relative address can be 16 times larger
for the stub index packing scheme than it is for the stub relative address
packing scheme.
Thus the index scheme can be used if
\TT{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS/16}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

Note that on machines that have 32 bit addresses (e.g.,
the IA32\footnote{Intel Architecture 32-bit, a.k.a, i386 machines.}
machines), there is little to gain by either the relative stub address
or stub index packing schemes,
so only the absolute stub address scheme should be used on such machines.

A 32-bit general value direct integer consists of a high order 4-bit
subtype code and a low order 28-bit signed integer stored in offset form,
so the true integer can be derived from the \TT{min::gen} value by
subtracting the \TT{min::gen} representation of zero.
The range of such a direct integer is the same as the range of a 28-bit
two's complement integer: $-2^{27}$ to $2^{27}-1$, inclusive.

Other 32-bit general values consist of a high order
8-bit subtype code and a low order 24-bit datum.
For most auxiliary pointer
general values the datum is a 24-bit auxiliary pointer
(see~\pagref{OBJECT-BODY-AUXILIARY-POINTER}
for a definition of auxiliary pointers).
For index and special values the datum is a 24-bit index.
For control code general values the datum is 24-bits that
contains flags and codes that have different interpretations in different
contexts.  And for direct string general values the datum
holds 0 to 3 8-bit \TT{char}'s.

For 64-bit general values that point at stubs, the high order 20 bits
are used as a subtype code.  For other 64-bit general values, the high
order 24 bits are the subtype code and the low order 40 bits are the datum.
The values chosen for these subtype codes make stub pointers, direct strings,
auxiliary pointers, indices, and control codes -- that is, all non-number
\TT{min::gen} values --
into IEEE Nan (Not-a-Number)
values that are never generated by hardware instructions.

For most auxiliary pointer general values the 40-bit datum is used to hold
a 40-bit auxiliary pointer.
For index and special values the datum holds a 40-bit index.
For control code general values the datum is a 40-bit control code;
and for direct string general values the datum holds 0-5 \TT{char}'s.

The \TT{min::gen} type has the alignment
properties of either \TT{min::uns32} or \TT{min::uns64},
and \TT{min::}\EOL \MINKEY{unsgen} is \TT{typedef}'ed to the appropriate one
of these two types.

Many \TT{min::gen} values, which are 32 or 64 bits, are divided into a subtype,
either 8 or 24 bits, and a datum, either 24 or 40 bits.  In this context the
datum is called the `\mkey{value}{part of a \TT{min::gen} value}'.

The following definitions are provided in \TT{min.h} to facilitate coding:

\begin{indpar}
\begin{tabular}{r@{}l}
\verb|typedef min::uns32 min::| & \MINKEY{unsgen}\COMPACT
\LABEL{MIN::COMPACT_UNSGEN} \\
\verb|typedef min::uns64 min::| & \MINKEY{unsgen}\LOOSE
\LABEL{MIN::LOOSE_UNSGEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_gen} \verb|( min::unsgen value )|
\LABEL{MUP::NEW_GEN} \\
\verb|min::unsgen MUP::| & \MUPKEY{value\_of} \verb|( min::gen value )|
\LABEL{MUP::VALUE_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{gen} \verb|( void )|
\LABEL{MIN::GEN_OF_VOID} \\
\verb|const unsigned min::| & \MINKEY{TSIZE}
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
\LABEL{MIN::VSIZE} \\
\end{tabular}
\end{indpar}

\TT{min::unsgen} is typedef'ed to
\TT{min::uns32}\COMPACT or \TT{min::uns64}\LOOSE.
\TT{MUP::\EOL new\_\EOL gen} and \TT{MUP::\EOL value\_of} are
unprotected converters between \TT{min::\EOL unsgen} and \TT{min::\EOL gen}
values.

\TT{min::\EOL gen (~void~)} is the default constructor that sets
an unassigned \TT{min::\EOL gen} value so it will more likely
trigger a fault if read by mistake (there is an exception for
\TT{min::gen} elements of packed structures and packed vectors,
which are set to \TT{0} when the structures or vectors are
created: see \itemref{PACKED-STRUCTURES} and \itemref{PACKED-VECTORS}).
Note that the existence of this constructor makes it impossible to
include \TT{min::\EOL gen} values in C++ \TT{union}'s, but
\TT{min::\EOL unsgen} values can be included instead and converted
using the unprotected converters.

\TT{TSIZE} is the subtype size in bits;
equal to \TT{8}\COMPACT or \TT{24}\LOOSE.
\TT{VSIZE} is the value size in bits;
equal to \TT{24}\COMPACT or \TT{40}\LOOSE.

\subsubsection{General Value Compilation}
\label{GENERAL-VALUE-COMPILATION}

The decisions on whether an implementation is
compact or loose (\pagref{COMPACT-OR-LOOSE})
must be made before C++ code is compiled.
Decisions must also be made determining the stub address packing
parameters (\pagref{STUB-ADDRESS-PACKING}).
The following macros, which must be defined identically
for all separately compiled parts of a single program, describe
these decisions.  These macros are in two groups, first the macros
that are set by the programmer, and then the macros which by default
are computed from the settings of the first group of macros.
All these macros are defined in
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

The macros set by the programmer are:

\begin{indpar}[0.2in]\begin{tabular}{p{2.1in}p{3.5in}}
\TTKEY{MIN\_IS\_COMPACT}	& 1 if compact implementation; 0 if loose;
				  defaults to 0.
\LABEL{MIN_IS_COMPACT}
\end{tabular}\end{indpar}
\begin{indpar}[0.2in]\begin{tabular}{p{2.1in}p{3.5in}}
\TTKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
				& Maximum number of garbage collector
				  ephemeral levels allowed in
				  \underline{any} execution of the
				  compiled binary; defaults to 2.
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\end{tabular}\end{indpar}

The macros which are normally set to default values computed from
the above macro settings are:
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTKEY{MIN\_IS\_LOOSE}	& 1 if loose implementation; 0 if compact;
				  Must equal `\TT{!~MIN\_IS\_COMPACT}\,'.
\LABEL{MIN_IS_LOOSE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
				& The maximum number of stubs that can
				  exist in \underline{any} execution
				  of the compiled binary.  Defaults: \\
& \hspace*{1em}\begin{tabular}{ll}
if \TT{MIN\_IS\_COMPACT} = 1:	& $2^{28} - 2^{25}$ \\
else pointers are 32 bits:	& $2^{28}$ \\
else:				& $2^{40-4e}$ \\
\end{tabular} \\
& where \\
& ~~$e = max(0,\mbox{\TT{MIN\_MAX\_EPHEMERAL\_LEVELS}}-2)$.
\LABEL{MIN_MAX_NUMBER_OF_STUBS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTKEY{MIN\_STUB\_BASE}
	& The value of the `stub base' for relative addressing
          (see \pagref{RELATIVE-STUB-ADDRESS}).  If defined
          this must be a non-negative integer constant.  Defaults to
	  \TT{0} if \TT{MIN\_MAX\_NUMBER\_OF\_STUBS} is set by
	  default, and otherwise is left undefined.
\LABEL{MIN_STUB_BASE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\multicolumn{2}{l}{\TTKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}} \\
	& The maximum address of any stub relative to the `stub base' (address
	  of the first stub), as an unsigned integer constant.  Default: \\
	& ~~\TT{16*MIN\_MAX\_NUMBER\_OF\_STUBS - 1}.
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\multicolumn{2}{l}{\TTKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}} \\
	& The maximum absolute address of any stub.  Defaults: \\
	& ~~~~ if \TT{MIN\_STUB\_BASE} defined: \\
	& ~~~~~~~~ \TT{  MIN\_STUB\_BASE} \\
	& ~~~~~~~~ \TT{+ MIN\_MAX\_RELATIVE\_STUB\_ADDRESS} \\
	& ~~~~ else if \begin{tabular}[t]{@{}l@{}}
	               \TT{MIN\_IS\_COMPACT} = 1 and \\
		       pointers are 32 bits:
		       \end{tabular} \\
	& ~~~~~~~~ $2^{32}-2^{29}-1$ \\
	& ~~~~ else if pointers are 32 bits: \\
	& ~~~~~~~~ $2^{32}-1$ \\
	& ~~~~ else: \\
	& ~~~~~~~~ $2^{48}-1$
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS}
\end{tabular}
\end{indpar}

\subsubsection{General Value Functions}
\label{GENERAL-VALUE-FUNCTIONS}

General values can be assigned using the default
\TT{=} operator and compared by the usual equality operations:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::==_OF_GEN} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::!=_OF_GEN} \\
\end{tabular}\end{indpar}

The following functions return \TT{true} if a \TT{min::gen} datum is of the
indicated subtype and \TT{false} otherwise:

\begin{indpar}
\verb|bool min::|\MINKEY{is\_stub} \verb|( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::|\MINKEY{is\_direct\_float\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::|\MINKEY{is\_direct\_int\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::|\MINKEY{is\_direct\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::|\MINKEY{is\_index} \verb|( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::|\MINKEY{is\_control\_code} \verb|( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::|\MINKEY{is\_special} \verb|( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::|\MINKEY{is\_list\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::|\MINKEY{is\_sublist\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::|\MINKEY{is\_indirect\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::|\MINKEY{is\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_AUX}
\end{indpar}

For a 32-bit general value \TT{is\_direct\_float\LOOSE} is unimplemented.
For a 64-bit general value \TT{is\_direct\_int\COMPACT} is unimplemented.
The \TT{min::\EOL is\_\EOL aux} function returns true if the general
value is any auxiliary pointer (i.e., list, sublist, etc.).

The following protected functions return the value appropriate for a given
subtype, after checking the subtype with a \TT{MIN\_ASSERT} statement:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * | & \MINKEY{NULL\_STUB}
\LABEL{MIN::NULL_STUB} \\
\verb|const min::stub * min::| & \MINKEY{stub\_of} \verb|( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of} \verb|( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\
\end{tabular}\end{indpar}

The \TT{min::stub\_of} function is unusual in that it can be applied
to a \TT{min::\EOL gen} value that does not contain a stub pointer, and will
return \TT{min::\EOL NULL\_\EOL STUB} in this case.  The latter is
just a \TT{NULL} value that has been
type cast to the \TT{const min::\EOL stub~*} type.
The other functions must be applied to \TT{min::\EOL gen}
values of the right kind else a \TT{MIN\_\EOL ASSERT} failure will
occur.

Here the \TT{min::uns64} value returned by \minkey{direct\_str\_of}
should be overlaid by a union with a \TT{char[]} buffer, as in
the code:

\begin{indpar}\begin{verbatim}
union { min::uns64 u; char s[6]; } v;
min::gen g;
. . . set g to a direct string value . . .
v.u = min::direct_str_of ( g );
cout << v.s;
\end{verbatim}\end{indpar}

The \TT{min::direct\_str\_of} function merely copies the 3 or
5 \TT{char}'s of the \TT{min::gen} direct string value and
appends a \TT{NUL} character.
It does this by writing an appropriate value into \TT{v.u}.

The \TT{min::\ldots{}\_aux\_of}, the \TT{min::index\_of} function,
the \TT{min::control\_code\_of} function,
and the \TT{min::\EOL spec\-ial\_\EOL index\_\EOL of} function all
return a 24-bit\COMPACT or 40-bit\LOOSE unsigned integer as a
\TT{min::unsgen} value.

The following unprotected functions return the value appropriate for a given
subtype, \underline{without} checking the subtype:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of} \verb|( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::| & \MUPKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of} \verb|( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of} \verb|( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{tabular}\end{indpar}

Note that \TT{MUP::stub\_of} returns a `\TT{min::stub *}' pointer
whereas \TT{min::stub\_of} returns a `\TT{const min::stub *}' pointer.
Also, if the \TT{min::\EOL gen} argument does not contain a stub pointer,
the argument is illegal for \TT{MUP::\EOL stub\_\EOL of}, but
it is legal for \TT{min::\EOL stub\_\EOL of} which will return
\TT{min::\EOL NULL\_\EOL STUB}.

The \TT{MUP::\EOL aux\_\EOL of} function returns the auxiliary pointer
of any \TT{min::gen} value containing an auxiliary pointer (list,
sublist, or indirect).

New \TT{min::gen} values can be generated by the following protected
functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_stub\_gen} \verb|( const min::stub * s )|
\LABEL{MIN::NEW_STUB_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE} \verb|( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen\COMPACT} \verb|( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_str\_gen} \verb|( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen} \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{tabular}\end{indpar}

These protected functions check for argument range errors.  Stubs are
\underline{not} allocated by these functions, so an \TT{int}
argument to \TT{min::new\_direct\_int\_gen\COMPACT} must fit in 28 bits,
and the \TT{const char *} strings must be short enough to
fit into a direct string.  For \TT{min::new\_\EOL direct\_\EOL str\_\EOL gen}
with a second argument \TT{n}, a string longer than \TT{n} characters
is shortened to \TT{n} characters (analogously to \TT{strncpy} and
\TT{strncmp}).
The \TT{min::unsgen} arguments used to make auxiliary pointers, indices,
control codes, and special values must fit within \TT{min::VSIZE} bits.

The subtype codes used for 64-bit \TT{min::gen} direct string, stub pointer,
auxiliary pointer, index, control code, and special values
-- that is, all the non-numeric \TT{min::gen} values --
are chosen to avoid being the same as the high order bits of any
IEEE floating point number normally generated by the compiler,
run-time system, or program execution.  A \TT{min::float64}
input to \TT{min::new\_direct\_\EOL float\_\EOL gen} is assumed not to have
these subtype
codes, and no check is made for such, even by range-checking protected
functions.

The following unprotected functions are analogous but do not check for
range errors.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen MUP::| & \MUPKEY{new\_stub\_gen} \verb|( min::stub * s )|
\LABEL{MUP::NEW_STUB_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_float\_gen\LOOSE}
     \verb|( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_int\_gen\COMPACT} \verb|( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen} \verb|( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen}
     \verb|( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::| & \MUPKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN}
\end{tabular}\end{indpar}

The following unprotected functions can be used to replace the data
(non-subtype) part of a \TT{min::gen} value that is \underline{not}
a pointer to a stub or a number (direct float or direct integer).
The intended use is for changing the value of an auxiliary pointer
in a general value, or the flags in a condition code.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen} \verb|( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\
\end{tabular}\end{indpar}

The actual direct atom, stub pointer, auxiliary pointer, index,
and control code
\TT{min::gen} subtype codes
are implementation dependent.  The following constants equal these
subtype codes:

\begin{indpar}
\verb|const unsigned min::|\MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_FLOAT\LOOSE}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_INT\COMPACT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::|\MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::|\MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::|\MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::|\MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL}
\end{indpar}

\TT{min::GEN\_ILLEGAL} is actually illegal as a subtype code but may
be returned by the following function which be used to retrieve
the subtype code field:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{gen\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{tabular}\end{indpar}

For 64-bit \TT{min::gen} values, this retrieves the high order
24 bits of the value, and then zeros any low order bits that are not
part of the subtype code (that is, the 64-bits are right shifted by
40 bits and then bits of the result that are not part of the
subtype, such as bits in a number, are zeroed).
For 32-bit \TT{min::gen} values, this retrieves
the high order 8 bits, and then zeros any low order bits that are not
part of the subtype code (similarly the 32-bits are right shifted by
24 bits, etc.).
\TT{min::GEN\_ILLEGAL} is returned by this function if the \TT{min::gen}
value is not a legal general value.

There are also unprotected functions to convert between
\TT{min::\EOL gen} and \TT{min::\EOL unsgen} values:
see \pagref{MUP::NEW_GEN}.

\subsection{Special Values}
\label{SPECIAL-VALUES}

Special general values are \TT{min::gen} values that are unique
and not equal to any non-special \TT{min::\EOL gen}
value that can be generated during
program execution.  Special general values are C/C++ \TT{const}
values, and must only be used as specified by documentation.
They are used as return or argument values by some functions.

For reasons given below, special values are defined by \TT{inline}
functions of no-arguments.  Special values are divided into two
groups, those that can only be used as function arguments and return
values, and those whose use is unrestricted (and, in particular, can be used
as object attribute values):

The special values that can only be used as function arguments and
return values (and \underline{cannot} be used as object attribute values)
are:\label{ATTR-ILLEGAL-SPECIAL-VALUES}

\begin{indpar}
\begin{list}{}{}
\item[\TT{const min::gen min::}\MINKEY{NONE()}]~%
	\LABEL{MIN::NONE}\\
Denotes a non-existent function argument or result.
\item[\TT{const min::gen min::}\MINKEY{ANY()}]~%
	\LABEL{MIN::ANY}\\
An argument value used to specify that any value from a set of values may be
used or returned.
\item[\TT{const min::gen min::}\MINKEY{MULTI\_VALUED()}]~%
	\LABEL{MIN::MULTI_VALUED}\\
A value returned to indicate that
a set of values has more than one element.
\end{list}
\end{indpar}

The special values whose use is unrestricted
(and can be used as object attribute values) are:

\begin{indpar}
\begin{list}{}{}
\item[\TT{const min::gen min::}\MINKEY{MISSING()}]~%
	\LABEL{MIN::MISSING}\\
Denotes a missing value or an empty set of values, and may be input
or output and used as an attribute value.
\item[\TT{const min::gen min::}\MINKEY{DISABLED()}]~%
	\LABEL{MIN::DISABLED}\\
Specifies that a feature is disabled.
\item[\TT{const min::gen min::}\MINKEY{ENABLED()}]~%
	\LABEL{MIN::ENABLED}\\
Specifies that a feature is enabled.
\item[\TT{const min::gen min::}\MINKEY{UNDEFINED()}]~%
	\LABEL{MIN::UNDEFINED}\\
A value given to an object variable vector element
(\itemref{GRAPH-TYPED-OBJECTS}) that has no value and can be indirected.
\item[\TT{const min::gen min::}\MINKEY{SUCCESS()}]~%
	\LABEL{MIN::SUCCESS}\\
A value returned to indicate a function has succeeded.
\item[\TT{const min::gen min::}\MINKEY{FAILURE()}]~%
	\LABEL{MIN::FAILURE}\\
A value returned to indicate a function has failed.
\item[\TT{const min::gen min::}\MINKEY{ERROR()}]~%
	\LABEL{MIN::ERROR}\\
A value returned to indicate a function call has suffered an error.
The function may print an error message in
this case, or may leave an error message in
\TT{min::\EOL error\_\EOL message} (\pagref{ERROR_MESSAGE}).
\item[\TT{const min::gen min::}\MINKEY{LOGICAL\_LINE()}]~%
	\LABEL{MIN::LOGICAL_LINE}\\
The value of the \TT{.initiator} attribute of a logical line:
see \pagref{LOGICAL-LINE-COMPACT-FORMAT}.
\item[\TT{const min::gen min::}\MINKEY{INDENTED\_PARAGRAPH()}]~%
	\LABEL{MIN::INDENTED_PARAGRAPH}\\
The value of the \TT{.terminator} attribute of an indented paragraph:
see \pagref{INDENTED-PARAGRAPH-COMPACT-FORMAT}.
\end{list}
\end{indpar}

Special general values each have a unique \ikey{index}{of special value}
that identifies them relative to other special values.  These
indices are in the range $0$ through $2^{24}-1$.  The last 1024 indices of this
range, $2^{24}-1024$ through $2^{24}-1$, are reserved for use by the MIN
system.  Other special values can be created by other systems,
and indices near 0 are reserved for non-system users.

For efficiency reasons it is desirable for special values to be
compile time constants.  Because \TT{min::\EOL gen} is a class type,
C++ constants cannot be used to insert special values into optimized
instructions, and \TT{inline} functions are used instead.  A
special value \TT{S} with index \TT{I} should be defined by:

\begin{indpar}\begin{verbatim}
inline min::gen S ( void )
{
    return min::new_special_gen ( I );
}
\end{verbatim}\end{indpar}

where \TT{I} is an integer constant in the range $0,\ldots,2^{24}-1025$.


\subsection{Stubs}
\label{STUBS}

General values may point at object stubs, which are 16 byte structures
that are \underline{not} relocated during execution.
Some stubs have pointers to object bodies, which can be
relocated during execution, either
because the object is being expanded or contracted, or because
memory is being compacted.

A stub contains an 8 byte stub value and an 8 byte stub control.
The type of a stub is \minkey{stub}.  Only pointers to stubs
are used, and these come in two flavors:
\TT{const min::stub~*} is used by protected functions and
\TT{min::stub~*} without the `\TT{const}' is used
by unprotected functions.

If the stub control is viewed as a 64 bit integer, its high order byte
is the type code.  The high order bit of this type code,
which is the high order
bit of the 64 bit stub control integer, is off if the stub is managed by
the allocator/collector/compactor (acc, of which the garbage collector is
a part).  In this case the stub is said to be `\key{collectible}'.
In the other case, where the bit is on, the stub is
said to be `\key{uncollectable}', and the stub is allocated and freed
by explicit calls to the acc, but is not garbage collected or compacted by the
acc.

If an stub has a body, its stub value is a pointer at that body.
Any other pointer into the body is called a `\key{body pointer}', and
will become invalid if the body is moved
by a relocating function (see \pagref{RELOCATING-FUNCTIONS}).

\subsubsection{Stub Type Codes}
\label{STUB-TYPE-CODES}

The \key{type code} of a stub may be returned by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MIN::TYPE_OF} \\
\verb|int MUP::| & \MUPKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MUP::TYPE_OF}
\end{tabular}\end{indpar}

If the argument is \TT{min::NULL\_STUB},
the \TT{min::type\_of} function returns \TT{0}, which is not
a stub type code (it does not even equal \TT{min::GEN\_ILLEGAL}),
whereas \TT{MUP::\EOL type\_\EOL of} suffers a memory fault (it
tries to read a byte near address \TT{0}).

The type code of the stub pointed at by a \TT{min::gen} value
can be obtained by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{type\_of} \verb|( min::gen v )|
\LABEL{MIN::TYPE_OF_GEN}
\end{tabular}\end{indpar}

This function will return \TT{0}, which is not a legal stub type,
if \TT{v} does not contain a stub pointer.

A determination of whether or not a stub is collectible may be made
by applying the function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_collectible} \verb|( int type )|
\LABEL{MIN::IS_COLLECTIBLE}
\end{tabular}\end{indpar}

to the type code of the stub.  Notice that type codes are \underline{signed}
integers, so that negative type codes are uncollectable and positive type codes
are collectible.

A partial list of stub type codes is:

\begin{indpar}
\begin{list}{}{}
\item[\TT{const int min::NUMBER}]~\\
Stub value is an IEEE 64-bit floating point number.
\item[\TT{const int min::SHORT\_STR}]~\\
Stub value is 0-8 \TT{const char} string, \TT{NUL} padded.
\item[\TT{const int min::LONG\_STR}]~\\
Stub value is a pointer at a body of type \TT{min::long\_\EOL string}
that contains a \TT{const char} vector and its size. 
\item[\TT{const int min::DEALLOCATED}]~\\
Stub has a deallocated body.
\item[\TT{const int min::PREALLOCATED}]~\\
Stub is preallocated, and does not yet have a body.
This can happen when an identifier referencing a stub via
an \TT{min::\EOL id\_\EOL map} precedes the definition of the
identified object.  See \itemref{IDENTIFIER-MAPS} and
\itemref{SWAPPING-STUBS}.

\end{list}
\end{indpar}

A full list of stub type codes complete with page references
is given on \pagref{STUB-TYPE-CODE-LIST}.

\subsubsection{Stub Values}
\label{STUB-VALUES}

A stub contains a 64-bit \key{stub value}.  If the stub is collectible
(as determined by its type), the type of this value
is determined by the stub type code (\itemref{STUB-TYPE-CODES}).
Otherwise the stub is typically attached to an object and the type of the stub
value is determined by how it is attached; in this case the type of the
stub value is most often just \TT{min::gen}.

Many stubs are immutable
and their stub values cannot be written after the stub has been created;
nevertheless we describe unprotected functions
below (\itemref{STUB-CONTROL-FUNCTIONS} and
\itemref{STUB-VALUE-READ-WRITE-FUNCTIONS}) that
write these values.  Unprotected functions are also provided to obtain
body pointers from stubs when these are the stub values of the stubs.
This cannot be done by protected
functions as these body pointers are relocatable and require special
programming be sure they are up-to-date (\itemref{UNPROTECTED-BODY-POINTERS}).

\subsubsection{Stub Control}
\label{STUB-CONTROL}

A stub contains a 64-bit \key{stub control}.  The high order 8 bits
of this is the stub type code, and the high order bit of this type
code determines whether the stub is collectible (bit is off)
or uncollectable (bit is on).

If the stub is collectible,
the stub control is used exclusively by the acc,
except for the type code, which is shared between the acc
and the rest of the system.  Such a control word is called
an `\key{acc control}\,'.  A typical (but not required)
organization of an acc control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 12-24 bits:	& acc flags \\
low order 44-32 bits:	& chain pointer \\
\end{tabular}
\end{center}

Here the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING})
that is used to build lists of allocated stubs which
the acc manages.

If a stub is uncollectable, its stub control, which is called
a `\key{non-acc control}\,', can be organized in different
ways according to the type code value.  The standard way of organizing
a non-acc stub control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 8 bits:		& subtype code \\
low order 48 bits:	& chain pointer or unsigned integer value \\
\end{tabular}
\end{center}

Again the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING}),
but now it has enough bits to be packed with the fastest packing scheme.

A non-acc control may also be used outside a stub, say by the acc, and
in this case it may be alternatively organized as:

\begin{center}
\begin{tabular}{ll}
high order 16 bits:	& locator \\
low order 48 bits:	& stub pointer \\
\end{tabular}
\end{center}

The main use of uncollectable stubs is as auxiliary stubs.
An `\key{auxiliary stub}' is an uncollectable stub attached to an object.
When the object is garbage collected, the auxiliary stub is freed.  Auxiliary
stubs are a means of adding memory to an object without relocating the object.
For example, if the object stores 64-bit IEEE floating point numbers,
a chain of auxiliary stubs can be used to add memory to the object
for additional numbers.  Note that the auxiliary stub itself does not
contain information that tells the type of the value it stores;
one has to trace the reference from the object pointing at the
auxiliary stub to determine this type.  Usually auxiliary stub
values are \TT{min::gen} values.
See \itemref{STUB-CONTROL-FUNCTIONS} and
\itemref{STUB-VALUE-READ-WRITE-FUNCTIONS}
for unprotected functions that can read and write auxiliary stubs.

\subsection{Protected Body Pointers}
\label{PROTECTED-BODY-POINTERS}

Bodies are relocatable
(\pagref{RELOCATABLE-BODY}) and pointers into bodies,
called \skey{body pointer}s,
require special handling to
ensure that they are up-to-date.  There are two ways of managing
this: the protected way and the unprotected way.
In this section we will describe the protected way.
The unprotected way is described, primarily for the benefit of those
who want to implement new types of stubs,
in \itemref{UNPROTECTED-BODY-POINTERS}.

Note also that \ikey{deallocation}{deallocate} of a body is treated as
reallocation of the body to inaccessible virtual memory.

\centerline{\large \bf IMPORTANT WARNING}

\begin{quote} \it
If a protected body pointer points at a body, the body's stub must not
be garbage collected, and the fact that it is being pointed at
by a protected body pointer is \underline{not} sufficient to
prevent this.  Therefore \underline{another}
pointer to the body's stub must
be stored elsewhere, such as in a \TT{min::\EOL locatable\_...}
variable (\pagref{LOCATABLE-VARIABLES}) or in another body that
is protected from garbage collection,
to keep the body's stub from being garbage collected.

However,
the body may be relocated without compromising the protected body
pointer.  Additionally, if the body is deallocated (without
garbage collecting its stub, see \pagref{MIN::DEALLOCATE}),
references using the protected body pointer will very likely
cause a segment fault, and not an undefined result.
\end{quote}

\subsubsection{Type Specific Body Pointers}
\label{TYPE-SPECIFIC-BODY-POINTERS}

The protected way of handling body pointers
uses special pointer data that is adapted to
the type of datum being pointed at.  For example, the following
code can access any string:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some string
assert ( min::is_str ( x ) );
min::str_ptr xp ( x );
int length = min::strlen ( xp );
for ( int i = 0; i < length; ++ i )
{
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Here the \TT{str\_ptr} datum is a \key{protected body pointer}.
For strings that are long enough to have a body, the
\TT{str\_ptr} stores a pointer to the stub of the string,
and `\TT{xp[i]}' is an inline function that expands to
code that reads the body pointer from the stub and adds both
an appropriate constant offset and then the index `\TT{i}'
to that pointer in order to get the address of the character.

It might be thought that this is inefficient as the body pointer
is re-read from the stub for every different iteration of the `\TT{for}'
loop.  However, if no out-of-line functions are called in the
loop, an optimizing compiler will typically eliminate
the excess reads and load the body pointer plus constant offset
into a register before the loop begins.  The key here is to
avoid out-of-line function calls, as for each such call the
optimizer must assume that the body pointer in the stub might
change.

Specialized protected pointer types are provided for most types of object
that have bodies.

\subsubsection{Body References and Pointers}
\label{BODY-REFERENCES-AND-POINTERS}

In addition to specialized pointer types for each type of object,
there are a general body reference and pointer types
that reference any type an element in any body associated with any stub.

\subsubsubsection{Body References}
\label{BODY-REFERENCES}

The functions for creating and using \TT{min::\EOL ref<T>}
body reference types are:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T const & location )|
\LABEL{MUP::NEW_REF_OF_LOCATION} \\
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_REF_OF_OFFSET} \\
\verb|min::|\MINKEY{ref<T>}\verb| min::| & \MINKEY{new\_ref}\ARGBREAK
    \verb|( T & location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_REF} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * MUP::| & \MUPKEY{ZERO\_STUB}
\LABEL{MUP::ZERO_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * const r| & \TTDMKEY{s}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_STUB} \\
\verb|min::unsptr const r| & \TTDMKEY{offset}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_OFFSET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T const & value )| \\
\LABEL{MIN::=REF_OF_T} \\
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  min::ref<T> const & r2 )|
\LABEL{MIN::=REF_OF_REF} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|T |
    & \TTOMKEY{T}{T}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_TO_T} \\
\verb|T |
	& \TTOMKEY{->}{->}{of {\tt min::ref<T>}}
	   \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_->} \\
\verb|T & |
	& \TTOMKEY{\textasciitilde}{\textasciitilde}{of {\tt min::ref<T>}}
	  \verb|( min::ref<T> const & r )| ~~~~ [unprotected]
\LABEL{MIN::TILDE_OF_REF} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::==REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}
      \verb|( T v, min::ref<T> const & r )|
\LABEL{MIN::==T_AND_REF} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::!=REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}
      \verb|( T v, min::ref<T> const & r )|
\LABEL{MIN::!=T_AND_REF} \\
\end{tabular}\end{indpar}

In addition, the following are defined
only if \TT{T} is a packed structure or vector pointer,
i.e., \TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<S>} or
\TT{min::\EOL packed\_\EOL vec\_\EOL xxxptr<E,H,L>}:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, const min::stub * s )|
\LABEL{MIN::==REF_AND_STUB} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r, const min::stub * s )|
\LABEL{MIN::!=REF_AND_STUB} \\
\end{tabular}\end{indpar}

A \TT{min::ref<T>} type is similar to the `\TT{T \&}' type.
Internally a \TT{min::ref<T>} value \TT{r}
is a pointer to a location of type \TT{T} that
consists of a \TT{const min::\EOL stub~*} pointer \TT{r.s} to a stub
and an \TT{min::\EOL unsptr} byte offset \TT{r.offset}
of a location in the body
associated with the stub.  Setting a reference type equal to a value
of type \TT{T} stores the value in the location.  Setting a reference
\TT{r} equal to another reference \TT{r2}, as in `\TT{r~=~r2}', does
\underline{not} copy the internal pointers, but instead copies the
value at the \TT{r2} location to the \TT{r} location.

A reference of type \TT{min::ref<T>} can be \underline{explicitly} converted
to an \underline{relocation unprotected}
reference of type `\TT{T\&}' by the unary `\TT{\textasciitilde}' operator.
In this case the value of the unary `\TT{\textasciitilde}'
is a reference \underline{not}
protected from relocation, so its only good use is to pass it to an
expression or function that will not relocate anything.
One must be careful that other arguments in the same statement
do not perform relocation, as then with the wrong optimized
order of argument evaluation `\TT{\textasciitilde}'
can be performed just before a
relocation and its result used just afterwords.

A \TT{min::ref<T>} value is implicitly convertible to the type \TT{T}
by reading the value referenced.
As this implicit conversion
is not activated by C++ in the case of an expression of the form
`\TT{r->\ldots}'\label{REF->},
`\TT{operator~->}' of a \TT{min::\EOL ref<T>}
argument is defined to invoke the conversion explicitly.
Similarly for \TT{operator ==} and \TT{operator !=}.
In addition, these are defined to make the conversion when
\TT{T} is convertible to \TT{const min::\EOL stub~*} and the
second argument is of this latter type, so that expressions such as
\begin{center}
\tt r == min::NULL\_STUB
\end{center}
can be used.

The implicit conversion of a \TT{min::\EOL ref<T>} value \TT{r} to a \TT{T}
value is \underline{not} activated by the C++ `\TT{.}' operator,
so if \TT{T} is a structure type with member \TT{m}, then \TT{r.m}
fails.  One must use \TT{(\textasciitilde r).m}
or \TT{(\&r)->m} instead.  The latter works because
the `\TT{->}' operator has been defined for \TT{min::\EOL ptr<T>}
values (see \pagref{PTR->}).
Unfortunately C++ does not allow a similar definition for the
`\TT{.}' operator.

\TT{min::ref<T>} values are returned by protected functions described
elsewhere:
\begin{center}
\begin{tabular}{ll}
packed structures & see \TT{MIN\_REF}
    \pagref{MIN_REF} and \pagref{PACKED_STRUCT_MIN_REF} \\
packed vector headers & see \TT{MIN\_REF}
    \pagref{MIN_REF} and \pagref{PACKED_VEC_MIN_REF} \\
packed vector elements	& see \TT{operator []}
    \pagref{MIN::PACKED_VEC_PTR_[]},
    \TT{push} function \pagref{MIN::PACKED_VEC_PUSH} \\
locatable variables	& see \TT{operator min::ref<T>}
    \pagref{LOCATABLE_VAR_REF} \\
object vector elements	& see access functions \pagref{OBJ_VEC_UPDPTR_REF},
			  push functions \pagref{OBJ_VEC_INSPTR_PUSH_REF}
\end{tabular}
\end{center}

The unprotected \TT{MUP::new\_ref} function is used by these
protected functions to construct a \TT{min::\EOL ref<T>} value
from a pointer \TT{s} to a stub and either a \TT{const} location
within the body associated with that stub or an \TT{offset}
within the body
(i.e., an address in bytes relative to the beginning of the body).
Note that in either case, and in particular for a location
of a `\TT{T const}' type, the resulting
\TT{min::\EOL ref<T>} reference value will allow the location
to be written.  This is done because locations inside data bodies
that point at stubs are declared as `\TT{const}' locations
so they cannot be written without using
the \TT{MIN\_\EOL REF} macro to construct a
\TT{min::\EOL ref<T>} value: see \pagref{MIN_REF_USAGE}.
Note also that when an offset is given to
\TT{MUP::\EOL new\_\EOL ref<T>}, the type \TT{T}
must be included in the function name,
which is \TT{MUP::\EOL new\_\EOL ref<T>}
and not just \TT{MUP::\EOL new\_\EOL ref}, as \TT{T} cannot
be deduced from the argument types.

The protected \TT{min::new\_ref} function\label{NEW_REF_USAGE}
may be used to construct
a \TT{min::\EOL ref<T>} value from a \underline{non-relocatable} location,
such as a global location or a location in the stack.
This function constructs a \TT{min::\EOL ref<T>} value whose
stub is the special \TT{MUP::\EOL ZERO\_\EOL STUB} stub that
has a body pointer equal to \TT{0} so the offset of the
\TT{min::\EOL ref<T>} value may be the address of the
non-relocatable location.

Actually there are two kinds of \TT{min::\EOL ref<T>} types that
differ according to whether or not the type \TT{T} is
`\mkey{locatable}{\TT{min::ref<T>} reference to}'
\label{LOCATABLE_REF}
(\TT{min::\EOL gen}, \TT{const min::\EOL stub~*}, and
classes such as \TT{min:\EOL packed\_\EOL\ldots ptr<\ldots>}
that encapsulate \TT{const min::\EOL stub~*} values are
locatable types: see \pagref{LOCATABLE-TYPE}).
If \TT{T} is locatable, storing a value in a \TT{min::\EOL ref<T>}
location implicitly calls the
\TT{min::\EOL acc\_\EOL write\_\EOL update} functions of
Section~\itemref{ACC-WRITE-UPDATE-FUNCTIONS} to update the stubs
involved, unless the \TT{min::\EOL ref<T>} value references
\TT{MUP::\EOL ZERO\_\EOL STUB}
or the value stored is \TT{min::\EOL NULL\_\EOL STUB}.
If \TT{T} is not locatable, or if the
\TT{min::\EOL ref<T>} value references \TT{MUP::\EOL ZERO\_\EOL STUB},
or if the value stored is \TT{min::\EOL NULL\_\EOL STUB},
then the \TT{min::\EOL acc\_\EOL write\_\EOL update} functions
are \underline{not} implicitly called.

\subsubsubsection{Body Pointers}
\label{BODY-POINTERS}

Associated with the \TT{min::\EOL ref<T>} reference type is
the companion \TT{min::\EOL ptr<T>} pointer type:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T * location )|
\LABEL{MUP::NEW_PTR_OF_LOCATION} \\
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_PTR_OF_OFFSET} \\
\verb|min::|\MINKEY{ptr<T>}\verb| min::| & \MINKEY{new\_ptr}\ARGBREAK
    \verb|( T * location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{ptr<T>} \verb| p|
\LABEL{MIN::PTR_OF_T} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * const p| & \TTDMKEY{s}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_STUB} \\
\verb|const min::unsptr p| & \TTDMKEY{offset}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_OFFSET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}
      \verb|( min::ptr<T> & p, min::ptr<T> const & p2 )|
\LABEL{MIN::=PTR_OF_PTR}
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}ll}
\verb|bool |
	& \TTOMKEY{bool}{bool}{of {\tt min::ptr<T>}}
	  \verb|( min::ptr<T> const & p )|
\LABEL{MIN::BOOL_OF_PTR} \\
\verb|min::ptr<T> min::|
	& \MINKEY{null\_ptr<T>} \verb|()|
\LABEL{MIN::NULL_OF_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|T * |
	& \TTOMKEY{->}{->}{of {\tt min::ptr<T>}}
	  \verb|( min::ptr<T> const & p )|
\LABEL{MIN::PTR_->} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}{of {\tt min::ref<T>}}
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::=AMPERSAND_OF_REF_OF_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{*}{*}{of {\tt min::ptr<T>}}
      \verb|( min::ptr<T> const & p )|
\LABEL{MIN::=*_OF_PTR_OF_T} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<T> p| & \TTBMKEY{i}{of {\tt min::ptr}}
\LABEL{MIN::PTR_[]} \\
\verb|min::ptr<T> |
    & \verb|p|\TTMOKEY{+}{of {\tt min::ptr}}\verb|i|
\LABEL{MIN::PTR_+} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}ll}
\verb|T * |
	& \TTOMKEY{\textasciitilde}{\textasciitilde}{of {\tt min::ptr<T>}}
	  \verb|( min::ptr<T> const & p )| & [unprotected]
\LABEL{MIN::TILDE_OF_PTR} \\
\verb|min::ptr<T> |
	& \MINKEY{ptr<T>}
	   \verb|( min::ptr<S> const & p )| & [unprotected]
\LABEL{MIN::PTR_OF_PTR} \\
\end{tabular}\end{indpar}

Internally a \TT{min::\EOL ptr<T>} value is exactly like a
\TT{min::\EOL ref<T>} value; both point at a location defined by
a stub and an offset within the body of the stub.
A main difference is that \TT{=} for reference values copies the
values of the locations pointed at, while \TT{=} for pointer values
copies the pointers themselves; i.e., the pointer to the stub and the offset.
Similarly \TT{==} for reference values compares the values of
the locations pointed at, whereas \TT{==} for pointer values
compares the pointers themselves.

Another difference is that if a \TT{min::\EOL ref<T>} value \TT{r}
designates a location containing a \TT{T} value \TT{v}, then
\TT{r->\ldots}\label{PTR->} is equivalent to \TT{v->\ldots}.
But if a \TT{min::\EOL ptr<T>} value \TT{p}
points at location \TT{loc} containing a \TT{T} value \TT{v}, then
\TT{p->\ldots} is equivalent to \TT{(\&loc)->\ldots}.
This is because
the \TT{->} operator has been defined for \TT{min::\EOL ptr<T>}
types to return \TT{\&loc}, the location designated by the pointer,
but for \TT{min::\EOL ref<T>} types
it returns \TT{v} (see \pagref{REF->}), the location designated by
the value in the location designated by the reference.

Creation of \TT{min::\EOL ptr<T>} values by \TT{\ldots::new\_\EOL ptr}
functions is just like
creation of \TT{min::\EOL ref<T>} values by \TT{\ldots::new\_\EOL ref}
functions (see \pagref{NEW_REF_USAGE}) with one exception.
Unlike \TT{MUP::\EOL new\_\EOL ref}, for which a \TT{const~T~\&}
location creates a \TT{min::\EOL ref<T>} reference in which \TT{T}
is \underline{not} \TT{const},
for \TT{MUP::\EOL new\_\EOL ptr}
a \TT{T~*} location creates a \TT{min::\EOL ptr<T>} pointer in which
the pointer \TT{T} is \TT{const} if and only if the location \TT{T}
is \TT{const}.

The `\TT{min::\EOL ptr<T>} p' constructor with no arguments creates \TT{p}
with \TT{p.s = NULL\_STUB} and \TT{ps.offset = 0}, which is the
\mkey{null value}{of {\tt ptr<T>}} of \TT{min::\EOL ptr<T>}.
The same value is returned by `\TT{min::\EOL null\_\EOL ptr<T>()}'.
Converting a \TT{min::\EOL ptr<T>} value to a \TT{bool} returns \TT{true}
if and only if the pointer is \underline{not} the null value.

A \TT{min::\EOL ptr<T>} value can be created by applying the
\TT{\&} operator to a \TT{min::\EOL ref<T>} value or to a
locatable variable (see \TT{operator \&} for locatable variables,
\pagref{LOCATABLE_VAR_PTR}).
A \TT{min::\EOL ref<T>} value can be recovered from a
pointer value by applying the
\TT{*} operator to the \TT{min::\EOL ptr<T>} value.

Given a \TT{min::\EOL ptr<T>} value \TT{p} and an index \TT{i} of some
suitable index type \TT{I} (such as \TT{int} or \TT{min::\EOL uns32}),
\TT{p[i]} is a \TT{min::\EOL ref<T>}
reference value for the \TT{i+1}'st element of
the vector with elements of type \TT{T} pointed at by \TT{p}, and
\TT{p+i} is a \TT{min::\EOL ptr<T>} pointer to that element.

Because \TT{p[i]} has type \TT{min::\EOL ref<T>} when \TT{p} has
type \TT{min::\EOL ptr<T>}, the expression \TT{p[i].m} fails when
\TT{T} is a structure type with member \TT{m} (see \pagref{REF->}).
In this case it is
necessary to use the alternative but usually equivalent expression
\TT{(\&p[i])->m}, which is undeniably awkward.

This is an unfortunate trade off between making the
the value of \TT{p[i]} protected from relocation
but harder to use when \TT{T} is a structure type of a vector element,
and the alternative of making the value of \TT{p[i]}
the type `\TT{T \&}', which would allow \TT{p[i].m}
to work properly, but which contains an unprotected relocatable pointer.
Unfortunately C++ does not permit definitions of `\TT{operator .}' in
the manner that it permits definitions of `\TT{operator ->}', or else
this awkwardness would not arise.

A pointer of type \TT{min::ptr<T>} can be \underline{explicitly} converted
to an \underline{relocation unprotected}
pointer of type `\TT{T*}' by the unary `\TT{\textasciitilde}' operator.
This can be of use in code such as
\begin{indpar}\begin{verbatim}
ptr<char> s = ...;
int length = strlen ( ~ s );
char buffer[length+1];
strcpy ( buffer, ~ s );
\end{verbatim}\end{indpar}

In this case the value of the unary `\TT{\textasciitilde}'
is a pointer \underline{not}
protected from relocation, so its only good use is to pass it to a
function such as \TT{strlen} or \TT{strcpy} which will not relocate
anything.  One must be careful that other arguments in the same statement
do not perform relocation, as then with the wrong optimized
order of argument evaluation `\TT{\textasciitilde}'
can be performed just before a
relocation and its result used just afterwords.

If \TT{p} is of type \TT{min::ptr<S>}, then \TT{min::ptr<T>(p)} is just
\TT{p} coerced to the type \TT{min::\EOL ptr<T>} without any change to the
actual value of \TT{p}, just as \TT{(T *)(q)} is a coercion of \TT{q}
if \TT{q} has type `\TT{S *}'.  Such coercions are inherently
unprotected, of course.

The following operators defined on \TT{min::ptr<T>} values
allow these values to be used to step through a vector:

\begin{indpar}\begin{tabular}{r@{}l@{~~~~}l}
\verb|bool |
    & \TTOMKEY{<}{<}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1,|\ARGBREAK
      \verb|  min::ptr<T> const & p2 )|
\LABEL{MIN::<_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{++}{++}{of {\tt min::ptr<T>}}
    & [postfix \TT{++}]\ARGBREAK
      \verb|( min::ptr<T> & p, int )|
\LABEL{MIN::POSTFIX_++_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{--}{-{}-}{of {\tt min::ptr<T>}}
    & [prefix \TT{-{}-}]\ARGBREAK
      \verb|( min::ptr<T> & p )|
\LABEL{MIN::PREFIX_--_OF_PTR_OF_T} \\
\end{tabular}\end{indpar}

These are just what is required to take the \TT{min::\EOL ptr<T>}
values of
\TT{min::\EOL begin\_\EOL ptr\_\EOL of} and
\TT{min::\EOL end\_\EOL ptr\_\EOL of} applied to various objects
and step through the vector bracketed by the
resulting pointers.  See, for example, 
\TT{min::\EOL begin\_\EOL ptr\_\EOL of} on
\pagref{MIN::BEGIN_PTR_OF_STR_PTR}
and \TT{min::\EOL begin/end\_\EOL ptr\_\EOL of} on
\pagref{MIN::BEGIN_PTR_OF_LAB_PTR}.
To protect as much as possible from misuse, \TT{<} is defined to be
false if the two pointers point at different relocatable bodies.
So one should use the pointers to access data only if the smaller
pointer is still \TT{<} than the larger pointer.

The following functions can be used to test if
\TT{min::\EOL ptr<T>} values are equal:

\begin{indpar}\begin{tabular}{r@{}l@{~~~~}l}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::==_OF_PTR_OF_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::!=_OF_PTR_OF_T} \\
\end{tabular}\end{indpar}

\subsubsubsection{Pointer General Values}
\label{POINTER-GENERAL-VALUES}

A \TT{min::ptr<T>} value can be stored in a \key{pointer general value}
and later retrieved from that general value.  The retrieval is
unprotected because \TT{T} cannot be stored in the general value.

A pointer general value is a pointer to a stub of
\ttkey{min::PTR}\label{MIN::PTR} type
that holds a pointer to an auxilary stub of
\minkey{PTR\_\EOL AUX}\label{MIN::PTR_AUX} type
that contains the stub pointer and offset of a \TT{min::\EOL ptr<T>} value.
The offset is stored as a \TT{min::\EOL unsgen} in the value of the
auxilary stub, and the stub pointer is stored in the control of
the auxilary stub.  An auxilary stub is necessary because the stub
of \TT{min::\EOL PTR} type is garbage collectable, and the control of
this stub is used by the garbage collector.

The functions for creating a pointer general value and retrieving
the \TT{min::\EOL ptr<T>} value it contains are:

\begin{indpar}\begin{tabular}{r@{}l@{~~~~}l}
\verb|min::gen min::|
	& \MINKEY{new\_ptr\_gen}
           \verb|( min::ptr<T> & p )|
\LABEL{MIN::NEW_PTR_GEN} \\
\verb|min::ptr<T> MUP::|
	& \MUPKEY{new\_ptr<T>}
           \verb|( min::gen p )|
\LABEL{MIN::NEW_PTR_OF_GEN} \\
\end{tabular}\end{indpar}

If the \TT{min::gen} argument to \TT{MUP::\EOL new\_\EOL ptr<T>} is not
a pointer general value, \TT{min::\EOL null\_\EOL ptr<T>()} is returned.

\subsubsection{Stack Temporaries of Relocatable Vectors}
\label{STACK-TEMPORARIES-OF-RELOCATABLE-VECTORS}

Sometimes it is useful to make a non-relocatable copy of
a vector that is resident in a body that might be relocated.
This can be done by the \TT{MIN\_\EOL STACK\_\EOL COPY} macro
which expands as follows:

\begin{indpar}
\TTKEY{MIN\_STACK\_COPY} \verb|( T, name, length, source )|
\LABEL{MIN_STACK_COPY}
\\[1ex]
expands to \\[1ex]
\verb|T name [length];| \\
\verb|memcpy ( name, ~ (source),| \\
\verb|         sizeof ( T ) * (length) )|
\end{indpar}

The vector at `\TT{source}', which may be inside a body and therefore
be relocatable, is copied to the stack vector `\TT{name}', which
is not relocatable.
Thereafter `\TT{name}' may be used to reference this copy.
Here `\TT{source}' should have type \TT{min::ptr<T>}.

Because copying is fast, it can be more efficient to do this than
it is to reference individual elements of a relocatable vector using
\TT{min::ptr<T>} values.

\subsection{Allocator/Collector/Compactor Interface}
\label{ACC-INTERFACE}

The garbage collector needs to be able to locate all
\TT{min::gen} and \TT{const min::\EOL stub~*} values
that are in use and that might contain stub pointers.
Values of these types are called \skey{locatable value}s.%
\label{LOCATABLE-VALUE}
These types, and types that are just classes which
encapsulate a \TT{min::\EOL gen} or \TT{const min::\EOL stub~*}
value (such as the \TT{min::packed\_\ldots ptr<\ldots>} types,
\itemref{PACKED-STRUCTURES} and
\itemref{PACKED-VECTORS})
are called \skey{locatable type}s.%
\label{LOCATABLE-TYPE}

Values of a locatable type \TT{T} stored in static memory or the stack
need to be locatable by the garbage collector.  This is done
by storing them in \TT{min::\EOL locatable\_\EOL var<T>} type
variables, as described in the first subsection of this section.

When you write a value of locatable type \TT{T} into a stub or associated
body, you need to call the \TT{MUP::\EOL acc\_\EOL write\_\EOL update}
function (\itemref{ACC-WRITE-UPDATE-FUNCTIONS}) to update garbage
collection flags associated with stubs.
This is done automatically if a \TT{min::\EOL ref<T>} reference value is
used to reference the location being written.  Such reference values are created
by functions described in the second subsection of this section.

If you are implementing a new type of stub and maybe bodies
associated with that stub type, or a new class of pointers to stubs,
then you need to use the unprotected
interfaces described in the third and fourth subsections of this section.

\subsubsection{Locatable Variables}
\label{LOCATABLE-VARIABLES}

Values that might contain stub pointers must be locatable
by the garbage collector (the collector part of the acc).  Since
in a compact implementation even double precision numbers are
represented by \TT{min::gen} values pointing at stubs, this means
the just about all general values must be locatable.  However,
in order to benefit loose implementations, a distinction is made
between \TT{min::gen} values known to be numeric and those
that might not be, so loose implementations can encounter less overhead
when dealing with numeric \TT{min::gen} values.

In addition to \TT{min::gen} values that might point at stubs,
\TT{min::packed\_\ldots{}xxxptr<\ldots>} values, which point at stubs
(see \itemref{PACKED-STRUCTURES} and \itemref{PACKED-VECTORS}),
and \TT{const min::stub~*} values must be locatable.

Consequently
locatable values of type \TT{T} in static or stack memory must be stored
in locations of type \TT{min::}\MINKEY{locatable\_\EOL var<T>}:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|class min::| & \MINKEY{locatable\_var<T>} \TT{: public T} \\
    & use \TT{min::stub\_ptr} for \TT{T} instead of \TT{const min::stub *}
\LABEL{MIN::LOCATABLE_VAR_BASECLASS} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|typedef min::locatable<min::gen> min::| & \MINKEY{locatable\_gen}
\LABEL{MIN::LOCATABLE_GEN} \\
\verb|typedef min::locatable<min::stub_ptr> min::|
    & \MINKEY{locatable\_stub\_ptr}
\LABEL{MIN::LOCATABLE_STUB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{In compact implementation:} \\
~~~~\verb|typedef min::locatable_gen  min::| & \MINKEY{locatable\_num\_gen} \\
\multicolumn{2}{l}{In loose implementation:} \\
~~~~\verb|typedef min::gen  min::| & \MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb| var ( void )|
\LABEL{MIN::LOCATABLE_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( min::locatable_var<T> const & var )|
\LABEL{MIN::LOCATABLE_VAR_OF_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( T const & value )|
\LABEL{MIN::LOCATABLE_VAR_OF_VALUE} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  min::locatable_var<T> const & var2 )|
\LABEL{MIN::=LOCATABLE_VAR_OF_LOCATABLE_VAR} \\
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  T const & value )|
\LABEL{MIN::=LOCATABLE_VAR_OF_VALUE} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::ref<T const> |
    & \TTOMKEY{min::ref<T const>}{min::ref<T const>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::CONST_LOCATABLE_VAR_TO_REF_CONST_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{min::ref<T>}{min::ref<T>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::LOCATABLE_VAR_TO_REF_T} \\
\verb|min::ptr<T const> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::AMPERSAND_CONST_LOCATABLE_VAR} \\
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::AMPERSAND_LOCATABLE_VAR} \\
\end{tabular}\end{indpar}

The name \TT{min::\EOL locatable\_\EOL gen} should be used instead
of the equivalent \TT{min::\EOL locatable\_\EOL var<min::gen>}.
If the implementation is loose (\pagref{LOOSE}),
\TT{min::locatable\_\EOL num\_\EOL gen} is equivalent to
\TT{min::gen}.  If the implementation is compact, it is equivalent to
\TT{min::locatable\_\EOL gen}.

Normally \TT{min::\EOL locatable\_\EOL var<T>} is only used with 
\TT{T = min::\EOL packed\_\ldots{}ptr<\ldots>}
(see \itemref{PACKED-STRUCTURES} and \itemref{PACKED-VECTORS}).
It cannot be used
with \TT{T = const min::stub *} as this is not a class type and
cannot be a base type for the locatable vector type.  Instead
use \TT{T = min::\EOL stub\_\EOL ptr}, which is a class whose
only member is a \TT{const min::stub~*} value that can be read
and written using standard operations:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{stub\_ptr}\ARGBREAK
    \verb| var ( void )|
\LABEL{MIN::STUB_PTR} \\
\verb|(constructor) min::| & \MINKEY{stub\_ptr}\ARGBREAK
    \verb|var ( const min::stub * s )|
\LABEL{MIN::STUB_PTR_OF_S} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::locatable_var<T> & |
    & \TTOMKEY{const min::stub *}{const min::stub *}%
              {of {\tt min::stub\_ptr}}\ARGBREAK
      \verb|( min::stub_ptr const & var )|
\LABEL{MIN::STUB_PTR_OF_STUB_PTR} \\
\verb|min::stub_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::stub\_ptr}}\ARGBREAK
      \verb|( min::stub_ptr & var,|\ARGBREAK
      \verb|  const min::stub * s )| \\
\LABEL{MIN::=STUBPTR} \\
\end{tabular}\end{indpar}

The main operations that can be performed on a
\TT{min::\EOL locatable\_\EOL var<T>} location are to copy a
value of type \TT{T} into it or out of it.
Setting one \TT{min::\EOL locatable\_\EOL var<T>}
location equal to another copies the value of the locations,
and not the location structure itself.
Setting a \TT{min::\EOL locatable\_\EOL var<T>} location to a value \TT{v}
of type \TT{T} value writes the value to the location.
A \TT{min::\EOL locatable\_\EOL var<T>} locatable variable
has its \TT{T} value as its base class, most other operations on
the \TT{T} value can be performed on the \TT{min::\EOL locatable\_\EOL var<T>}
variable.

A \TT{min::\EOL locatable\_\EOL var<T>} locatable variable
\label{LOCATABLE_VAR_REF}
is also implicitly convertible to a reference
of type \TT{min::\EOL ref<T>}
that references the value stored in the locatable variable.
Note that if the locatable variable is \TT{const}, the reference type
will be \TT{min::\EOL ref<const T>}, which does not allow
the variable to be written.

Applying the \TT{\&} operator to a
\label{LOCATABLE_VAR_PTR}
\TT{min::\EOL locatable\_\EOL var<T>} locatable variable
returns a pointer of type \TT{min::\EOL ptr<T>} that points
at the variable value.
Note that if the locatable variable is \TT{const}, the pointer type
will be \TT{min::\EOL ptr<const T>}, which does not allow
the value to be written.

An example using \TT{min::locatable\_gen} is:

\begin{indpar}\begin{verbatim}
static min::locatable_gen v;
. . . . . . . . . .
void f ( ref<min::gen> const & r );
. . . . . . . . . .
min::gen some_function ( min::gen x, min::gen y )
{
    min::locatable_gen q = x;
    min::ptr<min::gen> p = & q;
    min::ref<min::gen> r = q;
    . . .
    v = q;     // Copies the min::gen value of q to v.
    * p = y;   // Sets q to y.
    r = x;     // Sets q to x.
    . . .
    f ( v );   // Converts v to min::ref<min::gen>
    f ( q );   // Converts q to min::ref<min::gen>
    . . .
    return q;  // Returns the value of q.
}
\end{verbatim}\end{indpar}

An example using \TT{min::\EOL locatable\_\EOL var<T>} with
\TT{T = min::\EOL packed\_\EOL vec\_\EOL insptr<char>}
(see \itemref{PACKED-VECTORS}) is:

\begin{indpar}\begin{verbatim}

typedef min::packed_vec_insptr<char> bufvec;
min::locatable_var<bufvec> x;
void f ( min::ref<bufvec> p );
... some_function ( ... )
{
    min::locatable_var<bufvec> y = x;
    f ( y );  // Converts y to a min::ref<bufvec> reference.
}
\end{verbatim}\end{indpar}

Importantly a \TT{min::gen} or \TT{const min::stub *}
value need \underline{not} be stored
in a locatable variable if it can be located by the garbage collector by some
other means.  For example, if it is stored in one locatable variable,
it need not be stored in another.  Or if a \TT{min::gen}
or \TT{const min::\EOL stub~*} value
$V$ is stored in an object pointed at by another \TT{min::gen}
or \TT{const min::\EOL stub~*}
value $P$, and $P$ is locatable, then $V$ need not
be stored in a locatable variable.

A very important rule is that when a function is called, the caller
must be sure every \TT{min::gen}
or \TT{const min::\EOL stub~*} value passed to the called
function can be located by the garbage collector \underline{without} the called
function needing to store the value in a locatable variable.
For example, the caller can store the value in its own locatable
variable.  This is called the `\key{caller locating convention}'.

Also \TT{min::gen} and \TT{const min::\EOL stub~*}
values need only be locatable by
the garbage collector when a relocating function (\pagref{RELOCATING-FUNCTIONS})
is called.  In between such calls \TT{min::gen}
and \TT{const min::\EOL stub *} values can be
stored in other places.  In particular, there is no problem
returning these values from a called function to its caller.

\subsubsection{Locatable Member References}
\label{LOCATABLE-MEMBER-REFERENCES}

Suppose we have some kind of stub/body data type whose body
is the structure \TT{S} defined and used in the following:

\begin{indpar}\begin{verbatim}
struct S;
struct S_ptr
    // Pointer to a stub whose body is a datum of type S.
{
    const min::stub * s;

    S_ptr ( const min::stub * s ) : s ( s ) {}

    S * operator -> ( void )
    {
        return (S *) MUP::ptr_of ( s );
            // Return pointer to body.
    }

    operator const min::stub * ( void ) const
    {
        return s;
            // Return pointer to stub.
    }
};

struct S
{
    // Examples of different member types:
    //
    int x;
    min::gen g;
    S_ptr p;
};

void foo ( S_ptr q )
{
    // Examples of usage of members:
    //
    int x2 = q->x.
    q->x = ...;
    min::gen g2 = q->g;
    q->g = ...;
    MUP::acc_write_update ( q, q->g );
    S_ptr p2 = q->p;
    q->p = ...;
    MUP::acc_write_update ( q, q->p );
}
\end{verbatim}\end{indpar}

Because \TT{min::gen} and \TT{S\_ptr} are locatable types,
\TT{MUP::\EOL acc\_\EOL write\_\EOL update}
(\itemref{ACC-WRITE-UPDATE-FUNCTIONS}) must be called when
members of these types are written into a stub or associated body.  There is
a danger of unintentional omission of these calls.

An alternative is to replace some of the above code by the following:

\begin{indpar}\begin{verbatim}
struct S
{
    int x;
    const min::gen g;    // Added `const'.
    const S_ptr p;       // Added `const'.
};

inline min::ref<min::gen> g_ref ( S_ptr q )
{
    return MUP::new_ref ( q, q->g );
}

inline min::ref<S_ptr> p_ref ( S_ptr q )
{
    return MUP::new_ref ( q, q->p );
}

void foo ( S_ptr q )
{
    int x2 = q->x.
    x = ...;
    min::gen g2 = q->g;
    g_ref(q)= ...;       // q->g replaced by g_ref(q).
    S_ptr p2 = q->p;
    p_ref(q) = ...;      // q->p replaced by p_ref(q).
}
\end{verbatim}\end{indpar}

Here the calls to \TT{MUP::acc\_write\_update} are inside the
\TT{\ldots\_ref(q) =} calls (\pagref{LOCATABLE_REF}).
Writing \TT{q->g = \ldots}
and \TT{q->p = \ldots} is prevented by making the \TT{g} and \TT{p}
members `\TT{const}', so accidentally updating locatable members
without calling \TT{MUP::\EOL acc\_\EOL write\_\EOL update}
is prevented.

To make the above easier to code, the \TT{MIN\_REF}\label{MIN_REF_USAGE} macro
is provided which expands as follows:

\begin{indpar}
\TTKEY{MIN\_REF} \verb|( type, name, ctype )|
\LABEL{MIN_REF}
\end{indpar}

expands to

\begin{indpar}
\verb|inline min::ref<type> name_ref ( ctype container )| \\
\verb|{| \\
\verb|    return MUP::new_ref ( container, container->name );| \\
\verb|}|
\end{indpar}

Here `\TT{type}' is the member type and `\TT{ctype}' is
the `\key{container type}'.

This enables the \TT{inline} function definitions above to be
replaced by

\begin{indpar}\begin{verbatim}
MIN_REF ( min::gen, g, S_ptr )
MIN_REF ( S_ptr, p, S_ptr )
\end{verbatim}\end{indpar}

The \TT{MIN\_\EOL REF} macro is frequently
used with packed structures (see \itemref{PACKED-STRUCTURES}) and
packed vectors (see \itemref{PACKED-VECTORS}).

\subsubsection{Deallocation}
\label{DEALLOCATION}

The operation of \ikey{deallocating a body}{deallocate!body}\index{deallocation}
is considered to be a relocation of the body.  The body pointer in the
stub is pointed at a `deallocated body' located in
inaccessible virtual memory, and the type code in the stub
is set to \TT{min::DEALLOCATED} (\pagref{MIN::DEALLOCATED}).

The function that deallocates a body is:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{deallocate\REL} \verb|( const min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\end{tabular}\end{indpar}%
\index{deallocate!relocating}

If the stub has a body, this function relocates the body to inaccessible
memory and changes the type code of the stub to
\TT{min::DEALLOCATED}.  Otherwise the function does nothing; and
in particular, it does nothing to stubs with no body, and to stubs
that have already been deallocated.

The function that tests whether a stub
has \TT{min::DEALLOCATED} type code (\pagref{MIN::DEALLOCATED}) is:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_deallocated} \verb|( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED}
\end{tabular}\end{indpar}

The inaccessible memory to which a \TT{min::DEALLOCATED} stub is
pointed is called the `\key{deallocated body}' of the stub.
This is large enough that any attempt to access the body of a
deallocated stub will cause a memory fault.

\subsubsection{Swapping Stubs}
\label{SWAPPING-STUBS}

The type and values of two stubs can be swapped by:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::| & \MUPKEY{stub\_swap}\ARGBREAK
    \verb|( const min::stub * s1, const min::stub * s2 )|
\LABEL{MUP::STUB_SWAP}
\end{tabular}\end{indpar}

Neither stub may be the stub of a name (number, string, or label).
Neither stub may be the target of an existing
\TT{min::obj\_vec\_\ldots{}ptr}.

Stubs are most often swapped when one of the stubs has the
\TT{PREALLOCATED} (\pagref{MIN::PREALLOCATED}) type.
Functions for this type are:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_preallocated\_gen}
    \verb|( min::uns64 id )|
\LABEL{MIN::NEW_PREALLOCATED_GEN} \\
\verb|bool min::| & \MINKEY{is\_preallocated}
    \verb|( min::gen g )|
\LABEL{MIN::IS_PREALLOCATED} \\
\verb|min::uns64 min::| & \MINKEY{id\_of\_preallocated}
    \verb|( min::gen g )|
\LABEL{MIN::ID_OF_PREALLOCATED} \\
\end{tabular}\end{indpar}

The \TT{min::new\_preallocate\_gen} function returns a
\TT{min::gen} value pointing at a new stub
of \TT{min::PREALLOCATED} type that stores the given \TT{id}.
When a preallocated stub is created from an identifier input
from a file, the ID of the identifier can be recorded in the
preallocated stub.  Then the preallocated stub can be used
to represent the identifier.  Also if the identifier is later
assigned a non-object value, but a data reference to the
preallocated stub was made before this assignment, the reference will become
dangling, and the ID recorded in the stub can be used
in debugging to find the source of the dangling reference.

The other functions test a \TT{min::gen} value to see if
it points at a preallocate stub, and return its identifier
if it does.  If \TT{g} does not point at a preallocated
stub, \TT{0} is returned as its identifier.

\subsection{Implementing New Stub Types}
\label{IMPLEMENTING-NEW-STUB-TYPES}

If you are implementing a new type of stub, and maybe bodies
associated with that stub type, or a new class of pointers to stubs,
then you will probably need to use the unprotected
interfaces described in this section.

As described in the first subsection, you need to be able update stubs
using the \TT{MUP::\EOL acc\_\EOL write\_\EOL update} functions
when locatable values are written into stubs or associated bodies.
You need to be able to allocate and free stubs, as described in the
second subsection.  You need to be able to read and write stub values,
as described in the third subsection.  If you are using acc stubs you
need to be able to write the type field in stub controls, and if
you are using auxiliary stubs, you need to be able to read, write,
and manipulate entire stub controls.
This is described in the fourth subsection.

\subsubsection{ACC Write Update Functions}
\label{ACC-WRITE-UPDATE-FUNCTIONS}

In addition to needing to locate \TT{min::gen}
and \TT{min::\EOL stub~*} values, the acc
must be notified whenever a pointer to a collectible stub \TT{s2}
is stored in the data of a collectible stub \TT{s1} (i.e., in
the stub \TT{s1} or its body or auxiliary stubs attached to either).
This is done by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * s2 )|
\LABEL{MUP::ACC_WRITE_STUB_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_GEN_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_UPDATE} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * const * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_STUB_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_GEN_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_VEC_UPDATE} \\
\end{tabular}\end{indpar}

The first of the above functions updates the stubs \TT{s1} and \TT{s2}
if \TT{s2} is not \TT{NULL}.  The second updates the stub \TT{s1}
and the stub pointed at by \TT{g} if \TT{g} points at a stub.
The third of the above functions equals the second function for a compact
(\pagref{COMPACT}) implementation, and is a no-operation for a loose
implementation.

The last three of the above functions look at all the
values \TT{p[0]}, \ldots, \TT{p[n-1]}, and for each of these
call the corresponding function chosen from the first three
of the above functions.

The \TT{min::\EOL acc\_\EOL write\_\EOL num\_\EOL update}
functions should only be used if all the
\TT{min::gen} values they reference are numeric, as in a loose
implementation these functions do nothing.

These \TT{min::acc\_write\_update} functions
\underline{must not} be called with any argument that points at a stub
with \TT{min::ACC\_\EOL FREE} type, which can only happen when the
stub has been recently returned by
\TT{min::\EOL new\_\EOL acc\_\EOL stub}.
See \itemref{STUB-ALLOCATION-FUNCTIONS}.


\subsubsection{Stub Allocation Functions}
\label{STUB-ALLOCATION-FUNCTIONS}

The following functions are used to allocate stubs:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub} \verb|( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub} \verb|( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\end{tabular}\end{indpar}

The \TT{min::new\_acc\_stub} function returns a garbage collectible (acc)
stub with its type set to \minkey{ACC\_FREE}.  A stub with this type
\underline{must not} be visible to the garbage collector; no pointer
to it can be stored in an acc locatable variable.
The \TT{MUP::acc\_\EOL write\_\EOL update}
function \underline{must not} be called with any
\TT{min::gen} or \TT{min::\EOL stub~*} argument that points at
a stub with \TT{min::ACC\_\EOL FREE} type.  All
\TT{min::gen} or \TT{min::\EOL stub~*} values stored in
the data of a \TT{min::ACC\_\EOL FREE} stub must also be stored
in acc locatable variable, or must themselves point at 
\TT{min::ACC\_\EOL FREE} stubs.

The actions of changing the type of a stub
from \TT{min::ACC\_\EOL FREE}
to another collectible type and storing a
\TT{min::gen} or \TT{min::\EOL stub~*}
value pointing at the stub in an acc
locatable variable must not be separated by any
call to a relocating function.

It is permissible to allocate and build a graph of stubs some of
which have \TT{min::\EOL ACC\_\EOL FREE} type.  No stub locatable
by the garbage collector may contain (in its stub or body or
auxiliary stubs) a pointer to a stub with
\TT{min::\EOL ACC\_\EOL FREE} type.  Any stub with
\TT{min::\EOL ACC\_\EOL FREE} type can contain only pointers
to stubs of this type or stubs that are locatable by the garbage
collector.  After building the graph, the types of all stubs with
\TT{min::\EOL ACC\_\EOL FREE} type should be changed to
normal acc types, and pointers that permit the garbage collector
to locate these stubs should be stored in locatable variables,
all without making any calls to relocating functions.

The \TT{min::new\_aux\_stub} function returns a non-acc (i.e.,
not garbage collectible)
stub with its type set to \minkey{AUX\_FREE}.  This kind of stub is
is \underline{not} freed by the garbage collector.  It may be
freed only by calling:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::| & \MUPKEY{free\_aux\_stub} \verb|( min::stub * s )|
\LABEL{MUP::FREE_AUX_STUB} \\
\end{tabular}\end{indpar}

A non-acc stub is most often attached to an acc stub in such a way
that when the acc stub is garbage collected, the non-acc stub is
freed.  Such a non-acc stub is called an \key{auxiliary stub}, and
because most non-acc stubs are of this kind, functions dealing with
non-acc stubs have names containing `\ttkey{aux}' instead of
`\TT{non\_acc}'.

\subsubsection{Stub Value Read/Write Functions}
\label{STUB-VALUE-READ-WRITE-FUNCTIONS}

The following unprotected functions read or write the stub value part of a stub:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of} \verb|( const min::stub * s )|
\LABEL{MUP::VALUE_OF_STUB} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of} \verb|( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{ptr\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PTR_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_value\_of} \verb|( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of} \verb|( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of} \verb|( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_ptr\_of} \verb|( min::stub * s, void * p )|
\LABEL{MUP::SET_PTR_OF} \\
\end{tabular}\end{indpar}

Thus the stub value can be taken to be of type \TT{min::uns64},
\TT{min::float64}, \TT{min::gen}, or
of some pointer type.

These functions do \underline{not} check type codes,
call \TT{MUP::acc\_write\_update},
or check
that values read or written are within legal range for a particular
stub.  For example, a stub value that is not a floating point number can be
read by \TT{MUP::float\_of} with undefined results.

\subsubsection{Stub Control Functions}
\label{STUB-CONTROL-FUNCTIONS}

If you are using auxiliary stubs, you need to be able to read, write,
and manipulate the stub control part of the stub.  If you are using
acc stubs, you only need to read or write the type part of the control.

The following
read or write the stub control:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of} \verb|( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|int min::| & \MINKEY{type\_of} \verb|( const min::stub * s )| \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}\ARGBREAK
      \verb|( const min::stub * s,|\ARGBREAK
      \verb|  min::uns64 flags )|
\LABEL{MUP::TEST_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_control\_of} \verb|( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of} \verb|( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of} \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of} \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{tabular}\end{indpar}

The \TT{MUP::control\_of} and \TT{MUP::set\_control\_of} functions
deal with the entire 64 bit stub control value of a stub.  The other
functions deal only with parts.

For acc stubs, only the type part of the control should be read or
written.  The other parts of the control are for use by the
acc, and should not be accessed by non-acc code,
in order to ensure that the acc is independent of other code.

The stub control in a stub is an example of a MIN \key{control value}.
A MIN control value holds a stub address or an unsigned integer
in its low order bits.  It may hold an 8 bit type code in its highest order
bits.  Any bits left over are flag bits, or if there is no 8 bit type
code, the high order 16 bits may be a signed integer field called the
`\mkey{locator}{field of control value}'
which is used only by some acc code.  Control values have type
\TT{min::uns64}.  Control values are used as stub controls, and
may be use in other places, e.g., by the acc to hold pointers from
a block that holds a body back to the stub pointing at the body.

Thus control values contain an address/value low order field, and optional
type code high order field, and flag bits.  There are two kinds of
control values: (ordinary) control values and acc control values:

\begin{indpar}
Ordinary control value with type: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-56 & int8 type \\
55-48 & 8 flag bits \\
47-0 & unsigned integer value or absolute stub address
\end{tabular}

Ordinary control value with locator: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-48 & int16 locator \\
47-0 & unsigned integer value or absolute stub address
\end{tabular}

Acc control value: \\[1ex]
\hspace*{0.2in}\begin{tabular}{ll}
Bits & Contents \\[1ex]
63-56 & int8 type \\
55-(56-$G$) & $G$ flag bits \\
(55-$G$)-0 & absolute or packed stub address
\end{tabular}

where $8\leq G\leq 24$.
\end{indpar}

The larger G, the more acc flags, which may permit the
garbage collector to be more efficient (e.g., to have more ephemeral
levels).

The packed stub address is an absolute stub address,
relative stub address, or stub index.  The possible packing schemes used for
these are the same as the packing schemes used for general values:
see \pagref{STUB-ADDRESS-PACKING}.  However, the actual packing scheme
used for acc control values may differ from the actual packing scheme
used for general values, because the number of bits available for the
packed stub address may differ in the two cases.

Addresses stored in a control value must be stub addresses, as only they
can be packed into less than 64 bits.

The control values used as stub controls do have a type code field which
can be read by \TT{min::type\_of} (which is protected) and
written by \TT{MUP::set\_type\_of}.  For stub controls,
acc control values are used with
collectible types, and ordinary control values with
uncollectable types.

The flag bits are set, cleared, and tested individually.  They are
defined by constants of type \TT{min::uns64}, such as

\begin{indpar}
\begin{list}{}{}
\item[\TT{const min::uns64 MUP::}\MUPKEY{STUB\_ADDRESS}]~%
	\LABEL{MIN::STUB_ADDRESS}\\
Indicates that the address/value field of an ordinary (non-acc)
control holds a stub address.  This flag is only used for
uncollectable stubs whose control address/value field might
be either a stub address or an unsigned integer.
\end{list}
\end{indpar}

These flag constants are defined by expressions of the form

\begin{center}
\verb|( min::uns64(1) << |$K$\verb| )|
\end{center}

The above functions assume that any flag constants select bits
in a control value that are not inside the address/value field
or inside the type code field.

Ordinary (non-acc) control values that have a locator
field cannot have any flag bits.

The flags in the stub control value of a stub can be tested, set, or
cleared by some of the above functions.
The \TT{MUP::test\_flags\_of} function
returns true if and only if the logical AND of the \TT{flags} arguments
and the flags in the stub's control is non-zero.  The \TT{MUP::set\_flags\_of}
function sets one or more individual flags by logically ORing its
argument into the stub's control, and the
\TT{MUP::clear\_flags\_of} function clears flags by logically ANDing
the complement of its argument into the stub's control.

The above functions do \underline{not} check type codes, nor do they check
that values read or written are within legal range for a particular
stub.  Thus a stub control value
can be written by \TT{MUP::set\_control\_of} even if the written
control datum is incompatible with the garbage collector implementation,
and may produce undefined results when the garbage collector
next executes.

The high order byte of any control written by \TT{MUP::set\_control\_of}
is the type code, and the high order bit is clear if the stub is collectible
and set if the stub is uncollectable (\itemref{STUB-CONTROL}).
Changing a stub from collectible to uncollectable or vice versa requires
removing or adding the stub to garbage collector lists that are threaded
through the pointer field of the stub control.  So one cannot simply
change the type code field of a stub from collectible to uncollectable
or vice versa.

Ordinary (non-acc) control values can be manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator} \verb|( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value} \verb|( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|int MUP::| & \MUPKEY{locator\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{tabular}\end{indpar}

The `\TT{new}' functions compute a control value,
the `\TT{renew}' functions modify control values
by inserting a new locator, value, or stub address, and
the other functions return the parts of a control value.
Here the 16-bit locator is represented as an \TT{int}
in the range from $-2^{15}$ through $2^{15}-1$.

None of these functions check the ranges of their arguments.

Acc control values can be manipulated by the following similar functions
(this is only done by acc code):

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
\end{tabular}\end{indpar}

Either ordinary or acc control values can be
manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type} \verb|( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{tabular}\end{indpar}

Here the 8-bit type code is represented as an \TT{int} in
the range from $-128$ through $127$.

\subsubsection{Unprotected Body Functions}
\label{UNPROTECTED-BODY-FUNCTIONS}

If you are implementing a new kind of stub, and your stubs have bodies,
you need to be able to allocate, relocate, and deallocate the bodies.
The following functions allocate and deallocate bodies:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void MUP::|
    & \MUPKEY{new\_body} \verb|( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body} \verb|( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{tabular}\end{indpar}

Here \TT{n} is the size in bytes of the body to be allocated or deallocated.
The allocator is not required to remember the size of a body,
so when deallocating the body the caller must provide the same size
as was used to allocate the body.  The allocator will likely
run a check that will likely catch a wrong size, but it may not
be able to determine the right size.

Bodies are always aligned on 8 byte boundaries, but the size \TT{n}
need \underline{not} be a multiple of 8.

When a body is deallocated, the stub type is set to
\TT{min::DEALLOCATED} and the stub pointer is set to
point at a block of inaccessible memory.
As a special case, if the body size \TT{n} is zero,
\TT{MUP::\EOL deallocate\_\EOL body} does nothing
(see \TT{MUP::\EOL body\_\EOL size\_\EOL of} below).


The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of} \verb|( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\end{tabular}\end{indpar}

returns the size of the body, that is, the same size
as that passed to \TT{MUP::new\_\EOL body} when the
body was allocated.  This is necessary as the acc does
\underline{not} keep track of body sizes, and depends upon
this \TT{MUP::body\_\EOL size\_\EOL of} function to
find body sizes.  If the stub is deallocated (of type
\TT{min::DEALLOCATED}) or if the stub has no body,
\TT{0} is returned.  This enables the code
\begin{center}
\TT{MUP::deallocate\_body ( s, MUP::body\_size\_of ( s ) )}
\end{center}

The \TT{min::body\_size\_of} function uses the type of the
stub to select a type-appropriate algorithm to compute
the body size.  The code of this function must be modified
if a new stub type is added.

The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void * & MUP::| & \MUPKEY{ptr\_ref\_of}
	                \verb|( min::stub * s )| 
\LABEL{MUP::PTR_REF_OF_STUB} \\
\end{tabular}\end{indpar}

returns a pointer to a pointer to the body.
The first pointer points to a location P with a fixed address
(P is the stub value); P holds
a pointer to the body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS}).
Whenever the body is relocated the value of P is changed to
point to the new body location.

In order to change the size of a body, the following
can be used:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\ARGBREAK
    \verb|( min::stub * s,|\ARGBREAK
    \verb|  min::unsptr new_size, min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_ptr\_ref}
	     \verb|( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_PTR_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}
	     \verb|( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\verb|void MUP::| & \MUPKEY{retype\_resize\_body}\ARGBREAK
	     \verb|( MUP::resize_body & rb, int new_type )| 
\LABEL{MUP::RETYPE_RESIZE_BODY} \\
\end{tabular}\end{indpar}

When constructed the \TT{MUP::resize\_body} datum allocates
a new body for a stub \TT{s}, and when deconstructed the datum
installs the new body in the stub \TT{s} while deallocating the
old body of \TT{s}.  Stub \TT{s}
is not altered until the \TT{MUP::\EOL resize\_\EOL body}
datum is deconstructed, and the \TT{MUP::\EOL abort\_\EOL resize\_\EOL body}
function can be used to abort the body resizing
and prevent stub \TT{s} from ever being altered.
The sizes of the old and new body of \TT{s} must be passed to
the \TT{MUP::\EOL resize\_\EOL body} constructor.

Given a \TT{MUP::\EOL resize\_\EOL body} datum \TT{rb},
\begin{center}
\verb|MUP::new_body_ptr_ref ( rb )|
\end{center}
returns a pointer to a pointer to the new body.  The first pointer
points to a location P with a fixed address that exists as long
as the \TT{MUP::\EOL resize\_\EOL body} datum \TT{rb} exists.   P holds
a pointer to the new body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS})
as all bodies
can be, and will be pointed to by a changed value of P if it is
relocated.

After the new body is obtained, information should be copied from
the old body to the new body before the \TT{MUP::\EOL resize\_\EOL body}
datum is deconstructed.  The new body will not be touched by
the garbage collector while the \TT{MUP::\EOL resize\_\EOL body} datum
exists, but it may be relocated.  The existing stub \TT{s}
\underline{must} be protected from garbage collection and
its body protected from reorganization by the user while the
\TT{MUP::\EOL resize\_\EOL body} datum exists, but that body may
also be relocated.  \TT{s} must NOT be deallocated
while the \TT{MUP::\EOL resize\_\EOL body} datum exists, unless
\TT{MUP::\EOL abort\_\EOL resize\_\EOL body} has been called.

While the \TT{MUP::\EOL resize\_\EOL body} datum exists,
the garbage collector will process the stub and old body normally.
Any locatable values stored in the new body must also be stored
in a separate garbage collector locatable place, as the garbage collector
ignores the new body.

Normally the type of stub \TT{s} is not changed, but
if the \TT{MUP::\EOL retype\_\EOL resize\_\EOL body} function is called
with a new stub type, that type will be installed in stub \TT{s}
if and when the new body is installed in stub \TT{s}.

\subsubsection{Unprotected Body Pointers}
\label{UNPROTECTED-BODY-POINTERS}

\ikey{Unprotected body pointers}{unprotected body pointer}%
\index{pointer!unprotected body}\index{body pointer!unprotected}
are C/C++ pointers that point directly into a body.
Functions that obtain body unprotected
pointers from stubs are unprotected (\TT{MUP}) functions because
the unprotected body pointers they return are invalidated
if the body pointed at
is relocated.

In order to track possible relocation,
names of functions that might relocate bodies are marked
with the superscript {\REL} in this document.
Relocation can only happen inside such \skey{relocating function}s
(\pagref{RELOCATING-FUNCTIONS}).

The following uses unprotected body pointers to point at a character
string stored in a body:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some long string
assert ( min::is_stub ( x ) );
const min::stub * xstub = min::stub_of ( x );
assert ( min::type_of ( xstub ) == min::LONG_STR );
MUP::long_str * xstr = MUP::long_str_of ( xstub );
const char * xp = MUP::str_of ( xstr );
int length = MUP::length_of ( xstr );
for ( int i = 0; i < length; ++ i )
{
    // Relocating functions must NOT be called in this loop.
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Strings are in fact of three types, `direct' which stores characters
in the general value, `short' which stores up to 8 characters in the stub
value, and `long' which stores more than 8 characters in the body.  The
above code only works for long strings (\pagref{LONG-STRING-STUB}).


\subsection{UNICODE Characters}
\label{UNICODE-CHARACTERS}

Unicode characters are implemented by the following:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef min::uns32 min::| & \MINKEY{Uchar}
\LABEL{MIN::UCHAR} \\
\verb|const min::Uchar min::|
    & \MINKEY{UNKNOWN\_UCHAR}
\LABEL{MIN::UNKNOWN_UCHAR} \\
\verb|const min::Uchar min::|
    & \MINKEY{SOFTWARE\_NL}
\LABEL{MIN::SOFTWARE_NL} \\
\verb|const min::Uchar min::|
    & \MINKEY{NO\_UCHAR} \verb|= 0xFFFFFFFF|
\LABEL{MIN::UNICODE::NO_UCHAR} \\
\verb|min::Uchar min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( const char * & s, const char * ends )|
\LABEL{MIN::UTF8_TO_UNICODE} \\
\verb|unsigned min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb|( char * & s, min::Uchar c )|
\LABEL{MIN::UNICODE_TO_UTF8} \\
\end{tabular}\end{indpar}

Here UNICODE characters are represented as \TT{min::Uchar} values
that are 32-bit unsigned integers.  `\TT{char *}' strings are treated
as `Modified UTF-8' encodings of UNICODE character strings.
In these the NUL (zero) UNICODE \TT{min::Uchar} value is encoded as
the 2 string bytes \TT{"\textbackslash xC0\textbackslash x80"},
while the zero `\TT{char}' is used to terminate the `\TT{char *}' string.
The term `\key{Modified UTF-8}'\label{MODIFIED-UTF8} applies
to a UTF-8 encoding in which the \underline{only} permitted
overlong encoding is this 2-byte encoding of NUL.

The \TT{UNKNOWN\_UCHAR}\label{UNKNOWN_UCHAR} UNICODE character
is returned by the \TT{min::\EOL utf8\_\EOL to\_\EOL unicode}
function when it finds an illegal UTF8 encoding.  This is actually
the `\key{UNICODE replacement character}',
FFFD (hexadecimal), which is designated by the UNICODE standard
as representing an input
that is not encodable in UNICODE.

The \TT{SOFTWARE\_NL}\label{SOFTWARE_NL} UNICODE character is used
to represent the end of line in a \TT{min::\EOL file},
which is internally represented by a line-ending NUL character,
when the end of line is displayed on a printer.
See \TT{min::\EOL DISPLAY\_\EOL EOL} on \pagref{DISPLAY_EOL}.
This is actually an arbitrary UNICODE private use character, and is not
normally input or output itself.

The \TT{min::uft8\_to\_unicode} function reads a UNICODE character
encoded as a UTF-8 byte string.  Here \TT{s} points at the first byte
of the encoding and is updated to point after the encoding, while
\TT{ends} points just after the last byte that can be part of
the encoding.

The \TT{min::uft8\_to\_unicode} function returns \TT{min::\EOL NO\_\EOL UCHAR}
if \TT{s >= ends} when the function is called.
Otherwise in returns the first character encoded by the UTF-8 string
pointed at by \TT{s} and terminating just before \TT{ends}, and updates
\TT{s} to point just after that character's encoding.

The \TT{min::uft8\_to\_unicode} function will accept
\mkey{overlong}{UTF-8 encoding} UTF-8 encodings as legal,
and also accept 7-byte encodings (first byte \TT{0xFE})
so that $2^{32}-1$ can be encoded.  If it encounters an
illegal encoding it returns \TT{min::\EOL UNKNOWN\_\EOL UCHAR}.
An illegal encoding will terminate if the next byte cannot be
part of a legal encoding or if there is no next byte according
to \TT{ends}.

Applying the \TT{min::uft8\_to\_unicode} function repeatedly
until \TT{s >= ends} will produce a sequence of UNICODE
characters from any byte string, even one that is not legal UTF-8,
though if the string is not legal some \TT{min::\EOL UNKNOWN\_\EOL UCHAR}
characters will be returned.

The \TT{min::\EOL unicode\_\EOL to\_\EOL utf8} function writes
a UTF-8 character \TT{c} into \TT{s}, updating \TT{s} to point after the
character, and returns the number of bytes written.
This function will output
7-byte encodings (first byte \TT{0xFE}) for
UNICODE character values \TT{=> 0x80000000}, and will output
the overlong encoding \TT{"\textbackslash xC0\textbackslash x80"}
for \ttmkey{NUL}{UTF-8 encoding}.
UTF-8 in which this is the \underline{only} permitted overlong encoding
is called `Modified UTF-8' (\pagref{MODIFIED-UTF8}).
No other overlong encodings are output.
At most 7 bytes will be output, and
\TT{s} \underline{must}
point to a byte string buffer with \underline{at least} 7 bytes.

Strings of UNICODE characters can be converted to/from strings
of UTF-8 encoded characters by the functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( min::Uchar * & u, const min::Uchar * endu,|\ARGBREAK
      \verb|  const char * & s, const char * ends )|
\LABEL{MIN::UTF8_STR_TO_UNICODE_STR} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb| ( char * & s, const char * ends,|\ARGBREAK
      \verb|   const min::Uchar * & u,|\ARGBREAK
      \verb|   const min::Uchar * endu )|
\LABEL{MIN::UNICODE_STR_TO_UTF8_STR} \\
\end{tabular}\end{indpar}

The first of these repeatedly executes
\begin{center}
\tt * u ++ = min::utf8\_to\_unicode ( s, ends );
\end{center}
while \TT{u < endu} and \TT{s < ends}.
The second repeatedly executes
\begin{center}
\tt min::unicode\_to\_utf8 ( s, * u ++ );
\end{center}
while \TT{s < ends} and \TT{u < endu} provided the
next repetition will \underline{not} end with \TT{s > ends}
(so the \TT{s} string end will not be overrun).
Both these functions increment both \TT{s} and \TT{u} and return
the number of string elements, \TT{min::Uchar}'s or \TT{char}'s respectively,
written.

\subsubsection{Unicode Data Base}
\label{UNICODE-DATA-BASE}

Various attributes of UNICODE characters are stored in the
\key{UNICODE Data Base}.

To keep this data base compact, UNICODE characters are grouped
so all characters with the same attributes are assigned the
same group.  This is implemented by mapping each character to
a \key{UNICODE character index}\index{character index!UNICODE},
and then mapping the character index to various
attributes.  To enable a program to load only parts of the
database, each attribute is in a separately loadable vector.

The first part of this mapping is implemented by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns16 min::|
    & \MINKEY{Uindex} \verb|( min::Uchar c )|
\LABEL{MIN::UINDEX} \\
\end{tabular}\end{indpar}

which maps the UNICODE character \TT{c} to its UNICODE
character index \TT{Uindex~(~c~)}.

Given the index \TT{i = min::Uindex ( c )} of \TT{c}, you can
find out the name and picture of \TT{c} by using:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ustring min::|
    & \MINKEY{unicode::name}\verb|[i]|
\LABEL{MIN::UNICODE::NAME} \\
\verb|min::ustring min::|
    & \MINKEY{unicode::picture}\verb|[i]|
\LABEL{MIN::UNICODE::PICTURE} \\
\end{tabular}\end{indpar}

You can also find out the character flags of \TT{c} as described
below in \itemref{UNICODE-CHARACTER-FLAGS}.
So that ASCII and LATIN1 characters can each have their own
flags, each has its own index\label{ASCII-LATIN1-UNIQUE-INDEX}.  That is:
\begin{center}
\verb|min::Uindex ( c ) == c       if c <= 0xFF| \\
\verb|min::Uindex ( c )  > 0xFF    if c  > 0xFF|
\end{center}

For indices \TT{i} for which there is exactly one character that
has index \TT{i}, you can find out that character by using:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::Uchar min::|
    & \MINKEY{unicode::character}\verb|[i]|
\LABEL{MIN::UNICODE::CHARACTER} \\
\verb|const min::uns16 min::|
    & \MINKEY{unicode::index\_limit}
\LABEL{MIN::UNICODE::INDEX_LIMIT} \\
\end{tabular}\end{indpar}

As no two characters share a name or picture, this last can be
useful for finding the character that has a given name or picture.
If \TT{i} is associated with exactly one character,
\TT{min::\EOL unicode::\EOL character[i]} equals that
character, and otherwise it equals \TT{min::\EOL NO\_\EOL CHAR}.

The size of all the above vectors is
\TT{min::\EOL unicode::\EOL index\_\EOL limit},
which is a strict upper bound on the index \TT{i}
(i.e., \TT{0 <= i < index\_limit}).

Here `\TT{min::ustring}' values encode UNICODE character
strings in a format optimized for printing, or are \TT{NULL} to
indicate a missing value; see \itemref{UNICODE-STRINGS} for details.
The \mkey{name}{of UNICODE character}
is non-missing only for control characters; examples
are the name
\TT{CR} for the ASCII carriage return character with (hex) code \TT{0D},
\TT{SP} for the ASCII single space character with (hex) code \TT{20},
and \TT{NBSP} for the LATIN1 non-breaking single space character
with (hex) code \TT{A0}.
LATIN1 control characters (including horizontal spaces)
and some other control characters have
non-missing names.

The \mkey{picture}{of UNICODE character} is non-missing for
ASCII control characters, and for these is the UNICODE control picture
character corresponding to the ASCII control character name.
For example, the line feed picture is
{\tiny $\stackrel{\textstyle L~}{\textstyle ~F}$},
which is the single UNICODE character with code \TT{240A}.
As a special case, single space has the picture \TT{\textvisiblespace} and
the non-breaking single space (\TT{NBSP}) has the picture
\TT{\textblank}.

Also as special cases the \minmkey{UNKNOWN\_UCHAR}{name} character 
has name \TT{UUC} and picture $/\!\!/\!\!/$, and the
\minmkey{SOFTWARE\_NL}{name and picture} character has name
\TT{NL} and picture {\tiny $\stackrel{\textstyle N~}{\textstyle ~L}$}.

The \TT{ustring} name and picture values contain only graphic
characters (e.g., no spaces) and have non-zero numbers of columns
encoded in their second bytes.

\subsubsection{Unicode Character Flags}
\label{UNICODE-CHARACTER-FLAGS}

The most important attributes of a character are its
\smkey{flag}s{of UNICODE character}\index{character flag}%
\label{CHARACTER-FLAGS}.
Given the index of \TT{c}:

\begin{center}
\tt i = min::Uindex ( c )
\end{center}

you can find out the flags of \TT{c} by using:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 printer->|
    & \MINKEY{print\_format.char\_flags}\verb|[i]|
\LABEL{MIN::PRINT_FORMAT.CHAR_FLAGS} \\
\verb|const min::uns32 * min::|
    & \MINKEY{standard\_char\_flags}
\LABEL{MIN::STANDARD_CHAR_FLAGS} \\
\end{tabular}\end{indpar}

where usually

\begin{center}
\tt printer->print\_format.char\_flags == min::standard\_char\_flags
\end{center}

Character flags are obtained from
the \TT{char\_\EOL flags} member of the \TT{print\_\EOL format} member of
the \TT{printer} being used to print the character, and this
in turn is usually set to the \TT{min::\EOL standard\_\EOL char\_\EOL flags}
vector.  Unlike other character attributes, some of these flags can be computed
by user code in a flexible manner, so some of the standard character
flags which we describe here are only a special case of what is
possible.

As mentioned above (\pagref{ASCII-LATIN1-UNIQUE-INDEX}), each ASCII
and LATIN1 character has its own \TT{char\_\EOL flags} element, so each
can be assigned flags independently of the flags of any other character.

The standard character flags which must always be defined are

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_GRAPHIC}
\LABEL{MIN::IS_GRAPHIC} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_CONTROL}
\LABEL{MIN::IS_CONTROL} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_UNSUPPORTED}
\LABEL{MIN::IS_UNSUPPORTED} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_NON\_GRAPHIC} =\ARGBREAK
    \verb|  min::IS_CONTROL|\ARGBREAK
    \verb|+ min::IS_UNSUPPORTED|
\LABEL{MIN::IS_NON_GRAPHIC} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_HSPACE}
\LABEL{MIN::IS_HSPACE} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_VHSPACE}
\LABEL{MIN::IS_VHSPACE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_NON\_SPACING}
\LABEL{MIN::IS_NON_SPACING} \\
\end{tabular}\end{indpar}

The specific assignment of character flags is generally done
according to their
UNICODE `\key{General Category}' with some exceptions.
The following are the possible General Category values.
These have the form \TT{Xy} where \TT{X} denotes the category
and \TT{y} denotes the subcategory.  We use the notation
\TT{X} to represent the category \TT{X} including all its
subcategories, and we give here only \underline{some} of the
subcategories of each category.  We also give the LATIN1 characters
in each subcategory except where these are obvious (e.g, letters
and digits).
\begin{indpar}
\begin{tabular}{ll}
\TT{L}		& letters \\
~~~\TT{Ll}	& lower case letters, includes \TT{\textmu} \\
~~~\TT{Lu}	& upper case letters \\
~~~\TT{Lo}	& other letters, includes
                  \TT{\textordmasculine} and \TT{\textordfeminine} \\
\end{tabular}

\begin{tabular}{ll}
\TT{M}		& combining marks \\
~~~\TT{Mn}	& non-spacing combining marks \\
~~~\TT{Me}	& enclosing combining marks \\
\end{tabular}

\begin{tabular}{ll}
\TT{N}		& number \\
~~~\TT{Nd}	& decimal numbers, includes digits \\
~~~\TT{No}	& other numbers, includes
                  \TT{\textsuperscript{1}}
                  \TT{\textsuperscript{2}}
		  \TT{\textsuperscript{3}}
		  \TT{\textonequarter}
		  \TT{\textonehalf}
		  \TT{\textthreequarters} \\
\end{tabular}

\begin{tabular}{ll}
\TT{P}		& punctuation \\
~~~\TT{Pc}	& connector punctuation, includes \TT{\_} \\
~~~\TT{Pd}	& dash punctuation, includes \TT{-} \\
~~~\TT{Ps}	& open punctuation, includes \TT{\{} \TT{[} \TT{(} \\
~~~\TT{Pe}	& close punctuation, includes \TT{\}} \TT{]} \TT{)} \\
~~~\TT{Pi}	& initial punctuation, includes \TT{\guillemotleft} \\
~~~\TT{Pf}	& final punctuation, includes \TT{\guillemotright} \\
~~~\TT{Po}	& other punctuation, includes
                  \TT{!} \TT{"} \TT{\#} \TT{\%} \TT{\&} \TT{'} \TT{*}
		  \TT{,} \TT{.} \TT{/} \TT{:} \TT{;} \TT{?} \TT{@}
		  \TT{\textbackslash}
		  \TT{\textexclamdown}
		  \TT{\textsection}
		  \TT{\textpilcrow}
		  \TT{\textperiodcentered}
		  \TT{\textquestiondown} \\
\end{tabular}

\begin{tabular}{ll}
\TT{S}		& symbol \\
~~~\TT{Sm}	& math symbol, includes \TT{+} \TT{<} \TT{=} \TT{>} \TT{|}
                  \TT{\textasciitilde}
		  \TT{\textlnot}
		  \TT{\textpm}
		  \TT{\texttimes}
		  \TT{\textdiv}
		  \\
~~~\TT{Sc}	& currency symbol, includes \TT{\$}
		  \TT{\textcent}
		  \TT{\textsterling}
		  \TT{\textcurrency}
		  \TT{\textyen}
		  \\
~~~\TT{Sk}	& modifier symbol, includes
		  \TT{\textasciicircum}
		  \TT{\`{ }}
		  \TT{\"{~}}
		  \TT{\={~}}
		  \TT{\'{~}}
		  \TT{\c{~}}
		  \\
~~~\TT{So}	& other symbol, includes
		  \TT{\textbrokenbar}
		  \TT{\textcopyright}
		  \TT{\textregistered}
		  \TT{\textdegree}
		  \\
\end{tabular}

\begin{tabular}{ll}
\TT{Z}		& space characters \\
~~~\TT{Zs}	& non-zero width horizontal space,
                  includes single space and \TT{NBSP} \\
		& (but \underline{not} horizontal tab) \\
\end{tabular}

\begin{tabular}{ll}
\TT{C}		& control characters \\
~~~\TT{Cc}	& LATIN1 control codes in ranges [\TT{00}\ldots\TT{1F}]
		  and [\TT{7F}\ldots\TT{9F}], \\
		& includes horizontal tab \\
~~~\TT{Cf}	& format control character, includes \TT{SHY} (soft hyphen)
\end{tabular}
\end{indpar}

Each character gets exactly one of the following flags:

\begin{center}
\begin{tabular}{l}
\TT{min::IS\_GRAPHIC} \\
\TT{min::IS\_CONTROL} \\
\TT{min::IS\_UNSUPPORTED} \\
\end{tabular}
\end{center}

The \minkey{IS\_GRAPHIC} flag signifies that a character makes
some visible mark.

The \minkey{IS\_CONTROL} flag signifies
that a character makes no visible mark.

The \minkey{IS\_UNSUPPORTED} flag signifies that the character
cannot be output (except as a numeric character code) and that no information
about the character is available.

The assignment of these three flags in \TT{min::standard\_char\_flags} is:

\begin{indpar}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_GRAPHIC}: & characters in categories \TT{L}, \TT{M},
                            \TT{N}, \TT{P}, and \TT{S} \\
\ttkey{min::IS\_CONTROL}: & characters in categories \TT{C} and \TT{Z} \\
\ttkey{min::IS\_UNSUPPORTED}: & characters not given any category \\
		          & (or given a new category not mentioned above)
\end{tabular}
\end{indpar}

The support control part of a print format

\begin{center}
\TT{printer->print\_format.support\_control}
\end{center}

permits characters with particular flags to be marked unsupported in
a give context; so for example, all non-ASCII or all non-LATIN1
characters can be marked unsupported so they will not be output as is
(useful if the printer does not support them).
See \itemref{UNICODE-SUPPORT-CONTROL}
and \pagref{PRINT_FORMAT_SUPPORT_CONTROL}.

Horizontal space characters get the
\minkey{IS\_\EOL HSPACE} flag.  Included is the horizontal tab \TT{HT}.


Vertical space characters that standardly appear in printed output
get the \minkey{IS\_VHSPACE} flag.  There are four such characters:
form feed \TT{FF}, vertical tab \TT{VT}, line feed \TT{LF},
and carriage return \TT{CR}.  The last is included because
it is associated with line feeds.
Characters with the \TT{IS\_\EOL HSPACE} flag also get the
\TT{IS\_\EOL VHSPACE} flag.

The assignment of these two flags in \TT{min::standard\_char\_flags} is:

\begin{indpar}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_HSPACE}: & \TT{HT}, plus
                           characters in subcategory \TT{Zs} \\
\ttkey{min::IS\_VHSPACE}: & \TT{FF} \TT{VT} \TT{LF} \TT{CR},
                            plus characters with the \TT{IS\_HSPACE} flag
\end{tabular}
\end{indpar}


The \minkey{IS\_\EOL NON\_\EOL SPACING}
flag signifies that a character takes zero
columns, instead of 1 column.  The characters given this flag are
the non-spacing combining mark characters and
all control characters (including vertical spacing characters)
other than horizontal spacing characters.  Note that the
horizontal tabs are handled specially by the printer as far
as the number of columns they take, and this special handling
ignores the character flags of the horizontal tab character.

The assignment of this flag in \TT{min::standard\_char\_flags} is:

\begin{indpar}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_NON\_SPACING}: & characters with the \TT{IS\_CONTROL} flag,\\
			& but without the \TT{IS\_HSPACE} flag, \\
			       & plus characters in subcategories \TT{Mn}
			         and \TT{Me} \\
\end{tabular}
\end{indpar}

Other character flags are used by the printer context data and can
be adapted according to the application.  The following flags are
defined by 
\TT{min::\EOL standard\_\EOL char\_\EOL flags}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_SP}
\LABEL{MIN::IS_SP} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_BHSPACE}
\LABEL{MIN::IS_BHSPACE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{CONDITIONAL\_BREAK}
\LABEL{MIN::CONDITIONAL_BREAK} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_LEADING}
\LABEL{MIN::IS_LEADING} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_TRAILING}
\LABEL{MIN::IS_TRAILING} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_SEPARATOR}
\LABEL{MIN::IS_SEPARATOR} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_REPEATER}
\LABEL{MIN::IS_REPEATER} \\
\verb|const min::uns32 min::| & \MINKEY{NEEDS\_QUOTES}
\LABEL{MIN::NEEDS_QUOTES} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_MARK}
\LABEL{MIN::IS_MARK} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{IS\_ASCII}
\LABEL{MIN::IS_ASCII} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_LATIN1}
\LABEL{MIN::IS_LATIN1} \\
\end{tabular}\end{indpar}

The \minkey{IS\_SP} is just for the single space character.
The \minkey{IS\_\EOL BHSPACE} flag is for `breaking'
horizontal space characters.  These flags can be used in

\begin{center}
\TT{printer->print\_format.break\_control.break\_after}
\end{center}

to mark characters after
which automatic line breaks can be inserted (and then the
spaces at the end of the broken line are deleted).
See \pagref{BREAK-AFTER}.

The assignment of these two flags in \TT{min::standard\_char\_flags} is:

\begin{indpar}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_SP}: & \TT{SP}, the single space character \\
\ttkey{min::IS\_BHSPACE}: & all characters with the \TT{IS\_HSPACE} flag,\\
                          & except \TT{NBSP} (LATIN1 no-break space)\\
			  & and \TT{NNBSP} (narrow no-break space, character
			    code \TT{0x202F})\\
\end{tabular}
\end{indpar}

The \minkey{CONDITIONAL\_BREAK} flag is used in

\begin{center}
\TT{printer->print\_format.break\_control.conditional\_break}
\end{center}

to mark graphic characters which when preceded by a few graphic
characters and followed by a line break
indicate that their containing lexeme is continued on the next line.
See \pagref{CONDITIONAL-BREAK}.

The assignment of this flag in \TT{min::standard\_char\_flags} is:

\begin{center}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::CONDITIONAL\_BREAK}: & \TT{/} \TT{\#} \TT{\&} \\
                                 & plus characters in categories
				   \TT{Pc} and \TT{Pd} \\
				 & (includes \TT{-} and \TT{\_}) \\
\end{tabular}
\end{center}

The \minkey{IS\_LEADING} or \minkey{IS\_TRAILING} flags are used
to mark characters that can be leading separators prepended to
other lexemes or trailing separators appended to other lexemes.
The rough concept is
that a string of characters with no spaces may be separated into
lexemes by stripping leading separators from its beginning and
trailing separators from its end, so `\TT{[5;}' becomes the
leading separator lexeme \TT{[}, the middle lexeme \TT{5},
and the trailing separator lexeme \TT{;}, and therefore
\TT{[} is \TT{IS\_\EOL LEADING}, \TT{5} is neither \TT{IS\_\EOL LEADING}
nor \TT{IS\_\EOL TRAILING}, and
\TT{;} is \TT{IS\_\EOL TRAILING}.  See 
\TT{min::\EOL standard\_\EOL str\_\EOL classifier}
(\itemref{STRING-CLASSIFIERS})
and Leading and Trailing Separators
\itemref{LEADING-AND-TRAILING-SEPARATORS} for details.

The assignment of these two flags in \TT{min::standard\_char\_flags}
is as follows:

\begin{indpar}[0.1in]
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_LEADING}: & \TT{`}%
                         ~~~\TT{\textexclamdown}%
                         ~~~\TT{\textquestiondown}%
                         ~~~\TT{|}\\
			   & plus categories \TT{Ps} and \TT{Pi}
			     which include \TT{\{} \TT{(} \TT{[}
			      \TT{\guillemotleft} \\
\ttkey{min::IS\_TRAILING}: & \TT{'}%
			 ~~~\TT{!}~~~\TT{?}%
                         ~~~\TT{|}%
			 ~~~\TT{.}~~~\TT{,}~~~\TT{;}~~~\TT{:}\\
			   & plus categories \TT{Pe} and \TT{Pf}
			     which include \TT{\}} \TT{)} \TT{]}
			      \TT{\guillemotright} \\
\end{tabular}
\end{indpar}

Note that `\TT{|}' is \underline{both} \TT{IS\_\EOL LEADING} and
\TT{IS\_\EOL TRAILING}.

The \minkey{IS\_SEPARATOR} flag is used by
\TT{min::\EOL standard\_\EOL str\_\EOL classifier}
to identify characters that cannot be combined with other characters
in unquoted strings; e.g. \TT{(}, \TT{)}, and \TT{|}.
The \minkey{IS\_REPEATER} flag is used by
\TT{min::\EOL standard\_\EOL str\_\EOL classifier}
to identify characters that may be repeated when they appear in unquoted
separators; e.g. \TT{|}.
The \minkey{NEEDS\_QUOTES} flag is used by
\TT{min::\EOL standard\_\EOL str\_\EOL classifier}
to identify graphic characters that require any string containing them to be
quoted; e.g., \TT{"}.
See \itemref{STRING-CLASSIFIERS} for details.

The assignment of these three flags in \TT{min::standard\_char\_flags}
is as follows:

\begin{center}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_SEPARATOR}: & \TT{|} and categories
                              \TT{Ps}, \TT{Pi}, \TT{Pe}, \TT{Pf}, \\
			    & which include \TT{\{} \TT{(} \TT{[}
			      \TT{\guillemotleft}
			      \TT{\guillemotright}
			      \TT{]} \TT{)} \TT{\}} \\
\ttkey{min::IS\_REPEATER}: & \TT{|}%
                             ~~~~\TT{\textexclamdown}%
                             ~~~\TT{\textquestiondown}%
			     ~~~\TT{!}~~~\TT{?}%
			     ~~~\TT{.}~~~\TT{:}\\
\ttkey{min::NEEDS\_QUOTES}: & \TT{"}
\end{tabular}
\end{center}


A lexeme all of whose characters have the \minkey{IS\_\EOL MARK} flag is
called a `\key{mark}', and can be used just inside parentheses
as the type of a parenthesized list: see
\TT{min::\EOL standard\_\EOL str\_\EOL classifier}
(\itemref{STRING-CLASSIFIERS})
and the 
\TT{mark\_\EOL classifier} of the object format,
\pagref{MARK_CLASSIFIER}.

The assignment of this flag in \TT{min::standard\_char\_flags}
is as follows:

\begin{center}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_MARK}: & categories \TT{P} and \TT{S}
                         (punctuation and symbols), \\
		       & but \underline{not} characters 
		         with the \TT{IS\_\EOL SEPARATOR}
			 or \TT{NEEDS\_\EOL QUOTES} flags
\end{tabular}
\end{center}

The last two flags are used in

\begin{center}
\TT{printer->print\_format.support\_control.support\_mask}
\end{center}

to dynamically control which characters are supported.
The \minkey{IS\_\EOL ASCII} flag is on for ASCII characters, and
The \minkey{IS\_\EOL LATIN1} flag is on for LATIN1 non-ASCII characters.
See \itemref{UNICODE-SUPPORT-CONTROL} for details.

The assignment of these two flags in
\TT{min::standard\_char\_flags} is:

\begin{center}
\begin{tabular}{l@{~~~~~}l}
\ttkey{min::IS\_ASCII}: & ASCII characters with codes in range
                          [\TT{00}\ldots\TT{7F}] \\
\ttkey{min::IS\_LATIN1}: & LATIN1, non-ASCII characters with codes in range
                          [\TT{80}\ldots\TT{FF}] \\
\end{tabular}
\end{center}

The question of which characters can be supported is determined
by the file
\begin{center}
\ldots\TT{/min/\EOL unicode/\EOL CompositeCharacters.txt}%
\ttindex{CompositeCharacters.txt}
\end{center}
which lists the multi-key sequences that can be used to input
non-ASCII supportable characters, and also by the file
\begin{center}
\ldots\TT{/min/\EOL unicode/\EOL SupportSets.txt}%
\ttindex{SupportSets.txt}
\end{center}
which defines which sets of characters
are marked with which support set character flags, such as
\TT{min::\EOL IS\_\EOL ASCII/\EOL LATIN1}.

The non-control characters with the \TT{min::IS\_LATIN1} flag 
in \TT{min::standard\_char\_flags}
are listed,
along with the multi-key sequences commonly used to input them,
in Figures~\ref{LATIN1-CHARACTERS-I},
\ref{LATIN1-CHARACTERS-II},
and \ref{LATIN1-CHARACTERS-III}.
Printers can usually be configured to support these LATIN1 characters.

\TT{min::standard\_char\_flags} is computed using data taken from
\ldots\TT{/min/\EOL unicode/\EOL uni\-code\_\EOL data.h}%
\ttindex{unicode\_data.h} (which is included in the \ttkey{min::unicode}
namespace by the \ttkey{min\_unicode.h} file that is in turn
included in \TT{min.h}).  Other character flag vectors can be computed
using this data.

\begin{boxedfigure}[p]
\begin{tabular}{llll}
& Hex & Multi-Key \\
& Code & Sequence
\\[1ex]
\TT{~}
  & \TT{A0} & \TT{<space><space>} & No Break Space (\ttkey{NBSP}) \\
\TT{\textexclamdown}
  & \TT{A1} & \TT{!!} & Inverted Exclamation \\
\TT{\textcent}
  & \TT{A2} & \TT{c|} & Cent Sign \\
\TT{\textsterling}
  & \TT{A3} & \TT{L-} & Pound Sign \\
\TT{\textcurrency}
  & \TT{A4} & \TT{ox} & Currency Sign \\
\TT{\textyen}
  & \TT{A5} & \TT{Y=} & Yen Sign \\
\TT{\textbrokenbar}
  & \TT{A6} & \TT{!\textasciicircum} & Broken Bar \\
\TT{\textsection}
  & \TT{A7} & \TT{S!} & Section Sign \\
\TT{\"{~}}
  & \TT{A8} & \TT{""} & Diaeresis \\
\TT{\textcopyright}
  & \TT{A9} & \TT{oc} & Copyright Sign \\
\TT{\textordfeminine}
  & \TT{AA} & \TT{\textasciicircum\_a} & Feminine Ordinal Indicator \\
\TT{\guillemotleft}
  & \TT{AB} & \TT{<<} & Left-Pointing Double Angle Quotation Mark \\
\TT{\textlnot}
  & \TT{AC} & \TT{-,} & Not Sign \\
\TT{~}
  & \TT{AD} & \TT{--<space>} & Soft Hyphen (\TT{SHY}) \\
\TT{\textregistered}
  & \TT{AE} & \TT{or} & Registered Sign \\
\TT{\={~}}
  & \TT{AF} & \TT{\textasciicircum-} & Macron \\
\TT{\textdegree}
  & \TT{B0} & \TT{oo} & Degree Sign \\
\TT{\textpm}
  & \TT{B1} & \TT{+-} & Plus-Minus Sign \\
\TT{\textsuperscript{2}}
  & \TT{B2} & \TT{\textasciicircum2} & Superscript 2 \\
\TT{\textsuperscript{3}}
  & \TT{B3} & \TT{\textasciicircum3} & Superscript 3 \\
\TT{\'{~}}
  & \TT{B4} & \TT{''} & Acute Accent \\
\TT{\textmu}
  & \TT{B5} & \TT{mu} & Micro Sign \\
\TT{\textpilcrow}
  & \TT{B6} & \TT{p!} & Pilcrow Sign \\
\TT{\textperiodcentered}
  & \TT{B7} & \TT{\textasciicircum.} & Middle Dot \\
\TT{\c{~}}
  & \TT{B8} & \TT{,,} & Cedilla \\
\TT{\textsuperscript{1}}
  & \TT{B9} & \TT{\textasciicircum1} & Superscript 1 \\
\TT{\textordmasculine}
  & \TT{BA} & \TT{\textasciicircum\_o} & Masculine Ordinal Indicator \\
\TT{\guillemotright}
  & \TT{BB} & \TT{>>} & Right-Pointing Double Angle Quotation Mark \\
\TT{\textonequarter}
  & \TT{BC} & \TT{14} & Vulgar Fraction One Quarter \\
\TT{\textonehalf}
  & \TT{BD} & \TT{12} & Vulgar Fraction One Half \\
\TT{\textthreequarters}
  & \TT{BE} & \TT{34} & Vulgar Fraction Three Quarters \\
\TT{\textquestiondown}
  & \TT{BF} & \TT{??} & Inverted Question Mark \\
\end{tabular}
\caption{LATIN1 Characters: Part I}
\label{LATIN1-CHARACTERS-I}
\end{boxedfigure}

\begin{boxedfigure}[p]
\begin{tabular}{llll}
& Hex & Multi-Key \\
& Code & Sequence
\\[1ex]
\TT{\`A}
  & \TT{C0} & \TT{A\`~} & Latin Capital Letter A With Grave \\
\TT{\'A}
  & \TT{C1} & \TT{A'} & Latin Capital Letter A With Acute \\
\TT{\^A}
  & \TT{C2} & \TT{A\textasciicircum} & Latin Capital Letter A With Circumflex \\
\TT{\~A}
  & \TT{C3} & \TT{A\textasciitilde} & Latin Capital Letter A With Tilde \\
\TT{\"A}
  & \TT{C4} & \TT{A"} & Latin Capital Letter A With Diaeresis \\
\TT{\AA}
  & \TT{C5} & \TT{AA} & Latin Capital Letter A With Ring Above \\
\TT{\AE}
  & \TT{C6} & \TT{AE} & Latin Capital Letter AE \\
\TT{\c{C}}
  & \TT{C7} & \TT{C,} & Latin Capital Letter C With Cedilla \\
\TT{\`E}
  & \TT{C8} & \TT{E\`~} & Latin Capital Letter E With Grave \\
\TT{\'E}
  & \TT{C9} & \TT{E'} & Latin Capital Letter E With Acute \\
\TT{\^E}
  & \TT{CA} & \TT{E\textasciicircum} & Latin Capital Letter E With Circumflex \\
\TT{\"E}
  & \TT{CB} & \TT{E"} & Latin Capital Letter E With Diaeresis \\
\TT{\`I}
  & \TT{CC} & \TT{I\`~} & Latin Capital Letter I With Grave \\
\TT{\'I}
  & \TT{CD} & \TT{I'} & Latin Capital Letter I With Acute \\
\TT{\^I}
  & \TT{CE} & \TT{I\textasciicircum} & Latin Capital Letter I With Circumflex \\
\TT{\"I}
  & \TT{CF} & \TT{I"} & Latin Capital Letter I With Diaeresis \\
\TT{\DH}
  & \TT{D0} & \TT{DH} & Latin Capital Letter ETH \\
\TT{\~N}
  & \TT{D1} & \TT{N\textasciitilde} & Latin Capital Letter N With Tilde \\
\TT{\`O}
  & \TT{D2} & \TT{O\`~} & Latin Capital Letter O With Grave \\
\TT{\'O}
  & \TT{D3} & \TT{O'} & Latin Capital Letter O With Acute \\
\TT{\^O}
  & \TT{D4} & \TT{O\textasciicircum} & Latin Capital Letter O With Circumflex \\
\TT{\~O}
  & \TT{D5} & \TT{O\textasciitilde} & Latin Capital Letter O With Tilde \\
\TT{\"O}
  & \TT{D6} & \TT{O"} & Latin Capital Letter O With Diaeresis \\
\TT{\texttimes}
  & \TT{D7} & \TT{xx} & Multiplication Sign \\
\TT{\O}
  & \TT{D8} & \TT{O/} & Latin Capital Letter O With Stroke \\
\TT{\`U}
  & \TT{D9} & \TT{U\`~} & Latin Capital Letter U With Grave \\
\TT{\'U}
  & \TT{DA} & \TT{U'} & Latin Capital Letter U With Acute \\
\TT{\^U}
  & \TT{DB} & \TT{U\textasciicircum} & Latin Capital Letter U With Circumflex \\
\TT{\"U}
  & \TT{DC} & \TT{U"} & Latin Capital Letter U With Diaeresis \\
\TT{\'Y}
  & \TT{DD} & \TT{Y'} & Latin Capital Letter Y With Acute \\
\TT{\TH}
  & \TT{DE} & \TT{TH} & Latin Capital Letter Thorn \\
\TT{\ss}
  & \TT{DF} & \TT{ss} & Latin Small Letter Sharp S \\
\end{tabular}
\caption{LATIN1 Characters: Part II}
\label{LATIN1-CHARACTERS-II}
\end{boxedfigure}

\begin{boxedfigure}
\begin{tabular}{llll}
& Hex & Multi-Key \\
& Code & Sequence
\\[1ex]
\TT{\`a}
  & \TT{E0} & \TT{a\`~} & Latin Small Letter A With Grave \\
\TT{\'a}
  & \TT{E1} & \TT{a'} & Latin Small Letter A With Acute \\
\TT{\^a}
  & \TT{E2} & \TT{a\textasciicircum} & Latin Small Letter A With Circumflex \\
\TT{\~a}
  & \TT{E3} & \TT{a\textasciitilde} & Latin Small Letter A With Tilde \\
\TT{\"a}
  & \TT{E4} & \TT{a"} & Latin Small Letter A With Diaeresis \\
\TT{\aa}
  & \TT{E5} & \TT{aa} & Latin Small Letter A With Ring Above \\
\TT{\ae}
  & \TT{E6} & \TT{ae} & Latin Small Letter AE \\
\TT{\c{c}}
  & \TT{E7} & \TT{c,} & Latin Small Letter C With Cedilla \\
\TT{\`e}
  & \TT{E8} & \TT{e\`~} & Latin Small Letter E With Grave \\
\TT{\'e}
  & \TT{E9} & \TT{e'} & Latin Small Letter E With Acute \\
\TT{\^e}
  & \TT{EA} & \TT{e\textasciicircum} & Latin Small Letter E With Circumflex \\
\TT{\"e}
  & \TT{EB} & \TT{e"} & Latin Small Letter E With Diaeresis \\
\TT{\`{\i}}
  & \TT{EC} & \TT{i\`~} & Latin Small Letter I With Grave \\
\TT{\'{\i}}
  & \TT{ED} & \TT{i'} & Latin Small Letter I With Acute \\
\TT{\^{\i}}
  & \TT{EE} & \TT{i\textasciicircum} & Latin Small Letter I With Circumflex \\
\TT{\"{\i}}
  & \TT{EF} & \TT{i"} & Latin Small Letter I With Diaeresis \\
\TT{\dh}
  & \TT{F0} & \TT{dh} & Latin Small Letter ETH \\
\TT{\~n}
  & \TT{F1} & \TT{n\textasciitilde} & Latin Small Letter N With Tilde \\
\TT{\`o}
  & \TT{F2} & \TT{o\`~} & Latin Small Letter O With Grave \\
\TT{\'o}
  & \TT{F3} & \TT{o'} & Latin Small Letter O With Acute \\
\TT{\^o}
  & \TT{F4} & \TT{o\textasciicircum} & Latin Small Letter O With Circumflex \\
\TT{\~o}
  & \TT{F5} & \TT{o\textasciitilde} & Latin Small Letter O With Tilde \\
\TT{\"o}
  & \TT{F6} & \TT{o"} & Latin Small Letter O With Diaeresis \\
\TT{\textdiv}
  & \TT{F7} & \TT{-:} & Division Sign \\
\TT{\o}
  & \TT{F8} & \TT{o/} & Latin Small Letter O With Stroke \\
\TT{\`u}
  & \TT{F9} & \TT{u\`~} & Latin Small Letter U With Grave \\
\TT{\'u}
  & \TT{FA} & \TT{u'} & Latin Small Letter U With Acute \\
\TT{\^u}
  & \TT{FB} & \TT{u\textasciicircum} & Latin Small Letter U With Circumflex \\
\TT{\"u}
  & \TT{FC} & \TT{u"} & Latin Small Letter U With Diaeresis \\
\TT{\'y}
  & \TT{FD} & \TT{y'} & Latin Small Letter Y With Acute \\
\TT{\th}
  & \TT{FE} & \TT{th} & Latin Small Letter Thorn \\
\TT{\"y}
  & \TT{FF} & \TT{y"} & Latin Small Letter Y With Diaeresis \\
\end{tabular}
\caption{LATIN1 Characters: Part III}
\label{LATIN1-CHARACTERS-III}
\end{boxedfigure}

\newpage

\subsubsection{UNICODE Support Control}
\label{UNICODE-SUPPORT-CONTROL}

The inline function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|inline min::uns32 min::| & \MINKEY{char\_flags}\ARGBREAK
      \verb|( const min::uns32 * char_flags,|\ARGBREAK
      \verb|  min::support_control sc,|\ARGBREAK
      \verb|  min::Uchar c )|
\LABEL{MIN::CHAR_FLAGS} \\
\end{tabular}\end{indpar}

returns the \skey{character flag}s \TT{cflags} of the UNICODE character
\TT{c} according to the algorithm:

\begin{indpar}\begin{verbatim}
min::uns16 cindex = min::Uindex ( c );
min::uns32 cflags = char_flags[cindex];
if ( ( cflags & sc.support_mask ) == 0 )
    cflags = sc.unsupported_char_flags;
return cflags;
\end{verbatim}\end{indpar}

The function uses the \TT{char\_flags} vector (\pagref{CHARACTER-FLAGS})
and a support control structure \TT{sc} with the format:

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct     min::| & \MINKEY{support\_\EOL control}
\LABEL{MIN::SUPPORT_CONTROL_STRUCT} \\
\verb|{               | \\
\verb|     min::uns32 |
	& \TTMKEY{support\_mask}{in {\tt min::support\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{unsupported\_char\_flags}{in {\tt min::support\_control}} \\
\verb|}               | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\multicolumn{2}{l}{\tt const min::uns32
    min::\MINKEY{ALL\_CHARS} = \TT{0xFFFFFFFF}}
\LABEL{MIN::ALL_CHARS} \\
\multicolumn{2}{l}{\tt const min::support\_control
    min::\MINKEY{ascii\_support\_control} =}\ARGBREAK[1.0in]
	\verb|{ min::IS_ASCII, min::IS_UNSUPPORTED };|
\LABEL{MIN::ASCII_SUPPORT_CONTROL} \\
\multicolumn{2}{l}{\tt const min::support\_control
    min::\MINKEY{latin1\_support\_control} =}\ARGBREAK[1.0in]
	\verb|{ min::IS_LATIN1 + min::IS_ASCII, min::IS_UNSUPPORTED };|
\LABEL{MIN::LATIN1_SUPPORT_CONTROL} \\
\multicolumn{2}{l}{\tt const min::support\_control
    min::\MINKEY{support\_all\_support\_control} =}\ARGBREAK[1.0in]
	\verb|{ min::ALL_CHARS, min::IS_UNSUPPORTED };|
\LABEL{MIN::SUPPORT_ALL_SUPPORT_CONTROL} \\
\end{tabular}\end{indpar}

Both \TT{char\_flags} and \TT{sc} are typically elements of
\TT{printer->\EOL print\_\EOL format} for the printer being used.


\subsubsection{String Classifiers}
\label{STRING-CLASSIFIERS}

A \key{string classifier} is a function that inputs a string and
outputs a set of flags that can be used to determine whether the
string must be quoted, if it is a separator and whether it is
leading or trailing, and if the string is a mark that can be used as a type.

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|typedef min::uns32 ( * min::| & \MINKEY{str\_classifier}
                                      \verb| )|\ARGBREAK
      \verb|( const min::uns32 * char_flags,|\ARGBREAK
      \verb|  min::support_control sc,|\ARGBREAK
      \verb|  min::unsptr n,|\ARGBREAK
      \verb|  min::ptr<const min::Uchar> p )|
\LABEL{MIN::STR_CLASSIFIER} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|const min::str_classifier min::| & \MINKEY{standard\_str\_classifier}
\LABEL{MIN::STANDARD_STR_CLASSIFIER} \\
\verb|const min::str_classifier min::|
    & \MINLKEY{quote\_separator}{\_str\_classifier}
\LABEL{MIN::QUOTE_SEPARATOR_STR_CLASSIFIER} \\
\verb|const min::str_classifier min::|
    & \MINLKEY{quote\_separator\_and\_mark}{\_str\_classifier}
\LABEL{MIN::QUOTE_SEPARATOR_AND_MARK_STR_CLASSIFIER} \\
\verb|const min::str_classifier min::| & \MINKEY{quote\_all\_str\_classifier}
\LABEL{MIN::QUOTE_ALL_STR_CLASSIFIER} \\
\verb|const min::str_classifier min::| & \MINKEY{null\_str\_classifier}
\LABEL{MIN::NULL_STR_CLASSIFIER} \\
\end{tabular}\end{indpar}

The flags returned by the string classifier are used by the printer
to make printing decisions as follows:

\begin{indpar}\begin{tabular}{p{1.5in}@{~~~}p{4.0in}}
no flags (0 returned)	& The string is used just for formatting and
                          contains no graphic characters.  In some contexts the
			  string is printed as is and in others it is
			  quoted.

			  ~~
			  
			  For \TT{min::\EOL standard\_\EOL str\_\EOL classifier}
			  no flags are returned if the string is empty
			  or contains only characters which have the
			  \TT{IS\_\EOL VHSPACE} flag, and does not contain
			  any characters with the \TT{NEEDS\_\EOL QUOTES}
			  flag.
\label{NO_FLAGS_CLASSIFIER} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{p{1.5in}@{~~~}p{4.0in}}
\TT{min::NEEDS\_QUOTES}	& The string needs to be quoted.

			  ~~

			  For \TT{min::\EOL standard\_\EOL str\_\EOL classifier}
			  this is returned if the string:
			  \begin{enumerate}
			  \item
			  contains any character with the
			  \TT{NEEDS\_\EOL QUOTES} flag
			  \item
			  contains a character that does not
			  have the \TT{IS\_\EOL GRAPHIC} flag and a (possibly
			  different) character that does not have the
			  \TT{IS\_\EOL VHSPACE} flag
			  \item
			  \underline{all} of the following are true:
			  \begin{enumerate}
			  \item The first string character has the
			  \TT{IS\_\EOL LEADING} flag,
			  or the last string character has the
			  \TT{IS\_\EOL TRAILING} flag,
			  or any string character has the
			  \TT{IS\_\EOL SEPARATOR} flag
			  \item there is more than one character in the
			  string
			  \item not all characters in the string are identical
			  or the string character does not have the
			  \TT{IS\_\EOL REPEATER} flag.
			  \end{enumerate}
			  \end{enumerate}
\label{NEEDS_QUOTES_CLASSIFIER} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{p{1.5in}@{~~~}p{4.0in}}
\TT{min::IS\_GRAPHIC}	& Unless the \TT{NEEDS\_QUOTES} flag is present,
                          the string should be printed unquoted and may be
                          immediately preceded by leading separators or
			  immediately followed
			  by trailing separators.  Separators also have
			  this flag.

			  ~~

			  For \TT{min::\EOL standard\_\EOL str\_\EOL classifier}
			  this is returned for strings all of whose characters
			  have the \TT{IS\_\EOL GRAPHICS} flag.
\label{IS_GRAPHIC_CLASSIFIER} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{p{1.5in}@{~~~}p{4.0in}}
\TT{min::IS\_LEADING}	& The string is a leading separator.

			  ~~

			  For \TT{min::\EOL standard\_\EOL str\_\EOL classifier}
			  this is returned for strings all of whose characters
			  have the \TT{IS\_\EOL LEADING} flag.
\label{IS_LEADING_CLASSIFIER} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{p{1.5in}@{~~~}p{4.0in}}
\TT{min::IS\_TRAILING}	& The string is a trailing separator.

			  ~~

			  For \TT{min::\EOL standard\_\EOL str\_\EOL classifier}
			  this is returned for strings all of whose characters
			  have the \TT{IS\_\EOL TRAILING} flag.
\label{IS_TRAILING_CLASSIFIER} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{p{1.5in}@{~~~}p{4.0in}}
\TT{min::IS\_MARK}	& The string is a mark, and as such can be
                          used as the type of a bracketed expression
			  that can be output in compact form.

			  ~~

			  For \TT{min::\EOL standard\_\EOL str\_\EOL classifier}
			  this is returned for strings all of whose characters
			  have the \TT{IS\_MARK} flag.
\label{IS_MARK_CLASSIFIER} \\
\end{tabular}\end{indpar}

The \minlkey{quote\_separator}{\_str\_classifier} is just like the
\TT{min::\EOL standard\_\EOL str\_\EOL class\-ifier} except that
it adds the \TT{min::\EOL NEEDS\_\EOL QUOTES} flag if the
result has any of the
\TT{min::\EOL IS\_\EOL SEPARATOR},
\TT{min::\EOL IS\_\EOL LEADING}, or
\TT{min::\EOL IS\_\EOL TRAILING} flags.

The \minlkey{quote\_separator\_and\_mark}{\_str\_classifier} is just like the
\TT{min::\EOL quote\_\EOL sep\-arator\_\EOL str\_\EOL classifier} except that
it adds the \TT{min::\EOL NEEDS\_\EOL QUOTES} flag if the
result has the \TT{min::\EOL IS\_\EOL MARK} flag.

The \minkey{quote\_all\_str\_classifier} always returns just the
\TT{min::\EOL NEEDS\_\EOL QUOTES} flag.

The \minkey{null\_str\_classifier} is used when printing with a
\TT{min::str\_\EOL format} that is \TT{NULL} and returns 0 if all characters
in the string have the \TT{IS\_\EOL VHSPACE} flag, and just
\TT{min::\EOL IS\_\EOL GRAPHIC} otherwise.


\subsubsection{UNICODE Strings}
\label{UNICODE-STRINGS}

Constant \skey{UNICODE string}s can be represented
as \TT{min::\EOL ustring}\ttindex{ustring}\label{USTRING} values
which are sequences of 8 bit bytes.  The first two bytes,
called the \mkey{header}{of {\tt ustring}},
hold the length of the string (not counting the header)
in the first byte, and the number of print columns the string will take
if the string is all graphics,
in the second byte.  The remainder of the bytes
constitute a `\TT{const char *}' value that is the Modified UTF-8 encoded,
NUL-terminated, string itself.

Importantly \TT{ustring} values are pointers into
\underline{unrelocatable}
memory.  It is intended that \TT{ustrings} be used as parametric values in
printing formats, as character names and pictures, etc.

The following are for programming with \TT{ustring}'s:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef const min::uns8 * min::| & \MINKEY{ustring}
\LABEL{MIN::USTRING} \\
\verb|min::uns32 min::|
    & \MINKEY{ustring\_length} \verb|( min::ustring s )|
\LABEL{MIN::USTRING_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{ustring\_columns} \verb|( min::ustring s )|
\LABEL{MIN::USTRING_COLUMNS} \\
\verb|const char * min::|
    & \MINKEY{ustring\_chars} \verb|( min::ustring s )|
\LABEL{MIN::USTRING_CHARS} \\
\end{tabular}\end{indpar}

The \TT{min::ustring\_\EOL length} function returns the number
of \TT{char}'s in the \TT{const char *} string within the \TT{ustring}
(not including the terminating \TT{NUL}); the maximum is 63.
The \TT{min::ustring\_\EOL columns} function returns the number
of print columns these take; the maximum is 63.

\subsubsection{UNICODE Name Tables}
\label{UNICODE-NAME-TABLES}

A \key{UNICODE name table} can be used to look up a UNICODE
character given its name.  For most characters the name is that
given by \TT{min::\EOL unicode::\EOL name} (\pagref{MIN::UNICODE::NAME}),
but other names may be associated with characters.

UNICODE name tables have the type

\begin{indpar}[1em]\begin{tabular}{r@{}l}
(type) \verb|min::| & \MINKEY{unicode\_name\_table}
\LABEL{MIN::UNICODE_NAME_TABLE} \\
\end{tabular}\end{indpar}

whose implementation is hidden.  The tables may be created and
read using the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{{\tt min::unicode\_name\_table
                        min::}\MINKEY{init\REL}}\ARGBREAK
    \verb|( min::ref<min::unicode_name_table> table,|\ARGBREAK
    \verb|  const min::uns32 * char_flags =|\ARGBREAK
    \verb|            min::standard_char_flags,|\ARGBREAK
    \verb|  min::uns32 flags = min::ALL_CHARS,|\ARGBREAK
    \verb|  min::uns32 extras = 10 )|
\LABEL{MIN::INIT_OF_UNICODE_NAME_TABLE} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{add}\ARGBREAK
    \verb|( min::unicode_name_table table,|\ARGBREAK
    \verb|  const char * name,|\ARGBREAK
    \verb|  min::Uchar c,|\ARGBREAK
    \verb|  bool replace_allowed = false )|
\LABEL{MIN::ADD_OF_UNICODE_NAME_TABLE} \\
\verb|min::Uchar min::| & \MINKEY{find}\ARGBREAK
    \verb|( min::unicode_name_table table,|\ARGBREAK
    \verb|  const char * name)|
\LABEL{MIN::FIND_OF_UNICODE_NAME_TABLE} \\
\end{tabular}\end{indpar}

The \TT{min::init} function creates a hash table
if the \TT{table} argument equals \TT{min::\EOL NULL\_\EOL STUB},
and sets this argument to the new hash table.  If the table
already exists, the function and does nothing.  

If the table is created, the \TT{min::\EOL unicode::\EOL name}
name of a character is added to the table if its flags,
as given by the \TT{char\_\EOL flags} argument,
have a flag in common with the \TT{flags} argument.
Additionally extra space is reserved for later adding character
names to the table, as long as the number of names added later
does not exceed the value of the \TT{extras} argument.
The default arguments to \TT{min::\EOL init} add all names
in the \TT{min::\EOL unicode::\EOL name} data base and reserve
space for adding 10 additional names.

The \TT{min::add} function adds \TT{name} to the table, mapping
it to the character \TT{c}.  It is a programming error if
\TT{name} is already mapped to a \underline{different} character and
the \TT{replace\_\EOL allowed} argument is \TT{false}, or if
more names are added than allowed by the \TT{extras} argument
to \TT{min::\EOL init} (this latter error may not be detected
and may result in inefficient lookup).
If \TT{replace\_\EOL allowed} is \TT{true} and \TT{name} is
already mapped to a different character, the table is changed
so \TT{name} maps to \TT{c}.

The \TT{min::find} function looks up \TT{name} in the table
and returns the character it maps to.  \TT{min::\EOL NO\_\EOL UCHAR}
is returned if the name is not in the table.

\subsection{Numbers}
\label{NUMBERS}

A \key{number stub} is collectible, has \minkey{NUMBER}\LABEL{MIN::NUMBER}
stub type code, and has
an immutable \TT{min::float64} stub value that can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT} \verb|( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{tabular}\end{indpar}

Number stubs exist only in compact implementations;
in loose implementations number atoms are stored exclusively
in direct number general values
(\itemref{GENERAL-VALUE-SUBTYPES}).

General values that are numbers can be tested, created, and read
by the following protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_num} \verb|( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of} \verb|( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of} \verb|( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash} \verb|( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\end{tabular}\end{indpar}

The \TT{min::is\_num} function for a loose 64-bit \TT{min::gen} argument
is just another name for the \TT{min::is\_direct\_float} function of the same
argument.  For a compact 32-bit \TT{min::gen} argument the function returns
true if the argument is a direct integer or a stub pointer
pointing at a number stub.

The \TT{min::new\_num\_gen} function with \TT{min::float64} argument
and loose 64-bit \TT{min::gen} value
is just another name for \TT{min::new\_\EOL direct\_\EOL gen}, which
simply changes the type of its argument.
The \TT{min::new\_num\_gen} function with \TT{min::float64} argument
and compact 32-bit \TT{min::gen} value creates a direct integer
if the argument is an integer in the
require range; otherwise the function returns a \TT{min::gen} value
that is a pointer to a number stub.  If a pointer to a number stub is
to be returned and a number stub containing the argument value already exists,
a pointer to the existing stub is returned;
otherwise a new number stub is created and a pointer to it returned.
Therefore two 32-bit \TT{min::gen} values that represent equal numbers are
themselves \TT{==}.

The \TT{min::new\_num\_gen} function with an \TT{int} or \TT{min::unsptr}
argument does the
same thing as it would with its argument converted to a \TT{min::float64}
value, but is more efficient in the case where \TT{min::gen} values
are 32 bits and the argument is in the range of a direct integer general
value.

The \TT{min::float\_of} function for a loose 64-bit \TT{min::gen}
argument is just another name for the \TT{min::direct\_float\_of} function
of the same argument, which after checking the subtype of the argument,
simply changes the type of the argument.
For a compact 32-bit \TT{min::gen} argument the
function returns any integer stored directly
in the argument converted to a 64-bit IEEE floating point number, or
returns the stub value for any number stub pointed at by the argument.
In this last case the stub type code is checked by a \TT{MIN\_ASSERT}
statement to be sure the stub is a number stub.

The \TT{min::int\_of} function does the same thing as the
\TT{min::float\_of} followed by conversion to an \TT{int} value,
except that \TT{min::int\_of} includes a check that the result
is a pure integer, without any fractional part, and is within the
range of the \TT{int} type, and
\TT{min::int\_of} is more efficient when given a 32-bit direct integer
\TT{min::gen} argument.

Lastly, the \TT{min::numhash} function
returns the hash value of a \TT{min::gen}
value that is a number.  This value is computed by considering
the \TT{min::float\_of} value of the number
to be a \underline{big endian} string of 8 characters and using the algorithm
on \pagref{HASH-ALGORITHM} to compute the hash value of this string.%
\label{NUMBER-HASH-ALGORITHM}

To permit hash values of arbitrary floating point numbers to be computed,
the following function is provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{floathash} \verb|( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{tabular}\end{indpar}

The above \TT{min::float\_of}, \TT{min::int\_of}, and \TT{min::numhash}
functions of a \TT{min::gen} argument apply \TT{MIN\_ASSERT} to check
that their argument is a number.  The following unprotected function assumes
that its argument is a number without doing any \TT{MIN\_ASSERT} check:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN}
\end{tabular}\end{indpar}

\subsection{Strings}
\label{STRINGS}

In MIN all \skey{string}s\index{strings@strings}
are \TT{NUL} terminated UTF-8 encoded UNICODE character strings.
\key{UTF-8} encodes 32-bit UNICODE characters in 1 to 7 \TT{char}'s.

All ASCII characters are encoded as themselves in
the UTF-8 encoding.  This implies that
all ASCII character strings are UTF-8 encoded character
strings with the same characters as their ASCII representation indicates.%
\footnote{ASCII character codes range from 0 through 127.  UTF-8 extends
this by assigning meaning to codes from 128 to 255.}

It is possible for a string to be miscoded UTF-8.  Unless otherwise
mentioned, the functions given below, including the protected functions,
do \underline{not} check for this.

A MIN string value cannot store the \TT{NUL} character as legal UTF-8.
But it is possible to use the `\key{modified UTF-8}'
\label{MODIFIED-UTF-8} encoding instead of
strict UTF-8.  The difference is that strict UTF-8 encodes the NUL
character in a single byte as an ASCII NUL, whereas modified UTF-8
encodes the \TT{NUL} character as the `overlong' 2-byte string `\TT{0xC0,0x80}'
(which is not legal in strict UTF-8 because it is not the shortest
possible encoding of \TT{NUL} in UTF-8).

There are two kinds of string stubs: short strings and long strings.
In addition, a string of up to 3 \TT{char}'s can be stored within a 32-bit
\TT{min::gen} value, and a string of up to 5 \TT{char}'s can be stored
within a 64-bit \TT{min::gen} value,
without using a stub
(see \itemref{GENERAL-VALUE-SUBTYPES} and
\itemref{GENERAL-VALUE-FUNCTIONS}).
Such strings are called \skey{direct string}s, while strings stored in
stubs or bodies which are pointed at by \TT{min::gen} values,
the short and long strings, are called \skey{indirect string}s.
A short string holds up to 8 characters inside the string stub
(there must be more characters than a direct string will hold).
A long string has an string body that holds the string characters
(there must be more than 8)
along with the string length and hash value.

All three kinds of strings, direct, short, and long, are immutable
and have hash values (\pagref{HASH-VALUE}).

\subsubsection{Protected String Functions}
\label{PROTECTED-STRING-FUNCTIONS}

There are protected functions accessing general values that denote
strings of any kind without distinction, and these are described next.
Unprotected functions that apply only to particular
types of string are described later in
Section~\itemref{UNPROTECTED-STRING-FUNCTIONS}.

The following functions create new general string values:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( min::ptr<const char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}
	 \verb|( min::ptr<const char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}  \verb|( min::ptr<char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}
	 \verb|( min::ptr<char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_WITH_N} \\
\end{tabular}\end{indpar}

The \TT{min::new\_str\_gen} functions copy the input string after the
manner of \TT{strcpy} and \TT{strncpy}, respectively.  That is,
they copy from \TT{p}
until a \TT{NUL} is copied or \TT{n} characters have been copied, whichever
comes first.  The forms with a \TT{min::ptr<const char>}
or \TT{min::ptr<char>}
argument are for use when the input string is part of a relocatable body.
Because \TT{min::ptr<char>} is not implicitly cast-able to
\TT{min::ptr<const char>}, both types are argument are provided for.

When a string general value is created,
\label{STRING-CREATION}
if the input string is short enough for the general value
to hold the string itself, a direct string general value is created.
Otherwise \TT{min::new\_str\_gen} searches to see if any equal string
exists.  If such a string exists, a pointer to the stub of the existing
string is returned in the new \TT{min::gen} value, and no new stub
is created.  Otherwise, if the input string is 8 or fewer \TT{char}'s,
a short string stub is created, and if the input string has more
than 8 \TT{char}'s, a long string stub and body are created.

Thus if two string \TT{min::gen} values are equal as
strings, they have \TT{==~min::gen} values.

There are also functions to create a new general string values from
vectors of UNICODE characters:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( const min::Uchar * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<const min::Uchar> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_CONST_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<min::Uchar> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_UNICODE} \\
\end{tabular}\end{indpar}

The following functions test a \TT{min::gen} value to see if it
is a string and obtain information from
a string \TT{min::gen} value.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\[1ex]
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy} \verb|( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::|
    & \MINKEY{strncpy} \verb|( char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\[1ex]
\verb|int min::| & \MINKEY{strcmp} \verb|( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::|
    & \MINKEY{strncmp} \\
    & \verb|    ( const char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\verb|min::uns64 min::| & \MINKEY{strhead} \verb|( min::gen v )|
\LABEL{MIN::STRHEAD_OF_GEN} \\
\end{tabular}\end{indpar}

Five of these functions correspond to the standard C/C++
\TT{strlen}, \TT{strcpy}, \TT{strncpy}, \TT{strcmp},
and \TT{strncmp} functions, and differ
from these only in that instead of taking a \TT{char *} source string
argument, these functions take a \TT{min::gen} source argument.

The \TT{is\_str} function simply returns true if and only if
its argument is a string.

The \TT{strhead} function is an optimized function that
returns the first 8 bytes of the string
in a \TT{min::uns64} value.  This is intended to be used by
overloading it with \TT{min::uns8[8]}, as in the code:

\begin{indpar}\begin{verbatim}
union { min::uns64 u; min::uns8 s[8]; } v;
min::gen g;
. . . set g to a string value . . .
v.u = min::strhead ( g );
. . . first 8 bytes of string are now in v.s[0], ..., v.s[7] . . .
\end{verbatim}\end{indpar}

If a string has fewer than 8 bytes, it is padded with zero bytes
at its end so that 8 bytes may always be returned.  If the \TT{min::gen}
argument to \TT{strhead} is not a string, 8 zero bytes are returned
(as if the argument had been an empty string).

\TT{strhead} is useful for testing
to see what kind of lexeme the string represents; for
example, if the first byte is a letter, or the first byte is \TT{'}
and the second byte is a letter, then the string may represent a
word, but if the first byte is \TT{'} and the second is zero,
the string may represent a separator.
Note that the bytes are UTF-8 encoded, and may represent non-ASCII
UNICODE characters.  Note that UTF-8 can encode a UNICODE character
in as many as 7 bytes, so if the string begins with two non-ASCII
characters, the encoding of the second may be truncated.

To permit hash values of arbitrary strings to be computed,
without creating \TT{min::gen} values from them first,
the following functions are provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash} \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{tabular}\end{indpar}

Both \TT{strhash} and \TT{strnhash} accept \TT{NUL} terminated strings, but
\TT{strnhash} stops reading the string after the first \TT{n} characters
if none of these characters is NUL.

A string hash value is computed according to the following machine
independent algorithm:\label{HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = 0
n = length of string
for i = 1 through n:
    c = i'th char of string as unsigned 8 bit integer
    hash = ( hash * 65599 ) + c
if hash = 0, then hash = 2**32 - 1
\end{verbatim}\end{indpar}

where the final result is truncated to 32 bits.  The constant
is a prime such that multiplication by it may be turned into
shifts and adds by compilers: $65599=2^{16}+2^6-1$.
A hash value is never zero (so zero can be used to denote a missing hash value).

The low order bits of the hash value are random, so it can be
truncated to provide a random hash.

The following functions can be used to convert \TT{min::gen}
string values to numbers:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int32 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_INT32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int64 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_INT64} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns32 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_UNS32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns64 & value, min::gen g, int base = 0 )|
\LABEL{MIN::STRTO_UNS64} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float32 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT32} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float64 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT64} \\
\end{tabular}\end{indpar}

If the \TT{min::gen} argument is a
string consisting of a space surrounded number legal to the UNIX
\TT{strtol}, \TT{strtoll},
\TT{strtoul}, or \TT{strtoull} functions with given \TT{base} argument,
or to the UNIX
\TT{strtof}, or \TT{strtoud} functions, respectively,
\TT{true} is returned and the number is returned in the \TT{value}
argument.  Otherwise \TT{false} is returned and the \TT{value}
argument is left untouched.  This includes the case where the
\TT{min::gen} argument is not a string, the case where the
\TT{base} argument does not have a legal value,
and the case where the number that might be returned would be
outside the range of
numbers storable in the \TT{value} argument.

\subsubsection{Protected String Pointers}
\label{PROTECTED-STRING-POINTERS}

A read-only pointer to the characters of a string \TT{min::gen} value can
be obtained using the following functions to create and use
a \key{string pointer}:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MIN::STR_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MIN::STR_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp, min::gen v )|
\LABEL{MIN::=_STR_PTR_OF_GEN} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1, min::str_ptr const & sp2 )|
\LABEL{MIN::=_STR_PTR_OF_STR_PTR} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1, const min::stub * s )|
\LABEL{MIN::=_STR_PTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|operator |
    & \MINKEY{bool} \verb|( min::str_ptr const & sp )|
\LABEL{BOOL_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|char sp|
    & \TTBMKEY{i}{of {\tt min::str\_ptr}} --- for \TT{min::unsptr i}
\LABEL{MIN::[]_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<const char> min::|
    & \MINMKEY{begin\_ptr\_of}{{\tt str\_ptr}}
      \verb|( min::str_ptr const & sp )|
\LABEL{MIN::BEGIN_PTR_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::str_ptr const & sp )|
\LABEL{MIN::STRLEN_OF_STR_PTR} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::str_ptr const & sp )|
\LABEL{MIN::STRHASH_OF_STR_PTR} \\[1ex]
\verb|char * min::|
    & \MINKEY{strcpy} \verb|( char * p, min::str_ptr const & sp )|
\LABEL{MIN::STRCPY_OF_STR_PTR} \\
\verb|char * min::|
    & \MINKEY{strncpy}\ARGBREAK
      \verb|( char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_STR_PTR} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp} \verb|( const char * p, min::str_ptr const & sp )|
\LABEL{MIN::STRCMP_OF_STR_PTR} \\
\verb|int min::|
    & \MINKEY{strncmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_STR_PTR} \\[1ex]
\end{tabular}\end{indpar}

The constructors create a string pointer pointing to the \TT{char}'s
of the string specified by the \TT{min::gen} or
`\TT{min::stub *}' argument.  A \TT{min::gen} argument
should be a direct string or a pointer to a short or long string stub,
and a stub pointer should be a pointer to a short or long string stub.
If the arguments are not, then the string pointer is set to the
\TT{NULL} state in which using it to access the string will almost
certainly cause a memory fault.  The constructor with no argument also
sets the string pointer to the \TT{NULL} state.  The operator to
convert a string pointer to a \TT{bool} returns \TT{true} if the
string pointer is \underline{not} in the \TT{NULL} state, and \TT{false}
if the string pointer \underline{is} in the \TT{NULL} state.

The \TT{=} operator can reset the string
pointer to point at a different \TT{min::gen} value, or at a stub,
or at the
value pointed at by another string pointer.  Like the constructor,
the string pointer is set to the \TT{NULL} state
if the \TT{min::gen} value or stub pointer is not a string,
or the string pointer being assigned from is itself in the \TT{NULL} state.

The \TT{strlen}, \TT{strhash}, \TT{strcpy}, \TT{strncpy},
\TT{strcmp}, and \TT{strncmp} functions retrieve the same information
about the string pointed at by a string pointer as they retrieve about
the string value the pointer points at.

The \TT{min::begin\_ptr\_of} function
returns a \TT{min::ptr<const char>} pointer to
the \TT{NUL}-termin\-at\-ed vector of \TT{char}'s that is the string.
Its value can be converted to a `\TT{const char *}' by the unitary
`\TT{\textasciitilde}' operator, and that value
may be passed to the \TT{strcpy}, \TT{strcmp}, \ldots{}
C library functions.

\TT{sp[i]} can be used to access the \TT{i+1}'st character of
the \TT{NUL}-terminated string.
There is no protection against the operator index
being longer than the string length.

For direct and short strings the string pointer, when it is created,
copies the string \TT{char}'s into a buffer internal to the string pointer,
in order to save the \TT{char}'s in a direct string value, or to
add a missing \TT{NUL} to the end of the short string \TT{char} vector.
In long string cases no copying is done, and the string pointer
is essentially just a pointer to the string stub, which in turn points
at the string proper inside a relocatable string body.

Numbers can be read from a string pointed at by a string
pointer by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT64_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns64 & value,|\ARGBREAK
	\verb|  min::str_ptr & const sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS64_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float32 & value,|\ARGBREAK
	\verb|  min::str_ptr & const sp, min::unsptr & i )|
\LABEL{MIN::STRTO_FLOAT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float64 & value,|\ARGBREAK
	\verb|  min::str_ptr & const sp, min::unsptr & i )|
\LABEL{MIN::STRTO_FLOAT64_OF_STR_PTR} \\
\end{tabular}\end{indpar}

If the string pointer is not in the \TT{NULL} state and
the part of the string beginning with \TT{sp[i]} is
space followed by a number legal to the UNIX
\TT{strtol}, \TT{strtoll},
\TT{strtoul}, or \TT{strtoull} functions with the given
\TT{base} argument, or to the UNIX
\TT{strtof}, or \TT{strtoud} functions, respectively,
\TT{true} is returned, the number is returned in the
\TT{value} argument, and the \TT{i} argument is updated to point
just after the number.  Otherwise \TT{false} is returned and
\TT{value} and \TT{i} are left untouched.  This includes the
case where the string pointer is in the \TT{NULL} state,
the case where the \TT{base} argument does not have a legal value,
and the case where the number that might be returned would be
outside the range of
numbers storable in the \TT{value} argument.

\subsubsection{Unprotected String Functions}
\label{UNPROTECTED-STRING-FUNCTIONS}

The following unprotected
function is equivalent to \TT{min::begin\_ptr\_of()} with its
result cast to `\TT{const char *}':

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( min::str_ptr const & sp )|
\LABEL{MUP::STR_OF_STR_PTR} \\
\end{tabular}\end{indpar}

However, note that the pointer returned is relocatable, so this function
is unprotected.

The following unprotected functions
may be used to access the internals of short
and long strings.

A \key{short string stub}\label{SHORT-STRING-STUB} is collectible, has
\minkey{SHORT\_STR}\LABEL{MIN::SHORT_STR} stub type code, and has
an immutable \TT{min::\EOL uns64} stub value that holds a \TT{NUL} padded
8 \TT{char} vector and can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::|
    & \MUPKEY{short\_str\_of} \verb|( const min::stub * s )|
\LABEL{MUP::SHORT_STR_OF}
\end{tabular}\end{indpar}

This function does \underline{not} check the type of the stub \TT{s}.
The \TT{min::uns64} value returned by \MUPkey{short\_str\_of}
should be overlaid by a union with a \TT{char[~]} buffer, as in

\begin{indpar}\begin{verbatim}
union { min::uns64 str; char buf[9]; } u;
min::stub * s1;
. . . set s1 to point at a short string stub . . .
u.str = MUP::short_str_of ( s1 );
u.buf[8] = 0;	// Be sure result is NUL terminated.
cout << u.buf;
\end{verbatim}\end{indpar}

Short string values are \TT{NUL} (zero) padded 0 to 8 \TT{char}
strings.  To be sure any value read is \TT{NUL} terminated, a \TT{NUL} (zero)
must be stored after the value read, as is done by \TT{u.buf[8] = 0}
in the example.  Of course, short string values have more
characters than can be stored in a direct string
(\pagref{STRING-CREATION}).

A \key{long string stub}\label{LONG-STRING-STUB} is collectible, has
\minkey{LONG\_STR}\LABEL{MIN::LONG_STR} stub type code, and has
a value that is a pointer to a \MUPkey{long\_str} type body
which holds an arbitrary length \TT{NUL} terminated \TT{char} string.

The long string body consists of the 32-bit length and 32-bit hash value
of the string, followed by a \TT{char}
vector containing the string proper with the terminating NUL.  The
\TT{char} vector is padded to a multiple of 8 bytes with NUL
bytes, but the terminating \TT{NUL} and the padding are not included
in the length.  The length is larger than 8.

The following are unprotected functions to return a relocatable pointer to the
long string body, a relocatable pointer to the string itself,
and the length and hash of the string.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of} \verb|( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{tabular}\end{indpar}

These functions are unprotected because \TT{long\_str *} pointers
are relocatable.


\subsection{Labels}
\label{LABELS}

Object attribute labels
(see Section~\itemref{OBJECT-ATTRIBUTE-LEVEL})
are often atoms, i.e., single strings or numbers.
But they may be sequences of atoms.  Such sequences are represented by
\skey{label}s.\footnote{Labels could also be represented by
sublists stored inside objects (\pagref{LIST-LEVEL}), but each label tends to
be reused by many objects, and storing it inside each using object
would be inefficient.  In addition labels are useful as function arguments.}
Labels may also be elements of other labels.

A label is just a vector of name components, where a name
component is an atom or a label.  Labels are immutable and
have the property that no two distinct label stubs can have equal vectors of
name components.  

Note that a label of one element
is distinct from the element itself and has a different
hash code.  Also note that labels can be elements of labels.  A programming
language may wish to require that the elements of labels be numbers or
strings, that numbers and strings be treated as labels of one element,
and that proper labels with zero or one element not be created.  But the
\TT{min.h} code does not do this.

A \key{label stub}\label{LABEL-STUB} is collectible,
has \minkey{LABEL}\LABEL{MIN::LABEL} stub type code,
and has an immutable value.
The label value may be read by using \TT{min::\EOL lab\_\EOL ptr}'s:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr} \verb|labp ( min::gen v )|
\LABEL{MIN::LAB_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr} \verb|labp ( const min::stub * s )|
\LABEL{MIN::LAB_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr} \verb|labp ( void )|
\LABEL{MIN::LAB_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt min::lab\_ptr}}\ARGBREAK
          \verb|( min::lab_ptr const & labp )|
\LABEL{MIN::LAB_PTR_TO_MIN_STUB} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp, min::gen v )|
\LABEL{MIN::=_LAB_PTR_OF_GEN} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp, const min::stub * s )|
\LABEL{MIN::=_LAB_PTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen labp|
    & \TTBMKEY{i}{of {\tt min::lab\_ptr}} --- for \TT{min::uns32 i}
\LABEL{MIN::[]_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<const min::gen> min::|
	& \MINMKEY{begin\_ptr\_of}{{\tt lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINMKEY{end\_ptr\_of}{{\tt lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

Here if \TT{v} or \TT{s} do not point at the stub of a label
the new label pointer is set to \TT{min::\EOL NULL\_\EOL STUB},
but this is not in an of itself an error.  The resulting
\TT{min::\EOL lab\_\EOL ptr} can be tested to see if it is \TT{==}
to \TT{min::\EOL NULL\_\EOL STUB}.  Using such a pointer to access
parts of a label, however, gives undefined results,
but usually a memory fault.
The no-argument label
pointer constructor also creates a label pointer equal to
\TT{min::\EOL NULL\_\EOL STUB}, and the \TT{=} operators
set a label pointer just as a constructor with the \TT{=} right side
as the constructor argument would.

Given a label pointer \TT{labp} pointing at a real label,
\TT{labp[i]} is the \TT{i+1}'st
element of the label, for
\TT{0<i<min::lablen(labp)},
where the \TT{min::\EOL lablen} function
returns the number of elements in the label.
The \TT{min::\EOL labhash} function returns the hash of the label.

The \TT{min::\EOL begin\_\EOL ptr\_\EOL of} and
\TT{min::\EOL end\_\EOL ptr\_\EOL of}
functions return \TT{min::\EOL ptr<const min::\EOL gen>} values that
point at the first label element and the location just after the
last label element, respectively.
These functions return \TT{min::ptr} pointers that
remain valid even if the label body is relocated.

The length of a label is the number of elements (general values) in the label.
The length of a label may be read from a label pointer, or may be read
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{tabular}\end{indpar}

The hash value of a label may be computed from the label pointer, or
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{labhash}
     \verb|( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{tabular}\end{indpar}

The last function computes the hash value for a label that could be created
from the given vector \TT{p} of \TT{n} general values, where each
general value is a name component.

The hash of a label is computed from
the hash of each of its elements using:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{labhash\_initial} \verb|= 1009|
\LABEL{MIN::LABHASH_INITIAL} \\
\verb|const min::uns32 min::| & \MINKEY{labhash\_factor}
    \verb|= 65599**10 (mod 2**32)|
\LABEL{MIN::LABHASH_FACTOR} \\
\verb|min::uns32 min::| & \MINKEY{labhash}
     \verb|( min::uns32 hash, min::uns32 h )|
\LABEL{MIN::LABHASH_INCREMENTAL} \\
\end{tabular}\end{indpar}

in the following machine independent algorithm:\label{LABEL-HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = min::labhash_initial;
n = length of label
for i = 1 through n:
    h = hash of i'th element of label
    hash = min::labhash ( hash, h )
\end{verbatim}\end{indpar}

where \TT{min::labhash ( hash, h )} is defined as:

\begin{indpar}\begin{verbatim}
min::labhash ( hash, h ):
    // All arithmetic is mod 2**32
    hash = hash * min::labhash_factor + h
    if ( hash == 0 ) hash = -1
    return hash
\end{verbatim}\end{indpar}

Comparing this with the hash algorithm for strings
on \pagref{HASH-ALGORITHM}, one sees that as long as
label elements are numbers and strings of fewer than 10 characters,
the hash of a label is equivalent to the hash of the
string made by concatenating a prefix and then the label elements, where each
string of fewer than 10 characters is padded to 10 characters
by prefacing it with \TT{NUL} characters.  Note that
numbers are treated as 8 character strings; see
\pagref{NUMBER-HASH-ALGORITHM}.  The prefix is any 10 character string with
hash value \TT{min::\EOL labhash\_\EOL initial = 1009}.

The two argument \TT{labhash ( hash, h )} function performs the
incremental step in the computation of a label hash, and can be useful
in some lookup situations.

Although label values are generally read using lab pointers,
a label value may be read by the protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  const min::stub * s, min::uns32 n )|
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  min::gen v, min::uns32 n )|
\LABEL{MIN::LAB_OF_GEN} \\
\end{tabular}\end{indpar}

These read an initial segment of the label vector into the location
addressed by \TT{p}.  If the label vector has \TT{n} or more elements,
the first \TT{n} elements are read.  Otherwise, as many elements as
the label vector has are read.  The number of elements read is returned
in any case.  The label can be denoted by either its stub address or
by a general value pointing at its stub address.

A label may be created by the following protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( const min::gen * p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<const min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR_CONST} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR} \\
\end{tabular}\end{indpar}

Here \TT{p} must point to a vector of \TT{n} \TT{min::gen}
values that becomes the value vector of the label.  Each
\TT{min::gen} value must be a name component.
This function returns any existing label with elements equal to
those given by the function arguments, in preference to creating a new
label.  Thus two \TT{min::gen} label values with \TT{==} elements are
\TT{==}.

For convenience in generating frequently used labels,
2, 3, 4, and 5 element labels whose elements are strings may be created by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2 )|
\LABEL{MIN::NEW_LAB_GEN_OF_2_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3 )|
\LABEL{MIN::NEW_LAB_GEN_OF_3_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3,|\ARGBREAK
     \verb|  const char * s4 )|
\LABEL{MIN::NEW_LAB_GEN_OF_4_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3,|\ARGBREAK
     \verb|  const char * s4,|\ARGBREAK
     \verb|  const char * s5 )|
\LABEL{MIN::NEW_LAB_GEN_OF_5_STRS} \\
\end{tabular}\end{indpar}

The following function returns true if and only if its argument is
a label:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_lab} \verb|( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\end{tabular}\end{indpar}

The following unprotected constructors and functions operating
on the resulting unprotected label points are just like their
protected versions except that they assume any \TT{min::gen}
value \TT{v} or \TT{min::stub *} value \TT{s} is a label
and furthermore do not check subscript ranges:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr} \verb|labp ( min::gen v )|
\LABEL{MUP::LAB_PTR_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr} \verb|labp ( min::stub * s )|
\LABEL{MUP::LAB_PTR_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr} \verb|labp ( void )|
\LABEL{MUP::LAB_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::lab\_ptr}}\ARGBREAK
          \verb|( MUP::lab_ptr const & labp )|
\LABEL{MUP::LAB_PTR_TO_MIN_STUB} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, min::gen v )|
\LABEL{MUP::=_LAB_PTR_OF_GEN} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, const min::stub * s )|
\LABEL{MUP::=_LAB_PTR_OF_STUB} \\
\verb|min::gen labp|
    & \TTBMKEY{i}{of {\tt MUP::lab\_ptr}}
\LABEL{MUP::[]_OF_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<const min::gen> min::|
	& \MINMKEY{begin\_ptr\_of}{{\tt lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_MUP_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINMKEY{end\_ptr\_of}{{\tt lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_MUP_LAB_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_MUP_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_MUP_LAB_PTR} \\
\end{tabular}\end{indpar}

\subsection{Names}
\label{NAMES}

A \key{name} is a
number (\itemref{NUMBERS}),
string (\itemref{STRINGS}),
or label (\itemref{LABELS}), i.e., it is an atom or a label.
A name can also be viewed as
a sequence of \skey{name component}s, each of which is a number, string,
or label.
Names and name components are all immutable values which have an associated
hash value.

A number or string is used to represent a 1-component name whose
only component is the number or string.  Other names are represented
by labels whose elements are the components of the names.  A label whose
only component is a number or string is \underline{not}
used to represent a name, in order to ensure that each name has a unique
representation.

The following functions concern names in general:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_name} \verb|( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash} \verb|( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare} \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\verb|min::int32 min::| & \MINKEY{is\_subsequence}
    \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::IS_SUBSEQUENCE} \\
\verb|min::gen min::| & \MINKEY{new\_name\_gen}
    \verb|( const char * s )|
\LABEL{MIN::NEW_NAME_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_name\_gen}
    \verb|( min::ptr<const char> s )|
\LABEL{MIN::NEW_NAME_GEN_OF_PTR} \\
\end{tabular}\end{indpar}

The \TT{min::is\_name} function returns true if and only if its argument is
a name (number, string, or label).

The \TT{min::hash} function returns a non-zero
\key{hash value}\label{HASH-VALUE} of its argument, which must be
a name.

The \TT{min::compare} function returns an integer $<0$, $=0$, or $>0$
according to whether its \TT{v1} argument is less than, equal to, or
greater than its \TT{v2} argument.
In this ordering numbers are
before strings, strings are before labels, and labels are before
any non-name values.  Numbers are ordered
numerically, strings are ordered lexicographically as per the
C language \TT{strcmp} function, and labels are ordered lexicographically
using the \TT{min::\EOL compare} function recursively to compare
label elements.  Non-name values are ordered by converting their
\TT{min::gen} values to bit strings and comparing the bit strings.
This means that \TT{min::gen} values that point at stubs are ordered
according to their stub addresses.

The \TT{min::subsequence} function
returns the index of the first occurrence
of its first argument \TT{v1} as a subsequence of its second
argument \TT{v2}, or returns \TT{-1} if there is no such
occurrence.  For this function,
a non-label must be an atom, and is equivalent to a length \TT{1} label
whose sole element is the atom.

The \TT{min::new\_name\_gen} functions convert a UTF-8 character string
to a name.  The character string is parsed into components that contain no
(horizontal or vertical) space characters and these are made into
a name that is returned.  If there is more than one component, a label is
returned with each component being a MIN string element.
If there is exactly one component, a MIN string equal to
that component is returned.
If there are no components,  a label with zero elements is returned.

The following names are defined for general use:

\begin{indpar}\begin{tabular}{r@{}ll}
\verb|min::gen min::| & \MINKEY{TRUE}
		      & \verb|= min::new_str_gen ( "TRUE" )|
\LABEL{MIN::TRUE} \\
\verb|min::gen min::| & \MINKEY{FALSE}
		      & \verb|= min::new_str_gen ( "FALSE" )|
\LABEL{MIN::FALSE} \\
\verb|min::gen min::| & \MINKEY{empty\_str}
		      & \verb|= min::new_str_gen ( "" )|
\LABEL{MIN::EMPTY_STR} \\
\verb|min::gen min::| & \MINKEY{empty\_lab}
		      & \verb|= min::new_lab_gen ( NULL, 0 )|
\LABEL{MIN::EMPTY_LAB} \\
\verb|min::gen min::| & \MINKEY{doublequote}
		      & \verb|= min::new_str_gen ( "\"" )|
\LABEL{MIN::DOUBLEQUOTE} \\
\verb|min::gen min::| & \MINKEY{line\_feed}
		      & \verb|= min::new_str_gen ( "\n" )|
\LABEL{MIN::LINE_FEED} \\
\verb|min::gen min::| & \MINKEY{colon}
		      & \verb|= min::new_str_gen ( ":" )|
\LABEL{MIN::COLON} \\
\verb|min::gen min::| & \MINKEY{semicolon}
		      & \verb|= min::new_str_gen ( ";" )|
\LABEL{MIN::SEMICOLON} \\
\verb|min::gen min::| & \MINKEY{dot\_initiator}
		      & \verb|= min::new_str_gen ( ".initiator" )|
\LABEL{MIN::DOT_INITIATOR} \\
\verb|min::gen min::| & \MINKEY{dot\_separator}
		      & \verb|= min::new_str_gen ( ".separator" )|
\LABEL{MIN::DOT_SEPARATOR} \\
\verb|min::gen min::| & \MINKEY{dot\_terminator}
		      & \verb|= min::new_str_gen ( ".terminator" )|
\LABEL{MIN::DOT_TERMINATOR} \\
\verb|min::gen min::| & \MINKEY{dot\_type}
		      & \verb|= min::new_str_gen ( ".type" )|
\LABEL{MIN::DOT_TYPE} \\
\verb|min::gen min::| & \MINKEY{dot\_position}
		      & \verb|= min::new_str_gen ( ".position" )|
\LABEL{MIN::DOT_POSITION} \\
\end{tabular}\end{indpar}

\subsection{Packed Structures}
\label{PACKED-STRUCTURES}

A \key{packed structure} is a class datum stored in a body associated
with a stub that has a \minkey{PACKED\_STRUCT}\LABEL{MIN::PACKED_STRUCT}
stub type code.

The class type must be similar to a C-language \TT{struct} in that:
\begin{enumerate}
\item Construction\label{PACKED-STRUCTURE-TYPE-REQUIREMENTS}
of a datum of the type
by a no-argument constructor does not have to
set any datum byte to a non-zero value.  Note that bytes need not be
set to any value, but zero must be an acceptable value for all bytes
of a newly constructed datum.

When a packed structure is created it is zeroed and then one special
header member described below, the \TT{control} member,
is given a value.
No constructor is called.
\item
Destruction of a datum of the type does nothing.

When a packed structure is destroyed, no destructor is called.
\item
Assignment of a datum of the type from another datum of the same type
is equivalent to a \TT{memcpy} operation.

When a packed structure is moved by the copying part of
the ACC, it is moved by \TT{memcpy}.
\end{enumerate}

Numeric, \TT{min::gen}, and \TT{const min::stub *} values are permitted as
packed structure class members, as are
\TT{min::\EOL packed\_\ldots ptr<\ldots>}
values (see below) and C++ pointers.  Note that all these
are initialized to \TT{0} (equal to \TT{NULL} or \TT{min::NULL\_STUB}
for pointers) when a packed structure is created.

The type of a packed structure
must have as its first member
(that is, the member at displacement \TT{0});
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}
This first member holds subtype information and flags.

The packed structure type
may have a public base structure, as long as that also follows the above
rules.  In this case the
`\TT{control}' member must be the first member of the base structure.
This rule can be applied recursively to get, for example, a `\TT{struct}'
based on a public `\TT{struct}'
based on a public `\TT{struct}' whose first member is `\TT{control}'.

There are two types of pointers that can be used to
access members of packed structures:
\begin{indpar}\begin{tabular}{l}
\verb|min::packed_struct_ptr<S>| \\
\verb|min::packed_struct_updptr<S>|
\end{tabular}\end{indpar}
where \TT{S} is the class type of the structure.
The first \mkey{read-only pointer}{to packed structure} type
permits read-only access to packed structure members,
while the second \mkey{updatable pointer}{to packed structure} type
permits read-write access.
These pointers are like the type `\TT{const min::stub *}' but with extra
clothes.
Pointers of these types can also be included as members in packed structures
and in packed vector headers and elements (see \itemref{PACKED-VECTORS}).

The type of a packed structure is described at run-time by a
\TT{min::packed\_\EOL struct<S>} C++ static object, where
\TT{S} is the type of the structure.
The \TT{new\_gen} and \TT{new\_stub}
member functions of this C++ static object can be
used to create new packed structures of the described type.

More explicitly, to create a new type of \key{packed structure}
named \TT{pstype} use

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct<S>} \verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_with\_base<S,B>}
		\verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE_WITH_BASE} \\
\verb|min::uns32 min::| & \MINKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen pstype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\verb|const min::stub * pstype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_STUB} \\
\verb|min::uns32 pstype|
    & \TTDMKEY{subtype}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_SUBTYPE} \\
\verb|const char * const pstype|
    & \TTDMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{gen\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISP} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{stub\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_DISP} \\
\end{tabular}\end{indpar}

where

\begin{itemlist}[0.5in]

\item[\TT{S}]
The type of the body of packed structures of the type being
declared.  This type must be a class whose first
member is
\begin{center}
\verb|const min::uns32 control;|
\end{center}
This member holds a code that effectively
points at \TT{pstype}, and also holds some flags.
This member is initialized by \TT{new\_gen} or \TT{new\_stub} and must not
be changed by the user.
\TT{S} must meet the requirements given on
\pagref{PACKED-STRUCTURE-TYPE-REQUIREMENTS}.

\item[\TT{B}]
\TT{S} may have a single base type \TT{B} as in
\begin{indpar}\begin{verbatim}
struct S : public struct B { ... }
\end{verbatim}\end{indpar}
where \TT{B} is a packed structure type meeting the requirements given
on \pagref{PACKED-STRUCTURE-TYPE-REQUIREMENTS}.
In this case \TT{S} does
\underline{not} have a `\TT{control}' member, as
the `\TT{control}' member of \TT{B} serves as
the `\TT{control}' member of \TT{S}.

\TT{packed\_\EOL struct\_\EOL with\_\EOL base<S,B>}
enables conversion of
\TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<S>} pointers
to \TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>}
pointers.  In fact, given
\begin{center}
\begin{tabular}{l}
\TT{packed\_\EOL struct\_\EOL with\_\EOL base<S,B1>} s \\
\TT{packed\_\EOL struct\_\EOL with\_\EOL base<B1,B2>} b1 \\
\ldots\ldots\ldots \\
\TT{packed\_\EOL struct\_\EOL with\_\EOL base<BN,B>} bn \\
\TT{packed\_\EOL struct<B>} b \\
\end{tabular}
\end{center}
then conversion of
\TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<S>} pointers
to \TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>}
pointers is enabled.\footnote{What actually happens is the
\TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<S>} pointer
is implicitly converted to a \TT{const min::\EOL stub *} pointer and the
latter is converted to a
\TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>} pointer.
As part of this last conversion, the \TT{control} is read and
checked, and the check finds that the object subtype
is \TT{s.subtype} which is a super-subtype of
\TT{b1.subtype}, which is a super-subtype of \ldots, which
is a super-subtype of \TT{bn.subtype}, which is a super-subtype
of \TT{b.subtype}, and therefore the check passes and the
conversion is legal.}

\end{itemlist}

\begin{itemlist}[0.8in]

\item[\ttmkey{subtype}{in {\tt min::packed\_struct}}]
A small integer automatically assigned to uniquely identify \TT{pstype}.
This is stored in the `\TT{control}' member of all packed
structures that are created by \TT{pstype.new\_\EOL gen} or
\TT{pstype.new\_\EOL stub}, and serves as a pointer from any
of these packed structures to \TT{pstype}.

\item[\ttmkey{name}{in {\tt min::packed\_struct}}]
\label{NAME_IN_PACKED_STRUCT}
A name unique to the \TT{pstype} datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed structure type when a packed structure is
output.

\end{itemlist}

\begin{itemlist}[1.0in]

\item[\ttmkey{gen\_\EOL disp}{in {\tt min::packed\_struct}}]
This C vector is a list of the displacements (in bytes) of all
the \TT{min::gen} members of \TT{S},
terminated by the value \TT{min::DISP\_END}\minindex{DISP\_END}.
The displacement of member \TT{m} in structure type \TT{S} should
be computed by \TT{min::\EOL DISP(\&S::m)}.

This displacements vector should not
be given (its address should be \TT{NULL}) if there are no \TT{min::gen}
values in \TT{S}.  But if there are \TT{min::gen} members, this
displacements vector must be given for garbage collection purposes.

\TT{const min::gen} members are treated like \TT{min::gen}
members for these purposes.

\item[\ttmkey{stub\_\EOL disp}{in {\tt min::packed\_struct}}]\label{STUB_DISP}
Ditto but for \TT{const min::stub *} members of \TT{S}
instead of \TT{min::gen} members.  The following member types are
treated as \TT{const min::stub *} members for these purposes:
\begin{center}
\tt
\begin{tabular}{l}
const min::stub * const \\
min::packed\_struct\_xxxptr<S> \\
min::packed\_vec\_xxxptr<E,H,L> \\
\end{tabular}
\end{center}

\end{itemlist}

The \TT{pstype.new\_gen} and \TT{pstype.new\_stub}
functions create a new packed structure
datum of the type described by \TT{pstype} and return a
\TT{min::gen} or \TT{const min::\EOL stub~*} value pointing at it.
The new packed structure is set to all zeros, except for its
`\TT{control}' member.

The function call \TT{min::\EOL DISP~(~\&~S::m~)} will return the
displacement in bytes of the member \TT{m} of a structure
of \TT{struct} type \TT{S}.  This should be used instead of
assuming that \TT{struct} layouts are tightly packed, as often
they are not.  The type of the \TT{S::m} member must be one of
the types mentioned above: \TT{min::gen}, \TT{const min::stub~*},
\TT{min::\EOL packed\_\EOL \ldots{}ptr<\ldots>}, etc.

\TT{pstype.subtype}, \TT{pstype.name},
\TT{pstype.gen\_\EOL disp},
and \TT{pstype.stub\_\EOL disp}
can be used to retrieve the subtype, name, and displacement
information associated with \TT{pstype}.

The subtype of a packed structure (or packed vector)
and the name of that subtype can be retrieved by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype} \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_SUBTYPE} \\
\end{tabular}\end{indpar}

These functions work in the same way for both packed structures
and packed vectors (\itemref{PACKED-VECTORS}).
No packed structure has the same subtype as any packed vector, and
vice versa.

The \TT{min::\EOL packed\_\EOL subtype\_\EOL of}
functions return \TT{0}, which
is not a legal packed structure or packed vector subtype, if the
argument does not reference a packed structure or vector.  This includes
the case where the argument is \TT{min::\EOL NULL\_\EOL STUB}.
The \TT{MUP::\EOL packed\_\EOL subtype\_\EOL of} function gives
undefined result unless its argument references a packed structure
or packed vector.  When the argument is a packed structure
or packed vector,
the subtype is computed by looking in the
`\TT{control}' member of the structure or vector.

The \TT{min::name\_of\_packed\_subtype} function returns the
\TT{pstype.name} (\pagref{NAME_IN_PACKED_STRUCT}) of the
\TT{pstype} associated
with the subtype, which is useful for tracing and debugging.

Note that there can be several different
\TT{min::\EOL packed\_\EOL struct<S>}
values with different subtypes but the same structure
type \TT{S}.  Packed structure pointers such as those of type
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
described below may point at a packed structure with any of these subtypes;
the pointer type is \underline{not} specific to the subtype, but
is rather specific to \TT{S}.

The two kinds of pointers that can be used to access
a packed structure.  The read-only
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointers
have the usage:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	   \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	   \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	   \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
          \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_TO_MIN_STUB} \\
\verb|min::ptr<S const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_->} \\
\verb|min::ref<S const> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_*} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\end{tabular}\end{indpar}

A \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} value is just
a `\TT{const min::stub~*}' value in fancy clothes, and may be
converted to/from a `\TT{const min::stub~*}' value.

For the constructors and the \TT{=} assignment operator, if the
argument \TT{v} or \TT{s} does not point at a packed structure
of type \TT{S}, the \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
result is set to \TT{min::\EOL NULL\_\EOL STUB},
which is just the standard C language \TT{NULL}
cast to the `\TT{const min::stub *}' type.
Note that \TT{NULL} cannot itself be used as an argument to
the constructors or \TT{=} operator, as it is
convertible to either a `\TT{min::stub *}'
or \TT{min::gen} type, and is thus creates ambiguity.
But \TT{min::\EOL NULL\_\EOL STUB} can be used.
If a constructor for \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>}
is not given an argument, the pointer is also set to
\TT{min::\EOL NULL\_\EOL STUB}.

A pointer equal to
\TT{min::\EOL NULL\_\EOL STUB} gives undefined results if
used to access a structure,
though almost always the result will be a memory fault.
The \TT{==} and \TT{!=} operators can be used to test whether
or not a \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer
equals \TT{min::\EOL NULL\_\EOL STUB}.

A \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer is also
internally a `\TT{S const **}' value that is made to behave externally like a
`\TT{min::\EOL ptr<S~const>}' value with respect to the \TT{->} and
unary \TT{*} operators.  Thus looking ahead at the example below,
if \TT{upv} is a
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} value
and \TT{S} has a member \TT{m}, then \TT{upv->m} is the \TT{m}
member of the \TT{S} struct pointed at by \TT{upv}.

The read-write \TT{min::\EOL packed\_\EOL struct\_\EOL updptr<S>}
pointer type has 
as its \TT{public} base class the
\TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer type,
so that it can be implicitly converted to
a read-only pointer.  The new code defined for this read-write
pointer type is:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|
	   \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	  \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|
	               \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|min::ptr<S> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_udpptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_->} \\
\verb|min::ref<S> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_updptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_*} \\
\end{tabular}\end{indpar}

The \TT{->} and \TT{*} operators are redefined (i.e., \underline{not}
inherited) so that they
return `\TT{min::\EOL ptr<S>}' and `\TT{min::\EOL ref<S>}' values instead of
`\TT{min::\EOL ptr<S~const>}' and `\TT{min::\EOL ref<S~const>}' values.

\TT{min::\EOL packed\_\EOL struct\_\EOL updptr<S>} pointers can be
converted implicitly to \TT{const min::stub *} values because
the \TT{min::\EOL packed\_\EOL struct\_\EOL ptr<S>} pointer type
is a \TT{public} base class of
the \TT{min::\EOL packed\_\EOL struct\_\EOL updptr<S>} pointer type.

\TT{min::gen}, \TT{const min::stub~*}, and
\TT{min::\EOL packed\_\EOL\ldots ptr<\ldots>}
elements of packed structures must be locatable.
The \TT{MIN\_REF}\label{PACKED_STRUCT_MIN_REF}
macro described on \pagref{MIN_REF}
should be used with a \TT{min::\EOL packed\_\EOL
struct\_\EOL updptr<S>} container type
for locatable elements of a packed structure.

An example use of a packed structure is:
\begin{indpar}\begin{verbatim}
struct ps;
typedef min::packed_struct_ptr<ps> psptr;
typedef min::packed_struct_updptr<ps> psupdptr;
    // Note: pointers can be defined before struct is defined.

struct ps {
    min::uns32 control;
    min::uns32 i;
    min::uns32 j;
    const min::gen g;
    const psptr pv;
    const min::stub * const s;
};

MIN_REF ( min::gen, g, psupdptr )
MIN_REF ( psptr, pv, psupdptr )
MIN_REF ( const min::stub *, s, psupdptr )

static min::uns32 ps_gen_disp[2] =
    { min::DISP ( & ps::g ), min::DISP_END };
static min::uns32 ps_stub_disp[3] =
    { min::DISP ( & ps::s ), min::DISP ( & ps::pv ), min::DISP_END };

static min::packed_struct<ps> pstype
    ( "pstype", ps_gen_disp, ps_stub_disp );

main ( ... )
{
    . . . . . . .
    min::gen v1 = pstype.new_gen();
        // min::packed_subtype_of ( v1 ) == pstype.subtype
    psupdptr upv ( v1 );
        // min::packed_subtype_of ( upv ) == pstype.subtype
    upv->i = 55;
    upv->j = 99;
    g_ref(upv) = min::new_str_gen ( "Hello" );

    psptr pv = upv;
    // Upv is converted to a `const min::stub *' value
    // that is used to set pv.

    pv_ref(upv) = pv;
    upv = pstype.new_gen();
        // new.stub() could be used here in place of new_gen()

    // Now upv->i == 0, pv->i == 55, pv->pv->i == 55,
    //     upv->pv == min::NULL_STUB

    . . . . . . .
}
\end{verbatim}\end{indpar}

Packed structure pointers do no caching and
there is \underline{no need} for
a refresh function analogous to the \TT{min::\EOL \ldots\_\EOL refresh}
functions for list pointers (\pagref{LIST-POINTER-CACHE}).

\subsection{Packed Vectors}
\label{PACKED-VECTORS}

A \key{packed vector} is like a packed structure but with an added vector
that follows the structure,
and with a \minkey{PACKED\_VEC}\LABEL{MIN::PACKED_VEC}
stub type code instead of a \TT{min::\EOL PACKED\_\EOL STRUCT} type code.

The structure at the beginning of a packed vector
is called the packed vector \mkey{header}{of packed vector}
and the vector elements that follow the header are called the
packed vector \smkey{element}s{of packed vector}.
The types of both the vector header and the vector elements must follow
the three rules stated at the beginning of the Packed Structures
section (\itemref{PACKED-STRUCTURES}), with two exceptions.%
\label{PACKED-VECTOR-TYPE-REQUIREMENTS}

The type of a packed vector header, like that of a packed structure,
must be a class whose first member
(that is, the member at displacement \TT{0}) is
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}

The first exception is that
the header must also have the following two other members,
at no particular displacement:
\begin{indpar}
\verb|const L length;| \\
\verb|const L max_length;|
\end{indpar}
where \TT{L} is an unsigned integer type, and defaults to
\TT{min::\EOL uns32}.  Here \TT{length} is the current number
of elements in the vector and \TT{max\_length} is the
maximum number of elements that can be in the vector before
the vector needs to be resized to increase
\TT{max\_length} (resizing is automatic but moves the vector in memory).

The second exception is that the type of the vector elements
may be a class type, but without any of the members required
for the header, or may be any type appropriate to an element
of such a class.  So, for example, \TT{min::gen} may be
either the vector element type or the type of a member of
the vector element type.

There are also three pointer-to-packed-vector types:
\begin{indpar}\begin{tabular}{l}
\verb|min::packed_vec_ptr<E,H,L>| \\
\verb|min::packed_vec_updptr<E,H,L>| \\
\verb|min::packed_vec_insptr<E,H,L>|
\end{tabular}\end{indpar}
where \TT{E} is the type of the packed vector element,
\TT{H} is the type of the packed vector header struct,
and \TT{L} is the unsigned integer type of the \TT{length}
and \TT{max\_\EOL length} members of the header, and also of the
subscripts used to access vector elements.
The first \mkey{read-only pointer}{to packed vector} type
permits read-only access to packed vector members and elements,
the second \mkey{updatable pointer}{to packed vector} type
permits read-write access, while the
the third \mkey{insertable pointer}{to packed vector} type
permits read-write access \underline{and}
also permits pushing and popping vector elements
and resizing the vector.
These pointers are like the type `\TT{const min::stub *}' but with extra
clothes.
These pointer types can also be used as the types of packed vector
elements or as members of classes that are the types of packed vector
elements or headers or of packed structures.

A packed vector type is described at run-time by a
\TT{min::packed\_\EOL vec<E,H,L>} C++ static object, where
\TT{E}, \TT{H}, and \TT{L} are as above.
The \TT{new\_gen} and \TT{new\_stub}
member functions of this C++ static object can be
used to create new packed vectors of the described type.

More explicitly, to create a new type of \key{packed vector}
named \TT{pvtype} use

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{packed\_vec\_header<L>}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const min::uns32 control;|\ARGBREAK
    \verb|  const L length;|\ARGBREAK
    \verb|  const L max_length;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PACKED_VEC_HEADER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec}{packed\_vec}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINLKEY{packed\_vec\_with\_base}{<E,H,B,L=min::uns32>}
		\verb|pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE_WITH_BASE} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_STUB_VOID} \\
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_STUB_MAX_LENGTH} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const char * const pvtype| & \TTDMKEY{subtype}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_SUBTYPE} \\
\verb|const char * const pvtype| & \TTDMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_DISP} \\[1ex]
\verb|min::uns32 pvtype| & \TTDMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 pvtype| & \TTDMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 pvtype| & \TTDMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{tabular}\end{indpar}

where

\begin{itemlist}[0.5in]

\item[\TT{E}]\label{PACKED_VEC_ELEMENT_TYPE}
The type of the elements in the vector part of the
bodies of packed vectors of the type being
declared.  This must meet the requirements given on
\pagref{PACKED-VECTOR-TYPE-REQUIREMENTS}.

Also, \TT{E} must \underline{not} be a \TT{const} type.

\item[\TT{H}]\label{PACKED_VEC_HEADER_TYPE}
The type of the header at the beginning of the
bodies of packed vectors of the type being
declared.  This must meet the requirements given on
\pagref{PACKED-VECTOR-TYPE-REQUIREMENTS}.

This must be a class (or \TT{struct}) type
whose first member is
\begin{indpar}
\verb|const min::uns32 control;|
\end{indpar}
and which must also have the two members
\begin{indpar}
\verb|const L length;| \\
\verb|const L max_length;|
\end{indpar}
where \TT{L} is an unsigned integer type.
These members are initialized by \TT{new\_gen} or \TT{new\_stub}
and must not
be changed by the user.

\TT{H} defaults to \TT{min::packed\_vec\_header<min::uns32>} which
has just the require header members: \TT{control}, \TT{length}, and
\TT{max\_\EOL length} with \TT{L=min::uns32}.  Because of this default,
\TT{H} is the \underline{second} template parameter,
even though is precedes the vector elements in memory.

\item[\TT{L}]
The unsigned integer type of the vector length and vector element subscripts
of the vector.  Defaults to \TT{min::\EOL uns32}.
Other sensible values for \TT{L} are
\TT{min::\EOL uns16} and \TT{min::\EOL unsptr}.

\item[\TT{B}]
\TT{H} may have a single base type \TT{B} as in
\begin{indpar}\begin{verbatim}
struct H : public struct B { ... }
\end{verbatim}\end{indpar}
where \TT{B} is a packed structure type (see \itemref{PACKED-STRUCTURES}).
In this case \TT{H} does
\underline{not} have a `\TT{control}' member, as
the `\TT{control}' member of \TT{B} serves as
the `\TT{control}' member of \TT{H}.  The `\TT{length}' and
`\TT{max\_length}' members may be in either \TT{H} or \TT{B}.
If \TT{packed\_\EOL vec\_\EOL with\_\EOL base<E,H,B,L>}
is used to define the packed vector type, conversion of
\TT{min::\EOL packed\_\EOL vec\_\EOL xxxptr<E,H,L>} pointers
to \TT{min::\EOL packed\_\EOL struct\_\EOL xxxptr<B>}
pointers is enabled.

\end{itemlist}

\begin{itemlist}[1.0in]

\item[\ttmkey{subtype}{in {\tt min::packed\_vec}}]
A small integer automatically assigned to uniquely identify \TT{pvtype}.
This is stored in the `\TT{control}' member of all packed
vectors that are created by \TT{pvtype.new\_\EOL gen} or
\TT{pvtype.new\_\EOL stub}, and serves as a pointer from any
of these packed vectors to \TT{pvtype}.

\item[\ttmkey{name}{in {\tt min::packed\_vec}}]
A name unique to the \TT{pvtype} datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed vector type when a packed vector is
output.

\end{itemlist}

\begin{itemlist}[1.6in]

\item[\ttmkey{header\_\EOL gen\_\EOL disp}{in {\tt min::packed\_vec}}]
This vector is a list of the displacements (in bytes) of all
the \TT{min::gen} members of \TT{H},
terminated by the value \TT{min::DISP\_\EOL END}\minindex{DISP\_END}.
This displacements vector should not
be given (its address should be \TT{NULL}) if there are no \TT{min::gen}
values in \TT{H}.  But if there are \TT{min::gen} members, this
displacements vector must be given for garbage collection purposes.

\item[\ttmkey{header\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \TT{min::stub *} members of \TT{H}.
See \pagref{STUB_DISP} for more details.

\item[\ttmkey{element\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \TT{min::gen} members of \TT{E}.

\item[\ttmkey{element\_\EOL stub\_\EOL disp}{in {\tt min::packed\_vec}}]
Ditto but for \TT{min::stub *} members of \TT{E}.
See \pagref{STUB_DISP} for more details.

\end{itemlist}

\TT{pvtype.name},~~
\TT{pvtype.header\_\EOL gen\_\EOL disp},
\TT{pvtype.header\_\EOL stub\_\EOL disp},
~~\TT{pvtype.ele\-\EOL ment\_\EOL gen\_\EOL disp},
and \TT{pvtype.ele\-\EOL ment\_\EOL stub\_\EOL disp}
can be used to retrieve the name and displacement
information associated with \TT{pvtype}.

In addition the parameters
\TT{pvtype.ini\-tial\_\EOL max\_\EOL length},
\TT{pvtype.increment\_\EOL ratio}, and
\TT{pvtype.max\_\EOL increment}
may be set by the user:


\begin{itemlist}[1.5in]

\item[\ttmkey{initial\_max\_length}{in {\tt min::packed\_vec}}]
The maximum length of a packed vector newly created by calling the
\TT{pvtype.new\_gen} or \TT{pvtype.new\_stub}
function with no arguments.  Defaults to \TT{128}.

\item[\ttmkey{increment\_ratio}{in {\tt min::packed\_vec}}]
The \TT{min::reserve} function multiplies the old maximum length by
this ratio to get the maximum length increment: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \TT{0.5}.

\item[\ttmkey{max\_increment}{in {\tt min::packed\_vec}}]
The maximum increment of the maximum length computable by the
\TT{min::reserve} function: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \TT{4096}.

\end{itemlist}

The \TT{pvtype.new\_gen} and \TT{pvtype.new\_stub}
functions create a new packed vector
datum of the type described by \TT{pvtype} and return a
\TT{min::gen} or \TT{const min::stub *}
value pointing at it.  A packed vector has a
\mkey{length}{of packed vector} which is the number of elements
currently in the packed vector.  It also has a
\mkey{maximum length}{of packed vector} which is the maximum length
allowed before the packed vector must be resized.
The \TT{pvtype.new\_gen} or \TT{pvtype.new\_stub}
function may be given the maximum length
and length and a vector of length type \TT{E} elements that is copied
to the initial value of the packed vector.
If the vector \TT{vp} of initial elements is given as \TT{NULL},
the initial elements will be zeros.
If no parameters are given to
\TT{pvtype.new\_gen} or \TT{pvtype.new\_stub},
the length defaults to \TT{0} and
the maximum length defaults to \TT{pvtype.initial\_\EOL max\_\EOL length}.

A newly created packed vector is set to all zeros, except for its
`\TT{control}', `\TT{length}', and `\TT{max\_\EOL length}' members.

The subtype of a packed vector (or packed structure)
and the name of that subtype can be retrieved by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype} \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_VEC_SUBTYPE} \\
\\
\end{tabular}\end{indpar}

These functions work for packed vectors in the same was as for
packed structures; see \pagref{MIN::PACKED_STRUCT_SUBTYPE_OF_GEN} for details.

The following are defined for general use:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|min::packed_vec<char> min::|
	& \MINKEY{char\_packed\_vec\_type}
\LABEL{MIN::CHAR_PACKED_VEC_TYPE} \\
\verb|min::packed_vec<min::uns32> min::|
	& \MINKEY{uns32\_packed\_vec\_type}
\LABEL{MIN::UNS32_PACKED_VEC_TYPE} \\
\verb|min::packed_vec<const char *> min::|
	& \MINLKEY{const\_char\_ptr}{\_packed\_vec\_type}
\LABEL{MIN::CONST_CHAR_PTR_PACKED_VEC_TYPE} \\
\verb|min::packed_vec<min::gen> min::|
	& \MINKEY{gen\_packed\_vec\_type}
\LABEL{MIN::GEN_PACKED_VEC_TYPE} \\
\end{tabular}\end{indpar}

Above we listed three types of pointers that can be used to access
a packed vector.  The first is the read-only
\TT{min::\EOL packed\_\EOL vec\_\EOL ptr<E,H,L>}
packed vector pointer type which has the usage:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr}{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr}{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_ptr}{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_PTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
          \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_TO_MIN_STUB} \\
\verb|min::ptr<H const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_->} \\
\verb|min::ref<H const> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_*} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const L pvp| & \TTARMKEY{length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_LENGTH} \\
\verb|const L pvp| & \TTARMKEY{max\_length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_MAX_LENGTH} \\
\verb|min::ref<E const> pvp| & \TTBMKEY{i}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_[]} \\
\verb|min::ptr<E const> pvp|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_ptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_PTR_+} \\
\verb|min::ptr<E const>  min::|
    & \MINMKEY{begin\_ptr\_of}{{\TT packed\_vec\_ptr}}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_PTR} \\
\verb|min::ptr<E const> min::|
    & \MINMKEY{end\_ptr\_of}{{\tt packed\_vec\_ptr}}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_PTR} \\
\end{tabular}\end{indpar}

As for packed structures, read-only packed vector pointers used as the left
operand of \TT{->} are converted to
\TT{min::\EOL ptr<H const>} pointers.
This can be used to access the `\TT{length}'
and \TT{max\_length} members of the header.

Similarly, as for packed structures the \TT{*} operator converts
read only packed vector pointers to \TT{min::\EOL ref<H const>} references.

In addition subscripting read-only packed vector
pointers gives read-only access to the elements of the vector.  The subscripting
operator \TT{[]} checks the index \TT{i} against the current length
of the vector to ensure the access is legal
(i.e., \TT{pvp[i]} executes a \TT{MIN\_\EOL ASSERT}
check that \TT{0<=i<pvp->length}).
The vector elements in a
packed vector are organized as a C language vector so that
\begin{center}
\TT{(\textasciitilde~\& pvp[0])[i]} references the same element as \TT{pvp[i]}
\end{center}
But the vector elements are stored in a body whose address can change
if a relocating function is called, so C pointers to packed vector
elements are relocatable.  However, temporary use within a single
statement is all right if the statement does not call a relocating
function, so, for example, `\TT{\textasciitilde~\& pvp[i]}' may be used as an
argument to \TT{memcpy}.

\TT{pvp+i} can be used to compute a \TT{min::ptr<E const>} pointer that
points at the \TT{pvp[i]} vector element.
The \TT{MIN\_\EOL ASSERT} check \TT{0<=i<pvp->length}
is performed when \TT{pvp+i} is computed.

\TT{min::begin\_ptr(pvp)} is the same as `\TT{pvp + 0}'
except the latter would fail if \TT{pvp->\EOL length == 0}.
\TT{min::end\_ptr(pvp)} is the same as `\TT{pvp + pvp->length}'
except the latter will always fail because the index is not less than
\TT{pvp->length}.

For example, if \TT{memcpy} is used to copy
from the vector, use \TT{min::begin\_\EOL ptr(pvp)}:
\begin{indpar}\begin{verbatim}
memcpy ( ..., ~ min::begin_ptr(pvp), sizeof ( E ) * pvp->length );
\end{verbatim}\end{indpar}
Using \TT{\textasciitilde~\& pvp[0]}
instead of \TT{\textasciitilde~min::begin\_ptr(pvp)}
will fail with a \TT{MIN\_\EOL ASSERT} fault if \TT{pvp->\EOL length == 0}.

The read-write \TT{min::\EOL packed\_\EOL vec\_\EOL updptr<E,H,L>}
pointer type has as its \TT{public} base class the
\TT{min::\EOL packed\_\EOL vec\_\EOL ptr<E,H,L>} pointer type,
so that read-write pointers can be implicitly converted to
read-only pointers.  The new code defined for the read-write
pointer type is:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr}{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr}{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_updptr}{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<H> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_->} \\
\verb|min::ref<H> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_*} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<E> pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_[]} \\
\verb|min::ptr<E> pvup|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_updptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_UPDPTR_+} \\
\verb|min::ptr<E>  min::|
    & \MINMKEY{begin\_ptr\_of}{{\TT packed\_vec\_updptr}}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_UPDPTR} \\
\verb|min::ptr<E> min::|
    & \MINMKEY{end\_ptr\_of}{{\tt packed\_vec\_updptr}}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_UPDPTR} \\
\end{tabular}\end{indpar}

The \TT{->}, \TT{*}, \TT{[]}, and \TT{+} operators and
\TT{min::begin\_ptr\_of()} and \TT{min::end\_ptr\_of()} functions are
redefined (i.e., \underline{not}
inherited) so that they
return `\TT{min::\EOL ptr<H>}'
or `\TT{min::\EOL ref<E>}' values
instead of `\TT{min::\EOL ptr<H~const>}'
or `\TT{min::\EOL ref<E const>}' values.

The \TT{MIN\_REF}\label{PACKED_VEC_MIN_REF}
macro described in Section~\itemref{LOCATABLE-MEMBER-REFERENCES}
should be used with a \TT{min::\EOL packed\_\EOL
vec\_\EOL updptr<S>} container type
for locatable elements of a packed vector header.

Special considerations are required for writing vector elements
that are structures containing locatable members.
See the example at the end of this section.

The insertable \TT{min::\EOL packed\_\EOL vec\_\EOL insptr<E,H,L>}
pointer type, which permits elements to be added to a packed vector,
has the
\TT{min::\EOL packed\_\EOL vec\_\EOL updptr<E,H,L>} pointer type
as its \TT{public} base class,
so that insertable pointers can be implicitly converted to
read-write or read-only pointers.  The new code defined for the insertable
pointer type is:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr}{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr}{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINIKEY{packed\_vec\_insptr}{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	   \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&\
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<E> min::|
	& \MINKEY{push\RESIZE} \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_PUSH} \\[2ex]
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E const * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<const E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR_CONST} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|E min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_POP_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{resize\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{tabular}\end{indpar}

Insertable packed vector pointers permit the current length and maximum
length of the vector to be changed.
The current vector length is \TT{pvip->length} and the maximum
length is \TT{pvip->max\_length} (see description of \TT{H} on
\pagref{PACKED_VEC_HEADER_TYPE}).
The current length can be changed by \TT{min::\EOL push\RESIZE} and
\TT{min::\EOL pop} functions and the maximum length can be changed
by \TT{min::\EOL resize\RESIZE} and \TT{min::\EOL reserve\RESIZE}
functions.  If
\TT{min::\EOL push\RESIZE} needs more space it automatically calls
\TT{min::reserve\RESIZE}.

The \TT{min::push} function adds elements
to the end of the packed vector
by incrementing the current vector length, and if this would
exceed the maximum length, first calls the \TT{min::reserve} function
with the number of elements to be pushed.

The single argument \TT{min::\EOL push\RESIZE} adds one element to the vector,
zeros that element, and returns a reference to the element.  The
intended use is
\begin{indpar}\begin{verbatim}
push(pvip) = v;
\end{verbatim}\end{indpar}
where \TT{v} is the value of the element to be added to the vector.
If \TT{v} is
a structure type containing locatable elements, the situation is
tricky: see the below example.

The two or three argument \TT{min::\EOL push\RESIZE} adds \TT{n}
elements to the vector, and fills the new elements from \TT{vp}
if that is not \TT{NULL}, or with zeros otherwise.
If \TT{vp} is not \TT{NULL},
new elements are placed within the packed vector in the same
memory order as they appear in the \TT{vp} vector.
Here \TT{vp} cannot be an unprotected body pointer, as the data
it points at might be relocated during the execution of \TT{push}.
It can either be a non-body pointer, a \TT{min:\EOL ptr<const E>} pointer,
or a \TT{min:\EOL ptr<E>} pointer.
In any case \TT{min::\EOL acc\_\EOL write\_\EOL update} 
(\itemref{ACC-WRITE-UPDATE-FUNCTIONS})
is called by \TT{min::\EOL push} if \TT{E} is locatable.
Again the situation is tricky if \TT{v} is
a structure type containing locatable elements: see the below example.

The \TT{min::pop} function removes elements from the end of the
packed vector, decrementing the current vector length (which is checked
to be sure it is large enough).   A single element may be removed and
returned, or \TT{n} elements may be removed and returned in the
\TT{vp} vector.  In the latter case removed elements are placed in
\TT{vp} in the same memory order as they appeared in the packed vector.
Also,
if \TT{vp} is \TT{NULL}, the removed elements are simply discarded
instead of being copied.

The \TT{min::resize} function resets the maximum length.  If
the current length would be larger than the new maximum length,
the current length is reset to the new maximum length.

The \TT{min::reserve} function checks that
the current length plus the \TT{reserve\_length} is
at most the maximum length, and if this check fails,
resets the maximum length according to the formula:
\begin{indpar}\begin{verbatim}
new_maximum_length = max ( length + reserve_length,
                           old_maximum_length
                           +
                           min ( pvtype.max_increment,
                                   pvtype.increment_ratio
                                 * old_maximum_length ) )
\end{verbatim}\end{indpar}\label{PACKED-VEC-EXPANSION-FORMULA}

An example use of a packed vector is:
\begin{indpar}\begin{verbatim}
struct pvh;
struct pve;
typedef min::packed_vec_ptr<pve,pvh> pvptr;
typedef min::packed_vec_insptr<pve,pvh> pvinsptr;
    // Note: pointer types may be defined before
    //       header and element types are defined.

struct pvh {
    const min::uns32 control;
          min::uns32 i;
    const min::uns32 length;
    const min::uns32 max_length;
};

struct pve {
    // Note: pve is not a locatable type but contains
    // locatable type elements which means that
    // MUP::acc_write_update must be called explicitly
    // when pve elements are written into a packed vector.

    min::gen g;
    const min::stub * s;
    min::uns8 j;
};

static min::uns32 pve_gen_disp[2] =
    { min::DISP ( & pve::g ), min::DISP_END };
static min::uns32 pve_stub_disp[2] =
    { min::DISP ( & pve::s ), min::DISP_END };

static min::packed_vec<pve,pvh> pvtype
    ( "pvtype", pve_gen_disp, pve_stub_disp );

main ( ... )
{
    min::gen v = pvtype.new_gen ( 5 );
        // min::packed_subtype_of ( v ) == pvtype.subtype
    pvinsptr pvip ( v );
        // pvip->max_length == 5
        // pvip->length == 0
        // min::packed_subtype_of ( pvip ) == pvtype.subtype
    pve e1 = { min::MISSING(), NULL, 88 };
    min::push(pvip) = e1;
       // Need not call MUP::acc_write_update as neither
       // e1.g or e1.s point at a stub.
    pvptr pvp ( v );
        // pvp->length == 1
        // pvp[0].j == 88

    pve e2[3] = { { min::MISSING(), NULL, 11 },
                  { min::MISSING(), NULL, 22 },
                  { min::MISSING(), NULL, 33 } };
    min::push ( pvip, 3, e2 );
        // Again no need to call MUP::acc_write_update because
        // e2 does not point at stubs.
        //
        // pvp[1].j == 11
        // pvp[2].j == 22
        // pvp[3].j == 33

    min::locatable_gen name1, name2;
    name1 = min::new_str_gen ( "my-name-1" );
    name2 = min::new_str_gen ( "my-name-2" );

    pve e3 = { name1, min::stub_of ( name2 ), 44 };
    min::push(pvip) = e3
        // Here it is necessary that the right size of =
        // not call relocating min::new_... functions
        // because min::push returns a `pve &' value and
        // not a min::ref<pve> value.
    MUP::acc_write_update ( pvip, e3.g ); 
    MUP::acc_write_update ( pvip, e3.s ); 
        // We must call acc_write_update ourselves as
        // pve is not itself a locatable type.

        // pvp->length == 5
    min::resize ( pvip, 10 );
        // pvp->max_length == 10

    pve e4;
    locatable_gen g2;
    locatable_var<const min::stub *> s2;
    e4 = min::pop ( pvip );
        // e4.j == 44
        // pvp->length == 4
    g2 = e4.g;
    s2 = e4.s;
        // We must make e4.g and e4.s locatable before
        // we call any more relocating functions, where we
        // are assuming they might no longer be related to
        // name1 and name2 above.

    pve e5[3];
    min::pop ( pvip, 2, e5 );
        // e5[0].j == 22
        // e5[1].j == 33
    e4 = min::pop ( pvip );
        // e4.j == 11
        // pvp[0].j == 88
        // pvp->length == 1
}
\end{verbatim}\end{indpar}

Packed vector pointers do no caching and
there is \underline{no need} for
a refresh function analogous to the \TT{min::\EOL \ldots\_\EOL refresh}
functions for list pointers (\pagref{LIST-POINTER-CACHE}).

\subsection{Files}
\label{FILES}

A MIN \key{file} is a sequence of UTF-8 encoded \TT{NUL}-terminated
lines plus descriptive information.  A \minkey{file} value is a
pointer to a packed structure that contains the descriptive information
and also contains
a pointer to a packed \TT{char} vector,
the \key{file buffer}\index{buffer!file}, that contains the lines.

The main purpose of the \TT{min::file} type is to allow lines
previously read to be retrieved so they can be printed in error messages.
To this end, some or all read file lines are saved in the file buffer,
and an index to these lines is maintained in
a \key{line index}\index{index!file line}\index{file line index}.
There are two main options for managing this: one is to retain
\underline{all} previously read lines, and the other is to maintain
only the last $N$ lines, where $N$ is the \ttmkey{spool\_lines}{of file}
parameter of the file.

The data types and members of a file are:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::file_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{file}
\LABEL{MIN::FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::packed_vec_insprt<char> file| & \TTARMKEY{buffer}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER} \\
\verb|min::uns32 file| & \TTARMKEY{buffer->length}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER_LENGTH} \\
\verb|min::uns32 file| & \TTARMKEY{end\_offset}{in {\tt min::file}}
\LABEL{MIN::FILE_END_OFFSET} \\
\verb|min::uns32 file| & \TTARMKEY{end\_count}{in {\tt min::file}}
\LABEL{MIN::FILE_END_COUNT} \\
\verb|min::uns32 file| & \TTARMKEY{file\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_FILE_LINES} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL line\_\EOL number}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_NUMBER} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL offset}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_OFFSET} \\
\verb|min::packed_vec_insptr<min::uns32> file|
    & \TTARMKEY{line\_index}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_INDEX} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 file| & \TTARMKEY{spool\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_SPOOL_LINES} \\
\verb|min::uns32 file| & \TTARMKEY{line\_display}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_DISPLAY} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::istream * file| & \TTARMKEY{istream}{in {\tt min::file}}
\LABEL{MIN::FILE_ISTREAM} \\
\verb|min::file file| & \TTARMKEY{ifile}{in {\tt min::file}}
\LABEL{MIN::FILE_IFILE} \\
\verb|std::ostream * file| & \TTARMKEY{ostream}{in {\tt min::file}}
\LABEL{MIN::FILE_OSTREAM} \\
\verb|min::printer file| & \TTARMKEY{printer}{in {\tt min::file}}
\LABEL{MIN::FILE_PRINTER} \\
\verb|min::file file| & \TTARMKEY{ofile}{in {\tt min::file}}
\LABEL{MIN::FILE_OFILE} \\
\verb|min::gen file| & \TTARMKEY{file\_name}{in {\tt min::file}}
\LABEL{MIN::FILE_FILENAME} \\
\end{tabular}\end{indpar}


The members of a file may be read but \underline{not} written, unless
noted below.  They are:

\begin{itemlist}[1.4in]

\item[\ttmkey{buffer}{in {\tt min::file}}]
The vector of \TT{char}'s that contains the lines of the file.  Each
line is encoded using modified UTF-8\footnote{Modified UTF-8 is UTF-8
modified by using the overlong 2-byte encoding of \TT{NUL}, so that strings
may both contain the \TT{NUL} character (in the overlong encoding)
and be \TT{NUL} terminated.}
and \TT{NUL} terminated.
A non-\TT{NUL}-terminated, modified UTF-8
encoded, incomplete
last line, called a \key{partial line}\label{PARTIAL-LINE},
may appear at the end of the buffer.

Note that in general functions that load data into files do \underline{not}
check for illegal UTF-8 encodings, and should not be used to load
\TT{NUL} characters into files.  Line terminating
\TT{NUL} characters should be loaded by the \TT{min::end\_line} function.

Initialized to an empty buffer when the file is created.  The
\TT{min::\EOL init\_\EOL input\ldots} functions arrange for filling
the buffer.
Some of these functions fill the buffer with the complete file.
Others arrange for the buffer to be filled as needed from
the file \TT{istream} or \TT{ifile} members.  The 1-argument
\TT{min::\EOL init\_\EOL input} function creates an empty buffer
or empties an existing buffer and expects the user to fill the
buffer using \TT{min::\EOL push}, \TT{min::load\_\ldots},
and \TT{min::\EOL end\_\EOL line}
functions (see \pagref{WRITING-FILE-BUFFER}).

\item[\ttmkey{buffer->length}{in {\tt min::file}}]
The number of \TT{char} elements in the file buffer
(as per the buffer being a packed vector: see \itemref{PACKED-VECTORS}).
This is \TT{0} when the buffer is empty.

\item[\ttmkey{end\_\EOL offset}{in {\tt min::file}}]
The offset of the \TT{buffer} element just \underline{after} the last
line-terminating \TT{NUL} character in the \TT{buffer}.  Or \TT{0} if there
are no line-terminating \TT{NUL} characters.
This is \TT{0} when the buffer is empty.
Initialized to \TT{0} when the file is created and set appropriately by
\TT{min::\EOL init\_\EOL input\ldots}
and \TT{min::\EOL load\_\ldots}
functions.

\item[\ttmkey{end\_\EOL count}{in {\tt min::file}}]
The number of line-terminating \TT{NUL} characters that have ever been
placed into the \TT{buffer} for the file.
Initialized to \TT{0} when the file is created or initialized
for input by a \TT{min::\EOL init\_\EOL input\ldots} function.
Incremented by \TT{min::\EOL load\_\ldots} and
\TT{min::\EOL end\_\EOL line}.

When spooling is used, lines may be deleted from the beginning of
the \TT{buffer}, but \TT{end\_\EOL count} will not be changed, so
\TT{end\_\EOL count} may not be the number of \TT{NUL} characters
\underline{currently} in the buffer.

\item[\ttmkey{file\_\EOL lines}{in {\tt min::file}}]
If all the \TT{char}'s in the file have been appended to the file \TT{buffer},
this is the number of complete lines in the file, which equals
\TT{end\_count}. Otherwise this equals \TT{min::\EOL NO\_\EOL LINE}.

Initialized to \TT{min::\EOL NO\_\EOL LINE} when the file is created and by
\TT{min::\EOL init\_\EOL input\ldots} functions that do not load
the entire contents of the file into the file \TT{buffer}.
Set to the number of complete lines in the file
by \TT{min::\EOL init\_\EOL input\ldots} functions that load
the entire contents of the file into the file \TT{buffer}, or
by \TT{min::\EOL next\_\EOL line} when that function
reads an end of file from \TT{istream} or \TT{ifile}.
Set to \TT{end\_count} by the \TT{complete\_file} function that marks
a file has being complete.

\item[\ttmkey{next\_\EOL line\_\EOL number}{in {\tt min::file}}]
The number of the next line to be returned by the
\TT{min::\EOL next\_\EOL line}
function that is used by programs to read lines from a \TT{min::\EOL file}.
Or the total number of lines in the file if there is no next line
(there may still be a remaining portion of a partial line).
The first line number is \TT{0}.
Set to \TT{0} by \TT{min::\EOL init\_\EOL input\ldots} functions.
Reset appropriately when the file is rewound.

\item[\ttmkey{next\_\EOL offset}{in {\tt min::file}}]
The offset in the \TT{buffer} of the first character of the
next line to be returned by the \TT{min::\EOL next\_\EOL line}
function, when that function returns a line (i.e., does \underline{not}
return \TT{NO\_\EOL LINE}, i.e., when \TT{next\_offset < end\_offset}).
Specifically, \TT{buffer[next\_\EOL offset]} is
the first character of the next line.

Or when \TT{end\_offset <= next\_offset}, so that
\TT{NO\_\EOL LINE} is returned by \TT{min::\EOL next\_\EOL line},
the offset in the \TT{buffer} of the first character of the
partial line at the end of the buffer
that has not been previously skipped by
the \TT{min::\EOL skip\_\EOL remaining} function
(see \pagref{MIN::SKIP_REMAINING}).  This partial line may be
empty, and it is \underline{not} \TT{NUL} terminated:
see \TT{min::\EOL remaining\_\EOL length} on
\pagref{MIN::REMAINING_LENGTH}.

Set to \TT{0} by \TT{min::\EOL init\_\EOL input\ldots} functions.
Reset appropriately when the file is rewound.

\item[\ttmkey{line\_\EOL index}{in {\tt min::file}}]
If \TT{spool\_lines~!=~0} (see below), then
\TT{line\_index[m]} is the offset in the buffer of the first
character of line number \TT{n} (or of the line-terminating \TT{NUL}
if the line is empty), where
\begin{center}
{\tt m = line\_index->length - ( next\_line\_number - n )}
\end{center}
provided
\begin{center}
{\tt 0 < ( next\_line\_number - n ) <= line\_index->length}
\end{center}
or equivalently,
\begin{center}
\tt
next\_line\_number - line\_index->length \\
<= n < \\
next\_line\_number
\end{center}

If the file has not been rewound since it was initialized by
a \TT{min::\EOL init\_\EOL input\ldots} function with
\TT{spool\_lines~!=~0}, it is guaranteed that
\begin{center}
\tt
line\_index->length \\
>= \\
min ( spool\_lines, next\_line\_number)
\end{center}
so at least \TT{min(spool\_lines, next\_line\_number)}
lines can be located using the line index.

If \TT{spool\_lines~==~min::ALL\_LINES}, which is just the largest possible
\TT{min::uns32} integer, then \TT{spool\_lines >= next\_line\_number},
\TT{line\_\EOL index->\EOL length == next\_\EOL line\_\EOL number},
\TT{m~==~n}, and all the lines in the file before the next line can be located
using the line index.

Otherwise, if \TT{spool\_lines~>~0},
\TT{line\_\EOL index->\EOL length} is determined by
the past history of calls to \TT{min::\EOL flush\_\EOL spool} and
\TT{min::rewind} (see \pagref{LINE-INDEX-LENGTH}).

Created when \TT{spool\_\EOL lines} is set to a non-\TT{0} value
and set to \TT{min::\EOL NULL\_\EOL STUB}
when \TT{spool\_\EOL lines} is set to a \TT{0} value.
Truncated when a file is rewound and downsized when
\TT{min::\EOL flush\_\EOL spool} is called.

\item[\ttmkey{spool\_\EOL lines}{in {\tt min::file}}]
If \TT{0}, \TT{line\_index~==~min::NULL\_STUB} and there is
no spooling.  Otherwise when \TT{min::flush\_spool(n)} is called
with \TT{n <= next\_\EOL line\_\EOL number}, then
if there are more than \TT{spool\_\EOL lines} before line number
\TT{n} in the \TT{line\_\EOL index}, lines before
line number \TT{n - spool\_lines} are deleted.

Set to \TT{0} when the file is created.  Set to an argument
that defaults to \TT{min::\EOL ALL\_\EOL LINES}, the largest
\TT{min::uns32} number,
by \TT{min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{line\_\EOL display}{in {\tt min::file}}]\label{FILE_LINE_DISPLAY}
These are some of the printer
\TT{print\_\EOL format.op\_flags}
(see \pagref{PRINT_FORMAT_OP_FLAGS}) used to print
a file line for error message purposes,
in particular by the \TT{min::\EOL print\_\EOL line}
function (\pagref{MIN::PRINT_LINE}).
The flags involved are:
\begin{indpar}
\tt
\begin{tabular}{l}
min::DISPLAY\_EOL \\
min::DISPLAY\_PICTURE \\
min::DISPLAY\_NON\_GRAPHIC \\
\end{tabular}
\end{indpar}

These flags also determine the column position of each character representative
in the line, and are used to this end by the
by the \TT{min::\EOL print\_\EOL line\_\EOL column}
function (\pagref{MIN::PRINT_LINE_COLUMN}).

For example, the carriage
return prints as follows with the given flags:
\begin{center}
\begin{tabular}{l@{~~~~}ll}
\TT{min::DISPLAY\_PICTURE}
	& {\tiny $\stackrel{\textstyle C~}{~R}$} & 1 column \\
\\[1ex]
no \TT{min::DISPLAY\_PICTURE} & \TT{<CR>} & 4 columns \\
\end{tabular}
\end{center}

The \TT{min::print\_line} function, and the other functions that use
it, print file lines with the printer \TT{op\_flags} and \TT{print\_\EOL format}
set by
\begin{center}
\tt printer <{}< min::set\_line\_display ( file->line\_display )
\end{center}

\TT{line\_display} is set
to \TT{0} when the file is created, and set to an argument
that defaults to \TT{0}
by \TT{min::\EOL init\_\EOL input\ldots} functions.

\item[\ttmkey{istream}{in {\tt min::file}}]
If not \TT{NULL}, the \TT{min::\EOL next\_\EOL line} function
reads lines from this \TT{std::\EOL istream} when it finds
there is no line to return to its caller.
Set to \TT{NULL} when the file is created.

\item[\ttmkey{ifile}{in {\tt min::file}}]
If not \TT{min::NULL\_STUB}, the \TT{min::\EOL next\_\EOL line} function
reads lines from this \TT{min::\EOL file} when it finds
there is no line to return to its caller.
Set to \TT{min::\EOL NULL\_\EOL STUB} when the file is created.

Note that it is a programming error if \TT{istream != NULL}
\underline{and} \TT{ifile != NULL\_\EOL STUB}.

\item[\ttmkey{ostream}{in {\tt min::file}}]\label{OSTREAM_OF_FILE}
If not \TT{NULL}, then the \TT{min::\EOL flush\_\EOL file} function
outputs buffer \TT{char} elements to this \TT{std::\EOL ostream} when it finds
there are elements not yet output.
Line-terminating \TT{NUL} elements are translated into calls to
\TT{std::\EOL endl}.
Set to \TT{NULL} when the file is created.

\item[\ttmkey{printer}{in {\tt min::file}}]\label{PRINTER_OF_FILE}
If not \TT{min::NULL\_STUB}, then the \TT{min::\EOL flush\_\EOL file} function
outputs buffer \TT{char} elements
to this \TT{min::\EOL printer} when it finds
there are elements not yet output.
Non-NUL elements in a
line are output as per the \TT{min::\EOL verbatim}
printer operation (\pagref{MIN::VERBATIM}),
and the line-terminating
NUL elements are translated into sending \TT{min::eol} to the printer.
Note that \TT{line\_\EOL display} is \underline{not} used
when buffer elements are flushed to \TT{printer}.

Set to \TT{min::\EOL NULL\_\EOL STUB} when the file is created.

\item[\ttmkey{ofile}{in {\tt min::file}}]\label{OFILE_OF_FILE}
If not \TT{min::NULL\_STUB}, then the \TT{min::\EOL flush\_\EOL file} function
outputs buffer \TT{char} elements to this \TT{min::\EOL file} when it finds
there are elements not yet output.
Non-NUL elements are simply appended to the end of the \TT{ofile}, and
line-terminating \TT{NUL} elements are translated into calls to
\TT{min::\EOL line\_\EOL end~(~ofile~)}.
Set to \TT{min::\EOL NULL\_\EOL STUB} when the file is created.

\item[\ttmkey{file\_name}{in {\tt min::file}}]
If not \TT{min::MISSING()}, this
is the name of this file used for printing error messages
concerning file lines, in particular by the
\TT{min::\EOL pline\_\EOL numbers} constructor
(\pagref{MIN::PLINE_NUMBERS}).
Set to \TT{min::\EOL MISSING()} when the file is created.

\end{itemlist}

Creation, initialization, and parameterization of files is
accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{init\RESIZE}
     \verb|( min::ref<min::file> file )|
\LABEL{MIN::INIT_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_line\_display\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display )|
\LABEL{MIN::INIT_PRINT_FLAGS_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_\EOL file\_\EOL name\REL}\ARGBREAK
	     \verb|( min::ref<min::file> file,|\ARGBREAK
             \verb|  min::gen file_name )|
\LABEL{MIN::INIT_FILE_NAME_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_ostream\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_ofile\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ofile )|
\LABEL{MIN::INIT_OFILE_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_printer\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::printer printer )|
\LABEL{MIN::INIT_PRINTER_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{ALL\_LINES}
				\TT{=} maximum \TT{min::uns32} value
\LABEL{MIN::ALL_LINES} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{init\_\EOL input\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_stream\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::istream & istream,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STREAM_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ifile,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::gen file_name,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_NAMED_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<const char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  const char * string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CHAR_PTR_OF_FILE} \\
\end{tabular}\end{indpar}

All these \TT{min::}\MINKEY{init\ldots} functions create a \TT{file}
and set their first argument if that argument initially
has the value \TT{min::\EOL NULL\_\EOL STUB}.

The non-\TT{init\_\EOL input\ldots} functions just do this and set
a file member.
For example, \TT{min::\EOL init\_\EOL line\_\EOL display} just
creates the file if necessary and sets \TT{line\_\EOL display},
while \TT{min::\EOL init\_\EOL ostream} just
creates the file if necessary and sets \TT{ostream}.
Used on an existing file, these functions do nothing but change
a file parameter.

The \TT{min::\EOL init\_\EOL input\ldots} functions
reinitialize all members except \TT{ostream}, \TT{ofile},
and \TT{printer}.  Like all file \TT{init} functions, these
create the file if necessary.
All these functions take arguments that initialize \TT{line\_\EOL display}
and \TT{spool\_\EOL lines}.

The \TT{min::init\_input} function assumes
input to the file will come from some outside source.  It empties the
\TT{buffer} and sets
\TT{istream} to \TT{NULL}, \TT{ifile} to \TT{min::\EOL NULL\_\EOL STUB},
and \TT{file\_\EOL name} to \TT{min::\EOL MISSING()}.
For example,\label{WRITING-FILE-BUFFER}
\begin{indpar}\begin{verbatim}
min::locatable_ptr<min::file> file;
init_input ( file );
...
const char * my_string = ...;
int length = ::strlen ( my_string );
min::push ( file->buffer, length, my_string );
min::end_line ( file );
...
\end{verbatim}\end{indpar}
Here \TT{min::push} is just the packed vector push function
(\pagref{MIN::PACKED_VEC_PUSH}) applied
to push character representatives
to the end of the file \TT{buffer}, and the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::END_LINE_FILE} \\
\end{tabular}\end{indpar}

pushes a line terminating \TT{NUL} character to the end of
\TT{buffer}, updates \TT{end\_\EOL offset} to equal the
new buffer length, and increments \TT{end\_\EOL count}.

When a file initialized by \TT{min::\EOL init\_\EOL input}
is complete, you should call the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{complete\_file} \verb|( min::file file )|
\LABEL{MIN::COMPLETE_FILE} \\
\end{tabular}\end{indpar}

to mark the file as being complete by copying \TT{end\_\EOL count}
to \TT{file\_\EOL lines}.  After doing this, you should
not push any more characters into the file's buffer or call
\TT{min::\EOL end\_\EOL line} for the file.

You can also append to a file initialized by \TT{min::\EOL init\_\EOL input}
by making it the \TT{ofile} of another file and flushing this other file
(see \TT{min::\EOL flush\_\EOL file}, \pagref{MIN::FLUSH_FILE}).
For example,
\begin{indpar}\begin{verbatim}
min::locatable_ptr<min::file> file1, file2;
init_input ( file1 );
init_input_... ( file2, ... );
init_ofile ( file2, file1 );
. . . . .
min::flush_file ( file2 );
\end{verbatim}\end{indpar}
Here \TT{min::\EOL flush\_\EOL file} copies any portion of
\TT{file2} not previously flushed to the end of \TT{file1}.
Also, it calls \TT{complete\_file} for \TT{file1} if \TT{file2}
is complete (this last behavior can be suppressed by
giving an extra argument to \TT{min::\EOL flush\_\EOL file}).

You \underline{cannot} push characters to a file initialized by any
\TT{min::\EOL init\_\EOL input\ldots} function other than
\TT{min::\EOL init\_\EOL input}.

You can append the contents of a string to a file initialized
with \TT{min::\EOL init\_\EOL input} by using one of the functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<const char> string )|\ARGBREAK
\LABEL{MIN::LOAD_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<char> string )|\ARGBREAK
\LABEL{MIN::LOAD_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  const char * string )|\ARGBREAK
\LABEL{MIN::LOAD_CHAR_PTR_OF_FILE} \\
\end{tabular}\end{indpar}

These copy the \TT{string} to the end of the file \TT{buffer} and replace any
`\TT{\textbackslash n}' line feeds in the copy with line terminating
\TT{NUL}'s.  When these functions are called, \TT{file}
must \underline{not} be complete.
Any \TT{const char * string} argument must
\underline{not} be a pointer to a relocatable string.

Similarly the contents of an operating system named file
can be copied to the end of a file \TT{buffer} by the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|bool min::|
    & \MINKEY{load\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::gen file_name )|\ARGBREAK
\LABEL{MIN::LOAD_NAMED_FILE_OF_FILE} \\
\end{tabular}\end{indpar}

In this case, both
`\TT{\textbackslash n}' line feeds and \TT{NUL} characters in the copy
of the file contents are replaced by line terminating
\TT{NUL}'s.  Also, if there is any error reading the file,
an error message is written into \TT{min::\EOL error\_\EOL message}
(\pagref{ERROR_MESSAGE}) and \TT{false} is returned, whereas if
there is no read error \TT{true} is returned.
The file must have a well defined size; it cannot be a named stream.
When this function is called, \TT{file}
must \underline{not} be complete.

The \TT{min::init\_input\_string} function initializes the file
for input, loads that string into the file \TT{buffer}, and marks the file
complete.
Any \TT{const char * string} argument must
\underline{not} be a pointer to a relocatable string.

The \TT{min::init\_input\_named\_file} function
initializes the file for input,
sets the \TT{file\_\EOL name} member,
loads the contents of the operating system file this names into the
file \TT{buffer}, and marks the file complete.
The file must have a well defined size; it cannot be a named stream.
If no error occurs reading the file, \TT{true}
is returned.  Otherwise an error message is written into
into \TT{min::\EOL error\_\EOL message}
(\pagref{ERROR_MESSAGE}) and \TT{false} is returned.

The \TT{min::init\_input\_stream} function does not load data into
the file \TT{buffer}, but instead initializes the file as per
\TT{min::init\_input} with an empty \TT{buffer}
and sets the file \TT{istream} member
which causes the \TT{min::\EOL next\_\EOL line} function (see below)
to load lines to the end of
the file \TT{buffer}
from \TT{istream} as new lines are required.  Similarly
the \TT{min::\EOL init\_\EOL input\_\EOL file} function sets
\TT{ifile} which causes \TT{min::\EOL next\_\EOL line} to load lines
from \TT{ifile} as new lines are required.
In both cases, \TT{file\_lines} is initialized
to \TT{min::\EOL NO\_\EOL LINE}, and not changed until
an end of file is read from \TT{istream} or \TT{ifile}, at which time
\TT{file\_\EOL lines} is set to the number of lines in the file
thereby marking the file as complete.

Initializing a file with a \TT{min::\EOL init\_\EOL input\ldots} function
sets \TT{next\_\EOL line\_\EOL number}
and \TT{next\_\EOL line\_\EOL offset} to \TT{0}, thereby
setting up the \TT{min::\EOL next\_\EOL line} function to
sequence through file lines, beginning with the first line of the file:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{NO\_LINE}
\LABEL{MIN::NO_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{next\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::NEXT_LINE_OF_FILE} \\
\end{tabular}\end{indpar}

The \TT{min::\EOL next\_\EOL line} function returns an
\TT{offset} such that the file \TT{buffer[offset]} element
is the first character of the next \TT{NUL}-terminated line.
If there is no such line, because we are at the end of the \TT{buffer},
\TT{min::\EOL NO\_\EOL LINE} is returned instead.  In this case
there may still be a non-\TT{NUL}-terminated partial line at the end
of the file (see \pagref{PARTIAL-LINE}).

A file is complete, in the sense the no more characters will be
appended to its \TT{buffer}, if \TT{file\_\EOL lines} contains
the number of complete lines in the file, and is not equal to
\TT{min::\EOL NO\_\EOL LINE}.  This can be tested by

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|bool min::|
    & \MINKEY{file\_\EOL is\_\EOL complete} \verb|( min::file file )|
\LABEL{MIN::FILE_IS_COMPLETE} \\
\end{tabular}\end{indpar}

If \TT{istream} is not \TT{NULL}, then when
\TT{min::\EOL next\_\EOL line} encounters the
end of \TT{buffer} and the file is not complete,
\TT{min::\EOL next\_\EOL line}
reads from \TT{istream} and pushes the characters read to
the end of \TT{buffer}, until a linefeed, \TT{NUL}, or end of file
is read.  Both linefeeds and \TT{NUL}'s invoke \TT{min::\EOL end\_\EOL line}
to terminate the line.  If instead an end of file is read,
the file is completed by setting
\TT{file\_\EOL lines} to \TT{next\_\EOL line\_\EOL number},
and no further use of \TT{istream} is made on this or subsequent calls to
\TT{min::\EOL next\_\EOL line}.  In this case
a partial line may have been
produced at the end of \TT{buffer}.

If \TT{min::\EOL next\_\EOL line} returns
\TT{min::\EOL NO\_\EOL LINE}, the file may or may not be complete.
Certain files have the `\key{completeness property}', which means
that \TT{min::\EOL next\_\EOL line} returns
\TT{min::\EOL NO\_\EOL LINE} only if the file is complete.
A file with a non-\TT{NULL} \TT{istream} has the completeness property.

If the \TT{ifile} member of the file is not
\TT{min::\EOL NULL\_\EOL STUB}, instead of the \TT{istream} member
being non-\TT{NULL},
\TT{min::\EOL next\_\EOL line} gets
more characters by calling
\TT{min::\EOL next\_\EOL line(ifile)} instead of by using
\TT{istream}.  Characters in partial lines of \TT{ifile}
are also gotten when they become available,
and the file is completed when \TT{ifile} becomes complete.
The file has the completeness property only if \TT{ifile} has
this property.

The partial line (\pagref{PARTIAL-LINE}) that may end the file when
\TT{min::\EOL next\_\EOL line} returns \TT{min::\EOL NO\_\EOL LINE}
can be returned by the functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::REMAINING_OFFSET} \\
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::REMAINING_LENGTH} \\
\end{tabular}\end{indpar}

The \TT{min::\EOL remaining\_\EOL length}
function returns \TT{ buffer->\EOL length - next\_\EOL offset},
the total number of partial line bytes, and
the \TT{min::\EOL remaining\_\EOL offset} function returns
\TT{next\_\EOL offset},
the offset in the file buffer of the first of these bytes.
Note that these bytes do \underline{not} end with \TT{NUL}.
After processing these bytes, the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{skip\_\EOL remaining} \verb|( min::file file )|
\LABEL{MIN::SKIP_REMAINING} \\
\end{tabular}\end{indpar}

can be used to set \TT{next\_\EOL offset}
to be equal to \TT{buffer->\EOL length} in order to
prevent reprocessing the bytes.

The \TT{min::skip\_remaining} function can have an undesirable
interaction with the use of the two argument \TT{min::\EOL end\_\EOL line}
function (see below) to
make an initial segment of a partial line into a complete line.
It also affects the next
call to \TT{min::\EOL next\_\EOL line}; specifically, if remaining
bytes are skipped, then added to and made into a complete line,
the next call to \TT{min::\EOL next\_\EOL line} will return that line as if
it consisted of only of the non-skipped characters that were added
after the call to \TT{min::\EOL skip\_\EOL remaining}.

At any time the complete partial line at the end of the file, including
bytes skipped over by \TT{min::\EOL skip\_\EOL remaining}, can be
accessed by the functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_OFFSET} \\
\end{tabular}\end{indpar}

The \TT{min::\EOL partial\_\EOL length}
function returns \TT{ buffer->\EOL length - end\_\EOL offset},
the total number of partial line bytes, and
the \TT{min::\EOL partial\_\EOL offset} function returns
\TT{end\_\EOL offset},
the offset in the file buffer of the first of these bytes.
Note that these bytes do \underline{not} end with \TT{NUL}.

If the end of the \TT{buffer} contains a partial line,
the following function may be used to split this into
a complete line possibly followed by a shorter partial line:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::END_LINE_FILE_WITH_OFFSET} \\
\end{tabular}\end{indpar}

This function sets \TT{buffer[offset]} to NUL, overwriting
any previous \TT{char} value of this buffer element, and
making this element the line-terminating \TT{NUL} for an initial segment
of the partial line at the end of the buffer.  The remainder of
the partial line, if there is any, becomes the new partial line at the
end of the buffer.

Note that a partial line \underline{cannot}\label{SKIP_REMAINING_END_LINE}
be split using the
last function if \TT{min::\EOL skip\_\EOL remaining}
(\pagref{MIN::SKIP_REMAINING}) has been used to skip past the
\TT{offset} point where the \TT{NUL} would be written.

A main reason why the \TT{min::file} type exists is to allow lines
previously returned by \TT{min::\EOL next\_\EOL line} to be retrieved
so they can be printed in error messages.
The following function does this:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{line}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number )|
\LABEL{MIN::LINE_OF_FILE} \\
\end{tabular}\end{indpar}

Here \TT{line\_number} is \TT{0} for the first line of the file,
\TT{line\_index} must exist (i.e., not be \TT{NULL\_\EOL STUB}),
and
\begin{center}\begin{tabular}{rl}
       & \tt file->next\_line\_number - file->line\_index->length \\
\tt <= & \tt line\_number \\
\tt < & \tt file->next\_line\_number
\end{tabular}\end{center}
is required.  If these conditions are not met, \TT{min::\EOL line}
returns \TT{min::\EOL NO\_\EOL LINE}.

Whether\label{LINE-INDEX-LENGTH}
the required conditions are met depends upon
the setting of \TT{spool\_\EOL lines}
and any use of the \TT{min::\EOL flush\_\EOL spool} or \TT{min::rewind}
functions which are described below.

If \TT{spool\_\EOL lines} equals \TT{0},
\TT{line\_\EOL index} does not exist, and \TT{min::\EOL line}
always returns \TT{min::\EOL NO\_\EOL LINE}.
 If \TT{spool\_\EOL lines} equals
\verb|min::|\MINKEY{ALL\_\EOL LINES}, the default argument setting
for all \TT{min::\EOL init\_\EOL input\ldots} functions,
then all lines
previously returned by \TT{min::\EOL next\_\EOL line} are always available,
\TT{line\_\EOL index->\EOL length} always equals
\TT{next\_\EOL line\_\EOL number},
and the above requirement reduces to
\begin{center}
\tt 0 <= line\_number < file->next\_line\_number
\end{center}

For other values of \TT{spool\_\EOL lines}, which are useful
if a very long input file is being read and some ability to
look back a short ways is desired,
\TT{line\_\EOL index} exists and
\TT{line\_\EOL index->\EOL length} is a function of the history
of calls to the \TT{min::rewind} function (see below)
and to the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{flush\_spool\RESIZE}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number = min::NO_LINE )|
\LABEL{MIN::FLUSH_SPOOL} \\
\end{tabular}\end{indpar}

Provided \TT{spool\_\EOL lines > 0},
this function deletes lines from the file buffer
if there are more than \TT{spool\_\EOL lines}
lines before the line of the given \TT{line\_\EOL number} in the buffer.
In this case all lines before the one with number
\begin{center}
\tt max ( line\_number - spool\_lines, 0 )
\end{center}
are deleted from \TT{file->\EOL buffer} and \TT{file->\EOL line\_\EOL index}.
If the \TT{line\_\EOL number}
argument is omitted or equivalently given as \TT{min::\EOL NO\_\EOL LINE},
it is replaced by \TT{next\_\EOL line\_\EOL number}.
It is required that
\begin{center}
\tt 0 <= line\_number <= file->next\_line\_number
\end{center}
but it is never a programming error if \TT{line\_\EOL number} is within
this range, even if no lines are deleted and even if \TT{spool\_\EOL lines}
is \TT{0} (and therefore \TT{line\_\EOL index} does not exist).

It is possible to `rewind' a file with the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{rewind}\ARGBREAK
	\verb|( min::file file,|\ARGBREAK
	\verb|  min::uns32 line_number = 0 )|
\LABEL{MIN::REWIND_FILE} \\
\end{tabular}\end{indpar}

This resets the next line that will be returned by
\TT{min::\EOL next\_\EOL line} to some previously
returned line.  The file \TT{buffer} is not changed, but
the file \TT{line\_\EOL index}, if it exists, may be truncated.

\TT{min::rewind(n)} is in error if
\TT{min::line(n)} would return \TT{min::\EOL NO\_\EOL LINE},
(so line number \TT{n} has no entry in the file \TT{line\_\EOL index}),
except for two special cases.
The first special case is when \TT{n == next\_\EOL line\_\EOL number},
in which case \TT{min::\EOL rewind(n)} does nothing.
The second special case is when \TT{n == 0} (the default)
and also \TT{spool\_\EOL lines == 0} (so that no lines have ever been
deleted from the file), in which case the file is reset so the next
line returned will be the first line of the file.

Normally rewind with \TT{n > 0} is only
used with files whose \TT{spool\_\EOL length == min::\EOL ALL\_\EOL LINES},
which eliminates the possibility of error.

The following function is used to copy or `flush' the lines in a file
to any \TT{ostream}, \TT{ofile}, and/or \TT{printer}
that the file has

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  bool copy_completion = true )|
\LABEL{MIN::FLUSH_FILE} \\
\end{tabular}\end{indpar}

This function first calls \TT{min::next\_line} repeatedly
for the file, and flushes each line returned by that function.
Then it flushes any partial line left over at the end of the
file, and calls \TT{min::\EOL skip\_\EOL remaining}
(\pagref{MIN::SKIP_REMAINING}) to skip over this partial line
(so it will be invisible to subsequent calls to
\TT{min::\EOL next\_\EOL line}).
Lastly, if the \TT{copy\_\EOL completion} argument is \TT{true},
if the file is complete, and
if the file has an \TT{ofile}, the \TT{min::\EOL complete\_\EOL file}
function is called for \TT{ofile} to mark that file as being complete.

See descriptions of the \TT{ostream} (\pagref{OSTREAM_OF_FILE}),
\TT{ofile} (\pagref{OFILE_OF_FILE}),
and \TT{printer} (\pagref{PRINTER_OF_FILE}) members of a file for more
specifics on how lines are flushed.

The flushing sub-actions of \TT{min::flush\_file} are available by using
the following functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::FLUSH_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{flush\_remaining\RESIZE} \verb|( min::file file )|
\LABEL{MIN::FLUSH_REMAINING} \\
\end{tabular}\end{indpar}

\TT{min::flush\_line} copies the line beginning at the given offset
to any \TT{ostream}, \TT{ofile},
and/or \TT{printer},
while \TT{min::\EOL flush\_\EOL remaining} copies any remaining
bytes in the partial line
at the end of the file
to any \TT{ostream}, \TT{ofile}, and/or
\TT{printer}.
Note that neither of these functions calls \TT{min::\EOL next\_\EOL line},
\TT{min::\EOL skip\_\EOL remaining}, or \TT{min::\EOL complete\_\EOL file}.

\underline{None} of
the \TT{min::\EOL flush\_file/\EOL line/\EOL remaining}
functions call \TT{min::\EOL flush\_\EOL spool}.

The following \TT{<{}<} operators do the same thing as
\TT{min::\EOL flush\_\EOL file} with a \TT{false} \TT{copy\_\EOL complete}
argument, except that, instead of copying
to the file's \TT{ostream}, \TT{ofile}, and/or
\TT{printer}, they copy to their lefthand operand:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<{}<}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{OSTREAM_OPERATOR<<_OF_FILE} \\
\verb|min::file |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::file ofile,|\ARGBREAK
      \verb|  min::file ifile )|
\LABEL{FILE_OPERATOR<<_OF_FILE} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{PRINTER_OPERATOR<<_OF_FILE} \\
\end{tabular}\end{indpar}

Note that these \TT{<{}<} operators call the \TT{min::\EOL next\_\EOL line}
and \TT{min::\EOL skip\_\EOL remaining} functions in the same way as
\TT{min::\EOL flush\_\EOL file} does, and therefore
these \TT{<{}<} operators interact with each other and with the
\TT{min::\EOL flush\_\EOL file} function.  Generally such interaction
is avoided by using only one of the \TT{<{}<} operators or only
the \TT{min::\EOL flush\_\EOL file} function on a given file.
Also note that the \TT{<{}<} operators never
call \TT{min::\EOL complete\_\EOL file}.

\subsection{Identifier Maps}
\label{IDENTIFIER-MAPS}

\ikey{Identifier Maps}{identifier map} are used on output
to translate \TT{min::gen} values to
\smkey{identifier}s{in identifier map} whose external form is
\TT{@}{\em index}, where {\em index} is a small integer
that indexes an element in the identifier map.
Usually the \TT{min::gen} values are pointers to objects,
and their identifiers are used in external files as surrogates
for the pointers.  Usually other \TT{min::gen} values are
output as themselves and not as identifiers, although long
string values may be output as identifiers.

A \TT{min::\EOL id\_\EOL map} is a packed vector with
\TT{min::gen} elements such that the index of an identifier
is the vector index of the \TT{id\_map} element containing the
\TT{min::gen} value associated with the identifier.
If \TT{min::gen} values need to be converted to identifiers, the
\TT{min::\EOL id\_\EOL map} also has an associated hash table
that maps \TT{min::gen} values to identifier indices.
When the hash table is used, the map between identifier indices
and \TT{min::gen} values can be made 1-to-1.  This should be done for
object values, so identifiers act as pointers in the external file.

On input from a file, an identifier is translated
to a \TT{min::gen} value by looking up the identifier index
in the identifier map's packed vector.  For objects, it is possible to do
this even if the contents of the object will not be be defined
until later in the file, by using an object stub of type
\TT{min::PREALLOCATED} as a place to put the object contents when
they are defined later.  This cannot be done for non-objects, which
must be defined when their identifier is first encountered.
On input the hash table mapping from
\TT{min::gen} values to identifier indices is not used.

Creation and use of id maps is accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_vec_ptr|\ARGBREAK
	  \verb|    < min::gen,|\ARGBREAK
	  \verb|      min::id_map_header<min::uns32> >|\ARGBREAK
	  \verb|min::|\MINKEY{id\_\EOL map}
\LABEL{MIN::ID_MAP} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::id_map min::| & \MINKEY{init\REL}
    \verb|( min::ref<min::id_map> map )|
\LABEL{MIN::INIT_OF_ID_MAP} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::ref<const min::gen> map| & \TTBMKEY{id}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_[]} \\
\verb|const min::uns32 map->| & \TTMKEY{length}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_LENGTH} \\
\verb|const min::uns32 map->| & \TTMKEY{occupied}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_OCCUPIED} \\
\verb|min::uns32 map->| & \TTMKEY{next}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_NEXT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{find\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g )|
\LABEL{MIN::FIND_OF_ID_MAP} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{find\_\EOL or\_\EOL add\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g )|
\LABEL{MIN::FIND_OR_ADD_OF_ID_MAP} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{map\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g,|\ARGBREAK
    \verb|  const min::gen_format * f = NULL )|
\LABEL{MIN::MAP_OF_ID_MAP} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{insert\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g,|\ARGBREAK
    \verb|  min::uns32 id )|
\LABEL{MIN::INSERT_OF_ID_MAP} \\
\end{tabular}\end{indpar}

If \TT{map} is a \TT{min::\EOL id\_\EOL map},
the \TT{min::gen} value \TT{g} associated with identifier index \TT{id} is
\TT{map[id]}.  If `\TT{find}' is being used to maintain the hash
table of \TT{map}, then \TT{id == find(map,g)}.

If \TT{id >= map->length} or if \TT{map[id]} is
\TT{min::NONE()}, then \TT{id} does not correspond
to any \TT{min::gen} value stored in \TT{map}.

The identifier value \TT{0} and \TT{min::NONE()} always correspond.
\TT{min::\EOL find(map,g)} returns \TT{0} if \TT{g} is either
\TT{min::NONE()} or is not in any correspondence stored in the map.

The \TT{min::init} function may be used to create or reset a \TT{map}
so that \TT{map->length == 1}.  \TT{map[0]} is set to equal
\TT{min::NONE()}, and this \TT{map} element cannot
be changed.

If identifiers are being output, the \TT{min::find\_\EOL or\_\EOL add}
function can be used to find the identifier of a \TT{min::gen} value
\TT{g}.  If \TT{g} is already
in the \TT{map}, its associated identifier is returned.  Otherwise \TT{g}
is pushed to the end of the \TT{map} vector and assigned an identifier which
is returned.  However, as a special case,
\TT{min::\EOL find\_\EOL or\_\EOL add} returns
\TT{0} if \TT{g} is \TT{min::NONE()}.

The \TT{min::map} function is more sophisticated than
\TT{min::find\_\EOL or\_\EOL add} and is preferred.  If its
argument \TT{g} does
not already have an identifier, it performs
\TT{min::find\_\EOL or\_\EOL add} on \TT{g} and
then performs \TT{min::map} recursively on element and attribute values
of \TT{g} using the format \TT{f} for guidance, as if \TT{g} were
being printed with format \TT{f}.  During this process an object
that would be printed as an identifier if it had an identifier
is given an identifier by \TT{min::\EOL find\_\EOL or\_\EOL add}.  Objects
that would be printed in compact format are not given such identifiers
unless the format that would be used to print them has the
\TT{min::\EOL PREFERRED\_\EOL ID} flag.
Also strings whose byte length equals or exceeds
the \ttikey{id\_\EOL strlen}{id\_strlen}
member of the \TT{min::\EOL str\_\EOL format} that would be used
to print them
are given identifiers by \TT{min::\EOL find\_\EOL or\_\EOL add},
provided the \TT{id\_\EOL strlen} member is as least as large as
the value of \TT{MIN\_ID\_STRLEN}.
After all identifiers have
been assigned, they are swapped as necessary to make new non-object
identifiers come before new object identifiers.

When \TT{min::\EOL find\_\EOL and\_\EOL add} or \TT{min::map}
assign new identifiers, \TT{map->length} is incremented but
\TT{map->next} is not.  The identifiers \TT{map->next}, \ldots{},
\TT{map->length-1} are for objects that have not yet been
output.  The \TT{printer << min::flush\_\EOL id\_\EOL map} operation
(see \pagref{MIN::FLUSH_ID_MAP})
outputs the objects and strings referenced by these identifiers
in the the form

\begin{center}
\TT{@}{\em identifier} \TT{=} {\em object-or-string}
\end{center}

This operation outputs smallest identifiers first and increments
\TT{map->next} until it equals \TT{map->length}.

If identifiers are being input, \TT{map[id]} can be used
to find the \TT{min::gen} value
associated with \TT{id}, unless there is no such value.
If there is no value associated with \TT{id}, a \TT{min::gen}
value pointing at a stub of \minkey{PREALLOCATED}\LABEL{MIN::PREALLOCATED}
type can be created and inserted into the map with the \TT{min::\EOL insert}
function, which will increase the length of the map if necessary to
accommodate \TT{id}.  Later the contents of the stub can be set by using
\TT{MUP::stub\_swap}: see \itemref{SWAPPING-STUBS}.

The \TT{min::find} function is used internally by \TT{min::map} to find
out which objects or long strings already have an identifier.
It returns the identifier associated with a value \TT{g} if one exists,
or returns \TT{0} if no such identifier exists.
\TT{min::\EOL find} also returns
\TT{0} if \TT{g} is \TT{min::NONE()}.

Part of an identifier map is a hash table that permits
\TT{min::\EOL find\ldots} functions to work quickly.  This
hash table is created by the first call to a
\TT{min::\EOL find\ldots} function.
The hash table is maintained by \TT{min::\EOL find\_\EOL and\_\EOL add},
unless the hash table has become too small to be efficient, in which case
this function discards it so a larger hash table will be created
by the next call to a \TT{min::\EOL find\ldots} function.
The \TT{map->\EOL occupied} member of the map records the number of
\TT{map} vector elements that are not \TT{min::NONE()},
that is, the number of associations recorded in the map, and this is used
to determine the proper size of the hash table.

If the hash table does not exist, \TT{min::\EOL insert} does not created it.
Otherwise \TT{min::\EOL insert} maintains the hash table in the same was
as \TT{min::\EOL find\_\EOL and\_\EOL add}.

\subsection{Printers}
\label{PRINTERS}

A \key{printer} may be used to print general values, print graphics for
control characters, and break long lines to enforce line length.
Internally a \TT{min::\EOL printer} is
a packed structure that points at a \TT{min::\EOL file} and contains
additional information used to format lines put into the file.
Values are written to printers via the \TT{<{}<} operator, much like the
way values are written to \TT{std::\EOL ostream}'s.  A special
printer line end operation writes a line terminating \TT{NUL}
at the end of the printer file buffer, and optionally flushes the file.

The MIN system has a per-thread printer to hold error messages:
\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::locatable_var<min::printer> min::| & \MINKEY{error\_\EOL message}
\LABEL{MIN::ERROR_MESSAGE}%
\label{ERROR_MESSAGE} \\
\end{tabular}\end{indpar}

This functions like \TT{errno} in UNIX, but
holds multi-line error messages instead of an integer error
code.  The protocol for writing
an error message into this printer is to first apply
the 1-argument \TT{min::init} function to the printer to create the printer
if necessary, remove any previous message from the printer,
and put the printer into a default state,
and then write an error message consisting of one or more
complete lines to the printer.  The following code is often
used to do this:\label{ERROR_MESSAGE_EXAMPLE}
\begin{indpar}\begin{verbatim}
# define ERR min::init ( min::error_message )
...
if ( error-occurred )
{
    ERR << ... << min::eol;
    return value-indicating-error-occurred;
}
...
\end{verbatim}\end{indpar}

Here the \TT{min::init} function erases any previous error
message.

Creation and initialization of printers is
accomplished by the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::printer_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{printer}
\LABEL{MIN::PRINTER} \\
\verb|min::printer min::| & \MINKEY{init\REL}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  min::file file = min::NULL_STUB )|
\LABEL{MIN::INIT_OF_PRINTER} \\
\verb|min::printer min::| & \MINKEY{init\_ostream\RESIZE}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_PRINTER} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::file printer->| & \TTMKEY{file}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_FILE} \\
\verb|std::ostream * printer->| & \TTMKEY{ostream}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_OSTREAM} \\
\end{tabular}\end{indpar}

The \TT{min::}\MINKEY{init} function both re-initializes existing
printers and creates new ones.  It takes a variable as its
first argument, and if the variable value is \TT{min::\EOL
NULL\_\EOL STUB}, then a new printer is created and the
variable is set to point at the new printer.
The second argument to \TT{min::init} supplies the \TT{min::file}
to which the printer is attached.  If this argument is
\TT{min::\EOL NULL\_\EOL STUB}, then \TT{min::\EOL init\_\EOL input}
is applied to \TT{printer->file} to create that file if necessary
and empty it if it already exists; but if the argument is
not \TT{min::\EOL NULL\_\EOL STUB} then \TT{printer->file} is set
to the argument and the file is \underline{not} emptied or changed.

The \TT{min::}\MINKEY{init\_\EOL ostream}
function just executes
\begin{indpar}\begin{verbatim}
min::init ( printer );
min::init_ostream ( printer->file, ostream );
printer << min::flush_on_eol;
\end{verbatim}\end{indpar}

which is a very common way of setting up a printer.

Both initialization functions return the printer, which is
sometimes convenient, as in the code often used 
with \TT{min::\EOL error\_\EOL message}: see \pagref{ERROR_MESSAGE_EXAMPLE}.

Parameterization of printing is accomplished using the
following printer parameters:

\begin{indpar}[1em]\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct    min::| & \MINKEY{line\_\EOL break}
\LABEL{MIN::LINE_BREAK_STRUCT} \\
\verb|{              | \\
\verb|    min::uns32 | & \TTMKEY{offset}{in {\tt min::line\_break}}
			   & \verb|// Default 0| \\
\verb|    min::uns32 | & \TTMKEY{column}{in {\tt min::line\_break}}
			   & \verb|// Default 0| \\
\verb|    min::uns32 | & \TTMKEY{line\_length}{in {\tt min::line\_break}}
			   & \verb|// Default 72| \\
\verb|    min::uns32 | & \TTMKEY{indent}{in {\tt min::line\_break}}
			   & \verb|// Default 4| \\
\verb|}              | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 printer->| & \TTMKEY{column}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_COLUMN} \\
\verb|const min::line_break printer->|
    & \TTMKEY{line\_break}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK} \\
\verb|const min::line_break min::|
    & \TTKEY{default\_\EOL line\_\EOL break}
\LABEL{MIN::DEFAULT_LINE_BREAK} \\
\verb|const min::packed_vec_insptr<min::line_break>  | \\
\verb|printer->|
    & \TTMKEY{line\_break\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK_STACK} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rll}
\verb|struct              min::| & \MINKEY{print\_\EOL format}
	& \verb|// Defaults:|
\LABEL{MIN::PRINT_FORMAT_STRUCT} \\
\verb|{                        | \\
\verb|            min::uns32   |
	& \TTMKEY{op\_flags}{in {\tt min::print\_format}}
	& \verb|// min::EXPAND_HT| \\
\verb|            min::uns32 * |
	& \TTMKEY{char\_flags}{in {\tt min::print\_format}}
	& \verb|// min::standard_| \\
      & & \verb|//   char_flags| \\
\verb|     min::support_control|
	& \TTMKEY{support\_control}{in {\tt min::print\_format}}
        & \verb|// min::latin1_| \\
      & & \verb|//   support_control| \\
\verb|     min::display_control|
	& \TTMKEY{display\_control}{in {\tt min::print\_format}}
        & \verb|// min::graphic_and_| \\
      & & \verb|//   hspace_| \\
      & & \verb|//   display_control| \\
\verb|       min::break_control|
	& \TTMKEY{break\_control}{in {\tt min::print\_format}}
        & \verb|// min::break_after_| \\
      & & \verb|//   space_| \\
      & & \verb|//   break_control| \\
\verb|  min::char_name_format *|
	& \TTMKEY{char\_name\_format}{in {\tt min::print\_format}}
        & \verb|// min::standard_| \\
      & & \verb|//   char_name_format| \\
\verb|        min::gen_format *|
	& \TTMKEY{gen\_format}{in {\tt min::print\_format}}
        & \verb|// min::top_gen_format| \\
\verb|        min::gen_format *|
	& \TTMKEY{id\_map\_gen\_format}{in {\tt min::print\_format}}
        & \verb|// min::id_map_gen_format| \\
\verb|}                        | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::print_format printer->|
    & \TTMKEY{print\_format}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT} \\
\verb|const min::packed_vec_insptr<min::print_format>  | \\
\verb|printer->|
    & \TTMKEY{print\_format\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT_STACK} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::print_format min::|
    & \TTKEY{default\_\EOL print\_\EOL format}
\LABEL{MIN::DEFAULT_PRINT_FORMAT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::id_map printer->|
    & \TTMKEY{\EOL id\_\EOL map}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP} \\
\verb|min::uns32 printer->|
    & \TTMKEY{\EOL id\_\EOL map->\EOL next}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP_NEXT} \\
\end{tabular}\end{indpar}

\TT{print\_format.op\_flags}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{EXPAND\_HT}
\LABEL{MIN::EXPAND_HT_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_EOL}
\LABEL{MIN::DISPLAY_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_PICTURE}
\LABEL{MIN::DISPLAY_PICTURE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_NON\_GRAPHIC}
\LABEL{MIN::DISPLAY_NON_GRAPHIC_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ON\_EOL}
\LABEL{MIN::FLUSH_ON_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ID\_MAP\_ON\_EOM}
\LABEL{MIN::FLUSH_ID_MAP_ON_EOM_FLAG} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{FORCE\_SPACE}
\LABEL{MIN::FORCE_SPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{FORCE\_PGEN}
\LABEL{MIN::FORCE_PGEN_FLAG} \\
\end{tabular}\end{indpar}

\TT{print\_format.support\_control}:
See \pagref{MIN::SUPPORT_CONTROL_STRUCT}.

\TT{print\_format.display\_control}:

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct     min::| & \MINKEY{display\_\EOL control}
\LABEL{MIN::DISPLAY_CONTROL_STRUCT} \\
\verb|{               | \\
\verb|     min::uns32 |
	& \TTMKEY{display\_char}{in {\tt min::display\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{display\_suppress}{in {\tt min::display\_control}} \\
\verb|}               | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\multicolumn{2}{l}{\tt const min::display\_control
    min::\MINLKEY{graphic\_and\_hspace}{\_display\_control} =}\ARGBREAK[1.0in]
	\verb|{ min::IS_HSPACE  + min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_AND_HSPACE_DISPLAY_CONTROL} \\
\multicolumn{2}{l}{\tt const min::display\_control
    min::\MINLKEY{graphic\_only}{\_display\_control} =}\ARGBREAK[1.0in]
	\verb|{ min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_ONLY_DISPLAY_CONTROL} \\
\multicolumn{2}{l}{\tt const min::display\_control
    min::\MINLKEY{graphic\_and\_vhspace}{\_display\_control} =}\ARGBREAK[1.0in]
	\verb|{ min::IS_VHSPACE + min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_AND_VHSPACE_DISPLAY_CONTROL} \\
\multicolumn{2}{l}{\tt const min::display\_control
    min::\MINLKEY{display\_all}{\_display\_control} =}\ARGBREAK[1.0in]
	\verb|{ min::ALL_CHARS, 0 };|
\LABEL{MIN::DISPLAY_ALL_DISPLAY_CONTROL} \\
\end{tabular}\end{indpar}

\TT{print\_format.break\_control}:

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct     min::| & \MINKEY{break\_\EOL control}
\LABEL{MIN::BREAK_CONTROL_STRUCT} \\
\verb|{               | \\
\verb|     min::uns32 |
	& \TTMKEY{break\_before}{in {\tt min::break\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{break\_after}{in {\tt min::break\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{conditional\_break}{in {\tt min::break\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{conditional\_columns}{in {\tt min::break\_control}} \\
\verb|}               | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINKEY{no\_auto\_break\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ 0, 0, 0, 0 };|
\LABEL{MIN::NO_AUTO_BREAK_BREAK_CONTROL} \\
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINLKEY{break\_after\_space}{\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ min::IS_BHSPACE, 0, 0, 0 };|
\LABEL{MIN::BREAK_AFTER_SPACE_BREAK_CONTROL} \\
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINLKEY{break\_before\_all}{\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ 0, min::ALL_CHARS, 0, 0 };|
\LABEL{MIN::BREAK_BEFORE_NON_SPACE_BREAK_CONTROL} \\
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINLKEY{break\_after\_hyphens}{\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ min::IS_BHSPACE, 0, min::CONDITIONAL_BREAK, 4 };|
\LABEL{MIN::BREAK_AFTER_HYPHENS_BREAK_CONTROL} \\
\end{tabular}\end{indpar}

\TT{print\_format.char\_name\_format}:

\begin{indpar}[1em]\begin{tabular}{rl}
\verb|struct               min::|
    & \MINKEY{char\_\EOL name\_\EOL format}
\LABEL{MIN::CHAR_NAME_FORMAT_STRUCT} \\
\verb|{                         | \\
\multicolumn{2}{l}%
    {\tt ~~~~~// Members must encode non-zero numbers of columns.} \\
\verb|     min::ustring |
	& \TTMKEY{char\_name\_prefix}{in {\tt min::char\_name\_format}} \\
\verb|     min::ustring |
	& \TTMKEY{char\_name\_postfix}{in {\tt min::char\_name\_format}} \\
\verb|}                         | \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\multicolumn{2}{l}{\tt const min::char\_name\_format
    min::\MINKEY{standard\_char\_name\_format} =}\ARGBREAK[1.0in]
\verb|{ (min::ustring) "\x01\x01" "<",|\ARGBREAK[1.0in]
\verb|  (min::ustring) "\x01\x01" ">" };|
\LABEL{MIN::STANDARD_CHAR_NAME_FORMAT} \\
\end{tabular}\end{indpar}

The \TT{ustring} members of \TT{min::char\_name\_format} \underline{must not}
contain non-graphic characters (e.g., no spaces) and \underline{must}
have non-zero numbers of columns encoded in their second bytes.

The basic algorithm for printing a UNICODE character \TT{c} is:

\begin{enumerate}

\item Compute character flags of \TT{c} (see \itemref{UNICODE-DATA-BASE}):%
\label{COMPUTE-CHARACTER-FLAGS}
\begin{indpar}\begin{verbatim}
min::uns16 cindex = min::Uindex ( c );
min::uns32 cflags = printer->print_format.char_flags[cindex];
\end{verbatim}\end{indpar}

\item Replace character flags \TT{cflags} if \TT{c} is unsupported:%
\label{REPLACE-CHARACTER-FLAGS}
\begin{indpar}\begin{verbatim}
min::support_control sc = printer->print_format.support_control;
if ( ( cflags & sc.support_mask ) == 0 )
    cflags = sc.unsupported_char_flags;
\end{verbatim}\end{indpar}

\item Compute printed representation of \TT{c}:%
\label{COMPUTE-PRINTED-REPRESENTATION}
\begin{indpar}\begin{verbatim}
min::display_control dc = printer->print_format.display_control;
if ( printer->print_format.op_flags & min::DISPLAY_NON_GRAPHIC )
{
    dc.display_char &= ~ min::IS_NON_GRAPHIC;
    dc.display_suppress &= ~ min::IS_NON_GRAPHIC;
}
if ( cflags & dc.display_char )
    // Character represents itself, but if c == '\t', c is
    // represented by a sequence of 8 - printer->column % 8
    // ' ' spaces if EXPAND_HT op_flag is on.
else if ( cflags & dc.display_suppress )
    // Ignore character and do not print it
else
    // Character is represented by min::unicode::picture[cindex]
    // if that is not NULL and DISPLAY_PICTURE op_flag is on;
    // else character is represented by <X> where < and > are
    // the printer->print_format.char_name_format prefix and
    // postfix, and X is min::unicode::name[cindex] if that is
    // not NULL, or is the character code in hexa-decimal with
    // a leading decimal digit (may be 0) otherwise.
\end{verbatim}\end{indpar}

Note that \TT{<FF>} represents the form feed character with (hex)
code \TT{0C}, while \TT{<0FF>} represents the
latin small letter y with diaeresis, \"y, with code \TT{FF}.

Note that only the low order 16 bits of \TT{cflags} are used
by a \TT{display\_control}.

\item Compute automatic break points for \TT{c}:%
\label{COMPUTE-AUTOMATIC-BREAK-POINTS}
\begin{indpar}\begin{verbatim}
min::break_control bc = printer->print_format.break_control;
if ( cflags & bc.break_after )
    set break after representative of c
if ( cflags & bc.break_before )
    set break before representative of c
if ( cflags & bc.conditional_break
     &&
        printer->column - printer->line_break.column
     >= bc.conditional_columns )
    set break after representative of c
\end{verbatim}\end{indpar}

When we say that a break is set after the representative of \TT{c},
what we mean precisely is that a break is set before the representative
of the next character after \TT{c}, unless that character also sets
a break after its representative.  Thus given a sequence of single
spaces with the \TT{IS\_\EOL SP} flag in \TT{bc.break\_\EOL after},
followed by a letter, only one break, after the last single space
and before the letter, will be set.

Note that only the low order 16 bits of \TT{cflags} are used
by a \TT{break\_control}.

\end{enumerate}

The members of a printer may be read but \underline{not} written.
A complete list of these members follows:

\begin{itemlist}[0.8in]

\item[\ttmkey{file}{in {\tt min::printer}}]
The \TT{min::file} which contains the lines produced by the printer.
Initialized by the second argument of \TT{min::\EOL init}, if that is
not \TT{min::\EOL NULL\_\EOL STUB}, or otherwise created when the
printer is created.  Initialized by \TT{min::\EOL init(printer->\EOL file)}
(which resets the \TT{file} to empty)
\underline{except} when the 2-argument \TT{min::\EOL init}
is called (see above).


\item[\ttmkey{column}{in {\tt min::printer}}]
The number of columns currently in the line being assembled,
which equals the column number of the next character to be input to the
printer.  The first column number is \TT{0}.  Initialized to \TT{0}.

\end{itemlist}

\begin{itemlist}[0.6in]

\item[\ttmkey{line\_\EOL break.column}{in {\tt min::printer}}]~\\
The column of the
first byte in the current line after the last break point in the line.
Initialized to \TT{0}.

\item[\ttmkey{line\_\EOL break.offset}{in {\tt min::printer}}]~\\
The \TT{file->buffer} index of the
first byte in the current line after the last break point in the line.
Initialized to \TT{0}.

\item[\ttmkey{line\_\EOL break.line\_length}{in {\tt min::printer}}]%
\label{LINE-LENGTH}~\\
Nominal maximum line length in columns.  Initialized to \TT{72}.

More specifically,
when a character representative other than a single space, a horizontal
tab, or a sequence of single spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed \TT{line\_\EOL break.line\_length}, then if
\begin{center}
\tt line\_break.column > line\_break.indent
\end{center}
a break, consisting of a line end followed by \TT{line\_break.indent}
spaces,
is inserted into the printer file buffer just after the break point
(i.e., is inserted at \TT{line\_\EOL break.offset}).

Single space and horizontal tab
characters immediately before the inserted line end are deleted.
After the break is inserted, \TT{line\_\EOL break.column} is reset to
the number of indentation spaces (\TT{= line\_\EOL break.indent})
and \TT{line\_\EOL break.offset} to the first position after
the inserted indentation spaces.

Break points may be inserted automatically by using
\TT{print\_format.break\_con\-trol}; see below.

If a non-empty \TT{line\_break\_stack} exists
because a \TT{min::\EOL save\_\EOL line\_\EOL break} or 
\TT{min::\EOL save\_\EOL indent} was executed,
then an element of the line break stack may provide overrides for the
\TT{column}, \TT{offset}, and
\TT{indent} members, but not the \TT{line\_\EOL length} member,
of \TT{printer->\EOL line\_\EOL break}.
See \pagref{LINE-BREAK-STACK} for details.

\item[\ttmkey{line\_\EOL break.indent}{in {\tt min::printer}}]~\\
Indention of a new line created by automatic break insertion.
Also used by the \TT{min::\EOL indent} operation (\pagref{MIN::INDENT}).
Initialized to \TT{4}.

Specifically, when
a line break is automatically pushed into a printer file buffer, the
break consists of a line end (\TT{NUL} character) followed by
\TT{line\_\EOL break.indent} single space characters.

\item[\ttmkey{line\_\EOL break\_\EOL stack}{in {\tt min::printer}}]~\\
Used with \TT{min::\EOL save\_\EOL line\_\EOL break} and
\TT{min::\EOL save\_\EOL indent} to set
multiple break points when printing nested lists.
See \pagref{LINE-BREAK-STACK} for details.
Initialized to an empty stack.

\end{itemlist}

\begin{itemlist}[0.6in]

\item[\ttmkey{print\_format.op\_flags}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_OP_FLAGS}~\\
These are printer \skey{operation flag}s that control printing.  When passed as
function arguments they are referred to as the
\TT{print\_\EOL op\_\EOL flags}.
The flags are listed immediately below.

\end{itemlist}

\begin{indpar}\begin{itemlist}[0.4in]

\item[\ttmkey{EXPAND\_HT}{in {\tt print\_\EOL format.op\_\EOL flags}}]
~\\
\TT{EXPAND\_HT} causes the character \TT{'\textbackslash t'}
to be represented by a sequence of single spaces when it is to be
displayed as `itself' (and not using its picture or name).
As tabs are set every 8 spaces, the number of single spaces is:
\begin{center}
\tt 8 - printer->column \% 8
\end{center}

If \TT{EXPAND\_HT} is \underline{off} and the character \TT{'\textbackslash t'}
is to be displayed as `itself', the character represents itself, but its
width in columns is
\begin{center}
\tt 8 - printer->column \% 8
\end{center}


\item[\ttmkey{DISPLAY\_EOL}%
               {in {\tt print\_\EOL format.op\_\EOL flags}}]~\\
\label{DISPLAY_EOL}
If this flag is on, the end of line prints as the
{\tiny $\stackrel{\textstyle N~}{~L}$}
picture character if
\TT{DISPLAY\_\EOL PICTURE} is on, and as the name \TT{NL} (e.g., in \TT{<NL>})
otherwise.

\item[\ttmkey{DISPLAY\_PICTURE}%
               {in {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, characters not displayed as themselves
are displayed as picture characters
using \TT{min::\EOL unicode::\EOL picture[cindex]} if this is not
\TT{NULL}, as per \pagref{COMPUTE-PRINTED-REPRESENTATION}.
Otherwise they are displayed using their name if that exists, or
using their hex code if no name exists.

\item[\ttmkey{DISPLAY\_NON\_GRAPHIC}%
               {in {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, non-graphic characters (including single spaces and
horizontal tabs) are \underline{not} displayed
as themselves or suppressed,
regardless of the setting of the display control.

\item[\ttmkey{FLUSH\_ON\_EOL}%
{in {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, a \TT{min::flush()} printer operation (\pagref{MIN::FLUSH})
is executed at the very end of each \TT{min::\EOL eol} operation.

\item[\ttmkey{FLUSH\_ID\_MAP\_ON\_EOM}%
    {in {\tt print\_\EOL format.op\_\EOL flags}}]~\\
If this flag is on, a \TT{min::eom()} printer operation performs
a \TT{min::\EOL flush\_\EOL id\_\EOL map} operation
(\pagref{MIN::FLUSH_ID_MAP}) right after its
\TT{min::\EOL bol} operation.

\item[\ttmkey{FORCE\_SPACE}%
    {in {\tt print\_\EOL format.op\_\EOL flags}}]~\\
This flag forces the \TT{min::leading} and \TT{min::trailing}
printer operations to output a single space character.
See \pagref{FORCE_SPACE}.

\item[\ttmkey{FORCE\_PGEN}%
    {in {\tt print\_\EOL format.op\_\EOL flags}}]~\\
This flag causes the \TT{<{}<} operator to treat numbers and
characters strings that are to be printed directly by the
\TT{<{}<} operator as
\TT{min::gen} numbers or strings, which just means that
\TT{print\_\EOL format.gen\_\EOL format} is used to format them.
Printer operations such as \TT{min::\EOL space}, \TT{min::\EOL pint},
and \TT{min::\EOL punicode} are \underline{not} affected.
This flag is used mostly for debugging and demonstrations of
\TT{min::\EOL leading/\EOL trailing}.

\end{itemlist}\end{indpar}

\begin{itemlist}[0.6in]

\item[\ttmkey{print\_format.char\_flags}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_CHAR_FLAGS}~\\
This is the vector of character flags indexed by UNICODE character
indices.
See `Compute character flags' above
(\pagref{COMPUTE-CHARACTER-FLAGS})
and Section~\itemref{COMPUTE-CHARACTER-FLAGS}.

\item[\ttmkey{print\_format.support\_control}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_SUPPORT_CONTROL}~\\
\label{SUPPORT-CONTROL}
This \TT{min::support\_control} controls which characters are supported
and which are not.  The \TT{support\_\EOL mask}
(e.g., \TT{min::\EOL IS\_\EOL LATIN1}) is bitwise AND'ed with
the character flags and if the result is zero, the character is unsupported
and its flags are replaced by the
\TT{unsupported\_\EOL char\_\EOL flags}
(e.g., \TT{min::\EOL IS\_\EOL UNSUPPORTED}).
See `Replace character flags \ldots{} if \ldots{} unsupported' above
(\pagref{REPLACE-CHARACTER-FLAGS}).

\item[\ttmkey{print\_format.display\_control}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_DISPLAY_CONTROL}~\\
This \TT{min::display\_control} controls which characters display as
themselves and which are suppressed (ignored and not printed).
The \TT{display\_\EOL char} mask
(e.g., \TT{min::\EOL IS\_\EOL SP + min::\EOL IS\_\EOL GRAPHIC})
is bitwise AND'ed with
the character flags and if the result is non-zero,
the character is displayed as itself.  Note however there may
be special processing in this case for the horizontal tab character.

If the character is \underline{not} to be displayed as itself, then
the \TT{display\_\EOL suppress} mask
(e.g., \TT{min::\EOL IS\_\EOL CONTROL})
is bitwise AND'ed with
the character flags and if the result is non-zero,
the character is suppressed (ignored).

If a character is not displayed as itself or suppressed, its picture
or name are used to represent it.

See `Compute character representation' above
(\pagref{COMPUTE-PRINTED-REPRESENTATION}) for details.

\item[\ttmkey{print\_format.break\_control}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_BREAK_CONTROL}~\\
This \TT{min::break\_control} controls when breaks are automatically
inserted into the output (see \TT{min::\EOL set\_\EOL break},
\pagref{MIN::SET_BREAK}).

The \TT{break\_\EOL after} mask\label{BREAK-AFTER}
(e.g., \TT{min::\EOL IS\_\EOL SP + min::\EOL IS\_\EOL OTHER\_\EOL HSPACE})
is bitwise AND'ed with
the character flags and if the result is non-zero,
a break is inserted `after the character representative', or
more precisely, a break is inserted before the representative
of the next character if that character is not also having
a break automatically inserted after it..

The \TT{break\_\EOL before} mask
(e.g., \TT{min::ALL\_CHARS})
is bitwise AND'ed with
the character flags and if the result is non-zero,
a break is inserted before the character representative.

The \TT{conditional\_\EOL break} mask\label{CONDITIONAL-BREAK}
(e.g., \TT{min::\EOL CONDITIONAL\_\EOL BREAK}, set for the hyphen \TT{'-'})
is bitwise AND'ed with
the character flags and if the result is non-zero,
\underline{and} if
\begin{center}
\tt printer->column - printer->line\_break.column >= condition\_columns
\end{center}
a break is inserted `after the character representative' in the
same manner as for \TT{break\_\EOL after}.

See `Compute automatic break points' above
(\pagref{COMPUTE-AUTOMATIC-BREAK-POINTS}) for more details.

\item[\ttmkey{print\_format.char\_name\_format}{in {\tt min::printer}}]%
\label{PRINT_FORMAT_CHAR_NAME_FORMAT}~\\
This defines the prefix and suffix on character names and
codes: e.g., provides the prefix \TT{<} and suffix \TT{>} for
the representative \TT{<FF>} of a form feed character.

\item[\ttmkey{print\_format.gen\_format}{in {\tt min::printer}}]~\\
This controls the printing of
\TT{min::gen} values as described in Section \itemref{PRINTING-GENERAL-VALUES}.

\item[\ttmkey{print\_\EOL format\_\EOL stack}{in {\tt min::printer}}]~\\
Used with \TT{min::save\_print\_format} and
\TT{min::\EOL restore\_\EOL print\_\EOL format} to save and
restore the \TT{print\_\EOL format} parameters.
See \pagref{PRINT-FORMAT-STACK} for details.
Initialized to an empty stack.

\item[\ttmkey{id\_\EOL map}{in {\tt min::printer}}]~\\
Used to find or create identifiers when printing values with stubs
and \TT{min::gen} values that contain stub pointers.
See \itemref{IDENTIFIER-MAPS} and
\TT{flush\_\EOL id\_\EOL map} (\pagref{MIN::FLUSH_ID_MAP}).

\end{itemlist}

Copying characters into a printer is done by the
\TT{<{}<} operator:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, const char * s )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR_*} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::ptr<const char> s )|
\LABEL{PRINTER_OPERATOR<<_OF_PTR_CONST_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::ptr<char> s )|
\LABEL{PRINTER_OPERATOR<<_OF_PTR_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::str_ptr const & s )|
\LABEL{PRINTER_OPERATOR<<_OF_STR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, char c )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int32 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int64 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns32 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns64 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::float64 f )|
\LABEL{PRINTER_OPERATOR<<_OF_FLOAT64} \\
\end{tabular}\end{indpar}

A `\TT{const char *}' is interpreted as a UTF-8 encoded
string of UNICODE characters as per
\TT{min::\EOL utf8\_\EOL to\_\EOL unicode}, \pagref{MIN::UTF8_TO_UNICODE}.
However, a `\TT{const char *}' cannot be an unprotected body pointer,
as the body it points into may be relocated during the execution of the
\TT{<{}<\RESIZE} operator on a printer.
A `\TT{min::\EOL ptr<char>}' value can be used
instead as a pointer to a `\TT{const char *}' string inside a body.
And a `\TT{min::\EOL str\_\EOL ptr}' can be used instead to
point at the contents of a string \TT{min::gen} value.

\ikey{Horizontal tabs}{horizontal tab} are set every 8 columns.
When a horizontal tab is to be copied to the printer buffer, then if
the \TT{min::\EOL EXPAND\_\EOL HT} printer operation flag is on,
the horizontal tab is converted to between 1 and 8 single space characters.
But if the flag is off, the horizontal character itself is copied.
In either case the printer column is adjusted to the next multiple of 8.

When a \ttkey{NUL} is to be copied into a printer file buffer,
it is encoded as the overlong UTF-8 encoding
\TT{"\textbackslash xC0\textbackslash x80"}.

Values of types other than `\TT{const char *}'
which are presented to \TT{<{}<} are converted to `\TT{const char~*}' strings
as follows:
`\TT{char}' converts to a 1-\TT{char} string whose only element
is the \TT{char} value.  Numbers are converted by \TT{printf}
formats as follows:
\begin{center}
\tt
\begin{tabular}{l@{~~~~~~~~~~}l}
min::uns32	& "\%u" \\
min::uns64	& "\%llu" \\
min::int32	& "\%d" \\
min::int64	& "\%lld" \\
min::float64	& "\%.15g" \\
\end{tabular}
\end{center}

Operations can be performed on printers by applying the
\TT{<{}<} operator to a \TT{min::}\MINKEY{op}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}{of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::op const & op )|
\LABEL{OPERATOR<<_OF_PRINTER_OP} \\
\end{tabular}\end{indpar}

Operations behave for printers as \TT{iomanip}
C++ objects behave for \TT{iostreams}.  For example, the
printer analog of \TT{std::\EOL endl} is the \key{end of line}
operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{eol}
\LABEL{MIN::EOL} \\
\end{tabular}\end{indpar}

which inserts a line end into the output and then executes a
flush operation if the \TT{min::\EOL FLUSH\_\EOL ON\_\EOL EOL} printer
operation flag is set.

The flush operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{flush}
\LABEL{MIN::FLUSH} \\
\end{tabular}\end{indpar}

just executes
\begin{indpar}\begin{verbatim}
min::flush_file ( printer->file );
\end{verbatim}\end{indpar}

The \key{beginning of line} operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{bol}
\LABEL{MIN::BOL} \\
\end{tabular}\end{indpar}

executes \TT{min::eol} if and only if the printer is \underline{not}
already at the beginning of a line.

A {\ldots{} \tt <{}< printer} operation can be used to
flush the contents of \TT{printer->\EOL file} into
an \TT{std::\EOL ostream}, a \TT{min::\EOL file}, or
into another \TT{min::\EOL printer}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<{}<}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{OSTREAM_OPERATOR<<_OF_PRINTER} \\
\verb|min::file |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{FILE_OPERATOR<<_OF_PRINTER} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer oprinter,|\ARGBREAK
      \verb|  min::printer iprinter )|
\LABEL{PRINTER_OPERATOR<<_OF_PRINTER} \\
\end{tabular}\end{indpar}

In general {\ldots{} \tt <{}< printer} is equivalent to
{\ldots{} \tt <{}< printer->file} (see \pagref{OSTREAM_OPERATOR<<_OF_FILE}).

A single UNICODE character \TT{c}, or a string of UNICODE characters
\TT{str} of a given \TT{length},
can be printed using the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{punicode} \verb|( min::Uchar c )|
\LABEL{MIN::PUNICODE} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  const min::Uchar * str )|
\LABEL{MIN::PUNICODE_BUFFER} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  min::ptr<const min::Uchar> str )|
\LABEL{MIN::PUNICODE_BUFFER_CONST_PTR} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  min::ptr<min::Uchar> str )|
\LABEL{MIN::PUNICODE_BUFFER_PTR} \\
\end{tabular}\end{indpar}

Here it must be remembered that a `\TT{const min::uns32~*}' pointer
\TT{str} must not be relocatable.

Numbers may be formatted by specified \TT{printf} formats and the results
printed by using the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{pint}\ARGBREAK
	  \verb|( min::int32 i,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PINT32} \\
\verb|min::op min::|
    & \MINKEY{pint}\ARGBREAK
	  \verb|( min::int64 i,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PINT64} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{puns}\ARGBREAK
	  \verb|( min::uns32 u,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PUNS32} \\
\verb|min::op min::|
    & \MINKEY{puns}\ARGBREAK
	  \verb|( min::uns64 u,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PUNS64} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{pfloat}\ARGBREAK
	  \verb|( min::float64 f,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PFLOAT64} \\
\end{tabular}\end{indpar}

\TT{min::gen} values may be printed under the control of a
\TT{min::\EOL gen\_\EOL format}.  As printing objects
can be complex, printing \TT{min::gen} values is
described in the separate Section~\itemref{PRINTING-GENERAL-VALUES}.

Sometimes it is desirable to find out how many columns a
Modified UTF-8 string would take if printed.
For the horizontal tab character,
this depends upon the column the character is printed in.
So the following function updates a \TT{column} variable
whose initial value is that of \TT{printer->column}
before the string is printed
and whose final value is \TT{printer->\EOL column}
after the string is printed.

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{pwidth}\ARGBREAK
         \verb|( min::uns32 & column,|\ARGBREAK
         \verb|  const char * s, min::unsptr n,|\ARGBREAK
         \verb|  const min::print_format & print_format )|
\LABEL{MIN::PWIDTH_OF_STRING} \\
\end{tabular}\end{indpar}

This function updates `\TT{column}' to what it would be if
the \TT{n} byte string \TT{s} were printed with the given
\TT{print\_\EOL format}.
Here \TT{s} may be relocatable, as the \TT{min::\EOL pwidth}
function does not allocate or resize objects.
The number of columns added to `\TT{column}' is returned.

A function and a constant that can be useful as arguments to
message printing functions are:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{printf\_op}\verb|<unsigned length>|\ARGBREAK
          \verb|( const char * format, ... )|
\LABEL{MIN::PRINTF_OP} \\
\verb|const min::op min::| & \MINKEY{pnop}
\LABEL{MIN::PNOP} \\
\end{tabular}\end{indpar}

Here \TT{min::printf\_op<length>} is a constructor
that constructs a \TT{min::op} containing
a `\TT{length}' character buffer which in turn contains the results of
executing \TT{sprintf ( buffer, format, ... )}.  This buffer
is then output as a `\TT{const char *}' string by the printer
operation.  Overrunning the end of the
buffer is an undetected error.

The \TT{min::pnop} constant is a no-operation that can
be used as the default value of a message printing function
argument.

\subsubsection{Adjusting Printer Parameters}
\label{ADJUSTING-PRINTER-PARAMETERS}

The \TT{print\_format} parameters of a printer may be saved in the
\ttmkey{print\_\EOL format\_\EOL stack}{in {\tt min::printer}}%
\label{PRINT-FORMAT-STACK}
of the printer, and restored from that stack.
This may be done by the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{save\_print\_format}
\LABEL{MIN::SAVE_PRINT_FORMAT} \\
\verb|const min::op min::|
    & \MINKEY{restore\_print\_format}
\LABEL{MIN::RESTORE_PRINT_FORMAT} \\
\end{tabular}\end{indpar}

\TT{min::save\_print\_format}
pushes into the format stack a new element containing
the current \TT{print\_\EOL format}, while
\TT{min::\EOL restore\_\EOL print\_\EOL format}
resets \TT{print\_\EOL format} from the top format stack element and then
pops this element from the stack.

Some printer parameters may be set
by the following printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{set\_\EOL line\_length} \verb|( min::uns32 line_length )|
\LABEL{MIN::SET_LINE_LENGTH} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL indent} \verb|( min::uns32 indent )|
\LABEL{MIN::SET_INDENT} \\
\verb|min::op min::|
    & \MINKEY{set\_print\_op\_flags} \verb|( min::uns32 print_op_flags )|
\LABEL{MIN::SET_PRINT_OP_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{clear\_print\_op\_flags} \verb|( min::uns32 print_op_flags )|
\LABEL{MIN::CLEAR_PRINT_OP_FLAGS} \\
\end{tabular}\end{indpar}

\TT{min::\EOL set\_\EOL print\_\EOL op\_\EOL flags} logically OR's
its argument into \TT{print\_\EOL format.op\_\EOL flags} and
\TT{min::\EOL clear\_\EOL print\_\EOL op\_\EOL flags} logically AND's
the bitwise complement of its argument into
\TT{print\_\EOL format.op\_\EOL flags}
(recall that \TT{print\_\EOL format.op\_\EOL flags} are referred to as
\TT{print\_\EOL op\_\EOL flags} when used as arguments to functions).
For example, 
\begin{center}
\tt printer<{}<min::set\_print\_op\_flags(min::DISPLAY\_PICTURE)
\end{center}
sets the \TT{min::DISPLAY\_PICTURE} flag of
\TT{printer->\EOL print\_\EOL format.op\_\EOL flags}.

Particular \TT{print\_format.op\_flags} may be set and cleared by the
following printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{expand\_ht}
\LABEL{MIN::EXPAND_HT} \\
\verb|const min::op min::| & \MINKEY{noexpand\_ht}
\LABEL{MIN::NOEXPAND_HT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{display\_eol}
\LABEL{MIN::DISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_eol}
\LABEL{MIN::NODISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{display\_picture}
\LABEL{MIN::DISPLAY_PICTURE} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_picture}
\LABEL{MIN::NODISPLAY_PICTURE} \\
\verb|const min::op min::| & \MINKEY{display\_non\_graphic}
\LABEL{MIN::DISPLAY_NON_GRAPHIC} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_non\_graphic}
\LABEL{MIN::NODISPLAY_NON_GRAPHIC} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{flush\_on\_eol}
\LABEL{MIN::FLUSH_ON_EOL} \\
\verb|const min::op min::| & \MINKEY{noflush\_on\_eol}
\LABEL{MIN::NOFLUSH_ON_EOL} \\
\verb|const min::op min::| & \MINKEY{flush\_id\_map\_on\_eom}
\LABEL{MIN::FLUSH_ID_MAP_ON_EOM} \\
\verb|const min::op min::| & \MINKEY{noflush\_id\_map\_on\_eom}
\LABEL{MIN::NOFLUSH_ID_MAP_ON_EOM} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{force\_space}
\LABEL{MIN::FORCE_SPACE} \\
\verb|const min::op min::| & \MINKEY{noforce\_space}
\LABEL{MIN::NOFORCE_SPACE} \\
\verb|const min::op min::| & \MINKEY{force\_pgen}
\LABEL{MIN::FORCE_PGEN} \\
\verb|const min::op min::| & \MINKEY{noforce\_pgen}
\LABEL{MIN::NOFORCE_PGEN} \\
\end{tabular}\end{indpar}

Here \TT{printer <{}< min::display\_picture} sets the
\TT{min::\EOL DISPLAY\_\EOL PICTURE} prin\-ter operation flag in
\TT{printer->\EOL print\_\EOL format.op\_\EOL flags},
while the \TT{printer <{}< min::\EOL nodisplay\_\EOL picture} clears this flag.
The other operations similarly set or clear their associated flags.

The \TT{printer\_format.support\_control} can be set by the following
printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{ascii}
\LABEL{MIN::ASCII} \\
\verb|const min::op min::| & \MINKEY{latin1}
\LABEL{MIN::LATIN1} \\
\verb|const min::op min::| & \MINKEY{support\_all}
\LABEL{MIN::SUPPORT_ALL} \\
\verb|min::op min::|
    & \MINKEY{set\_support\_control}\ARGBREAK
          \verb|( const min::support_control & sc )|
\LABEL{MIN::SET_SUPPORT_CONTROL} \\
\end{tabular}\end{indpar}

Here \TT{min::ascii} is equivalent to
\begin{center}
\verb|min::set_support_control ( min::ascii_support_control )|
\end{center}
and similarly for \TT{min::latin1} and \TT{min::support\_all}.

The \TT{printer\_format.display\_control} can be set by the following
printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{graphic\_and\_hspace}
\LABEL{MIN::GRAPHIC_AND_HSPACE} \\
\verb|const min::op min::| & \MINKEY{graphic\_only}
\LABEL{MIN::GRAPHIC_ONLY} \\
\verb|const min::op min::| & \MINKEY{graphic\_and\_vhspace}
\LABEL{MIN::GRAPHIC_AND_VHSPACE} \\
\verb|const min::op min::| & \MINKEY{display\_all}
\LABEL{MIN::DISPLAY_ALL} \\
\verb|min::op min::|
    & \MINKEY{set\_display\_control}\ARGBREAK
          \verb|( const min::display_control & dc )|
\LABEL{MIN::SET_DISPLAY_CONTROL} \\
\end{tabular}\end{indpar}

Here \TT{min::graphic\_and\_hspace} is equivalent to
\begin{center}
\verb|min::set_display_control ( min::graphic_and_hspace_display_control )|
\end{center}
and similarly for \TT{min::\EOL graphic\_\EOL only},
\TT{min::\EOL graphic\_\EOL and\_vhspace}, and \TT{min::\EOL display\_\EOL all}.

The \TT{printer\_format.break\_control} can be set by the following
printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{no\_auto\_break}
\LABEL{MIN::NO_AUTO_BREAK} \\
\verb|const min::op min::| & \MINKEY{break\_after\_space}
\LABEL{MIN::BREAK_AFTER_SPACE} \\
\verb|const min::op min::| & \MINKEY{break\_before\_all}
\LABEL{MIN::BREAK_BEFORE_ALL} \\
\verb|const min::op min::| & \MINKEY{break\_after\_hyphens}
\LABEL{MIN::BREAK_AFTER_HYPHENS} \\
\verb|min::op min::|
    & \MINKEY{set\_break\_control}\ARGBREAK
          \verb|( const min::break_control & bc )|
\LABEL{MIN::SET_BREAK_CONTROL} \\
\end{tabular}\end{indpar}

Here \TT{min::no\_auto\_break} is equivalent to
\begin{center}
\verb|min::set_break_control ( min::no_auto_break_break_control )|
\end{center}
and similarly for \TT{min::break\_\EOL after\_\EOL space},
\TT{min::break\_\EOL before\_\EOL all},
and \TT{min::break\_\EOL after\_\EOL hyphens}.

The printer operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{verbatim}
\LABEL{MIN::VERBATIM} \\
\end{tabular}\end{indpar}

is used when it is desired to copy characters verbatim to the
printer buffer.  \TT{printer <{}< min::\EOL verbatim} is equivalent to:

\begin{indpar}\begin{verbatim}
printer << min::noexpand_ht
        << min::support_all
        << min::display_all
        << min::no_auto_break
\end{verbatim}\end{indpar}

This permits characters in a \TT{printer->file} line to be copied
to another printer verbatim.  Note that
the \TT{min::\EOL DISPLAY\_\EOL EOL} printer operation flag
is not affected, as when copying to a printer from some file
line terminating NULs are translated to \TT{min::\EOL eol}
operations on the target printer and may or may not be
displayed according to the setting of
\TT{min::\EOL DISPLAY\_\EOL EOL} on the target printer.
Also note that the operation to undo the results
of \TT{min::\EOL verbatim} does not exist (you must save and restore
\TT{print\_\EOL format}).

The printer operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{set\_line\_display} \verb|( min::uns32 line_display )|
\LABEL{MIN::SET_LINE_DISPLAY} \\
\end{tabular}\end{indpar}

is used when it is desired print a line in a file as part of an
error message, and is used, for example, by the
\TT{min::\EOL print\_\EOL line} function, \pagref{MIN::PRINT_LINE}.
\TT{printer <{}< min::\EOL set\_\EOL line\_\EOL display ( line\_\EOL display )}
is equivalent to:

\begin{indpar}\begin{verbatim}
min::uns32 flags = min::DISPLAY_EOL
                 + min::DISPLAY_PICTURE
                 + min::DISPLAY_NON_GRAPHIC;

printer << min::clear_op_flags ( flags )
        << min::set_op_flags ( flags & line_display )
        << min::expand_ht
        << min::set_display_control
               ( line_display & min::DISPLAY_NON_GRAPHIC ?
                 min::graphic_only_display_control :
                 min::graphic_and_hspace_display_control )
        << min::no_auto_break
\end{verbatim}\end{indpar}

\subsubsection{Printer Line Breaks}
\label{PRINTER-LINE-BREAKS}

The \TT{min::set\_\EOL break} printer operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{set\_\EOL break}
\LABEL{MIN::SET_BREAK} \\
\end{tabular}\end{indpar}

can be used to explicitly set a break point:
More specifically, \TT{printer<{}<min::set\_\EOL break} sets a break point after
the last character in the printer file buffer by executing:
\begin{indpar}\begin{verbatim}
printer->line_break.offset = printer->buffer->length;
printer->line_break.column = printer->column;
\end{verbatim}\end{indpar}

If a \TT{min::set\_break} operation is executed as a non-initial
member of a sequence of
\TT{min::\EOL leading\ldots},
\TT{min::\EOL trailing\ldots},
\TT{min::\EOL save\_\EOL indent},
and \TT{min::\EOL set\_\EOL break} operations, then the
\TT{min::\EOL set\_\EOL break} operation is delayed until
after the other operations in the sequence have executed.  See
\pagref{LEADING-TRAILING-SET-BREAK} for details.

Recall from the description of \TT{line\_\EOL break.line\_\EOL length} on
\pagref{LINE-LENGTH}
that when a character representative other than single space, horizontal
tab, or spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed \TT{line\_\EOL break.line\_\EOL length},
then if
\begin{center}
\tt line\_break.column > line\_break.indent
\end{center}
a break, consisting of a line end followed by \TT{line\_\EOL break.indent}
spaces,
is inserted into the printer file buffer just after the break point
(i.e., at \TT{line\_\EOL break.offset}).  Also
single space and horizontal tab
characters immediately before the inserted line end are deleted.

One typically sets a break point just before printing text that one wants
to appear all on one line.  Then if
a character representative other than single space, horizontal
tab, or spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed the \TT{line\_\EOL break.line\_\EOL length},
a line end will be inserted at the break point.

For example, if \TT{line\_\EOL break.line\_\EOL length} is 72 one might
print
\begin{center}
\tt [ aaa, bbb, ccc, ddd, eee, fff, ggg ]
\end{center}
in which \TT{min::\EOL set\_\EOL break} was called after every single space
character (which could be done automatically using
\TT{break\_\EOL control.break\_\EOL after}).
If instead \TT{line\_\EOL break.line\_\EOL length}
was just 14 and \TT{line\_\EOL break.indent} was 2,
the same output would
print as
\begin{center}
\tt
\begin{tabular}{l}
[~aaa,~bbb, \\
~~ccc,~ddd, \\
~~eee,~fff, \\
~~ggg~] \\
\end{tabular}
\end{center}

In particular, after `\TT{[~aaa,~bbb,~}' a break point would be set,
and then when the third `\TT{c}' is about to be printed in column 15,
after `\TT{[~aaa,~bbb,~cc}' has already been printed, this
break point would be changed to a line end with 2 following single
spaces and the single space preceding the line end would be deleted.  Similarly
a break point would be set after `\TT{\ldots~ddd,~}' and changed
when `\TT{e}' is about to be printed in column 15, and a break
point would be set after `\TT{\ldots~fff,~}' and changed
when `\TT{g}' is about to be printed in column 15.  Break points
would also be set after `\TT{[~}', `\TT{\ldots~aaa,~}', etc. but
these would never be used.

The break point is said to be `\mkey{enabled}{break point}' whenever
\begin{center}
\tt line\_break.column > line\_break.indent
\end{center}
and `\mkey{disabled}{break point}' whenever
\begin{center}
\tt line\_break.column <= line\_break.indent
\end{center}
A break point must be enabled to be used.
Whenever a line end is inserted, the break point is
disabled by either setting it to be at the beginning of the line
(so \TT{line\_\EOL break.column} is \TT{0}) or setting it to
just after the \TT{line\_\EOL break.indent} spaces
if these are inserted after the line end.
Thus \TT{min::\EOL eol} and the \TT{min::\EOL indent} operation
(see \pagref{MIN::INDENT}) both end by executing
an implied \TT{min::\EOL set\_\EOL break},
and an implied \TT{min::\EOL set\_\EOL break}
is also executed just after inserting a line end
and \TT{line\_\EOL break.indent} spaces at a break point.

The \TT{min::left} and \TT{min::right} operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{left} \verb|( min::uns32 width )|
\LABEL{MIN::LEFT} \\
\verb|const min::op min::| & \MINKEY{right} \verb|( min::uns32 width )|
\LABEL{MIN::RIGHT} \\
\end{tabular}\end{indpar}

can be used to left or right adjust text in a line.
These operations add spaces to make the current printer column
equal to \TT{line\_\EOL break.column + width}.
The \TT{min::\EOL left} operation simply appends spaces to the
current line.  The \TT{min::\EOL right} operation inserts spaces
at the last break point.  Both operations end with an implicit
\TT{min::\EOL set\_\EOL break} that resets the breakpoint.
Both operations behave exactly as if spaces were inserted at the
appropriate point by \TT{printer <{}< "~"}, except that
\TT{min::right} will give undefined results if a horizontal
tab has been output since the last break point (which can only
happen if the horizontal tab is to represent itself and the
\TT{min::\EOL EXPAND\_\EOL HT} printer operation flag is off).

The \TT{min::reserve} operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{reserve} \verb|( min::uns32 width )|
\LABEL{MIN::RESERVE} \\
\end{tabular}\end{indpar}

can be used to force a line break if there are fewer than \TT{width}
columns remaining in a line.
Here the line break consists of a \TT{min::eol} end of line followed
by \TT{line\_\EOL break.indent} single spaces followed by setting a break
as per \TT{min::\EOL set\_\EOL break}.

The \TT{min::indent} operation:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{indent}
\LABEL{MIN::INDENT} \\
\end{tabular}\end{indpar}

produces a line break if the current printer
column is greater than \TT{line\_\EOL break.indent}, and then (always) inserts
single spaces until the current printer column is equal to
\TT{line\_\EOL break.indent} (whether or not a line break was inserted).
The operation
ends by setting a break point as per \TT{min::\EOL set\_\EOL break}.

Several operations are conditioned on the relative values of
\TT{printer->\EOL line\_\EOL break.indent}, the printer indent,
and \TT{printer->\EOL column}, the printer column:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{eol\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::EOL_IF_AFTER_INDENT} \\
\verb|const min::op min::| & \MINKEY{spaces\_\EOL if\_\EOL before\_\EOL indent}
\LABEL{MIN::SPACES_IF_BEFORE_INDENT} \\
\verb|const min::op min::| & \MINKEY{space\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::SPACE_IF_AFTER_INDENT} \\
\verb|const min::op min::| & \MINKEY{space\_\EOL if\_\EOL none}
\LABEL{MIN::SPACE_IF_NONE} \\
\end{tabular}\end{indpar}

The \TT{min::eol\_\EOL if\_\EOL after\_\EOL indent} operation performs
an \TT{min::eol} operation if and only if the printer column is after
the printer indent.
The \TT{min::spaces\_\EOL if\_\EOL before\_\EOL indent} operation performs
an \TT{min::indent} operation if and only if the printer column is before
the printer indent, inserting single space characters to make the
column equal to the indent in this case.
The \TT{min::space\_\EOL if\_\EOL after\_\EOL indent} operation outputs
a single space character if and only if the printer column is after
the printer indent.
The \TT{min::space\_\EOL if\_\EOL none} operation outputs
a single space character if and only if the last thing in the current
line is a non-space (more specifically, if the last item has non-zero
string class, i.e., it executes the
\TT{min::\EOL print\_\EOL space\_\EOL if\_\EOL none} function,
\pagref{MIN::PRINT_SPACE_IF_NONE}).

Two operations can be used to erase single spaces at the end of the
current printer line:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{erase\_\EOL space}
\LABEL{MIN::ERASE_SPACE} \\
\verb|const min::op min::| & \MINKEY{erase\_\EOL all\_\EOL space}
\LABEL{MIN::ERASE_ALL_SPACE} \\
\end{tabular}\end{indpar}

The first, \TT{min::erase\_space},
erases a single space from the end of the current line,
if there is such a space, and does nothing otherwise.  If it erases
a space, \TT{printer->column} is decremented.  
The second, \TT{min::\EOL erase\_\EOL all\_\EOL space}, erases as
many single spaces as possible from the current line, and
decrements \TT{printer->column} by the number of spaces erased.

The line break parameters of a printer
may be saved in the
\ttmkey{line\_\EOL break\_\EOL stack}{in {\tt min::printer}}%
\label{LINE-BREAK-STACK}
of the printer, and restored from that stack.
This may be done by the following operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{save\_line\_break}
\LABEL{MIN::SAVE_LINE_BREAK} \\
\verb|const min::op min::|
    & \MINKEY{restore\_line\_break}
\LABEL{MIN::RESTORE_LINE_BREAK} \\
\end{tabular}\end{indpar}

\TT{min::save\_line\_break}
pushes into the line break stack a new element containing
the current value of \TT{line\_\EOL break}, while
\TT{min::\EOL restore\_\EOL line\_\EOL break}
resets \TT{line\_\EOL break} from the top line break stack element and then
pops this element from the stack.

In addition, a non-empty line break stack modifies break point
behavior in the following way.
When a character representative other than single space, horizontal
tab, or spaces representing a horizontal tab
is to be inserted into the line, and this would cause the number
of columns in the line to exceed
the printer \TT{line\_\EOL break.line\_\EOL length} parameter,
then if any break stack entry is enabled, the first such entry's
\TT{offset}, \TT{column}, and \TT{indent},
are used in place of the printer
\TT{line\_\EOL break.offset},
\TT{line\_\EOL break.column}, and
\TT{line\_\EOL break.indent} parameters.
If this happens, then all later line break stack entries
and the printer \TT{line\_\EOL break}
are adjusted by adding to offsets
the change in offset of the character following the break and adding to
columns and indents the change in column of this character.

To be more specific, we say that a line break stack
entry \TT{break\_\EOL stack[i]} is `\key{enabled}' if
\begin{center}
\tt break\_stack[i].column > break\_stack[i].indent
\end{center}
and `\key{disabled}' otherwise.  The entries are ordered by \TT{i},
so the `first enabled entry' means the enabled entry with lowest \TT{i},
which is the bottommost (not topmost) enabled element of the line break stack.
The `later entries' are entries with larger \TT{i}.  Note that
after using an entry to insert a line end, that entry's
\TT{line\_\EOL break.offset}
and \TT{line\_\EOL break.column} are reset to make its break point
be just after the indentation spaces that are inserted after the line end.
This sets \TT{break\_\EOL stack[i].column}
equal to \TT{break\_\EOL stack[i].indent},
and thus disables \TT{break\_\EOL stack[i]} so it will not be reused.
Note also that if \underline{no} line break stack entry is enabled,
break point operation proceeds using the printer \TT{line\_\EOL break}
as if the line break stack did not exist.
Lastly note that \TT{break\_\EOL stack[i].line\_\EOL length} is never
used during these operations; its only use is to restore 
\TT{line\_\EOL break.line\_\EOL length} when the \TT{break\_\EOL stack}
is popped.


Management of nested list indentation can be done with the help of
the \TT{line\_\EOL break\_\EOL stack} using the operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::|
    & \MINKEY{save\_indent}
\LABEL{MIN::SAVE_INDENT} \\
\verb|const min::op min::|
    & \MINKEY{restore\_indent}
\LABEL{MIN::RESTORE_INDENT} \\
\end{tabular}\end{indpar}

It is intended that a list header will be printed by first
executing a \TT{min::\EOL set\_\EOL break}, then printing the
header (e.g.~\TT{"[ "}), then executing
\TT{min::save\_indent}, while the list trailer will be printed
by first \underline{not} executing \TT{min::\EOL set\_\EOL break},
then printing the trailer (e.g.~\TT{" ]"}), then executing
\TT{min::\EOL restore\_\EOL indent}.

\TT{min::save\_indent} executes
\TT{min::\EOL save\_\EOL line\_\EOL break} and then
sets \TT{line\_\EOL break.indent} to equal the printer
\TT{column}.
~\TT{min::restore\_\EOL indent} just
executes \TT{min::\EOL restore\_\EOL line\_\EOL break}.

For example, suppose we print the following
with \TT{line\_\EOL length} equal to 72:
\begin{center}
\tt \{~aaa,~bbb,~[~ccc,~ddd,~eee,~(~fff,~ggg~),~hhh~],~iii,~jjj~\}
\end{center}
by using code equivalent to the statement:
\begin{indpar}\begin{verbatim}
    printer << min::set_break << "{ " << min::save_indent
            << min::set_break << "aaa, "
            << min::set_break << "bbb, "
            << min::set_break << "[ " << min::save_indent 
            << min::set_break << "ccc, "
            << min::set_break << "ddd, "
            << min::set_break << "eee, "
            << min::set_break << "( " << min::save_indent 
            << min::set_break << "fff, "
            << min::set_break << "ggg "
            << " ), " << min::restore_indent 
            << min::set_break << "hhh "
            << " ], " << min::restore_indent 
            << min::set_break << "iii, "
            << min::set_break << "jjj "
            << " }" << min::restore_indent 
            << min::eol;
\end{verbatim}\end{indpar}
Then if instead \TT{line\_\EOL length} was just 34 the same output would
print as
\begin{center}
\tt
\begin{tabular}{l}
\{~aaa,~bbb, \\
~~[~ccc,~ddd,~eee,~(~fff,~ggg~), \\
~~~~hhh~],~iii,~jjj~\} \\
\end{tabular}
\end{center}

After printing the 34 characters
\begin{center}
\tt \{~aaa,~bbb,~[~ccc,~ddd,~eee,~(~fff
\end{center}
a line break is triggered just before printing the `\TT{,}' following
`\TT{fff}'.  The first element in the line break stack was pushed
just after printing `\TT{\{~}'% }
and is disabled as it is at the beginning of the line.
The second element, pushed just after printing `\TT{[~}', has
\TT{column} just after `\TT{bbb,~}', and \TT{indent}
just after `\TT{\{~}', and so it is
enabled and used, and in the process it is disabled.
At this point the output is
\begin{center}
\tt
\begin{tabular}{l}
\{~aaa,~bbb, \\
~~[~ccc,~ddd,~eee,~(~fff \\
\end{tabular}
\end{center}
The third element was pushed after printing `\TT{(~}' and it
is updated when the second element is used so it still faithfully
reflects the point just after `\TT{(~}'.
Next this third element is popped after printing `\TT{~),~}'.
Then when the second `\TT{h}' is about to be printed, neither of the
two break points left in the line break stack are enabled, so the non-stack
break point before the first `\TT{h}' is used.  At this point the
current \TT{indent} is that which was saved in and restore from the
second element, and this indent is just after `\TT{[~}'.

If a \TT{min::save\_indent} operation is executed as a non-initial
member of a sequence of
\TT{min::\EOL leading\ldots},
\TT{min::\EOL trailing\ldots},
\TT{min::\EOL set\_\EOL break},
and \TT{min::\EOL save\_\EOL indent} operations, then the
\TT{min::\EOL save\_\EOL indent} operation is delayed until
after the other operations in the sequence have executed.  See
\pagref{LEADING-TRAILING-SAVE-INDENT} for details.

The \key{begin message} and \key{end message} operations can be used
to surround the body of an error message or other message:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::op min::| & \MINKEY{bom}
\LABEL{MIN::BOM} \\
\verb|const min::op min::| & \MINKEY{eom}
\LABEL{MIN::EOM} \\
\end{tabular}\end{indpar}

\TT{min::bom} executes both
a \TT{min::\EOL save\_\EOL indent}
and a \TT{min::\EOL save\_\EOL print\_\EOL format} operation.
\TT{min::\EOL eom} executes in order a
\TT{min::\EOL restore\_\EOL indent},
a \TT{min::\EOL bol},
a \TT{min::\EOL flush\_\EOL id\_\EOL map} (\pagref{MIN::FLUSH_ID_MAP})
if the printer operation flag
\TT{FLUSH\_ID\_MAP\_ON\_EOM} printer operation flag is on, and lastly
a \TT{min::\EOL restore\_\EOL print\_\EOL format}.
Note that the print format and its operation flags
in effect just before \TT{min::\EOL eom}
is executed govern all the operations executed by
\TT{min::\EOL eom}.

For example, the following might be used to print an error message:
\begin{indpar}\begin{verbatim}
    printer << "ERROR: " << min::bom;
    . . . . . .
    // Print contents of error message
    . . . . . .
    printer << min::eom;
\end{verbatim}\end{indpar}

Here the error message will be indented by the number of columns
consumed by `\TT{ERROR:~}', and any format parameters changed
while printing the error message body will be restored at the end
of the message by the \TT{min::\EOL eom}.

\TT{min::bom} will set \TT{line\_\EOL break.indent}
to the current value of \TT{column},
but if a different indent is desired, it can be set by following
\TT{min::\EOL bom} with \TT{min::\EOL set\_\EOL indent}
(\pagref{MIN::SET_INDENT}) or one of the operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::|
    & \MINKEY{place\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::PLACE_INDENT} \\
\verb|min::op min::|
    & \MINKEY{adjust\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::ADJUST_INDENT} \\
\end{tabular}\end{indpar}

These operations set the indent in \TT{line\_\EOL break.indent}
to the sum of `\TT{offset}' and either
the printer `\TT{column}' for \TT{min::\EOL place\_\EOL indent}
or the indent itself for \TT{min::\EOL adjust\_\EOL indent}.
If the indent would be set to a negative value,
\TT{0} is used instead.

\subsubsection{Leading and Trailing Separators}
\label{LEADING-AND-TRAILING-SEPARATORS}

Consider a lexical scanner in which proto-lexemes that contain
no space characters are first scanned, and then `\skey{leading separator}s'
such as the opening single quote (\TT{`}) and dollar sign (\TT{\$})
are removed from the beginning of the proto-lexeme,
`\skey{trailing separator}s' such as closing single quote (\TT{'})
and comma (\TT{,}) are removed from the end of the proto-lexeme,
and anything left over of the proto-lexeme is designated to be a
`\key{middle lexeme}'.  So the proto-lexeme \TT{\$10,000,} translates
to the three lexemes \TT{\$}, \TT{10,000}, and comma (\TT{,}).  Note
that the first comma is part of the middle lexeme and the last is
a trailing separator by itself.

The same effect can be somewhat achieved by a different kind of scanner
that declares a \TT{\$} character to be a separator only if it is
followed by a digit and a comma to be a separator unless
it is surrounded by digits.

Suppose you want to print the 3 element list of strings,
\TT{\$} \TT{10,000} comma (\TT{,}), and you know the first string
may be a leading separator, the second may be middle, and the last
may be trailing.  But maybe not.

You can do this with the code:

\begin{indpar}\begin{verbatim}
printer << min::new_str_gen ( "$")
        << min::leading
        << min::new_str_gen ( "10,000" )
        << min::trailing
        << min::new_str_gen ( "," );
\end{verbatim}\end{indpar}

or if the \TT{min::FORCE\_PGEN} flag is on, with the equivalent
code:

\begin{indpar}\begin{verbatim}
printer << "$" << min::leading << "10,000" << min::trailing << ",";
\end{verbatim}\end{indpar}

(The \TT{min::FORCE\_PGEN} flag is mostly of use in testing
and debugging \TT{min::\EOL leading/\EOL trailing}.)

Here we have used the printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::| & \MINKEY{leading}
\LABEL{MIN::LEADING} \\
\verb|min::op min::| & \MINKEY{trailing}
\LABEL{MIN::TRAILING} \\
\end{tabular}\end{indpar}

Each of these denotes a space character with may be output or
not according to its context.

To give as second example,
consider the code, with \TT{min::\EOL FORCE\_\EOL PGEM} flag on:
\begin{indpar}\begin{verbatim}
printer << "100" << min::trailing << "," << " " << "200";
printer << "100" << min::trailing << "#" << " " << "200";
\end{verbatim}\end{indpar}

We want the first line to output `\TT{100, 200}' in which
\TT{min::\EOL trailing} does \underline{not} output a space,
while we want the second line to output `\TT{100 \# 200}'
in which \TT{min::\EOL trailing} \underline{does} output a space.

And to consider one last example,
consider the code, with \TT{min::\EOL FORCE\_\EOL PGEM} flag on:
\begin{indpar}\begin{verbatim}
printer << "("   << min::leading << "100" << min::trailing <<  ")";
printer << "(+"  << min::leading << "100" << min::trailing << "+)";
\end{verbatim}\end{indpar}

We want the first line to output `\TT{(100)}' in which there are
\underline{no} spaces,
while we want the second line to output `\TT{(+ 100 +)}'
in which there are \underline{two} spaces.

So how to we compute whether \TT{min::leading/trailing} output
a space? 

First, we run every string that is output though a string classifier.
If we use \TT{min::\EOL standard\_\EOL str\_\EOL classifier} on the
strings in the above examples we get:

\begin{center}
\begin{tabular}{l@{~~~~~}l}
String & Class \\[2ex]
\TT{"\$"} & \TT{IS\_LEADING+IS\_GRAPHIC} \\
\TT{"10,000"} & \TT{IS\_GRAPHIC} \\
\TT{","} & \TT{IS\_GRAPHIC+IS\_TRAILING} \\
\TT{"100"} & \TT{IS\_GRAPHIC} \\
\TT{"~"} & \TT{0} \\
\TT{"200"} & \TT{IS\_GRAPHIC} \\
\TT{"\#"} & \TT{IS\_GRAPHIC} \\
\end{tabular}
\end{center}

Then \TT{min::leading} produces a single
space if both the string before it and the string after it have
the \TT{IS\_\EOL GRAPHIC} flag and the string before it does
\underline{not} have the \TT{IS\_\EOL LEADING} flag, and
similarly \TT{min::trailing} produces a single
space if both the string before it and the string after it have
the \TT{IS\_\EOL GRAPHIC} flag and the string after it does
\underline{not} have the \TT{IS\_\EOL TRAILING} flag.

Thus \TT{"100" <{}< min::trailing <{}< ","} does not output a space
while \TT{"100" <{}< min::\EOL trail\-ing <{}< "\#"} does output a space.

There are a number of extra details.

First, if the above had not been printed with the \TT{FORCE\_\EOL PGEN}
flag on, then \TT{min::\EOL null\_\EOL str\_\EOL classifier} would have
been used instead of \TT{min::\EOL standard\_\EOL str\_\EOL classifier},
and the string classes would have been the same but \underline{without}
the \TT{IS\_\EOL LEADING} or \TT{IS\_\EOL TRAILING} flags, so that the
\TT{min::\EOL leading} and \TT{min::\EOL trailing} operations would have all
produced spaces.

Second, if the \TT{min::FORCE\_SPACE} flag is on, \TT{min::leading}
and \TT{min::trailing} always output a space \underline{unless}
either the preceding or following string does \underline{not} have
the \TT{IS\_\EOL GRAPHIC} flag.  But there are variant printer
operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::| & \MINKEY{leading\_always}
\LABEL{MIN::LEADING_ALWAYS} \\
\verb|min::op min::| & \MINKEY{trailing\_always}
\LABEL{MIN::TRAILING_ALWAYS} \\
\end{tabular}\end{indpar}

which are just like \TT{min::leading/trailing} except they
ignore the \TT{min::\EOL FORCE\_\EOL SPACE} flag.  So if
the \TT{FORCE\_\EOL PGEN} flag is on:

\begin{indpar}\begin{verbatim}
printer << "(" << min::leading
        << "100" << min::trailing_always << ", " << "200"
        << min::trailing << ")";
\end{verbatim}\end{indpar}
prints `\TT{(100, 200)}' if \TT{min::\EOL FORCE\_\EOL SPACE} is off, and
prints `\TT{( 100, 200 )}' if \TT{min::\EOL FORCE\_\EOL SPACE} is on.
Some people prefer extra spacing next to parentheses, and
\TT{min::\EOL FORCE\_\EOL SPACE} accommodates this.

Third, above we have dealt with `strings', but the printer actually
deals with
`\ikey{print items}{print item}\index{item!print}'\label{PRINT-ITEM}.
A character string is a print item, but so is a number, and so are
\TT{min::gen} values that are not labels or objects.  Labels and
objects are `\key{composite}' and output multiple print items.
The default rule is that \TT{min::gen} string values are print
items classified by

\begin{center}
\TT{printer->print\_format.gen\_format->str\_format.str\_classifier}
\end{center}

if it exists, whereas in all other cases print items are classified by
the \TT{min::\EOL null\_\EOL str\_\EOL classifier}.
This last classifier just separates out whitespace strings, to which
it gives the class \TT{0}, from other strings, to which it gives
the class \TT{IS\_\EOL GRAPHIC}.

Fourth, a \TT{min::gen} string whose string class contains the
\TT{NEEDS\_\EOL QUOTES} flag, or does \underline{not}
contain the \TT{IS\_\EOL GRAPHIC} flag, is quoted,
and the whole quoted string is treated as a single print item with just the
\TT{IS\_\EOL GRAPHIC} flag.

In general print items may be separated by
consecutive sequences of one \underline{or more} of the print operations
\label{LEADING-TRAILING-RULES}:
\begin{center}
\TTALL
\begin{tabular}{l}
min::leading \\
min::leading\_always \\
min::trailing \\
min::trailing\_always \\
min::save\_indent \\
min::set\_break \\
\end{tabular}
\end{center}
Such a sequence of print operations outputs either a single space or
nothing according to the following rules:
\begin{enumerate}
\item If either the preceding or following print items do not have the
\TT{IS\_\EOL GRAPHIC} flag, no space is emitted.
\item Otherwise if either \TT{min::leading} or \TT{min::trailing}
is in the sequence and the \TT{FORCE\_\EOL SPACE} printer\label{FORCE_SPACE}
operation flag is on, a space is output.
\item Otherwise if either \TT{min::leading} or \TT{min::leading\_\EOL always}
is in the sequence and the preceding print item has the \TT{IS\_\EOL LEADING}
flag, no space is output.
\item Otherwise if either \TT{min::trailing} or \TT{min::trailing\_\EOL always}
is in the sequence and the following print item has the \TT{IS\_\EOL TRAILING}
flag, no space is output.
\item Otherwise a space is output.
\end{enumerate}

If the operation sequence contains a
\TT{min::save\_indent}\label{LEADING-TRAILING-SAVE-INDENT}
or \TT{min::set\_break} operation\label{LEADING-TRAILING-SET-BREAK}
that is preceded by a \TT{min::leading\ldots} or \TT{min::trailing\ldots}
operation in the sequence, this
\TT{min::save\_indent} or \TT{min::set\_break} operation
is delayed until the space is output or a decision not to output
the space has been made.
The sequence must not contain more than one \TT{min::save\_indent}
operation, not counting the first operation in the sequence,
due to implementation limitations.


\subsubsection{Printer Strings}
\label{PRINTER-STRINGS}

Sequence of print items can be represented by `\skey{printer string}s':

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef min::printer (* min::| & \MINKEY{pstring}
				       \verb|) ( min::printer printer )|
\LABEL{MIN::PSTRING} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::pstring}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::pstring pstring )|
\LABEL{PRINTER_OPERATOR<<_OF_PSTRING} \\
\end{tabular}\end{indpar}

where the \TT{<{}<} operator is defined so that if \TT{p} is a
\TT{min::\EOL pstring} then
\begin{center}
\TT{printer<{}<p} ~~~ is equivalent to ~~~ \TT{(*p)(printer)}
\end{center}

\TT{min::pstring} functions usually call the following primitive
string functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_item}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  const char * p,|\ARGBREAK
	\verb|  min::unsptr n,|\ARGBREAK
	\verb|  min::uns32 columns,|\ARGBREAK
	\verb|  min::uns32 str_class = min::IS_GRAPHIC )|
\LABEL{MIN::PRINT_ITEM} \\
\verb|min::printer min::| & \MINKEY{print\_space}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  min::unsptr n = 1 )|
\LABEL{MIN::PRINT_SPACE} \\
\verb|min::printer min::| & \MINKEY{print\_space\_if\_none}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_SPACE_IF_NONE} \\
\verb|min::printer min::| & \MINKEY{print\_erase\_space}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  min::uns32 n = 1 )|
\LABEL{MIN::PRINT_ERASE_SPACE} \\
\verb|min::printer min::| & \MINKEY{print\_leading}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_LEADING} \\
\verb|min::printer min::| & \MINKEY{print\_trailing}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_TRAILING} \\
\verb|min::printer min::| & \MINKEY{print\_leading\_always}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_LEADING_ALWAYS} \\
\verb|min::printer min::| & \MINKEY{print\_trailing\_always}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_TRAILING_ALWAYS} \\
\end{tabular}\end{indpar}

The \TT{min::print\_item} function prints a single print item
that is a UTF-8 string of \TT{n} \TT{chars} taking the given
number of columns and having the given string class.  However,
this function \underline{ignores} the \TT{printer->\EOL print\_\EOL format},
and in particular the \TT{support\_\EOL control},
\TT{display\_\EOL control}, and \TT{break\_\EOL control} parts.
Instead only the following is done in order:

\begin{enumerate}
\item If \TT{n == 0} this function does nothing.
\item The string class is used to determine whether preceding
\TT{min::\EOL leading/\EOL trailing\ldots} operations should
produce a space.
\item The string class is saved for use in processing subsequent
\TT{min::\EOL leading/\EOL trailing\ldots} operations.
\item The UTF-8 string is copied directly to the printer buffer.
\item The printer column is updated.
\item If the printer column exceeds the printer line length,
and the printer line break information warrants, a line break
is inserted.
\end{enumerate}

Therefore the UTF-8 string should encode only of characters
that are graphic, that are supported according to
the printer format \TT{support\_\EOL control},
that display as themselves according to the
printer format \TT{display\_\EOL control},
and that do not cause breaks according to the
printer format \TT{break\_\EOL control}.
Short items containing only ASCII graphics characters
typically meet these qualifications except possibly for
the \TT{break\_\EOL control} in cases where a break is not
really necessary (the item being short).

Therefore \TT{min::print\_item} is mostly of use for inserting
punctuation.

The \TT{min::print\_space} function outputs \TT{n} single spaces
as an item with \TT{0} string class.  It does the same thing
as \TT{print\_item} would do it the item were \TT{n} single spaces,
except it does not insert line breaks and it does do the
printer format \TT{break\_\EOL control.break\_\EOL after}
processing, so it respects the common case where breaks are inserted
automatically \underline{after} single spaces.

The \TT{min::print\_space\_if\_none} function outputs a single space
as per \TT{print\_space} if and only if the string class of the
previous item is not \TT{0}, and does nothing if it is \TT{0}.

The \TT{min::print\_erase\_space} function erases single spaces from
the end of the current line, decrementing \TT{printer->column} by the
number of spaces erased.  It erases at most \TT{n} spaces, and stops
when the current line does not end in a single space.

The \TT{min::print\_leading/trailing\ldots} functions do the same thing as the
corresponding \TT{min::\EOL leading/\EOL trailing\ldots} printer operations.

Sometimes it is useful to perform parts of \TT{min::\EOL print\_\EOL item}
using the functions:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_item\_preface}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  min::uns32 str_class )|
\LABEL{MIN::PRINT_ITEM_PREFACE} \\
\verb|min::printer min::| & \MINKEY{print\_chars}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  const char * p,|\ARGBREAK
	\verb|  min::unsptr n,|\ARGBREAK
	\verb|  min::uns32 columns )|
\LABEL{MIN::PRINT_CHARS} \\
\end{tabular}\end{indpar}

The \TT{min::print\_item\_preface} function does the string class
processing steps of \TT{min::\EOL print\_\EOL item}, while the
\TT{min::print\_\EOL chars} function does the string buffer and column
processing steps.  Both functions assume the string is of non-zero
length.  The main use of these is to concatenate several strings
using multiple calls to \TT{min::\EOL print\_\EOL chars} after a
single call to \TT{min::\EOL print\_\EOL item\_\EOL preface}.
Its also possible to optimize by replacing a call to
\TT{min::\EOL print\_\EOL item} by a call to
\TT{min::\EOL print\_\EOL chars} if that call is sandwiched between
calls to \TT{min::\EOL print\_\EOL space}.

Lastly a \TT{min::ustring} can be printed using

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_ustring}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::ustring s )|
\LABEL{MIN::PRINT_USTRING} \\
\end{tabular}\end{indpar}

This performs the same actions as \TT{min::print\_chars} but
uses the length and number of columns encoded in the
\TT{ustring} argument.  It also does nothing if \TT{s} is \TT{NULL}.


\subsubsection{Printing File Lines and Phrases}
\label{PRINTING-FILE-LINES-AND-PHRASES}

The following function uses \TT{min::line} to print a line as part of
an error message:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE} \\
\end{tabular}\end{indpar}

The \TT{file} line with the given \TT{line\_number}
is printed on a single \TT{printer} line.
\begin{center}
\TT{printer <{}< min::set\_line\_display ( file->line\_display )}
\end{center}
is used to print this line
(see \pagref{FILE_LINE_DISPLAY} and \pagref{MIN::SET_LINE_DISPLAY}),
and the number of columns in the result,
including any end of line representation printed by the
\TT{min::\EOL DISPLAY\_\EOL EOL}, is returned.

If a line is
unavailable (i.e., \TT{min::\EOL line} returns \TT{min::\EOL NO\_\EOL LINE},
see \pagref{MIN::LINE_OF_FILE})
and \TT{line\_\EOL number} is not equal \TT{file->\EOL file\_\EOL lines},
then \TT{unavailable\_\EOL line} is printed on a line by itself instead, and
\TT{0} is returned, if \TT{unavailable\_\EOL line} is not \TT{NULL}.
But if \TT{unavailable\_\EOL line} is \TT{NULL}, nothing is done except
to return \TT{min::\EOL NO\_\EOL LINE}.

If a line would print as blank, and if
\TT{blank\_\EOL line} is not \TT{NULL},
\TT{blank\_\EOL line} is printed instead of the line, and \TT{0} is returned.
More specifically, a line is deemed to print as blank if it only contains
ASCII and LATIN1 horizontal space characters (including horizontal tabs and
single spaces, see \pagref{MIN::IS_HSPACE})
which when printed represent themselves or are suppressed.

If there is no line
because \TT{line\_\EOL number == file->\EOL file\_\EOL lines},
then any partial line at the end of the file buffer is printed,
immediately followed by \TT{end\_\EOL of\_\EOL file}, all on one line,
and the number of columns used to print the partial line is returned.
However, if \TT{end\_\EOL of\_\EOL file} is \TT{NULL}, then
if there is a partial line, only that is printed, on a single line
without any visible ending line feed, and if there is no partial line,
nothing is printed and \TT{NO\_\EOL LINE} is returned.

Note that
\TT{file->\EOL line\_\EOL display} is not used to print
\TT{unavailable\_\EOL line}, \TT{blank\_\EOL line}, or
\TT{end\_\EOL of\_\EOL line} or any line feed following these,
and it is best if these special strings consist of nothing but
graphic ASCII characters and single spaces.
Also, these ASCII strings may not be unprotected body pointers,
as printing may relocate bodies.

In all cases where anything is printed, exactly one complete print line is
printed.

Error messages typically consist of a description of the error
followed by the lines involved printed with the above function.
Often the portions of the lines involved are marked by printing
`\TT{\^{ }}' characters under them.  The error description before
the lines typically ends with the name of the file containing
the lines and the numbers of the lines, which can be produced
by the code:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  min::uns32 first, min::uns32 last )|
\LABEL{MIN::PLINE_NUMBERS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::pline_numbers const & pline_numbers )|
\LABEL{PRINTER_OPERATOR<<_OF_PLINE_NUMBERS} \\
\end{tabular}\end{indpar}

An example use is

\begin{indpar}\begin{verbatim}
    printer << ... error description ...
            << min::pline_numbers ( file, first, last )
            << min::eol;
    for ( min::uns32 line_number = first;
          line_number <= last,
          ++ line_number )
        min::print_line ( printer, file, line_number );
\end{verbatim}\end{indpar}

The line numbers printed by \TT{min::\EOL pline\_\EOL number}
are \TT{1} greater than the line numbers given in the arguments,
so the line number of the first line of a file is denoted by a
\TT{0} argument which is printed as \TT{1}.

There is a better way to print the lines of a file within an
error message if the positions of the erroneous text in the file
are known and are encoded in
\TT{min::position} structures:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::uns32 line;|\ARGBREAK
    \verb|  min::uns32 offset;|\ARGBREAK
    \verb|};|
\ttmindex{line}{in {\tt min::position}}
\ttmindex{offset}{in {\tt min::position}}
\ttmindex{column}{in {\tt min::position}}
\LABEL{MIN::POSITION_STRUCT} \\
\end{tabular}\end{indpar}

Here \TT{line} is the number of full lines before the line
containing the position and \TT{offset} is the
number of bytes before the position in the line.

A missing value and the following operations are defined
for \TT{min::\EOL position} structures:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::position min::| & \MINKEY{MISSING\_POSITION}
    \verb|= { 0xFFFFFFFF, 0xFFFFFFFF }|
\LABEL{MIN::MISSING_POSITION} \\
\verb|bool |
    & \TTOMKEY{==}{==}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR==_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR!=_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{<}{<}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR<_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{<=}{<=}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR<=_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{>}{>}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR>_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{>=}{>=}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR>=_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{(bool)}{(bool)}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p )|
\LABEL{OPERATOR(bool)_OF_POSITION} \\
\end{tabular}\end{indpar}

A \TT{min::position} is less than another if its line is less
or its line is equal and its offset is less.  A \TT{min::\EOL position}
\TT{p} converts to \TT{true} if \TT{p.line != 0xFFFFFFFF}
and to \TT{false} otherwise.  This permits special values other than
\TT{min::\EOL MISSING\_\EOL POSITION} to be defined with \TT{line}
equal to \TT{0xFFFFFFFF}.

Two \TT{min::position} structures are needed to encode the boundaries
of a piece of text in a file.  Such a piece of text is called
a `\key{phrase}', and its positions are encoded in a
\TT{min::\EOL phrase\_\EOL position} structure:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{phrase\_\EOL position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::position begin;|\ARGBREAK
    \verb|  min::position end;|\ARGBREAK
    \verb|};|
\ttmindex{begin}{in {\tt min::phrase\_position}}
\ttmindex{end}{in {\tt min::phrase\_position}}
\LABEL{MIN::PHRASE_POSITION_STRUCT} \\
\end{tabular}\end{indpar}

Here `\TT{begin}' encodes the position of the first character
of the phrase in the file, and `\TT{end}' encodes the position
of the first character \underline{after} the phrase in the file.
If the phrase is empty, \TT{begin == end}, and the position
referenced by both `\TT{begin}' and `\TT{end}'
is the position of the empty phrase in the file.

To print the line numbers of a phrase one can use the constructor:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  min::phrase_position const & position )|
\LABEL{MIN::PLINE_NUMBERS_OF_PHRASE_POSITION} \\
\end{tabular}\end{indpar}

which uses \TT{position.begin.line} and
\TT{position.end.line} as
line numbers, except that when
\begin{center}
\TT{position.end.offset == 0} \\
and \\
\TT{position.end.line > position.begin.line}
\end{center}
then \TT{position.end.line - 1} is used in place of
\TT{position.end.line}.

To print a phrase one can use the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES} \\
\end{tabular}\end{indpar}

The lines containing the phrase are printed, and under each phrase
character a \TT{mark} is printed.  The lines are printed
as per \TT{min::\EOL print\_\EOL line} using the
\TT{blank\_\EOL line},
\TT{end\_\EOL of\_\EOL file}, and
\TT{unavailable\_\EOL line} arguments.
An empty phrase is marked as if it were 1-column wide, that column
being at the empty phrase position.

If the \TT{mark} argument is given as \TT{0}, the marking lines
will be omitted.  This permits just printing the lines containing
a phrase, without marking the phrase.

The column number of position.begin is returned (this is \TT{0}
for the first column).  If position bounds the non-whitespace
portion of some lines, this is the indent of that portion in
the first of these lines.

An example using a \TT{phrase\_position} is

\begin{indpar}\begin{verbatim}
    printer << ... error description ...
            << min::pline_numbers ( file, phrase_position )
            << min::eol;
    min::print_phrase_lines ( printer, file, phrase_position );
\end{verbatim}\end{indpar}

Internally \TT{min::\EOL print\_\EOL phrase\_\EOL lines}
makes the call:

\begin{indpar}\begin{verbatim}
    min::print_line_column
        ( file, position, file->line_display,
          printer->print_format );
\end{verbatim}\end{indpar}

which uses the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\_\EOL column\RESIZE}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  const min::print_format & print_format )|
\LABEL{MIN::PRINT_LINE_COLUMN} \\
\end{tabular}\end{indpar}

that, given a file, a position within that file, a line display,
and the print format, returns the number of
columns before the position in a \TT{min::\EOL print\_\EOL line}
printout of the line.  To do this, \TT{min::\EOL print\_\EOL line\_\EOL column}
calls \TT{min::\EOL pwidth} with its \TT{print\_\EOL format} argument modified
as per
\begin{center}
\TT{min::set\_line\_display ( line\_display )}
\end{center}

Some of the above functions use \TT{file->line\_display}
to control how lines are printed and therefore which column
a position corresponds to.  Specifically, if \TT{min::\EOL DISPLAY\_\EOL EOL}
is on in \TT{file->line\_display}, \TT{<NL>} 
will print at the end of a line if
\TT{min::\EOL DISPLAY\_\EOL PICTURE} is off, and
{\tiny $\stackrel{\textstyle N~}{~L}$} will print if
\TT{min::\EOL DISPLAY\_\EOL PICTURE} is on.  Also,
non-graphic, non-horizontal-space characters always print as pictures
(e.g., {\tiny $\stackrel{\textstyle F~}{~F}$})
if \TT{min::\EOL DISPLAY\_\EOL PICTURE} is on, and otherwise as
as their names with prefix and postfix determined by
\TT{printer->\EOL print\_\EOL format.char\_\EOL name\_\EOL format}
(e.g., \TT{<FF>}).
If in addition \TT{min::\EOL DISPLAY\_\EOL NON\_\EOL GRAPHIC} is on,
horizontal space characters will also print as pictures
(e.g., \TT{\textvisiblespace} and {\tiny $\stackrel{\textstyle H~}{~T}$}),
if \TT{min::\EOL DISPLAY\_\EOL PICTURE} is on, and otherwise as
as their names (e.g., \TT{<SP>} and \TT{<HT>}).

The following are alternatives to the above functions that take
an extra \TT{line\_\EOL display} argument and use that in place of
\TT{file->\EOL line\_\EOL display}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE_WITH_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES_WITH_FLAGS} \\
\end{tabular}\end{indpar}

There is a type of packed vector, the `\key{phrase position vector}\,',
that is specialized to
record the phrase positions of elements of any linear vector:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|typedef min::|
	& \verb|packed_vec_ptr<min::phrase_position_vec_header,|\\&
	  \verb|               min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec}
\LABEL{MIN::PHRASE_POSITION_VEC} \\
\verb|typedef min::|
	& \verb|packed_vec_insptr<min::phrase_position_vec_header,|\\&
	  \verb|                  min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec\_insptr}
\LABEL{MIN::PHRASE_POSITION_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::| 
  & \verb|phrase_position_vec_insptr min::|\MINKEY{init\RESIZE}\ARGBREAK
    \verb|( min::ref<min::phrase_position_vec_insptr> vec,|\ARGBREAK
    \verb|  min::file file,|\ARGBREAK
    \verb|  min::phrase_position const & position,|\ARGBREAK
    \verb|  min::uns32 max_length )|
\LABEL{MIN::INIT_OF_PHRASE_POSITION_VEC} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 vpp| & \TTARMKEY{length}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_LENGTH} \\
\verb|const min::file vpp| & \TTARMKEY{file}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_FILE} \\
\verb|min::phrase_position vpp| & \TTARMKEY{position}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_POSITION} \\
\verb|min::phrase_position vpp| & \TTBMKEY{i}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_ELEMENT} \\
\end{tabular}\end{indpar}

A phrase position vector is associated with some other data vector.
For example, a phrase position vector may be the value of the
\TT{.position} attribute of an object
(see below), in which case it will be associated with
the attribute vector of the object.
If \TT{vpp} is a phrase position vector pointer, \TT{vpp->\EOL position}
is the position of the phrase that is encoded in the data vector,
\TT{vp[i]} is the position of the phrase that is encoded in
the \TT{i+1}'st element of the data vector, and
\TT{vpp->\EOL file} is the file containing these phrases.
\TT{vpp->\EOL length} is, as per the definition of packed vectors,
the number of elements in the phrase position vector, and should
match the number of elements in the data vector.
The \TT{min::\EOL init} function above can be used to create or
reinitialize a \TT{min::\EOL phrase\_\EOL position\_\EOL vec},
and sets the \TT{file}, \TT{position}, and initial maximum length
of the phrase position vector.

A MIN object may have a \TT{.position} attribute equal to a
phrase position vector.  If an object does, the phrase position
pointer is returned by the following function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::phrase_position_vec min::| & \MINKEY{position\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::POSITION_OF_OBJECT_VEC_PTR} \\
\end{tabular}\end{indpar}

Here the object is identified by the \TT{min::\EOL obj\_\EOL vec\_\EOL ptr}
which is being used to access the object elements; see
\pagref{MIN::OBJ_VEC_PTR_OF_GEN}.
If the object has no \TT{.position} attribute, or if the attribute is
not a \TT{min::\EOL phrase\_\EOL position\_\EOL vec} value,
\TT{min::\EOL NULL\_\EOL STUB} is returned.

\subsection{Printing General Values}
\label{PRINTING-GENERAL-VALUES}

\TT{min::gen} values are printed using the \TT{min::\EOL pgen} printer
operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::| & \MINKEY{pgen} \verb|( min::gen v )|
\LABEL{MIN::PGEN} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::gen v )|
\LABEL{PRINTER_OPERATOR<<_OF_GEN} \\
\verb|min::op min::|
    & \MINKEY{pgen}\ARGBREAK
	  \verb|( min::gen v,|\ARGBREAK
	  \verb|  const min::gen_format * gen_format )|
\LABEL{MIN::PGEN_WITH_GEN_FORMAT} \\
\verb|min::op min::|
    & \MINKEY{set\_gen\_format}\ARGBREAK
	  \verb|( const min::gen_format * gen_format )|
\LABEL{MIN::SET_GEN_FORMAT} \\
\verb|min::op min::| & \MINKEY{pgen\_name} \verb|( min::gen v )|
\LABEL{MIN::PGEN_NAME} \\
\verb|min::op min::| & \MINKEY{pgen\_quote} \verb|( min::gen v )|
\LABEL{MIN::PGEN_QUOTE} \\
\verb|min::op min::| & \MINKEY{pgen\_never\_quote} \verb|( min::gen v )|
\LABEL{MIN::PGEN_NEVER_QUOTE} \\
\end{tabular}\end{indpar}

The expression `\TT{printer\,<{}<\,min::pgen(v)}'
prints the \TT{min::gen} value \TT{v} to the
\TT{printer} using the \TT{printer}'s \TT{gen\_\EOL format} value
\begin{center}
\TT{printer->\EOL print\_\EOL format.gen\_\EOL format} \\
\end{center}
to control the printing.

`\TT{printer\,<{}<\,v}' can be used as the equivalent of
`\TT{printer\,<{}<\,min::pgen(v)}'.
The following function has the same effect:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_gen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::PRINT_GEN} \\
\end{tabular}\end{indpar}

The expression `\TT{printer\,<{}<\,min::pgen(v,f)}' is similar but
uses \TT{f} as the \TT{gen\_\EOL format} value.
The following function has the same effect:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_gen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  const min::gen_format * f )|
\LABEL{MIN::PRINT_GEN_WITH_FORMAT} \\
\end{tabular}\end{indpar}

The expression
`\TT{printer\,<{}<\,min::set\_gen\_format(f)}' sets
\begin{center}
\TT{printer->\EOL print\_\EOL format.gen\_\EOL format} \\
\end{center}
to the value `\TT{f}'.  The default value of
\begin{center}
\TT{printer->\EOL print\_\EOL format.gen\_\EOL format} \\
\end{center}
is \ttkey{min::top\_gen\_format} (\pagref{MIN::TOP_GEN_FORMAT}).

\TT{min::\EOL pgen\_\EOL name(v)},
\TT{min::\EOL pgen\_\EOL quote(v)}, and
\TT{min::\EOL pgen\_\EOL never\_\EOL quote(v)} are respectively
shorthand for
\begin{center}
\tt
\begin{tabular}{l}
min::pgen ( v, min::name\_gen\_format ) \\
min::pgen ( v, min::always\_quote\_gen\_format ) \\
min::pgen ( v, min::never\_quote\_gen\_format ) \\
\end{tabular}
\end{center}



A \TT{min::gen\_\EOL format} cannot be stored in a
relocatable body, and is intended to be a static C++ structure.
In making new versions, one must copy an existing
\TT{min::\EOL gen\_\EOL format}
and then change particular members in the copy, because one cannot
count on all the members being organized in a particular way.
Copies can be made in the stack.

The detailed structure and available standard values
for general value formats is as follows:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{gen\_format}}
\LABEL{MIN::GEN_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::printer ( * pgen )|\ARGBREAK
    \verb|       ( min::printer printer,|\ARGBREAK
    \verb|         min::gen v,|\ARGBREAK
    \verb|         const min::gen_format * gen_format );|%
\ttmindex{pgen}{in {\tt min::gen\_format}}\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  // Members beyond this point are for use of|\ARGBREAK
    \verb|  // min::standard_pgen.|\ARGBREAK
    \verb||\ARGBREAK
    \verb|  const min::num_format *  num_format;|%
\ttmindex{num\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::str_format *  str_format;|%
\ttmindex{str\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::lab_format *  lab_format;|%
\ttmindex{lab\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::special_format *  special_format;|%
\ttmindex{special\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::obj_format *  obj_format;|%
\ttmindex{obj\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|};|
\end{tabular}
\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{element\_gen\_format}:}
\LABEL{MIN::ELEMENT_GEN_FORMAT}\ARGBREAK
\verb|& min::standard_pgen                    // pgen |\ARGBREAK
\verb|min::long_num_format                    // num_format|\ARGBREAK
\verb|min::quote_separator_str_format         // str_format|\ARGBREAK
\verb|min::bracket_lab_format                 // lab_format|\ARGBREAK
\verb|min::bracket_special_format             // special_format|\ARGBREAK
\verb|min::compact_obj_format                 // obj_format|\ARGBREAK
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{top\_gen\_format}:}
\LABEL{MIN::TOP_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::top_obj_format                     // obj_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{value\_gen\_format}:}
\LABEL{MIN::VALUE_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::quote_all_str_format               // str_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{id\_map\_gen\_format}:}
\LABEL{MIN::ID_MAP_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::quote_separator_and_mark_str_format // str_format|\ARGBREAK
\verb|min::isolated_line_obj_format           // obj_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{name\_gen\_format}:}
\LABEL{MIN::NAME_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::quote_separator_and_mark_str_format // str_format|\ARGBREAK
\verb|min::name_lab_format                    // lab_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{leading\_always\_gen\_format}:}
\LABEL{MIN::LEADING_ALWAYS_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::standard_str_format                // str_format|\ARGBREAK
\verb|min::leading_always_lab_format          // lab_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{trailing\_always\_gen\_format}:}
\LABEL{MIN::TRAILING_ALWAYS_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::standard_str_format                // str_format|\ARGBREAK
\verb|min::trailing_always_lab_format         // lab_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{always\_quote\_gen\_format}:}
\LABEL{MIN::ALWAYS_QUOTE_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::quote_all_str_format               // str_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{never\_quote\_gen\_format}:}
\LABEL{MIN::NEVER_QUOTE_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|NULL                                    // str_format|\ARGBREAK
\verb|min::name_lab_format                    // lab_format|\ARGBREAK
\verb|min::name_special_format                // special_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINLKEY{line}{\_gen\_format}:}
\LABEL{MIN::LINE_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::line_obj_format                    // obj_format|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{paragraph\_gen\_format}:}
\LABEL{MIN::PARAGRAPH_GEN_FORMAT}\ARGBREAK
\verb|// Same as min::element_gen_format except for:|\ARGBREAK
\verb|min::paragraph_obj_format               // obj_format|
\end{tabular}\end{indpar}

A general value format can be any structure whose first member
is:

\begin{indpar}[1em]
\verb|min::printer ( * pgen )|\\
\verb|     ( min::printer printer,|\\
\verb|       min::gen v,|\\
\verb|       const min::gen_format * gen_format )|
\end{indpar}

This first member is called with the \TT{min::\EOL gen\_\EOL format}
itself as third argument to execute the \TT{pgen} operation.  So in
effect a \TT{min::\EOL gen\_\EOL format} value is a
`\mkey{closure}{\tt min::gen\_\EOL format}' whose first member is
the function to execute and whose remaining members are data for
this function.

The standard first member function value is:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{standard\_pgen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  const min::gen_format * gen_format )|
\LABEL{MIN::STANDARD_PGEN} \\
\end{tabular}\end{indpar}

The \TT{min::\EOL gen\_\EOL format} structure described above
is what is expected by this
`\ikey{standard \TT{pgen}}{standard pgen@standard {\tt pgen}}'.
In this document it is this format and the standard \TT{pgen}
that are implicitly described.

The members of a general value format control the printing
of different kinds of general values.  For example, the
\TT{str\_\EOL format} member controls the printing of string
general values.  We will describe how each member is used in
the following subsections.

\subsubsection{Printing Numeric General Values}
\label{PRINTING-NUMERIC-GENERAL-VALUES}

The format for printing numeric \TT{min::gen} values is:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{num\_format}}
\LABEL{MIN::NUM_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const char *        int_printf_format;|%
\ttmindex{int\_printf\_format}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  min::float64        non_float_bound;|%
\ttmindex{non\_float\_bound}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  const char *        float_printf_format;|%
\ttmindex{float\_printf\_format}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  const min::uns32 *  fraction_divisors;|%
\ttmindex{fraction\_divisors\_format}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  min::float64        fraction_accuracy;|%
\ttmindex{fraction\_accuracy}{in {\tt min::num\_format}}\ARGBREAK
    \verb|};|
\end{tabular}
\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::num\_format *
                   min::\MINKEY{short\_num\_format}:}\ARGBREAK
\verb|"%.0f"                  // int_printf_format|\ARGBREAK
\verb|1e7                     // non_float_bound|\ARGBREAK
\verb|"%.6g"                  // float_printf_format|\ARGBREAK
\verb|NULL                    // fraction_divisors|\ARGBREAK
\verb|0                       // fraction_accuracy|
\LABEL{MIN::SHORT_NUM_FORMAT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::num\_format *
                   min::\MINKEY{fraction\_num\_format}:}\ARGBREAK
\verb|"%.0f"                  // int_printf_format|\ARGBREAK
\verb|1e7                     // non_float_bound|\ARGBREAK
\verb|"%.6g"                  // float_printf_format|\ARGBREAK
\verb|min::standard_divisors  // fraction_divisors|\ARGBREAK
\verb|1e-9                    // fraction_accuracy|
\LABEL{MIN::FRACTION_NUM_FORMAT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::num\_format *
                   min::\MINKEY{long\_num\_format}:}\ARGBREAK
\verb|"%.0f"                  // int_printf_format|\ARGBREAK
\verb|1e15                    // non_float_bound|\ARGBREAK
\verb|"%.15g                  // float_printf_format|\ARGBREAK
\verb|NULL                    // fraction_divisors|\ARGBREAK
\verb|0                       // fraction_accuracy|
\LABEL{MIN::LONG_NUM_FORMAT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::uns32 *
                   min::\MINKEY{standard\_divisors}:}\ARGBREAK
\verb|2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,|\ARGBREAK
\verb|16, 32, 64, 128, 256, 512, 1024, 0|\ARGBREAK
\LABEL{MIN::STANDARD_DIVISORS} \\
\end{tabular}\end{indpar}

The following function is called when a numeric \TT{min::gen} value
is printed, and can be used to print a \TT{min::\EOL float64}
value according to the above formats:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_num}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::float64 value,|\ARGBREAK
    \verb|  const min::num_format * num_format = NULL )|
\LABEL{MIN::PRINT_NUM} \\
\end{tabular}\end{indpar}

If the third argument is not provided,
\TT{printer->\EOL print\_\EOL format.num\_\EOL format} is used.

Given an \TT{min::gen} numeric value \TT{g}, \TT{printer <{}< g}
and \TT{printer <{}< min::\EOL pgen~(~g~)} are both
equivalent to
\begin{center}
\verb|min::print_num ( printer, min::float_of ( g ) )|
\end{center}

\TT{printer <{}< min::\EOL pgen~(~g,~f~)} is equivalent to
\begin{center}
\verb|min::print_num ( printer, min::float_of ( g ), f->num_format )| \\
\end{center}

The algorithm used by \TT{min::print\_num} is as follows when the
\TT{min::\EOL num\_\EOL format} argument is \TT{nf}:

\begin{enumerate}
\item If the absolute value of the \TT{value} argument is strictly
less than \TT{nf->\EOL non\_\EOL float\_\EOL bound}, then:
\begin{enumerate}
\item If \TT{value} is an integer, it is printed using the
\TT{nf->\EOL int\_\EOL printf\_\EOL format}.
\item If \TT{nf->fraction\_divisors} is not \TT{NULL} and within
this vector a divisor \TT{D} can be found such that for suitable integers
\TT{I} and \TT{N}, \TT{0 <= N < D} and
\begin{center}
\TT{|value - I - N/D| < nf->fraction\_accuracy}
\end{center}
then `\TT{I N/D}' is printed if \TT{I>0}, `\TT{N/D}' is printed if \TT{I == 0},
`\TT{-M/D}' is printed if \TT{I == -1} where \TT{M = D-N}, and
`\TT{-J M/D}' is printed if \TT{I < -1} where \TT{J = I+1}.
\end{enumerate}
\item If \TT{value} has not been printed by the above, it is printed
using \TT{nf->\EOL float\_\EOL printf\_\EOL format}.
\end{enumerate}

The list of allowed divisors \TT{D} in \TT{nf->fraction\_\EOL divisors}
must be in ascending order and be terminated by a \TT{0}.

\subsubsection{Printing String General Values}
\label{PRINTING-STRING-GENERAL-VALUES}

The formats for printing string \TT{min::gen} values are:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{str\_format}}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::str_classifier   str_classifier;|%
\ttmindex{quote\_control}{in {\tt min::str\_format}}\ARGBREAK
    \verb|  min::quote_format     quote_format;|%
\ttmindex{quote\_format}{in {\tt min::str\_format}}\ARGBREAK
    \verb|  min::display_control  display_control;|%
\ttmindex{display\_control}{in {\tt min::str\_format}}\ARGBREAK
    \verb|  min::uns32            id_strlen;|%
\ttmindex{id\_strlen}{in {\tt min::str\_format}}\ARGBREAK
    \verb|};|
\LABEL{MIN::STR_FORMAT}
\end{tabular}\end{indpar}

\begin{indpar}[1em]
\TTKEY{MIN\_ID\_STRLEN}
    \verb|  // == 21, minimum effective value for id_strlen.|
\LABEL{MIN_ID_STRLEN}
\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::str\_format *
    min::\MINKEY{standard\_str\_format}:}
\LABEL{MIN::STANDARD_STR_FORMAT}\ARGBREAK
\verb|min::standard_str_classifier           // str_classifier|\ARGBREAK
\verb|min::standard_quote_format             // quote_format|\ARGBREAK
\verb|min::graphic_only_display_control      // display_control|\ARGBREAK
\verb|MIN_ID_STRLEN                          // id_strlen|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::str\_format *
                   min::\MINLKEY{quote\_separator}{\_str\_format}:}
\LABEL{MIN::QUOTE_SEPARATOR_STR_FORMAT}\ARGBREAK
\verb|// Same as min::standard_str_format except for:|\ARGBREAK
\verb|min::quote_separator_str_classifier    // str_classifier|\ARGBREAK
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::str\_format *
                   min::\MINLKEY{quote\_separator\_and\_mark}{\_str\_format}:}
\LABEL{MIN::QUOTE_SEPARATOR_AND_MARK_STR_FORMAT}\ARGBREAK
\verb|// Same as min::standard_str_format except for:|\ARGBREAK
\verb|min::quote_separator_and_mark_str_classifier // str_classifier|\ARGBREAK
\verb|0                                            // id_strlen|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{const min::str\_format *
                   min::\MINKEY{quote\_all\_str\_format}:}
\LABEL{MIN::QUOTE_ALL_STR_FORMAT}\ARGBREAK
\verb|// Same as min::standard_str_format except for:|\ARGBREAK
\verb|min::quote_all_str_classifier                // str_classifier|\ARGBREAK
\verb|0                                            // id_strlen|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{quote\_format}}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::ustring    str_prefix;|%
\ttmindex{str\_prefix}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|  min::ustring    str_postfix;|%
\ttmindex{str\_postfix}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|  min::ustring    str_postfix_name;|%
\ttmindex{str\_postfix\_name}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|  min::ustring    str_concatenator;|%
\ttmindex{str\_concatenator}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|};|
\LABEL{MIN::QUOTE_FORMAT}
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::quote\_format
                   min::\MINKEY{standard\_quote\_format}:}\ARGBREAK
\verb|(min::ustring) "\x01\x01" "\""   // str_prefix|\ARGBREAK
\verb|(min::ustring) "\x01\x01" "\""   // str_postfix|\ARGBREAK
\verb|(min::ustring) "\x03\x03" "<Q>"  // str_postfix_name|\ARGBREAK
\verb|(min::ustring) "\x01\x01" "#"    // str_concatenator|\ARGBREAK
\LABEL{MIN::STANDARD_QUOTE_FORMAT}
\end{tabular}\end{indpar}

The \TT{ustring} members of \TT{min::quote\_format} \underline{must not}
contain non-graphic characters (e.g., no spaces).

The following function, which is used to print string general values,
prints a UTF-8 encoded \TT{const char *}
value according to the above formats:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_cstring}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  const char * str,|\ARGBREAK
    \verb|  const min::str_format * str_format = NULL )|
\LABEL{MIN::PRINT_CSTRING} \\
\end{tabular}\end{indpar}

If \TT{str\_\EOL format} is \TT{NULL},
the string is printed as is without quoting.
Otherwise \TT{str\_\EOL format->\EOL str\_\EOL classifier}
is used to compute the
string class of the string, and if that has the
\TT{min::\EOL NEEDS\_\EOL QUOTES} flag or does \underline{not} have the
\TT{min::\EOL IS\_\EOL GRAPHIC} flag, the string is quoted.

If not quoted, the string
is considered to be a print item (\pagref{PRINT-ITEM}).
As such its string class is computed by
\TT{str\_\EOL format->\EOL str\_\EOL classifier} if \TT{str\_\EOL format}
is not \TT{NULL}, and by \TT{min::\EOL null\_\EOL str\_\EOL classifier}
otherwise.
See \itemref{STRING-CLASSIFIERS} for details on string classifiers
and \itemref{LEADING-AND-TRAILING-SEPARATORS} for the uses of string
classes in determining the behavior of the
\TT{min::\EOL leading/\EOL trailing\ldots} printer operations.

When `\TT{printer <{}< min::pgen ( str )}' calls
\TT{min::\EOL print\_\EOL cstring}, it uses
\begin{center}
\TT{str\_format = printer->print\_format.gen\_format->str\_format}
\end{center}
However,
\TT{printer->\EOL print\_\EOL format.str\_\EOL format} is \underline{not}
implicitly used when \TT{min::\EOL print\_\EOL cstring} is called directly
with a \TT{NULL} third argument.

\TT{min::print\_cstring} copies the string to the stack (converting from
UTF-8 to a UNICODE \TT{min::\EOL Uchar} vector) before invoking
any functions that might allocate or relocate objects, so \TT{str}
\underline{can} be a relocatable address.


If the string is to be quoted, \TT{str\_format->quote\_format}
determines how the string is quoted.  The quoted string is preceded
by the \TT{str\_\EOL prefix} member (e.g., \TT{"}) and followed by the
\TT{str\_\EOL postfix} member (e.g., \TT{"}).  If the quoted string itself
contains a copy of the \TT{str\_\EOL postfix} member (e.g., \TT{"}),
that copy is replaced by the \TT{str\_\EOL postfix\_\EOL replacement}
member (e.g., \TT{<Q>}).  If the string is too long to fit in the
columns between \TT{printer->\EOL line\_\EOL break.indent}
and \TT{printer->\EOL line\_\EOL break.line\_\EOL length}
(\pagref{LINE-LENGTH}), and if
the \TT{str\_\EOL concatenator} member is not \TT{NULL}, then
the quoted string is broken into multiple quoted strings, each
fitting within the columns, separated by copies of
\TT{str\_\EOL concatenator} (e.g., \TT{\#})
surrounded by single spaces.

Lastly, the characters of the string being quoted (but \underline{not}
those of \TT{str\_\EOL format->\EOL quote\_\EOL format.str\_\ldots})
are printed using \TT{str\_\EOL format->\EOL display\_\EOL control}
instead of \TT{printer->\EOL print\_\EOL format.display\_\EOL control}.
E.g., only graphic characters may be allowed to print as themselves,
and everything else may be represented by a character name
(or if the \TT{min::\EOL DISPLAY\_\EOL PICTURE} printer operation
flag is set, by a character picture).

If instead of a \TT{const char *} string you want to print a vector
of \TT{n} UNICODE \TT{Uchar}'s pointed at by \TT{p}, you may use the
function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_unicode}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::unsptr n,|\ARGBREAK
    \verb|  min::ptr<const min::Uchar> p,|\ARGBREAK
    \verb|  const min::str_format * str_format = NULL )|
\LABEL{MIN::PRINT_UNICODE} \\
\end{tabular}\end{indpar}

Note the vector of \TT{min::Uchar}'s may be in a relocatable body.

The following function may be called to print a string \TT{min::gen} value:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_str}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min:gen str,|\ARGBREAK
    \verb|  const min::str_format * str_format = NULL )|
\LABEL{MIN::PRINT_STR} \\
\end{tabular}\end{indpar}

This function just calls the \TT{min::\EOL print\_\EOL cstring} function
described above with the \TT{const char *} part of the string general value.
The \TT{str} argument must be a string general value.

The \TT{min::\EOL standard\_\EOL pgen} function that prints general
values for \TT{min::pgen} will print a long enough string as an
identifier of the form \TT{@}{\em <id>} if
the \ttikey{id\_\EOL strlen}{id\_strlen}
member of the \TT{min::\EOL str\_\EOL format} being used
to print the string has a \TT{id\_\EOL strlen} member is as least as large as
the value of \TT{MIN\_ID\_STRLEN} but no larger than the string length,
and provided that the string has \underline{already} been given
an identifier (e.g., by \TT{min::map}, see \pagref{MIN::MAP_OF_ID_MAP}).

\subsubsection{Printing Label General Values}
\label{PRINTING-LABEL-GENERAL-VALUES}

The format for printing label \TT{min::gen} values is:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{lab\_format}}
\LABEL{MIN::LAB_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::pstring         lab_prefix;|%
\ttmindex{lab\_prefix}{in {\tt min::lab\_format}}\ARGBREAK
    \verb|  min::pstring         lab_separator;|%
\ttmindex{lab\_separator}{in {\tt min::lab\_format}}\ARGBREAK
    \verb|  min::pstring         lab_postfix;|%
\ttmindex{lab\_postfix}{in {\tt min::lab\_format}}\ARGBREAK
    \verb|};|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{name\_lab\_format}:}
\LABEL{MIN::NAME_LAB_FORMAT}\ARGBREAK
\verb|NULL                                     // lab_prefix|\ARGBREAK
\verb|min::space_if_none_pstring               // lab_separator " "|\ARGBREAK
\verb|NULL                                     // lab_postfix|\ARGBREAK
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{leading\_always\_lab\_format}:}
\LABEL{MIN::LEADING_ALWAYS_LAB_FORMAT}\ARGBREAK
\verb|NULL                                     // lab_prefix|\ARGBREAK
\verb|min::leading_always_pstring              // lab_separator|\ARGBREAK
\verb|     // Equivalent to printer << min::leading|\ARGBREAK
\verb|NULL                                     // lab_postfix|\ARGBREAK
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{trailing\_always\_lab\_format}:}
\LABEL{MIN::TRAILING_ALWAYS_LAB_FORMAT}\ARGBREAK
\verb|NULL                                     // lab_prefix|\ARGBREAK
\verb|min::trailing_always_pstring             // lab_separator|\ARGBREAK
\verb|     // Equivalent to printer << min::trailing|\ARGBREAK
\verb|NULL                                     // lab_postfix|\ARGBREAK
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{bracket\_lab\_format}:}
\LABEL{MIN::BRACKET_LAB_FORMAT}\ARGBREAK
\verb|min::left_square_angle_space_pstring     // lab_prefix    "[< "|\ARGBREAK
\verb|min::space_if_none_pstring               // lab_separator " "|\ARGBREAK
\verb|min::space_right_angle_square_pstring    // lab_postfix   " >]"|\ARGBREAK
\end{tabular}\end{indpar}

A label format is only of use as part of a \TT{min::\EOL gen\_\EOL format},
as the latter is needed to print the elements of the label.

Given a label format \TT{lf}, a \TT{min::gen} label value is printed as
\TT{lf->\EOL lab\_\EOL prefix}, followed by the label elements separated by
\TT{lf->\EOL lab\_\EOL separator}'s, followed by
\TT{lf->\EOL lab\_\EOL postfix}.  Note that \TT{NULL} values for
\TT{lf->\EOL lab\_\EOL prefix/separator/postfix} act like empty strings
that print nothing, and a \TT{NULL} value for \TT{lf} acts like
\TT{min::\EOL bracket\_\EOL lab\_\EOL format}.

\subsubsection{Printing Special General Values}
\label{PRINTING-SPECIAL-GENERAL-VALUES}

The format for printing special \TT{min::gen} values is:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{special\_format}}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::pstring                         special_prefix;|%
\ttmindex{special\_prefix}{in {\tt min::special\_format}}\ARGBREAK
    \verb|  min::pstring                         special_postfix;|%
\ttmindex{special\_postfix}{in {\tt min::special\_format}}\ARGBREAK
    \verb|  min::packed_vec_ptr<min::ustring>    special_names;|%
\ttmindex{special\_names}{in {\tt min::special\_format}}\ARGBREAK
    \verb|};|
\LABEL{MIN::SPECIAL_FORMAT}
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::special\_format
                   min::\MINKEY{name\_special\_format}:}\ARGBREAK
\verb|NULL                                     // special_prefix|\ARGBREAK
\verb|NULL                                     // special_postfix|\ARGBREAK
\verb|min::standard_special_names              // special_names|\ARGBREAK
\LABEL{MIN::NAME_SPECIAL_FORMAT}
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::special\_format
                   min::\MINKEY{bracket\_special\_format}:}\ARGBREAK
\verb|min::left_square_dollar_space_pstring    // special_prefix   "[$ "|\ARGBREAK
\verb|min::space_dollar_right_square_pstring   // special_postfix  " $]"|\ARGBREAK
\verb|min::standard_special_names              // special_names|\ARGBREAK
\LABEL{MIN::BRACKET_SPECIAL_FORMAT}
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{rl}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<min::ustring>
    min::\MINKEY{standard\_\EOL special\_\EOL names}}
\LABEL{MIN::STANDARD_SPECIAL_NAMES}\ARGBREAK
\verb|// Names of specials 0xFFFFFF - 0 .. 0xFFFFFF - 24 are:|\ARGBREAK
\verb|//     first 13 unused: name SPECIAL(0xFFFFF...)|\ARGBREAK
\verb|//     MULTI_VALUED ANY  NONE|\ARGBREAK
\verb|//     MISSING  DISABLED  ENABLED|\ARGBREAK
\verb|//     UNDEFINED  SUCCESS  FAILURE  ERROR|\ARGBREAK
\verb|//     LOGICAL_LINE INDENTED_PARAGRAPH|
\end{tabular}\end{indpar}

Given a special format \TT{sf},
a \TT{min::gen} special value \TT{v} is printed as its name surrounded
by \TT{lf->\EOL special\_\EOL prefix/\EOL postfix}.
Let
\begin{center}
\begin{tabular}{l}
\tt i = min::special\_index\_of ( v ) \\
\tt j = 0xFFFFFF - i
\end{tabular}
\end{center}
Here \TT{i} is the index of \TT{v} and \TT{0xFFFFFF} is the maximum possible
value of \TT{i}.
Then if \TT{sf->\EOL special\_\EOL names} is not \TT{min::\EOL NULL\_\EOL STUB},
and
\begin{center}
\tt 0 <= j < sf->special\_names->length
\end{center}
then \TT{sf->\EOL special\_\EOL names[j]} is the name of \TT{v}.

Otherwise
\TT{SPECIAL(}$i$\TT{)} is he name of \TT{v}, where $i$ is represented as
a 6-digit hexadecimal integer (e.g., \TT{0x000000}, \TT{0x000001},
\ldots, \TT{0xFFFFFF}).

\TT{NULL} values for
\TT{sf->\EOL lab\_\EOL prefix/postfix} act like empty strings
that print nothing, and a \TT{NULL} value for \TT{sf} acts like
\TT{min::\EOL bracket\_\EOL special\_\EOL format}.

WARNING: The \TT{special\_\EOL names} member of a \TT{min::special\_format} is
\underline{not} locatable by the ACC, and its value must therefore be
stored elsewhere in a locatable variable.  It is expected that values of
\TT{special\_\EOL names} will never be garbage collected and
will be pointed at by \TT{static min::\EOL locatable\_\EOL var} or
\TT{min::\EOL locatable\_\EOL gen} variables.

\subsubsection{Printing Other General Values}
\label{PRINTING-OTHER-GENERAL-VALUES}

Printing \TT{min::gen} values that are objects
uses the \TT{obj\_\EOL format} element of a
a \TT{min::\EOL gen\_\EOL format}.
The \TT{min::\EOL flush\_\EOL id\_\EOL map} printer operation uses
the \TT{id\_\EOL map\_\EOL gen\_\EOL format} element of
the printer's \TT{min::\EOL print\_\EOL format}
to print a general value, which is most often an object.
Printing objects is complex and
its discussion is deferred until \itemref{PRINTING-OBJECT-GENERAL-VALUES},
after the description of object general values.

The other kinds of general values are similar to special values but
with a different types and without names such as `\TT{MISSING}'.
They are printed in the same way as special values and given
names such as \TT{AUX(0x000000004)}.  They are also printed using
\TT{printer->\EOL print\_\EOL format.gen\_\EOL format->\EOL
special\_\EOL format.special\_\EOL prefix/\EOL postfix}
to surround the value name.


\subsubsection{Printing Using An Identifier Map}
\label{PRINTING-USING-AN-IDENTIFIER-MAP}

General values that have stubs, namely objects, packed structures and vectors,
and long strings, can be
output as an identifier of the form \TT{@}{\em <id>} by using
the printer \key{identifier map} (\itemref{IDENTIFIER-MAPS}).

The function to give a value \TT{v} an appropriate ID is:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{map\_id}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::MAP_ID} \\
\end{tabular}\end{indpar}

which executes (\pagref{MIN::MAP_OF_ID_MAP}):
\begin{indpar}
\verb|min::map ( printer->id_map, v| \\
\verb|           printer->print_format.id_map_gen_format )|
\end{indpar}

The function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_id}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::PRINT_ID} \\
\end{tabular}\end{indpar}

executes (\pagref{MIN::FIND_OR_ADD_OF_ID_MAP}):

\begin{indpar}\begin{verbatim}
    min::uns32 ID = min::find_or_add ( id_map, v );
    printer << "@" << ID;
\end{verbatim}\end{indpar}

It is used when an ID \underline{must} be printed
to represent an object but the object may not already have gotten
an ID.  In this case \TT{min::map} cannot be used because it may
create forward references to long strings, which cannot be handled
on input.

A printer's \TT{id\_map} member is initialized automatically when
needed.  However, it can also be set by:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::id_map min::|
    & \MINKEY{set\_\EOL id\_\EOL map\RESIZE}\ARGBREAK
    \verb|( <min::printer printer,|\ARGBREAK
    \verb|  min::id_map map = min::NULL_STUB )|
\LABEL{MIN::SET_ID_MAP_OF_PRINTER} \\
\end{tabular}\end{indpar}

which permits maps to be shared among printers.  If no second argument
is given, an identifier map is created for the printer if none previously
exists.  This can then be shared with other printers.  The final
\TT{id\_\EOL map} member of the printer is returned, and this
is never \TT{min::\EOL NULL\_\EOL STUB}.

When a value with a stub is printed as
`\TT{@}{\em <id>}', it is recorded in \TT{printer->\EOL id\_\EOL map}
so it may be printed on separate lines.  This may be done by
the printer operations:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::op min::| & \MINKEY{flush\_\EOL one\_\EOL id}
\LABEL{MIN::FLUSH_ONE_ID} \\
\verb|min::op min::| & \MINKEY{flush\_\EOL id\_\EOL map}
\LABEL{MIN::FLUSH_ID_MAP} \\
\end{tabular}\end{indpar}

The first operation prints the value at \TT{printer->\EOL id\_\EOL map[i]}
where \TT{i} equals \TT{printer->\EOL id\_\EOL map->\EOL next}, and then
increments \TT{printer->\EOL id\_\EOL map->\EOL next}.
However it does nothing if 
\TT{printer->\EOL id\_\EOL map->\EOL next} is initially beyond the
end of \TT{printer->\EOL id\_\EOL map[i]}.
The second operation
simply repeats the first operation as long as
\TT{printer->\EOL id\_\EOL map->\EOL next}
is less than \TT{printer->\EOL id\_\EOL map->\EOL length}.
The \TT{min::\EOL flush\_\EOL id\_\EOL map} operation is also
performed by the \TT{min::\EOL eom} end-of-message operation
if the print format
\TT{FLUSH\_\EOL ID\_\EOL MAP\_\EOL ON\_\EOL EOM} printer operation flag is on.

These \TT{id\_map} flushing operations use the \TT{min::gen\_\EOL format}:
\begin{center}
\TT{printer->\EOL print\_\EOL format.id\_\EOL map\_\EOL gen\_\EOL format}
\end{center}
to print the \TT{printer->id\_map[i]} {\em values} in lines of the form:
\begin{center}
\TT{@}{\em <id>} \TT{=} {\em value}
\end{center}

In the following functions,
if the \TT{gen\_format} argument is not given or \TT{NULL},
it defaults to
\begin{center}
\TT{printer->\EOL print\_\EOL format.id\_\EOL map\_\EOL gen\_\EOL format}
\end{center}
and if the \TT{id\_map} argument is not given or \TT{min::\EOL NULL\_\EOL STUB},
it defaults to \TT{printer->\EOL id\_\EOL map}.
Also in all these functions the `\TT{printer}' argument is returned as the
function value.

The functions

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_one\_id}
\LABEL{MIN::PRINT_ONE_ID}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\verb|min::printer min::| & \MINKEY{print\_id\_map}
\LABEL{MIN::PRINT_ID_MAP}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\end{tabular}\end{indpar}

are equivalent to \TT{printer <{}< min::flush\_one\_id}
and \TT{printer <{}< min::\EOL flush\_\EOL id\_\EOL map} respectively,
except an alternative \TT{id\_map} and \TT{gen\_\EOL format}
can be given.

The function

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_mapped\_id}
\LABEL{MIN::PRINT_MAPPED_ID}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::uns32 ID,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\end{tabular}\end{indpar}

prints \TT{id\_map[ID]} in a line of the form:
\begin{center}
\TT{@}{\em <ID>} \TT{=} {\em value}
\end{center}

The function

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_mapped}
\LABEL{MIN::PRINT_MAPPED}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\end{tabular}\end{indpar}

first executes

\begin{indpar}\begin{verbatim}
    min::map ( id_map, v, gen_format );
    min::uns32 ID = min::find_or_add ( id_map, v );
    min::print_id_map ( printer, id_map, gen_format );
\end{verbatim}\end{indpar}

Then if this has not printed a line of the form
`\TT{@}{\em <ID>} \TT{=} {\em value of \TT{v}}', it further
executes

\begin{indpar}\begin{verbatim}
    min::print_mapped_id ( printer, ID, id_map, gen_format );
\end{verbatim}\end{indpar}

\subsection{Objects}
\label{OBJECTS}

An \key{object} is conceptually a hash table that maps
\skey{attribute name}s to \skey{attribute value}s.
An attribute name is a sequence of name components, which
are numbers, strings, and labels.
The part of the hash table that maps attribute names that are equal to
or begin with small unsigned integers is actually a vector.
An attribute value is a \verb|min::gen| datum.

Each attribute name-value pair in an object map represents an
\ikey{arrow}{attribute} in the data base.
The \ikey{source}{of attribute arrow} of the arrow is the object
which is the map,
the \ikey{label}{of attribute arrow} of the arrow is the attribute name,
and the \ikey{destination}{of attribute arrow}
of the arrow is the attribute value.
Some arrows can be \skey{double arrow}s pointing
both to and from the arrow destination.
If the arrow is a double arrow,
a reverse direction label, called the \key{reverse attribute name}
is attached to the arrow, and the object at the destination end of the
arrow is the source of the reversed arrow, whose label is the
reverse attribute name and whose destination is the unreversed arrow's
source.

There can be several arrows with the same attribute name,
and even several arrows with both the same attribute name and the
same value.
There can be several double arrows with the same attribute name and
the same reverse attribute name, and even several double arrows with
the same names and destination object.

Therefore an attribute name and reverse attribute name together name a
multi-set of values, where the reverse attribute name can be missing to
indicate that only single arrows are to be considered, and is present to
indicate that only double arrows are to be considered.
For single arrows the values are any \verb|min::gen| values, but for
double arrows the values are always other objects.
It is possible to add a value to one of these multi-sets
or delete a value from a
multi-set.  It is possible to delete an entire multi-set.
It is possible to treat a multi-set as a set, by adding a value
to it only if the value does not already occur in the multi-set.
When testing for value equality, \TT{==} is normally used, as this tests for
equality of both name components and objects.

Flags, called \key{attribute flags}, can be attached to an attribute name.
Note that flags are attached to object attribute names, and not to arrows,
values, or reverse attribute names.

There are also graph typed objects, each of which is a pair of objects,
one called the graph type that is constant,
is shared among many graph typed objects,
and contains attribute labels and constant attribute values, and one called the
context, which contains a vector of \skey{variable}s that hold variable
attribute values.  Graph typed objects are described in more detail in
\itemref{GRAPH-TYPED-OBJECTS}.

\subsubsection{Object Bodies}
\label{OBJECT-BODIES}

An object has a body that consists of the following 6 parts in
the order given:

\begin{center}
\begin{tabular}{l}
header \\
variable vector \\
hash table \\
attribute vector \\
unused area\\
auxiliary area
\end{tabular}
\end{center}

The \mkey{header}{of object} contains object flags
(see Object Flags, \pagref{OBJECT-FLAGS-LIST}, for a complete list of
object flags)
and the sizes of the other 5 parts.
The \mkey{variable vector}{of object} stores the object's variables.
The \mkey{hash table}{of object}
stores attribute name/value pairs, for attributes whose names do not
begin with small unsigned integers.
The \mkey{attribute vector}{of object} stores attribute values
for attributes whose names begin with small unsigned integers.
The \mkey{auxiliary area}{of object}
stores elements of lists headed by hash table and attribute vector
elements, and any other data that would overflow a single
\TT{min::gen} value.
The \mkey{unused area}{of object}
provides for growth of the attribute vector and auxiliary area.

The variable vector and hash table are of fixed size;
their size can only be changed by resizing, reorganizing, and often relocating
the object body.  The attribute vector
grows up from the end of the hash table into the unused
area, and the auxiliary storage grows down from the end of the body into
the unused area.

A variable vector, hash table, and attribute vector element is accessed
using an index relative to the beginning of the vector or table that
contains the element.  Auxiliary area elements are accessed by
\skey{auxiliary pointer}s\label{OBJECT-BODY-AUXILIARY-POINTER}
that give the index of the element relative to the end of the
object body.  Auxiliary pointers with zero index do not address
a body vector element.
For more details see the \TT{var/\EOL hash/\EOL attr/\EOL aux}
functions on \pagref{MIN::VAR_OF_OBJ_VEC_PTR}, and their equivalents on
\pagref{OBJECT-VECTOR-EQUIVALENTS}.

An object may be grown or compacted by relocating and reorganizing its body.
It may be
grown to expand its unused area or hash table, or, less commonly,
its variable vector.  An object may be compacted to eliminate, or less
commonly to shrink, its unused area, and possibly to shrink its hash
table.

There are four kinds of objects: tiny, short, long, and huge.
These have respectively 4, 8, 16, and 32 byte headers, and are capable
of storing information for successively larger objects.
There is no essential difference between these headers and their
internal structure is not visible.  There is no practical limit on
the size of an object%
\footnote{Currently the maximum virtual address space size is $2^{48}$ bytes.}.

An object body may be \smkey{relocate}d{object body}, which means the
body is simply copied to a new address, or
\smkey{reorganize}d{object body}, which means the object body is reformatted,
and possibly converted from one header size to another.  Frequently an
object whose attribute labels and number of values for each label are no
longer subject to change will be compacted, to make it as small as possible,
and this is one kind of object body reorganization.
Objects are compacted by the `\TT{min::\EOL publish\REORG}'
function that sets the
object \TT{OBJ\_\EOL PUBLIC} flag\label{OBJ_PUBLIC}
which prevents changes to the
attribute labels, attribute label flags, and number of attribute values
of an object.
Reorganization can also occur whenever an object is relocated by the
compactor, provided that the \TT{OBJ\_\EOL PRIVATE} and
\TT{OBJ\_\EOL PUBLIC} object flags are not set.

The data structure of an object body can be viewed at any of three levels:
vector level (\itemref{OBJECT-VECTOR-LEVEL}),
list level (\itemref{OBJECT-LIST-LEVEL}),
and attribute level (\itemref{OBJECT-ATTRIBUTE-LEVEL}).
The interfaces to all of these levels is protected.  In addition
there is an unprotected vector level interface
(\itemref{OBJECT-UNPROTECTED-VECTOR-LEVEL}) and a
graph typed object interface (\itemref{GRAPH-TYPED-OBJECTS}).

\subsubsection{Object Creation}
\label{OBJECT-CREATION}

An object can be created by the protected function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}\ARGBREAK
    \verb|( min::unsptr unused_size,|\ARGBREAK
    \verb|  min::unsptr hash_size = 0,|\ARGBREAK
    \verb|  min::unsptr variable_size = 0,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::NEW_OBJ_GEN} \\
\end{tabular}\end{indpar}

The new object has a zero length attribute vector, but this can be
expanded by growing the attribute vector upward into the unused area.
Similarly the auxiliary area is zero length, but can be expanded by
growing downward into the unused area.

The sizes of parts of an object may be changed after the object has
been created by the object maintenance functions
described in Section~\itemref{OBJECT-MAINTENANCE-FUNCTIONS}.

Allocators often maintain sets of free memory blocks of particular
sizes, often powers of two, and allocate new object bodies to one
of these blocks.  In such a case the block may be larger than the
requested body size.  If the `\TT{expand}' argument is \TT{true},
\TT{min::\EOL new\_\EOL obj\_\EOL gen} will round the unused area
size of the new object up so that the new object body fills the
free block to which it is allocated.

On the flip side, the compactor part of the
allocator/\EOL collector/\EOL compactor
may reduce the size of the unused
area.  For an object that has been around a long enough time, the
compactor may eliminate the unused area completely, and may reorganize
the object to downsize its hash table and compact its auxiliary area.

The hash table of the returned object is filled with \TT{min::LIST\_END()}
values (\pagref{MIN::LIST_END}), and is therefore an empty hash table.
The variable vector is filled with \TT{min::UNDEFINED()} values.
Unused area elements are initialized to some implementation defined
value like \TT{0}.
The attribute vector and auxiliary areas of the returned object are
zero length, and all space not used by the header, hash table, and
variable vector is allocated to the unused area.
The attribute vector and auxiliary area can be
filled by `push' instructions described below
(\pagref{OBJECT_PUSH_FUNCTIONS}).

A \TT{min::gen} value may be tested to see if it points at an
object by the function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_obj} \verb|( min::gen v )|
\LABEL{MIN::IS_OBJ} \\
\end{tabular}\end{indpar}

The \TT{min::type\_of} function (\pagref{MIN::TYPE_OF_GEN})
applied to an object returns one of the following:

\begin{center}
\begin{tabular}{l}
\minkey{TINY\_OBJ}\LABEL{MIN::TINY_OBJ} \\
\minkey{SHORT\_OBJ}\LABEL{MIN::SHORT_OBJ} \\
\minkey{LONG\_OBJ}\LABEL{MIN::LONG_OBJ} \\
\minkey{HUGE\_OBJ}\LABEL{MIN::HUGE_OBJ} \\
\end{tabular}
\end{center}

\subsubsection{Object Maintenance Functions}
\label{OBJECT-MAINTENANCE-FUNCTIONS}

Object maintenance functions are used to change the sizes of
object components and compact objects.  The most basic of
these functions do nothing but change the size of the unused
area and variable area:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND} \\
\end{tabular}\end{indpar}

The 4-argument \TT{min::resize} function can change
the size of both the variables vector and unused area at the same
time.  The object body is reallocated, and the function's
`\TT{expand}' argument, if `\TT{true}', will increase
the size of the requested unused area until the object fills
the actual allocated block.  This is useful because allocators
typically allocate blocks whose size is a power of two or
a bit less, so if the requested size is not just right, some
memory will be wasted.

The 2-argument \TT{min::resize} function and the \TT{min::\EOL expand}
function are both equivalent to \TT{min::\EOL resize} with no change
in variables vector size.  The 2-argument \TT{min::\EOL resize}
has implied \TT{false} `\TT{expand}' argument, and the
\TT{min::\EOL expand} function has implied \TT{true} `\TT{expand}'
argument.

The \TT{min::expand} function is the one implicitly used when an object simply
needs more memory for its attribute vector or auxiliary area to grow into.
In this case the argument is just the memory required, and extra unused
area is allocated to fill the next real allocated size block.  Repeated
uses of \TT{min::expand} on the same object will more or less keep
doubling the actual size of the object.

The \TT{min::resize} and \TT{min::expand} functions with object arguments
are called `\skey{resizing function}s'\label{RESIZING-FUNCTIONS}
because they change the size of the object.  They also change
the offset of some elements within the object, and usually
relocate the object.
The names of such functions are marked with the subscript
\subsmkey{S}{of function}.  A resizing function is also
a relocating function (\pagref{RELOCATING-FUNCTIONS}).

The remaining maintenance functions assume objects are organized
as per Section~\itemref{OBJECT-LIST-LEVEL}, Object List Level.
These functions all \ikey{reorganize}{object}
an object so it has no discontinuities
in its lists, and therefore no unnecessary invisible jumps (auxiliary
list pointers, actually) within its lists, and makes no use of
auxiliary stubs (\itemref{OBJECT-AUXILIARY-STUBS}).  So in this
sense these functions clean up and compactify the object.  Object
reorganization involves changing auxiliary pointers in the object and
changing the locations of list elements in the object auxiliary area.
It also involves resizing the object.

A function that changes the size of an object hash table further
assumes that hash table elements are {\em attribute/node-name-descriptor-pairs}
as per Section~\itemref{OBJECT-ATTRIBUTE-LEVEL}, Object Attribute Level.
More specifically, it is assumed just that hash table entries are lists
whose elements are grouped into pairs and the first element of each
pair is a hashable \TT{min::gen} value such that if the hash of this
element is $H$, then the pair is put into the list of the $H$\TT{\%}$S+1$'st
hash table element, where $S$ is the size of the hash table.

With all this in mind, the following function can be used to
reorganize and object and change the sizes of its variable vector, hash table,
and unused area.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE} \\
\end{tabular}\end{indpar}

The `\TT{expand}' argument to this function works to increase the
size of the unused area in the same was as the
the `\TT{expand}' argument to the \TT{min::resize} function above.
If the hash table size is not actually changed, the Object Attribute Level
assumptions made above do not apply, but the Object List Level assumptions
do apply to all object reorganizations.

After all an object's attributes have been set, the number of
{\em attribute/node-name-descriptor-pairs} in the object hash table
will cease to change, and the hash table size an be optimized
to about twice this number.  The following functions use this idea:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE} \\
\verb|void min::| & \MINKEY{compact\REORG}
    \verb|( min::gen object )| \\
\LABEL{MIN::COMPACT} \\
\verb|void min::| & \MINKEY{publish\REORG}
    \verb|( min::gen object )|
\LABEL{MIN::PUBLISH} \\
\end{tabular}\end{indpar}

These functions are like the \TT{min::reorganize} function
but they pick the size of the hash table automatically as
follows.  If $N$ is the number of
{\em attribute/node-name-descriptor-pairs} in the hash table
and $S$ is the size of the hash table, the hash table size
is left unchanged if $2N/3\leq S\leq 3N$.  Otherwise the
hash table size is reset to $2N$.

The 1-argument \TT{min::compact} function does not change the
size of the variables vector and forces the unused area size
to be zero.  Its goal is to compact the object under the assumption
the object will not change any of its sizes in the future.

The \TT{min::publish} function just executes a
1-argument {min::compact} function and then sets
the object \TT{OBJ\_\EOL PUBLIC} flag which prevents further changes to the
to the object sizes or organization (but not to attribute values).

The \TT{min::reorganize}, \TT{min::compact}, and \TT{min::\EOL publish}
functions with object arguments
are called `\skey{reorganizing function}s'\label{REORGANIZING-FUNCTIONS},
because they move elements around inside the object.
The names of such functions are marked with the subscript
\subsmkey{O}{of function}.
A reorganizing function is also a resizing function
(\pagref{RESIZING-FUNCTIONS}) and
a relocating function (\pagref{RELOCATING-FUNCTIONS}).

It is sometimes useful to discover the values of an object's
\TT{OBJ\_\EOL PRIVATE} and \TT{OBJ\_\EOL PUBLIC} flags.
This can be done by the functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{private\_flag\_of}
    \verb|( min::gen object )| \\
\LABEL{MIN::PRIVATE_FLAG_OF} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}
    \verb|( min::gen object )| \\
\LABEL{MIN::PUBLIC_FLAG_OF} \\
\end{tabular}\end{indpar}

All of the above maintenance functions except the last two
flag reading functions work by creating
vector pointers and using versions of the functions in which the
\TT{min::gen} object argument is replaced by a vector pointer argument.
The functions that actually change the object use a
\TT{min::\EOL obj\_\EOL vec\_\EOL insptr} insertable object
vector pointer and therefore will not work if the object's
\TT{min::\EOL OBJ\_\EOL PUBLIC} flag as already been set.

If you want to build your own compactification function implementing
a different algorithm for choosing hash table size, you may use
the vector pointer version of \TT{min::reorganize}
(\pagref{MIN::REORGANIZE_OBJ_VEC_INSPTR}) and the following:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{hash\_count\_of}
    \verb|( min::obj_vec_ptr & vp )| \\
\LABEL{MIN::HASH_COUNT_OF} \\
\verb|void min::| & \MINKEY{set\_public\_flag\_of}
    \verb|( min::obj_vec_insptr & vp )| \\
\LABEL{MIN::SET_PUBLIC_FLAG_OF} \\
\end{tabular}\end{indpar}

The \TT{min::hash\_count\_of} function just returns the number of
{\em attribute/node-name-descrip\-tor-pairs} in the object's hash table,
and the \TT{min::\EOL set\_\EOL publish\_\EOL flag} function just sets
the object's \TT{min::\EOL OBJ\_\EOL PUBLIC} flag.

\subsubsection{Object Copy Functions}
\label{OBJECT-COPY-FUNCTIONS}

The following functions are like the \TT{min::\EOL resize} functions on
\pagref{MIN::RESIZE} except that instead of resizing the object specified
by their argument, they make a new resized object which they return:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COPY} \\
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::COPY_UNUSED} \\
\end{tabular}\end{indpar}

The new object is \underline{not} public even if the original
object is.  The second 2-argument form of \TT{min::\EOL copy}
always expands the unused area to fit the space actually allocated
to the new object.

Alternative forms of these functions take object
vector pointers (see \itemref{PROTECTED-OBJECT-VECTOR-POINTERS}):

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COPY_VEC_PTR} \\
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::COPY_UNUSED_VEC_PTR} \\
\end{tabular}\end{indpar}


\subsubsection{Object Vector Level}
\label{OBJECT-VECTOR-LEVEL}

At the \key{vector level}, the object body is viewed as
a \key{body vector} of \TT{min::gen} values.
The entire body vector, except
for the header, consists of \TT{min::gen} elements of the
body vector.
A \key{body vector index} is an index of an element in this vector,
and ranges from 0
to one less than the total size of the object,
which is the size of the body vector in \TT{min::\EOL gen} units.
The index 0 cannot be used, as it corresponds to the
header, which does not contain \TT{min::gen} values.
0 can be used as a form of null pointer.

An auxiliary pointer index \TT{i} corresponds to the
body vector index total size \TT{- i}, so \TT{i=1} corresponds
to the last element of the auxiliary area.
The 0 auxiliary pointer index corresponds to the location just
beyond the body vector and is not
usable as the index of an auxiliary area element, so it
can also be used as a form of null pointer.  By indexing auxiliary
area elements in this way, the unused area size can be changed without
changing any auxiliary pointers.

There are three kinds of vector level protected object pointers.
A read-only \TT{min::\EOL obj\_\EOL vec\_\EOL ptr} pointer
permits read-only access to body
vector elements.
A read-write or updatable
\TT{min::\EOL obj\_\EOL vec\_\EOL updptr} pointer
permits read-write access to body vector elements,
but does not permit pushing or popping elements from the
object's attribute vector or auxiliary area.
An insertable \TT{min::\EOL obj\_\EOL vec\_\EOL insptr} pointer
does permit these pushes and pops, in addition to permitting
read-write access to body vector elements.

An object has two flags that regulate the creation of vector level
pointers: \minkey{OBJ\_PRIVATE}\label{MIN::OBJ_PRIVATE}
and
\minkey{OBJ\_PUBLIC}\label{MIN::OBJ_PUBLIC}.
If an object has neither of these flags, an object vector pointer
to the object may be created, and this will set the \TT{min::OBJ\_PRIVATE}
flag.  When the object vector pointer is destructed, this flag will be cleared.
While this flag is set, no other vector pointer to the object may be
created.  The object is therefore private to the code possessing the
vector pointer.

If an object has neither flag, its \TT{min::OBJ\_PUBLIC} flag may be set
by calling the \TT{min::\EOL publish\REORG} function
(\pagref{MIN::PUBLISH}).
When this is set, any number of read-only and read-write (updatable) vector
pointers to the object may be created, but no insertable vector pointers
to the object may be created.  Constructing and destructing
pointers in this case does not set or clear object flags.
The \TT{min::OBJ\_PUBLIC} flag may not be cleared by
protected functions.  The idea here is that setting the \TT{min::OBJ\_PUBLIC}
flag fixes the attribute label structure of the object, the flags attached
to attribute labels, and the size of
the value multiset of each attribute, but permits the existing values of an
attribute to be read or written.  This permits read-only
sharing of the object and read-write sharing of attribute values of the
object, but does not permit attribute values to be added to or deleted
from the object.

An object with its \TT{min::OBJ\_PUBLIC} flag set is said to be a
\ikey{public}{object} object.

Note that object bodies can be relocated whenever a
relocating function (\pagref{RELOCATING-FUNCTIONS}) is called.
However object bodies may be reorganized by a relocating
function only if neither the
\TT{min::OBJ\_PRIVATE} nor the \TT{min::OBJ\_PUBLIC} flags are set.
Object bodies may also be reorganization when insertions are made
using the \TT{min::\EOL insert\_\EOL reserve\RESIZE} function
(\pagref{MIN::INSERT_RESERVE}) on an insertable pointer,
and object bodies are usually reorganized
when the \TT{min::\EOL OBJ\_\EOL PUBLIC} flag is set on an object
by the \TT{min::\EOL publish\REORG} function
(\pagref{MIN::PUBLISH}).

\subsubsubsection{Protected Object Vector Pointers}
\label{PROTECTED-OBJECT-VECTOR-POINTERS}

An \key{object vector pointer} points at the stub of an object
and caches information derived from the header of the object,
so that the differences between different sized object headers are
hidden.  A non-public object can have at most one object vector
pointer pointing at it.  A public object can have any number of
read-only or read-write (update) object vector pointers pointing
at it, but may not change the sizes of its various parts
(like the attribute vector or auxiliary area), so that the
information cached in the object vector pointers never changes.

A \minkey{obj\_\EOL vec\_\EOL ptr} read-only object vector pointer
may be created and set by the following functions:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}\verb| vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}%
       \verb| vp ( void )|
\LABEL{MIN::OBJ_VEC_PTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_MIN_STUB} \\
	& \TTOMKEY{bool}{bool}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_BOOL} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_GEN} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_STUB} \\
\end{tabular}\end{indpar}

Here if \TT{v} or \TT{s} do not point at the stub of an object
the new object vector pointer is set to \TT{min::\EOL NULL\_\EOL STUB},
which gives undefined results, but usually a memory fault, if
used to access the parts of a object.
The case where \TT{s} equals \TT{min::\EOL NULL\_\EOL STUB}
also sets the object vector pointer to \TT{min::\EOL NULL\_\EOL STUB},
as does the no-argument object vector pointer constructor.
An \TT{=} operator
sets an object vector pointer just as if the pointer
had just been constructed by a constructor whose argument
was the right-side argument of the \TT{=} operator.

Because an object vector pointer can be converted to a
\TT{const min::\EOL stub~*} value, it is possible to check whether
an object vector pointer equals \TT{min::\EOL NULL\_\EOL STUB}
by using the \TT{==} function.  It is also possible to set one
vector pointer from another, as the latter will be converted to a
\TT{const min::\EOL stub~*} value, but note that the object
must be public in order for more than one object vector pointer to
point at it.

The conversion of a vector pointer to a \TT{bool} returns \TT{true}
iff the vector pointer stub is \underline{not} \TT{min::\EOL NULL\_\EOL STUB}.

Unlike label, packed structure, or packed vector pointers,
object vector pointers cache information about the object, and must always
be writable, and never \TT{const}.

The following protected functions may be used to discover information
about the object pointed at by a read-only \TT{min::obj\_vec\_ptr}:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr min::| & \MINKEY{var\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::VAR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::AUX_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}\label{OBJECT_SIZE_FUNCTIONS}

Here the sizes are in \TT{min::gen} units.  When an object
body is reorganized, some of these sizes may change, but simply
relocating the object body does not change these sizes.  The
automatic resizing of the object that may occur when new elements
are pushed into the attribute vector or auxiliary area only changes
the unused and total sizes.

The following functions can be used for \underline{read-only}
access to object elements:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|const min::gen & | & \MINKEY{var}
     \verb|( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_PTR} \\
\verb|const min::gen & | & \MINKEY{hash}
     \verb|( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_PTR} \\
\verb|const min::gen & | & \MINKEY{attr}
     \verb|( min::obj_vec_ptr & vp, min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_PTR} \\
\verb|const min::gen & | & \MINKEY{aux}
     \verb|( min::obj_vec_ptr & vp, min::unsptr aux_ptr )|
\LABEL{MIN::AUX_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

Given a vector pointer \TT{vp}, \TT{min::var(vp,i)} can be used
to read the \TT{i+1}'st variable in the object pointed at
by \TT{vp}, for $0\leq i<\mbox{\TT{min::var\_size\_of(vp)}}$.
Similarly, \TT{min::hash(vp,i)} can be used
to read the \TT{i+1}'st hash table entry
for $0\leq i<\mbox{\TT{min::hash\_size\_of(vp)}}$,
\TT{min::attr(vp,i)} can be used
to read the \TT{i+1}'st attribute vector entry
for $0\leq i<\mbox{\TT{min::attr\_size\_of(vp)}}$.
\TT{min::aux(vp,p)} differs slightly in that it reads
the \TT{i}'th auxiliary area element ordering the
elements from the end of the auxiliary area to its beginning,
for $1\leq i\leq\mbox{\TT{min::attr\_size\_of(vp)}}$.
Auxiliary area indices are defined in this manner
so that an object body may be resized by simply
expanding or contracting its unused area, without modifying
the contents of the other parts of the object body.

The operations

\begin{indpar}[0.2in]\begin{tabular}{r@{}l@{\hspace*{1.2in}}l}
\verb|const min::gen & |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj\_vec\_ptr}}
	& [same as \TT{min::attr}]\\&
	  \multicolumn{2}{l}{~(~min::obj\_vec\_ptr const \& vp,}\\&
	  \multicolumn{2}{l}{~~~min::unsptr index )}
\LABEL{MIN::[]_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{size\_of}
	& [same as \TT{min::attr\_size\_of}]\\&
          \multicolumn{2}{l}{~( min::obj\_vec\_ptr \& vp )}
\LABEL{MIN::SIZE_OF_OBJ_VEC_PTR}
\end{tabular}\end{indpar}

are can be used as alternatives that make the attribute
vector part of an object look like a simple vector.

Note that addresses such as \TT{\&min::\EOL var(vp,i)} and
\TT{\&vp[i]} are relocatable addresses, and as such should only
be passed to a non-relocating function like \TT{memcpy},
and never saved in a local variable.
Both \TT{vp[i]} and \TT{min::\EOL attr(vp,i)} include a 
\TT{MIN\_\EOL ASSERT} check that
$0\leq i<\mbox{\TT{min::\EOL attr\_\EOL size\_\EOL of(vp)}}$.

Also in this vein, the operations

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<const min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINMKEY{begin\_ptr\_of}{of {\tt obj\_vec\_ptr}}
      \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINMKEY{end\_ptr\_of}{of {\tt obj\_vec\_ptr}}
      \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_PTR} \\
\end{tabular}\end{indpar}

can be used to return \TT{min::ptr<const min::gen>} pointers
to elements of the attribute vector.  \TT{vp + i} returns a
pointer to the \TT{i}+1'st element, and includes a
\TT{MIN\_\EOL ASSERT} check that \TT{i} is less than the
size of the attribute vector.  The \TT{min::\EOL begin\_\EOL ptr\_\EOL of}
and \TT{min::\EOL end\_\EOL ptr\_\EOL of} functions are the same as
\TT{vp + 0} and \TT{vp + min::\EOL size\_\EOL of(vp)} but do
not include this \TT{MIN\_\EOL ASSERT} check, so that, for
example, \TT{min::\EOL begin\_\EOL ptr\_\EOL of} can be used when
the attribute vector has zero length.

A \minkey{obj\_vec\_updptr} read-write (update) object vector
pointer is like a \TT{min::\EOL obj\_\EOL vec\_\EOL ptr}
read-only object vector pointer,
but has element access functions that have been modified
to permit writing elements.  Its functions are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}
    \verb|vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}
    \verb|vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_updptr}
    \verb|vp ( void )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_updptr}}\ARGBREAK
          \verb|( min::obj_vec_updptr const & vp )|
\LABEL{MIN::OBJ_VEC_UPDPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::ref<min::gen> | & \MINKEY{var}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{hash}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{attr}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{aux}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::AUX_OF_OBJ_VEC_UPDPTR} \\

\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ref<min::gen> |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::[]_OF_OBJ_VEC_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINMKEY{begin\_ptr\_of}{of {\tt obj\_vec\_updptr}}
      \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINMKEY{end\_ptr\_of}{of {\tt obj\_vec\_updptr}}
       \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_UPDPTR} \\
\end{tabular}\end{indpar}

Updatable pointer read-write element access
functions return either \TT{min::\EOL ref<min::gen>}%
\label{OBJ_VEC_UPDPTR_REF}
or \TT{min::\EOL ptr<min::gen>} values while read-only pointer
element access functions return
`\TT{const min::\EOL gen~\&}' or
\TT{min::\EOL ptr<const min::gen>} values.

A \TT{min::\EOL obj\_\EOL vec\_\EOL updptr} read-write pointer
may be automatically
downcast to a \TT{min::\EOL obj\_\EOL vec\_\EOL ptr} read-only pointer.
This means that
the non-constructor functions not redefined above that are applicable to
\TT{min::\EOL obj\_\EOL vec\_\EOL ptr}'s are applicable to
\TT{min::\EOL obj\_\EOL vec\_\EOL updptr}'s.

A \minkey{obj\_vec\_insptr} insertable object vector pointer is like a
\TT{min::obj\_\EOL vec\_\EOL updptr} read-write object vector pointer
but has additional functions which support pushing or popping elements
from the end of the object body attribute vector or the beginning
of the object body auxiliary area and resizing the unused area and
variable vector portions of the object body.
A \minkey{obj\_vec\_insptr} point may not point at a public
object (\pagref{MIN::PUBLISH}).
The additional functions for this type of pointer are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK
    \verb|( min::gen v )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK
    \verb|( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_insptr} \verb|vp|\ARGBREAK
    \verb|( void )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_insptr}}\ARGBREAK
          \verb|( min::obj_vec_insptr const & vp )|
\LABEL{MIN::OBJ_VEC_INSPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_GEN} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::ref<min::gen> min::| & \MINKEY{attr\_push}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_PUSH_OF_VEC_INSPTR} \\
\verb|void min::ref<min::gen> min::| & \MINKEY{aux\_push}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_PUSH_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}\label{OBJECT_PUSH_FUNCTIONS}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, const min::gen * p = NULL )|
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, const min::gen * p = NULL )|
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_POP_OF_VEC_INSPTR} \\
\verb|min::gen min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_POP_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::AUX_POP_MULTIPLE_OF_VEC_INSPTR} \\
\end{tabular}\end{indpar}

The push functions push values to the end of the attribute vector
and the beginning of the unused area.  The pop functions pop values
from the end of the attribute vector and the beginning of the unused
area.

There are two versions of each push or pop: one that
returns either a \TT{min::\EOL ref<min::gen>} reference to
a single \TT{min::gen} value,%
\label{OBJ_VEC_INSPTR_PUSH_REF}
and one that handles
\TT{n} values stored in a C/C++ vector pointed at by \TT{p}.
These latter push and pop functions preserve the order of the values in memory,
so \TT{p[0]} is pushed into or popped from a body vector location immediately
before the location into which \TT{p[1]} is pushed into or popped from, etc.
Thus the attribute vector push function pushes
in the order \TT{p[0]}, \TT{p[1]}, \TT{p[2]}, \ldots; while the
auxiliary vector push function pushes
in the order \TT{p[n-1]}, \TT{p[n-2]}, \TT{p[n-3]}, \ldots.
The order of the elements of \TT{p} in memory is the same
as the order of the elements in the object body.

If the push functions are called with argument \TT{p = NULL},
they set the elements pushed to zero.
If the pop functions are called with argument \TT{p = NULL},
they discard the values of the popped elements.

If the push functions are called when the unused
area size is smaller by $k$ elements
than the number of \TT{min::gen} values being pushed, these
functions call the \TT{min::\EOL expand} function (see below)
to add $k$ elements to the unused area before the push is executed.

A \TT{min::\EOL obj\_\EOL vec\_\EOL insptr} may be automatically
downcast to either a \TT{min::\EOL obj\_\EOL vec\_\EOL updptr}
or a \TT{min::\EOL obj\_\EOL vec\_\EOL ptr}.  This means that
all the non-constructor functions applicable to
\TT{min::\EOL obj\_\EOL vec\_\EOL updptr}'s or
\TT{min::\EOL obj\_\EOL vec\_\EOL ptr}'s are also applicable to
\TT{min::\EOL obj\_\EOL vec\_\EOL insptr}'s.

\subsubsubsection{Vector Level Object Maintenance}
\label{VECTOR-LEVEL-OBJECT-MAINTENANCE}

The object maintenance functions of
Section~\itemref{OBJECT-MAINTENANCE-FUNCTIONS}
which operate on \TT{min::\EOL gen} values have counterparts
that operate on object vector pointers.  These last are merely listed
here, and are as described in the section
just mentioned, with the exception that
the two functions that set the \TT{min::\EOL PUBLIC} flag,
\TT{min::\EOL set\_\EOL public\_\EOL flag\_\EOL of} and
\TT{min::\EOL publish}, end by setting the insertable object vector pointer
they use to \TT{min::\EOL NULL\_\EOL STUB}, as an insertable object vector
pointer is not allowed to point at a public object.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}


\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::COMPACT_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{publish\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::PUBLISH_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}


\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{private\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PRIVATE_FLAG_OF_OBJ_VEC_PTR} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PUBLIC_FLAG_OF_OBJ_VEC_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{hash\_count\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_COUNT_OF_OBJ_VEC_PTR} \\
\verb|void min::| & \MINKEY{set\_public\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::SET_PUBLIC_FLAG_OF_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}

\subsubsubsection{Unprotected Object Vector Level}
\label{OBJECT-UNPROTECTED-VECTOR-LEVEL}

Using unprotected functions, an object body can be treated
as a simple C/C++ vector of \TT{min::gen} values.  The
required functions are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|const min::gen * & MUP::| & \MUPKEY{base}
    \verb|( min::obj_vec_ptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_PTR} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}
    \verb|( min::obj_vec_updptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_UPDPTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::stub * MUP::| & \MUPKEY{stub\_of} \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::STUB_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::VAR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_OBJ_VEC_PTR} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_INSPTR} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_INSPTR} \\

\end{tabular}\end{indpar}

The offset values returned by the above are those of the
variable vector(\TT{var}), hash table(\TT{hash}),
attribute vector(\TT{attr}), unused area (\TT{unused}), 
and auxiliary area(\TT{aux}).  These offsets are in \TT{min::gen}
units, and these offsets and the sizes returned by the functions
on page \pagref{OBJECT_SIZE_FUNCTIONS} are related by

\begin{center}
\begin{tabular}{rcl}
variable vector offset	& = & header size \\
hash table offset       & = & variable vector offset + variable vector size \\
attribute vector offset & = & hash table offset + hash table size \\
unused area offset      & = & attribute vector offset + attribute vector size \\
auxiliary area offset   & = & unused area offset + unused area size \\
total size              & = & auxiliary area offset + auxiliary area size \\
\end{tabular}
\end{center}

Note that when an object is reorganized all these values may
change, including the header size.

Note that the \TT{min::\EOL unused\_\EOL offset\_\EOL of} and
\TT{min::\EOL aux\_\EOL offset\_\EOL of} functions for a
\TT{min::\EOL obj\_\EOL vec\_\EOL insptr} return an
lvalue.  For insertable pointers these offsets change when
values are pushed into or popped from the attribute vector or
auxiliary area.  Using these unprotected functions it is possible
to write your own push and pop functions.  The offset lvalues
actually reference cache locations in the
\TT{min::\EOL obj\_\EOL vec\_\EOL insptr} which are copied
back into the object when the 
\TT{min::\EOL obj\_\EOL vec\_\EOL insptr} is destructed.

The following are equivalences except for
the omission of \TT{MIN\_\EOL ASSERT} checks that the index \TT{i}
is not too large or too small (auxiliary area indices may not be 0),
calls to \TT{min::\EOL expand} when the unused area is too small
for a push, \TT{MIN\_\EOL ASSERT} checks that elements to be popped
actually exist,
conversions to \TT{min::ref<min::gen>}
values for appropriate element access functions, and
calls to \TT{MUP::\EOL acc\_\EOL write\_\EOL update}
for push operations
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}):

\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|var ( vp, i )| & $\equiv$
    & \verb|return base(vp)[var_offset_of(vp) + i]| \\
\verb|hash ( vp, i )| & $\equiv$
    & \verb|return base(vp)[hash_offset_of(vp) + i]| \\
\verb|attr ( vp, i )| & $\equiv$
    & \verb|return base(vp)[attr_offset_of(vp) + i]| \\
\verb|aux ( vp, i )| & $\equiv$
    & \verb|return base(vp)[total_size_of(vp) - i]| \\
\end{tabular}\end{indpar}\label{OBJECT-VECTOR-EQUIVALENTS}
\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|attr_push ( vp ) = v| & $\equiv$
    & \verb|base(vp)[unused_offset_of(vp)++] = v| \\
\verb|v = attr_pop ( vp )| & $\equiv$
    & \verb|v = base(vp)[--unused_offset_of(vp)]| \\
\verb|aux_push ( vp ) = v| & $\equiv$
    & \verb|base(vp)[--aux_offset_of(vp)] = v| \\
\verb|v = aux_pop ( vp )| & $\equiv$
    & \verb|v = base(vp)[aux_offset_of(vp)++]| \\
\end{tabular}\end{indpar}



The header is the only part of an object body that is
\underline{not} \TT{min::gen} values.  Even so it is
sized in \TT{min::gen} units; e.g., a short object header size
is \TT{2} for a compact implementation and \TT{1}
for a loose implementation (\pagref{COMPACT-OR-LOOSE}).

The header may contain implementation dependent information used
for optimization.
For example, objects which have auxiliary stubs
(\pagref{OBJECT-AUXILIARY-STUBS})
may be flagged, thereby identifying objects that need extra work
when deallocated or reorganized.

\subsubsection{Object List Level}
\label{OBJECT-LIST-LEVEL}

At the \key{list level},\label{LIST-LEVEL}
the body consists of two vectors whose
elements are lists.  The two vectors are the hash table, and the
attribute vector (the variable vector is ignored).
The elements of the lists are
\TT{min::gen} values other than the list or sublist auxiliary
pointers, and sublists.  The lists are constructed with
the help of the list and sublist auxiliary pointers:

\begin{center}
\begin{tabular}{lp{3in}}
\key{list auxiliary pointer} &
The list is \underline{continued} at the target of the list auxiliary pointer.
\\[2ex]
\key{sublist auxiliary pointer}	&
A sublist \underline{starts} at the target of the sublist auxiliary pointer.
\end{tabular}
\end{center}

Lists also make use of two constant values:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::gen min::}\MINKEY{LIST\_END()}]~\LABEL{MIN::LIST_END}\\
The list ends here.
This actually equals a list auxiliary pointer with zero index.
\item[{\tt const min::gen min::}\MINKEY{EMPTY\_SUBLIST()}]~%
	\LABEL{MIN::EMPTY_SUBLIST}\\
A list element value that represents an empty sublist.
This actually equals a sublist auxiliary pointer with zero index.
\end{list}
\end{indpar}

Each hash table or attribute vector element is a \key{list head}.
Each list head is a \key{list continuation}, which is an element of the
body vector that has a particular interpretation, described below.
However, not all list continuations are list heads.

A list continuation represents a final segment of a list.
If it has the value \TT{min::LIST\_END()}, the final segment is empty.
If the list continuation has a list auxiliary pointer value,
that pointer points at another list continuation that continues the list.
Otherwise the list continuation represents an element of the list,
and is called a \key{list element}.

A list element is an element of the list, and cannot be a list auxiliary
pointer or the special value \TT{min::LIST\_END()}.  But it can be
a sublist auxiliary pointer, or the special value \TT{min::EMPTY\_SUBLIST()},
both of which denote a list element that is a sublist.

Given a list element, the rest of the list after the element begins with
a list continuation that has an index one less than that of the list
element within the object body vector, unless the list element is a
list head, in which case there is no next element, and the list has only
one element.  All list heads lie in the hash table or attribute vector,
so testing whether a list element is a list head can be done if just the
index of the list element in the body vector is known.
As a consequence of all this,
zero and one element lists with heads in the hash table
or attribute vector are represented by either \TT{min::\EOL LIST\_\EOL END()}
or by the single list element, stored in the hash table or attribute
vector entry, without any part of the list being stored in the
auxiliary area.

A list element
that is a sublist auxiliary pointer or the value \TT{min::EMPTY\_SUBLIST()}
represents a sublist, and is the \key{sublist head} of that sublist.  A
sublist head is a list element of the list containing a sublist,
but cannot be a list element of the sublist.
If it is a sublist auxiliary pointer,
it points at a list continuation of the sublist.  If it is the
value \TT{min::EMPTY\_SUBLIST()}, it represents an empty sublist.

There are several rules that the list level obeys that lead to
some efficiencies:

\begin{indpar}
{\bf No Superfluous \TT{\bf min::LIST\_END()}'s}.%
\index{superfluous LIST_END()@superfluous \TT{LIST\_END()}}%
\label{NO-SUPERFLUOUS-LIST}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a \TT{min::LIST\_END()} value.

{\bf No Superfluous List Auxiliary Pointers}.%
\index{superfluous list!auxiliary pointers}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a list auxiliary pointer.

{\bf No List Sharing}.%
\index{list sharing}
Parts of lists may not be shared with other lists.  In other words,
there is only one way to reach any element of the auxiliary area
using object list level functions.

Or more specifically, list and sublist
auxiliary pointers must point at elements of the auxiliary area,
two list or sublist auxiliary pointers are not permitted to point
at the same auxiliary
area element, and an auxiliary area element that is followed
in the auxiliary area by a list element may not be pointed at by
a list or sublist auxiliary pointer (because the following list element
in effect points at the auxiliary area element as being the
continuation of the list containing the following list element).
\end{indpar}

Thus if the one way to reach an element of
the auxiliary area is deleted, the element may be put on a list of
free elements for the auxiliary area.  As an optimization,
an implementation may use the unused area or space in the object's header
to hold a count of the freed elements as an aid to determine when to
reorganize the object.  It is even possible to establish a list of
free elements for reuse, but due to auxiliary area fragmentation this
may not be efficient.

As an optimization, \skey{auxiliary stub}s can be used in place of object
auxiliary area elements.  When this is done, the description of this
section must be modified as explained in \itemref{OBJECT-AUXILIARY-STUBS}.

Auxiliary pointers that are used to build lists cannot be stored as
values of list elements.  The following function returns \TT{true}
if and only if its argument can be stored in a list element:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{is\_list\_legal} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_LEGAL} \\
\end{tabular}\end{indpar}

Only auxiliary general values (with subtypes \TT{GEN\_...\_AUX})
and illegal general values (with subtype \TT{GEN\_ILLEGAL}) cannot be stored
in a list element, with the exception of \TT{min::\EOL EMPTY\_\EOL SUBLIST()},
which can be stored like a normal value in a list element.

\subsubsubsection{List Pointers}
\label{LIST-POINTERS}

A \key{list pointer} can be used to move around in a object at
the list level.
There are three kinds of list pointers.
A \TT{min::list\_ptr} read-only list pointer permits read-only access to list
elements.
A \TT{min::\EOL list\_\EOL updptr} read-write or updatable list pointer
permits read-write access to list elements, but does not permit
adding or removing list elements.
A \TT{min::\EOL list\_\EOL insptr} insertable list pointer
permits adding and removing elements, in addition to permitting
read-write access to elements.

Note that unlike vector pointers, you \underline{cannot} downcast more capable
list pointers to less capable list pointers.  E.g., a
\TT{min::\EOL obj\_\EOL vec\_\EOL insptr} object vector pointer may be
explicitly or implicitly downcast to a
\TT{min::\EOL obj\_\EOL vec\_\EOL updptr}
or \TT{min::\EOL obj\_\EOL vec\_\EOL ptr} object vector pointer, but 
a \TT{min::\EOL list\_\EOL insptr} list pointer may \underline{not} be
explicitly or implicitly downcast to an
\TT{min::\EOL list\_\EOL updptr}
or \TT{min::\EOL list\_\EOL ptr} list pointer.

The functions for using a \minkey{list\_\EOL ptr} read-only list pointer
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_ptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::list_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::list\_ptr}}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::obj_vec_ptr & vp )|
\LABEL{MIN::=LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt list\_ptr}}\ARGBREAK
	  \verb|( min::list_ptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist} \verb|( min::list_ptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_ptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_ptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_ptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_ptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_ptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_PTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_PTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{is\_list\_end} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{tabular}\end{indpar}

A list pointer is created to move around in a particular object.
Once created it can be started on a new list by one of the
\skey{start list function}s:
\TT{min::\EOL start\_\EOL hash}, \TT{min::\EOL start\_\EOL attr},
\TT{min::\EOL start\_\EOL copy}, or
the 2-argument \TT{min::\EOL start\_\EOL sublist}.
The \TT{min::\EOL next} function moves forward one element
in the current list,
while the \TT{min::\EOL peek} function returns the next element without
moving to it.
The list pointer is always pointing at a current element, or at
the end of the list.
The \TT{min::\EOL current} function returns the current element
or \TT{min::\EOL LIST\_\EOL END()}.

Assigning a vector pointer to a list pointer (via the `\TT{=}' assignment
operator) reconstructs the
list pointer to point at the object pointed at by the vector
pointer.  This must be done whenever the vector pointer itself
is reassigned to point at a different object.  Once reassigned,
the list pointer must be restarted.

Determining whether a list pointer current element value
represents a sublist requires
the \TT{min::\EOL is\_\EOL sublist} function, which checks whether the
value is a sublist auxiliary pointer,
is the value \TT{min::\EOL EMPTY\_\EOL SUBLIST()},
or is a pointer to a sublist auxiliary stub as described in
\itemref{OBJECT-AUXILIARY-STUBS}.
The \TT{min::\EOL is\_\EOL empty\_\EOL sublist}
function, on the other hand, merely checks whether the value is
\TT{min::\EOL EMPTY\_\EOL SUBLIST()}.

Determining whether a list pointer current element value
represents the end of a list can be done by
simply checking whether the value equals \TT{min::\EOL LIST\_\EOL END()},
or can be done equivalently
with the \TT{min::\EOL is\_\EOL list\_\EOL end} function.

If the current element
is updated using \TT{min::\EOL update}
on another updatable or insertable list pointer,
the \TT{min::\EOL update\_\EOL refresh} function
must be used to reestablish the
current element's value,
which is \ikey{cached}{cache!list pointer}\label{LIST-POINTER-CACHE}
in the list pointer.
Similarly one of the \TT{min::\EOL\ldots\_refresh} functions may
need to be used when another pointer is used to insert elements into
or remove elements
from the object, though in some situations this is
not adequate and the list pointer must be restarted
with a \TT{min::\EOL start\_\dots} function
(see \pagref{RESTARTING_LIST_PTR} for details).

A list pointer that has been created but not started by one of the
list start functions appears to be
at the end of an immutable empty list.

The \TT{min::\EOL start\_\EOL hash} function positions
a list pointer at the beginning of the
list whose head is at the given index within the hash table, treating the
hash table as a vector.  This function mod's the index by the hash table
size, so the index can be, and usually should be, a hash value returned
by \TT{min::\EOL hash} (\pagref{MIN::HASH}).
Index 0 refers to the first element of the hash table,
and the size of the hash table minus 1 refers to the last element.
The size of the hash table may be obtained from the
\TT{min::\EOL hash\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index.
This function returns the value of the first
element of the list, or returns \TT{min::\EOL LIST\_\EOL END()}
if the list is empty.

The \TT{min::\EOL start\_\EOL attr} function is analogous except it is given
an index within the object attribute vector and positions the list pointer
at the beginning of the list whose head is the attribute vector element
at that index.  Index 0 refers to the first element of the attribute vector,
and the maximum index is the size of the attribute vector minus 1.
The size of the attribute vector may be obtained from the
\TT{min::\EOL attr\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index and is \underline{not} mod'ed
by the attribute vector size.

The \TT{min::\EOL start\_\EOL copy} function
positions a list pointer (\TT{lp})
to the same place as another list pointer (\TT{lp2}).
The two list pointers must have been constructed from the \underline{same}
object vector pointer.
Also note that the list pointer \TT{lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before \TT{min::\EOL start\_\EOL copy} is executed.

The value of a list element can represent a sublist
(see the \TT{min::\EOL is\_\EOL sublist} function described below).
The 2-argument \TT{min::\EOL start\_\EOL sublist} function
positions a list pointer (\TT{lp})
to the first element of the sublist represented by the current
element of another list pointer (\TT{lp2}).
The current element of the second pointer must represent a sublist.
This function returns the value of the first element of
the sublist, or returns \TT{min::\EOL LIST\_\EOL END()}
if the sublist is empty.
The two list pointers must have been constructed from the \underline{same}
object vector pointer.
Also note that the list pointer \TT{lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before \TT{min::\EOL start\_\EOL sublist} is executed.

The 1-argument \TT{min::\EOL start\_\EOL sublist} function
positions a list pointer
to the first element of the sublist represented by the current
element of the pointer (it is equivalent to 2-argument
\TT{min::\EOL start\_\EOL sublist} with \TT{lp2} and \TT{lp} being
the same).
Again the list pointer must be valid before this function is executed.

The \TT{min::\EOL next} function moves the list pointer
to the next list element of the
list the pointer points at, and returns the value of that
list element.  It returns \TT{min::\EOL LIST\_\EOL END()} if there is
no next list element because the end of the list has been reached.
After the end of a list has been reached, additional
calls to \TT{min::next}
will do nothing but return \TT{min::\EOL LIST\_\EOL END()}.

The \TT{min::\EOL peek} function returns the next element of the
list, i.e., the
same value as the \TT{min::\EOL next} function would return, but does not
change the element the list pointer is pointing at, i.e., does not
modify the list pointer.

The \TT{min::current} function just returns the value of the list
element the list pointer currently points at, or returns
\TT{min::\EOL LIST\_\EOL END()}
if there is no such element because the pointer is at the end of a list.
This function does not modify the list pointer.

The \TT{min::update\_\EOL refresh}
function must be called for
a pointer that points at an element if the \TT{min::\EOL update} function
is used with \underline{another} pointer to the same object to update
the element, or if the element is a sublist head and a function is used
to remove the first element of the sublist or insert elements at the
beginning of the sublist or after the first element of the sublist.

The \TT{min::\EOL insert\_\EOL refresh} function must be called if the
\TT{min::\EOL insert\_\EOL reserve} function is used with \underline{another}
pointer to the same object and that function returned \TT{true} indicating
that it resized the object, or if a resizing function is called
for the object (\pagref{RESIZING-FUNCTIONS}).  The 
\TT{min::\EOL insert\_\EOL refresh} function also does what the
\TT{min::\EOL update\_\EOL refresh} function does, and therefore it is
never necessary to call both functions.
There are also situations detailed on \pagref{RESTARTING_LIST_PTR}
in which use of \TT{min::\EOL insert\_\EOL before},
\TT{min::\EOL insert\_\EOL after}, or
\TT{min::\EOL remove} with \underline{another} pointer to the same object
absolutely requires that the current pointer be
restarted by a \TT{min::\EOL start\_\ldots} function.

A \minkey{list\_\EOL updptr} updatable list pointer allows read-write access to
list elements without permitting insertion or removal of elements
from lists.  The functions for using this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_updptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::LIST_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::list_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::list\_updptr}}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::obj_vect_updptr & vp )|
\LABEL{MIN::=LIST_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::obj_vec_updptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt list\_updptr}}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_updptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_updptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_updptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_updptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_UPDPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_updptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_UPDPTR} \\
\end{tabular}\end{indpar}

Functions defined for read-only list pointers are also
applicable to updatable (read-write) list pointers with the
same results.  However, updatable list pointers
can\underline{not} be converted to be read-only list pointers
(unlike the situation with vector pointers).
Also note that \TT{min::start\_\EOL sublist} works when
\TT{lp2} is a read-only list pointer, but \TT{min::start\_\EOL copy}
does not.

The \TT{min::update} function can be used to replace the
value of the current element of a list.
The value being replaced must be a list element (and not a
non-empty sublist or list end), and the
new value of the element must be legal for storage
in a list element (\pagref{MIN::IS_LIST_LEGAL}).

If a list pointer \TT{lp2} points at a element that is
\TT{min::update}'ed using a different updatable list pointer \TT{lp1},
then \TT{lp2} will be invalid until
\TT{min::\EOL update\_\EOL refresh(lp2)},
\TT{min::\EOL insert\_\EOL refresh(lp2)}, or
\TT{min::\EOL start\_\ldots(lp2,\ldots)}
has been executed.

Inserting and removing elements from a list requires yet another
kind of list pointer,
a \minkey{list\_\EOL insptr} insertable list pointer.
The functions defined for this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_insptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::LIST_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::list_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::list\_insptr}}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::obj_vect_insptr & vp )|
\LABEL{MIN::=LIST_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::obj_vec_insptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt list\_insptr}}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_COPY_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_insptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_insptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_insptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_insptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_INSPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_insptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{insert\_reserve\RESIZE}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr insertions,|\ARGBREAK
	  \verb|  min::unsptr elements = 0,|\ARGBREAK
	  \verb|  bool use_obj_aux_stubs =|\ARGBREAK
	  \verb|      min::use_obj_aux_stubs )|
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_AFTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{remove}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr n = 1 )|
\LABEL{MIN::REMOVE_FROM_LIST_INSPTR} \\
\end{tabular}\end{indpar}

Functions defined for updatable (and read-only) list pointers are also
applicable to insertable list pointers with the
same results.  However, insertable list pointers
can\underline{not} be converted to be updatable or read-only list pointers
(unlike the situation with vector pointers).
Note that \TT{min::start\_\EOL sublist} works when
\TT{lp2} is a read-only or updatable
list pointer, but \TT{min::start\_\EOL copy}
does not.

Also, there is one function, \TT{min::update}, that can do more for
an insertable list pointer than it can for an updatable list pointer.  For
an insertable list pointer (but not for an updatable list pointer)
the current value replaced by \TT{min::update}
may be a non-empty sublist.  Thus \TT{min::update} can be used
to truncate a sublist by replacing it with \TT{min::\EOL EMPTY\_\EOL SUBLIST()}.

Making insertions in object lists requires reservation of the necessary
space first, in order to be sure that a sequence of insertions will
all succeed.
The \TT{min::insert\_reserve} function reserves space for the given number
of insertion function calls and the given total number of list elements
to be inserted.  If the later is \TT{0}, the default, it is taken to
be equal to the number of insertion function calls.  If space is not
reserved for insertion function calls in this way, the calls will be
in error.

Reservations are made against a list pointer and its object, and are
\underline{not} affected by calls to functions such as
\TT{min::\EOL start\_\EOL hash}, \TT{min::\EOL start\_\EOL copy},
\TT{min::\EOL start\_\EOL sublist}, and \TT{min::\EOL next},
which reposition the list pointer.
A reservation on a list pointer may be made as soon as the list pointer
has been created and before any start list function has been called
for it.  Functions like \TT{min::\EOL start\_\EOL copy} do
\underline{not} transfer reservations from one list pointer to another.

Only one pointer at a time
for a given object may have an effective reservation.
Each call to \TT{min::\EOL insert\_reserve} for a list pointer
to an object invalidates all previous calls to
\TT{min::\EOL insert\_reserve} for any other list pointer
to the same object.  Errors in this regard involving two different
list pointers will be detected if insufficient memory is reserved,
but not otherwise.

The \TT{min::insert\_reserve\RESIZE} function may expand the body of
the object in which space is being reserved
(using \TT{min::\EOL expand\RESIZE},
\pagref{MIN::EXPAND_OBJ_VEC_INSPTR}).
It returns \TT{true} if it expands the
object's body, and \TT{false} if it does not.

Importantly \TT{min::\EOL insert\_reserve\RESIZE} is the only list pointer
function that may cause a resizing of
the object pointed at, and if a resizing occurs (i.e., if \TT{true}
is returned),
all other list pointers to the same object
become invalid and must be refreshed by
a call to \TT{min::\EOL insert\_\EOL refresh}.

The \TT{min::\EOL insert\_reserve\RESIZE} function can expand the object
if it's size is insufficient, or instead it can depend upon using
object auxiliary stubs (\itemref{OBJECT-AUXILIARY-STUBS}) if the object
runs out of space, in which case \TT{min::\EOL insert\_reserve\RESIZE}
must be sure
there are sufficient free stubs to satisfy the insertion calls.  The
last argument to \TT{min::\EOL insert\_reserve\RESIZE}
determines which strategy is
used.  It defaults to the value of \minkey{use\_obj\_aux\_stubs}
(see \pagref{MIN::USE_OBJ_AUX_STUBS}).%
\footnote{But if the auxiliary stub code is not compiled in, the last
argument is treated as if it was always \TT{false}:
see \TT{MIN\_\EOL USE\_\EOL OBJECT\_\EOL AUX\_\EOL STUBS} on
\pagref{MIN_USE_OBJ_AUX_STUBS}.}

The \TT{min::\EOL insert\_before} function inserts list elements
just before the current position of a list pointer and positions the
list pointer to the first element inserted.
The \TT{min::\EOL insert\_after} function inserts list elements just after the
current position and leaves the pointer position unchanged (pointing at
the element before the first inserted element).
If the list pointer is at the end of list,
\TT{min::\EOL insert\_before} inserts the elements at the end of the list, and
\TT{min::\EOL insert\_after} is in error.
The elements are specified by a length \TT{n}
vector \TT{p} of \TT{min::gen} values.
\TT{p[0]} is inserted into the list before \TT{p[1]}, etc.
If \TT{n=0} elements are to be inserted, both insert
functions are no-operations.

To insert a sublist, first insert \TT{min::\EOL EMPTY\_SUBLIST()}, then
position the pointer to the sublist and use
\TT{min::\EOL start\_sublist} to enter the sublist, and then use
\TT{min::\EOL insert\_before} to insert the elements of the sublist.
Also, as noted above, you can use \TT{min::\EOL update} with an
insertable pointer to change
the current element to \TT{min::\EOL EMPTY\_\EOL SUBLIST()}.

A sequence of instructions that begins with a
call to \TT{min::\EOL insert\_reserve\RESIZE} and ends with the last
list insertion function for which the beginning call made a reservation
is called a `\key{list insertion sequence}'.  A list insertion sequence
must not contain any call to a resizing function
(\RESIZE, \pagref{RESIZING-FUNCTIONS}) or reorganizing function
(\REORG, \pagref{REORGANIZING-FUNCTIONS}), aside from
the beginning call to \TT{min::\EOL insert\_reserve\RESIZE}.
In particular, there can be no
second call to \TT{min::\EOL insert\_reserve\RESIZE}.  There can be calls to
create and position list pointers, and to read, update, and remove
list elements.

If \TT{min::\EOL insert\_\EOL before}
or \TT{min::\EOL insert\_\EOL after}
are used to insert elements at the beginning of a sublist or elements
just after the first element of a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to \TT{min::\EOL update\_\EOL refresh} or
\TT{min::\EOL insert\_\EOL refresh} or restarted with a call to a
\TT{min::\EOL start\_\ldots} function.

The \TT{min::\EOL remove} function can be used to remove
\TT{n} consecutive elements
of a list, the first of which is the element currently pointed at by
the list pointer.
After removal, the list pointer points at the first element after the
elements removed, or at the end of the list if there is no such element.
If there are fewer than \TT{n} elements in the list at and after
the list pointer current element, then there is no error, but all the
elements at and after the current element are removed, and the list
pointer is pointed at the end of the list.  The returned value is the
number of elements actually removed (and is less than \TT{n} if the
list was too short).  Element removal requires no reservation.

If \TT{min::\EOL remove} is used to remove the first element of
a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to \TT{min::\EOL update\_\EOL refresh} or
\TT{min::\EOL insert\_\EOL refresh} or restarted with a call to a
\TT{min::\EOL start\_\ldots} function.

If an insertable list pointer \TT{lp2} is used to add or remove
elements or remove sublists, and there is another list pointer \TT{lp1}
pointing at the same object, then \TT{lp1} is invalidated and must
be restarted with a
\TT{min::\EOL start\_}\,\ldots function\label{RESTARTING_LIST_PTR}
if \TT{lp1} is pointing at:

\begin{enumerate}
\item an element that is removed
\item an element in a removed sublist
\item the end of a removed sublist
\item an element adjacent to an element that is inserted or removed
\item the end of a list whose last element is inserted or removed
\item the first element of a sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\item the end of an empty sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\end{enumerate}

The effects can be subtle
and not obvious: for example, using \TT{lp2} to insert before or after
a list element that is an empty sublist can invalidate \TT{lp1}
if \TT{lp1} points at the end of that empty sublist.

If the insertable vector pointer of an insertable list pointer
\TT{lp1} is used as an argument to
a resizing function (\pagref{RESIZING-FUNCTIONS}) or
a reorganizing function (\pagref{REORGANIZING-FUNCTIONS}) to resize
or reorganize the object \TT{lp1} points to, then
\TT{lp1} must be restarted with a
\TT{min::\EOL start\_}\,\ldots function.

The invalidation of \TT{lp1} in the above situations
is \underline{not} a detectable error.

\begin{quote}
\key{List Implementation Note}:\label{LIST-IMPLEMENTATION-NOTE}
In order to enforce the `No Superfluous' rules on 
\pagref{NO-SUPERFLUOUS-LIST}, \TT{MUP::list\_insptr}'s keep
track of the location of any auxiliary pointer
(or equivalent as per \itemref{OBJECT-AUXILIARY-STUBS})
pointing a the current
element.  Insertions before or after the current element may change
this auxiliary pointer, and may move the current element to another
location.  Otherwise insertions replace the current element
by an auxiliary pointer (or equivalent)
pointing at a vector of elements (or equivalent),
one of which is a copy of the replaced element.
This last is done for insertions after the single element of a one
element list headed in the hash table or attribute vector.
Any insertion before the end of a list of such a single element list
is transformed into an insertion after the list's single element.
\end{quote}

An object can be resized with its lists reorganized so as to
compact the auxiliary area, and also to move information out
of any auxiliary stubs attached to the object and into the
auxiliary area.  This can be done by the functions:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
      \verb|( min::list_insptr & lp,|\ARGBREAK
      \verb|  min::unsptr unused_size,|\ARGBREAK
      \verb|  min::unsptr var_size )|
\LABEL{MIN::RESIZE_OF_LIST_INSPTR} \\
\verb|bool min::| & \MINKEY{resize\RESIZE}\ARGBREAK
      \verb|( min::list_insptr & lp,|\ARGBREAK
      \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OF_LIST_INSPTR} \\
\end{tabular}\end{indpar}

The size of the unused area is changed by these functions, and
the size of the variable area is also changed by the first of these
functions.

The various list pointer types are instances of
\verb|MUP::|\MUPKEY{list\_ptr\_type} defined as follows:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_ptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_ptr}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_updptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_updptr}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_ptr_type<min::obj_vec_insptr>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_insptr}\verb|;| \\
\end{tabular}\end{indpar}

It is important not to instantiate \TT{MUP::list\_ptr\_type}
with any parameter that is not a vector pointer type (which is why
it is unprotected).

\subsubsubsection{Object Auxiliary Stubs}
\label{OBJECT-AUXILIARY-STUBS}

As an optimization, \skey{object auxiliary stub}s\index{auxiliary stub!object}
can be used instead of object
auxiliary area elements.  Object auxiliary stubs are a way of adding
list elements to
an object whose unused area has been exhausted, without relocating the
object.  Object auxiliary stubs
are considered to be \skey{extension}s of the object.
If the object is later reorganized,
use of any object auxiliary stubs that extend the object may be eliminated
by moving information from these into a new larger object auxiliary area.

The code implementing object auxiliary stubs can be compiled into a program
or left out of a program according to the setting of the macro:


\begin{indpar}
\begin{tabular}{l}
\TTKEY{MIN\_USE\_OBJ\_AUX\_STUBS} \\
~~~~~ 1 if code to use object auxiliary stubs is to be compiled; \\
~~~~~ 0 if this code is not to be compiled; the default.
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\end{tabular}
\end{indpar}

If compiled, the code can be enabled or disabled by setting the
following variable:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs} \\
& ~~~~\verb|true| to enable use of object auxiliary stubs; the default \\
& ~~~~\verb|false| to disable use of object auxiliary stubs
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{tabular}\end{indpar}

The value of an object
auxiliary stub is treated like an auxiliary area element value that is
always a list element, and is never a list auxiliary pointer
or a \TT{min::LIST\_END()} value.  However, as a list element,
the value may be a sublist auxiliary pointer (or equivalent, see below)
or a \TT{min::EMPTY\_SUBLIST()} value.

The control of an object auxiliary stub is treated like an auxiliary
area element value that is always a list auxiliary pointer
or a \TT{min::LIST\_END()} value, and is never a list element.

The value and control of an object auxiliary stub are treated like
consecutive elements of the object auxiliary area, with the control
preceding the value in the area, and therefore
following the value in list order.

An object auxiliary stub has one of the following two uncollectable stub type
codes:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const int min::}\MINKEY{LIST\_AUX}]~%
	\LABEL{MIN::LIST_AUX}\\
A \TT{min::gen} value or stub control
pointing at this stub behaves like a list pointer.
\item[{\tt const int min::}\MINKEY{SUBLIST\_AUX}]~%
	\LABEL{MIN::SUBLIST_AUX}\\
A \TT{min::gen} value pointing at this stub behaves like a sublist pointer.
\end{list}
\end{indpar}

Any stub pointer to an object auxiliary stub of type \minkey{LIST\_AUX}
is treated as a list auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \TT{min::gen} values or in auxiliary stub controls.

Any stub pointer to an object auxiliary stub of type \minkey{SUBLIST\_AUX}
is treated as a sublist auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \TT{min::gen} values or in auxiliary stub \TT{min::gen}
values.

Thus the following rules are obeyed:

\begin{indpar}

{\bf \minkey{LIST\_AUX} stubs}.
A \TT{min::gen} value that points at a stub $S$
of type \TT{min::\EOL LIST\_\EOL AUX} is the equivalent of a list auxiliary
pointer pointing at the list element that is stub $S$'s value.

Similarly,
if the control of an object auxiliary stub holds a stub pointer, that pointer
must point at an object auxiliary stub $S$ of type \TT{min::LIST\_AUX} and the
control is the equivalent of a list auxiliary pointer pointing at
the list element that is stub $S$'s value.

{\bf \minkey{SUBLIST\_AUX} stubs}.
A \TT{min::gen} value that points at
a stub $S$ of type \TT{min::\EOL SUBLIST\_\EOL AUX}
is the equivalent of a sublist auxiliary
pointer pointing at the list element that is stub $S$'s value.

{\bf Values of Object Auxiliary Stubs}.%
\index{value!of object auxiliary stub}
An object auxiliary stub value is always a list element, and can never
be a list auxiliary pointer value, a \TT{min::gen} value pointing at
a stub of type \TT{min::LIST\_AUX}, or a \TT{min::LIST\_END()} value.

However, it can be a sublist auxiliary pointer value, a \TT{min::gen}
value pointing at a stub of type \TT{min::SUBLIST\_AUX}, or a
\TT{min::EMPTY\_SUBLIST()} value.

{\bf Controls of Object Auxiliary Stubs}.%
\index{control!of object auxiliary stub}
An object auxiliary stub control is never a list element, and must
be a list auxiliary pointer value, a stub pointer value pointing at
a stub of type \TT{min::LIST\_AUX}, or a \TT{min::LIST\_END()} value.

{\bf Pointers to Object Auxiliary Stubs}.%
\index{pointer!to object auxiliary stub}
Every object auxiliary stub is pointed at by a \TT{min::gen}
value or by the control of another object auxiliary stub.  There is
only one such pointer pointing at each object auxiliary stub.
A \TT{min::gen} value pointing at an object auxiliary stub $S$
must be one of the following:
\begin{center}
\begin{tabular}{l@{~~~}l}
Location of \TT{min::gen} & Type of auxiliary stub
\\[2ex]
value of auxiliary area element & \TT{LIST\_AUX} or \TT{SUBLIST\_AUX}
\\[1ex]
value of auxiliary stub & \TT{SUBLIST\_AUX}
\\[1ex]
value of hash table element & \TT{LIST\_AUX}
\\[1ex]
value of attribute vector element & \TT{LIST\_AUX}
\end{tabular}
\end{center}

\end{indpar}

Object auxiliary stubs
must obey the object list level rules on \pagref{NO-SUPERFLUOUS-LIST}.
This means, for example, that a list auxiliary pointer cannot point
at an auxiliary area element that holds a \TT{min::gen} value
pointing at an object auxiliary stub of type \TT{min::LIST\_AUX},
as this would be equivalent to a list auxiliary pointer pointing at an
element holding another list auxiliary pointer.

The use of object auxiliary stubs by an implementation is hidden from
the user of MIN by object list level functions.  There are no functions
for dealing explicitly with object auxiliary stubs.  There are, however,
unprotected functions to read and write stubs of all kinds in
\itemref{STUB-CONTROL-FUNCTIONS} and
\itemref{STUB-VALUE-READ-WRITE-FUNCTIONS},
though the only use of these functions on
object auxiliary stubs would be for debugging.

\subsubsubsection{List Debugging Functions}
\label{LIST-DEBUGGING-FUNCTIONS}

The following list level functions are only intended for debugging:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{list\_equal}\ARGBREAK
    \verb|( min::gen v1, min::gen v2,|\ARGBREAK
    \verb|  bool include_var = true,|\ARGBREAK
    \verb|  bool include_attr = true,|\ARGBREAK
    \verb|  bool include_hash = true )|
\LABEL{MIN::LIST_EQUAL} \\
\verb|bool min::| & \MINKEY{list\_equal}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp1,|\ARGBREAK
    \verb|  min::obj_vec_ptr & vp2,|\ARGBREAK
    \verb|  bool include_var = true,|\ARGBREAK
    \verb|  bool include_attr = true,|\ARGBREAK
    \verb|  bool include_hash = true )|
\LABEL{MIN::LIST_EQUAL_VEC_PTR} \\
\end{tabular}\end{indpar}

These functions return true if and only if:

\begin{itemize}
\item \TT{v1} and \TT{v2} are both points to objects, \\
      or equivalently, \\
      neither \TT{vp1} nor \TT{vp2} equal \TT{min::\EOL NULL\_\EOL STUB}.
\item The two object hash table sizes are equal.
\item All the lists headed by the two object hashes are equal.
\item The two object attribute vector sizes are equal.
\item All the lists headed by the two object attribute vectors are equal.
\item The two object number of variables are equal.
\item The values of the two object variable vector elements are equal.
\end{itemize}

If the \TT{include\_hash} argument is \TT{false}, the tests involving
the hash tables are omitted.
If the \TT{include\_attr} argument is \TT{false}, the tests involving
the attribute vector are omitted.
If the \TT{include\_var} argument is \TT{false}, the tests involving
the object variables are omitted.

A printout of the list level object suitable for debugging can be had
by the functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{list\_print}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  bool include_var = true,|\ARGBREAK
    \verb|  bool include_attr = true,|\ARGBREAK
    \verb|  bool include_hash = true )|
\LABEL{MIN::LIST_PRINT} \\
\verb|min::printer min::| & \MINKEY{list\_print}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  bool include_var = true,|\ARGBREAK
    \verb|  bool include_attr = true,|\ARGBREAK
    \verb|  bool include_hash = true )|
\LABEL{MIN::LIST_PRINT_VEC_PTR} \\
\end{tabular}\end{indpar}

The output is indented by the column position at the time
the function is called, and the parts of the object indicated
by the arguments are included.

The following can be used to compare two lists or print
a single list:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{list\_equal}\ARGBREAK
    \verb|( min::list_ptr & lp1,|\ARGBREAK
    \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::LIST_PTR_EQUAL} \\
\verb|min::printer min::| & \MINKEY{list\_print}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::list_ptr & lp )|
\LABEL{MIN::LIST_PRT_PRINT} \\
\end{tabular}\end{indpar}

The list pointer positions are changed, either to the end of the
list, or to the locations of the first disagreeing members of the
two lists for the equality testing function.
The print output is indented by the column position at the time
the print function is called.


\subsubsection{Object Attribute Level}
\label{OBJECT-ATTRIBUTE-LEVEL}

At the \key{attribute level}\,, the object is a map from attribute-names to
flags and multi-sets of values and from attribute-name/reverse-attribute-name
pairs to multi-sets of values.
Here names are sequences of name components, which are
numbers, strings, or labels.  The object map is stored in a set of lists which
are entries in the hash table or attribute vector.  These lists have
one of two syntaxes depending upon the setting of the following macro:

\begin{indpar}
\begin{tabular}{l}
\TTKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS} \\
~~~~~ 1 if partial attribute labels are supported; \\
~~~~~ 0 if partial attribute labels are not supported.
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}
\end{indpar}

If partial attribute labels are supported, the attribute name given to
a function that locates an attribute may be too long,
and the function will use only an initial segment of that name,
returning the length of that segment.

If partial attribute names are \underline{not} supported
the object lists have the syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em hash-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em attribute-descriptor}
\\[1ex]
\emkey{hash-list} ::= {\em attribute-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{attribute-name-descriptor-pair} ::=
    {\em attribute-name } {\em attribute-descriptor}
\\[1ex]
\emkey{attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{attribute-descriptor} ::= {\em value} $|$ {\em attribute-sublist}
\\[1ex]
\emkey{attribute-sublist} ::=
    {\em value}$\,^\star$ {\em double-arrow-sublist-option} {\em flag-set}
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emlkey{double-arrow}{-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{atom} ::= {\em string} $|$ {\em number}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

Here the syntactic categories represent \TT{min::gen} values
or lists or sublists
of \TT{min::gen} values in the sense of the object list level.

An {\em X-list} is a list, in the sense of the object list level.  Thus
a {\em hash-list} and {\em vector-list} are lists.

An {\em X-sublist} is a sublist, in the sense of the object list level, which
is to say it is a list that is an element of another list.  Thus
{\em attribute-sublists} and {\em double-arrow-sublists} are sublists.

An {\em X-option} is an optional element of a list that is an {\em X} if
it is not omitted.

Everything else is a single list element or
a sequence of elements in some list or sublist.
{\em X-pairs} are sequences of two elements.
{\em Flag-sets} are sequences of {\em control-codes}.

An {\em atom} is a \TT{min::gen} number or string.
An {\em label} is a \TT{min::gen} label.
An {\em object} is a \TT{min::gen} value pointing at an object stub.
A {\em control-code} is a \TT{min::gen} control code value.
An {\em index} is a \TT{min::gen} index value.
An {\em indirect-auxiliary} is a \TT{min::gen} indirect auxiliary value.

The above form of object map maps an {\em attribute-name} to a list of
{\em values}, a list of flag {\em control codes}, and a optional
{\em double-arrow-sublist}.  This last maps {\em reverse-attribute-names}
to lists of values.

The lists of {\em values} here represent multisets of {\em values}.
That is, the
order of the {\em values} in the list is not meaningful.
Similarly the order of {\em attribute-name-descriptor-pairs}
in a {\em hash-list}
or the order of {\em double-arrow-name-descriptor-pairs}
in a {\em double-arrow-sublist} is not meaningful.
On the other hand, a {\em flag-set} is actually an ordered list
of {\em control-codes}; here order matters.

A {\em hash-list} is simply a list of alternating {\em attribute-names}
and {\em attribute-descriptors}.
The long form of an {\em attribute-descriptor} is an
{\em attribute-sublist} that gives  a possibly empty list of {\em values},
an optional {\em double-arrow-sublist}, and a possibly empty
list of flag control codes.
An {\em attribute-sublist} may be empty.
The short form of an {\em attribute-descriptor} is just a single
{\em value}, and is equivalent to an {\em attribute-sublist}
that contains nothing but that {\em value}.
This is a common case, and is optimized to conserve memory.

An {\em attribute-name-descriptor-pair} with an
empty {\em attribute-sublist} is equivalent to a missing
{\em attribute-name-descriptor-pair}.
Such {\em attri\-bute-name-descriptor-pairs}
are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

An {\em attribute-vector-entry} is just an {\em attribute-descriptor}
stored in an attribute vector element whose index is the
{\em attribute-name} associated with the {\em attribute-descriptor}.

{\em Attribute-names} can be either {\em atoms} or {\em labels}.
If an {\em attribute-name} is an integer {\em atom}
that is in the range of a legal
attribute vector index then the associated
{\em attribute-descriptor} is put in the attribute vector element
indexed by the integer.
Otherwise an {\em attribute-name-descriptor-pair} containing
the {\em attribute-name} is put
in the {\em hash-list} of the object's hash table entry whose index
in the hash table
equals the hash of the {\em attribute-name} modulo the length of the
hash table.

A {\em double-arrow-sublist} is 
simply a sublist of alternating {\em reverse-attribute-names}
and {\em value-multisets}.  The former are just like {\em attribute-names}
and the latter are just like {\em attribute-descriptors} that have no
flag control codes or {\em double-arrow-sublists}.
The values in the {\em value-multisets} of {\em double-arrow-sublists}
are restricted to be {\em objects}, i.e., pointers to objects.

A {\em double-arrow-name-descriptor-pair} with an empty {\em value-multiset}
is equivalent to a missing {\em double-arrow-name-descriptor-pair}.
Such {\em dou\-ble-arrow-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are \underline{not} supported, multi-component
attribute names are represented in object data lists as labels.
Thus an {\em attribute-name} is an {\em atom} if it represents a 1-component
attribute name, and a {\em label} if it represents a several component
attribute name, or if it represents a 1-component name whose one component
is itself a label.

In the interests of compatibility with the case where partial attribute
names are supported, {\em attribute-names} and {\em reverse-attribute-names}
that are {\em labels} whose sole element is an {\em atom} are not
permitted in the object data lists, and when functions are presented with
such names, the functions replace them with their sole element, namely the
{\em atom}.  In addition, {\em attribute-names} that are labels with no elements
are forbidden, for reasons of compatibility.

If partial attribute names \underline{are} supported
the object lists have the following alternative syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em node-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em node-descriptor}
\\[1ex]
\emkey{node-list} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{node-name-descriptor-pair} ::=
    {\em attribute-name-component } {\em node-descriptor}
\\[1ex]
\emkey{attribute-name-component} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{node-descriptor} ::= {\em value} $|$ {\em node-sublist}
\\[1ex]
\emkey{node-sublist}
    \begin{tabular}[t]{@{}r@{~}l@{}}
    ::= & {\em value}$\,^\star$
          {\em flag-set} \\
    $|$ & {\em value}$\,^\star$
          {\em child-sublist}
	  {\em double-arrow-sublist-option}
	  {\em flag-set}
    \end{tabular}
\\[1ex]
\emkey{child-sublist} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emlkey{double-arrow}{-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{atom} ::= {\em string} $|$ {\em number}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

This differs from the previous representation in that the object map
is represented by a tree of nodes,
where each node is labeled by an {\em attribute-name-component}.
An {\em attribute-name} is viewed as a sequence of
{\em attribute-name-components}, so the {\em attribute-name}
defines a path in the tree from the root to a node.
Each node has an associated {\em node-descriptor} that
contains the node {\em values},
optional {\em double-arrow-sublist}, and flag control codes,
which are associated
with the {\em attribute-name} that names the path from the root to the
node.  The {\em node-descriptor} also may contain
an optional {\em child-sublist}
which describes the children of the node in the tree.

A {\em hash-table-entry} is a {\em node-list} that gives alternating
{\em attribute-name-component}/\EOL {\em node-\EOL de\-scrip\-tor} pairs for
children of the object root node.  A {\em attribute-vector-entry}
is just a {\em node-descriptor} whose associated {\em attribute-name-component}
is the index of the attribute vector element that contains the
{\em attribute-vector-entry}.
For a node that is a child of the object root,
if the child node's {\em attribute-name-component} is an integer in the legal
range of the object's attribute vector indices, then the child node's
{\em node-descriptor} is stored in
the indexed vector element.
If a vector index is not the first component of
any of the object's attribute names, then the corresponding
{\em attribute-vector-entry} must be an empty {\em node-sublist}.

For a child of the root whose name component is not a legal attribute
vector index, its {\em attribute-name-component}/{\em node-descriptor}
pair is placed in the {\em hash-table-entry}
whose index in the object's hash table equals the hash of the
{\em attribute-name-component} modulo the length of the hash table.

A {\em node-descriptor} that consists of nothing but a single {\em value}
can be represented by just that {\em value}; otherwise it is represented
by a {\em node-sublist}.  If this last contains a sublist, the first
such sublist must
be the {\em child-sublist}, which has the same structure as a {\em node-list}
and describes the children of the node.  Otherwise neither the
{\em child-sublist} nor the {\em double-arrow-sublist} can be present.
Note that to avoid ambiguity it is not permitted to omit the
{\em child-sublist} without also omitting
the {\em double-arrow-sublist}, but the
{\em child-sublist} can be empty.  Except for these details
the {\em node-descriptor} structure is the same was as that of the
{\em attribute-descriptor} in the case where partial attribute names are
not allowed.  The {\em double-arrow-sublist} structure is exactly
the same.

A {\em node-name-descriptor-pair} with an empty {\em node-sublist}
is equivalent to a missing {\em node-name-descriptor-pair}.
Such {\em node-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are supported, an attribute name is viewed
as a sequence of {\em attribute-name-components}.  If this sequence is
a single {\em atom}, function arguments representing the name can be
either this {\em atom} or a {\em label} whose only element is the {\em atom}.
Otherwise function arguments must be non-empty
{\em labels} whose elements are the {\em attribute-name-components}.
Note that zero length labels may not be used as attribute names.

\ikey{Attribute flags}{attribute flag!representation}\label{ATTRIBUTE-FLAGS}
are represented by a {\em flag-set} in an {\em attribute-sublist} or
{\em node-sublist}.
The {\em flag-set} is a sequence of \TT{min::gen}
control codes.

The flags are numbered 0, 1, 2, \ldots.  Flag $N$ corresponds to
the bit in the $I+1$'st control code
selected by the mask $2^K$ where $I=\mbox{floor}(N/\mbox{\TT{VSIZE}})$,
$K=N~\mbox{mod}~\mbox{\TT{VSIZE}}$, where \TT{VSIZE},
the number of bits in a control code integer,
is the value of the \TT{min::VSIZE} constant (\pagref{MIN::VSIZE}),
which is 24 if \TT{min::gen}
values are 32-bits, and 40 if \TT{min::gen} values are 64-bits.
A flag is set for an attribute name if and only if its corresponding
bit is present and set and in the attribute's {\em flag-set}.
If a flag's bit is not present in the {\em flag-set}, the flag is
treated as if its bit were present and cleared.

Control codes, auxiliary pointers, and some specials values
(\TT{min::\EOL NONE()}, \TT{min::\EOL ANY()}, etc.: see
\pagref{ATTR-ILLEGAL-SPECIAL-VALUES}),
cannot be values of attributes.
The following function returns \TT{true}
if and only if its argument can be a value of an attribute:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{is\_attr\_legal} \verb|( min::gen v )|
\LABEL{MIN::IS_ATTR_LEGAL} \\
\end{tabular}\end{indpar}

Only special values (with subtype \TT{GEN\_SPECIAL}) having
indices greater than or equal to the index of \TT{min::\EOL NONE()},
control code values (with subtypes \TT{GEN\_CONTROL\_CODE}),
auxiliary general values (with subtypes \TT{GEN\_...\_AUX}),
and illegal general values (with subtype \TT{GEN\_ILLEGAL})
cannot be attribute values.

Only pointers to objects
(satisfying \TT{min::\EOL is\_\EOL obj}, see \pagref{MIN::IS_OBJ})
can be double-arrow attribute values.

Attribute names must be strings, numbers, or labels
(\TT{min::gen} labels as per \itemref{LABELS}).

\subsubsubsection{Attribute Pointers}
\label{ATTRIBUTE-POINTERS}

An \key{attribute pointer} can be used to access attribute
flags and values
in an object.
An attribute pointer stores an attribute name
and a reverse attribute name.  The latter can take the special
values \TT{min::NONE()} and \TT{min::ANY()}.  The attribute name designates
the object attribute pointed at by the attribute pointer.
The flag set pointed at is always
the flag set of this attribute, regardless of the setting of the
reverse attribute name.  The attribute name and
reverse attribute name together designate the
value multiset pointed at.  If the reverse attribute name
is \TT{min::NONE()}, the value multiset pointed at is the set of all values
\underline{not} associated with any reverse attribute name.  If the
reverse attribute name is \TT{min::ANY()},
the value multiset is the set of all
values that are associated with any reverse attribute name
(see \pagref{REVERSE-ATTRIBUTE-NAME-ANY} for details).
Otherwise the value multiset pointed at is the set of values
associated with the reverse attribute name stored in the pointer.

There are three kinds of attribute pointers.
A read-only \TT{min::\EOL attr\_\EOL ptr}
permits read-only access to attribute values and flags.
An updatable \TT{min::\EOL attr\_\EOL updptr}
permits read-only access to attribute values and flags,
and write access to attribute non-multiset-values that already exist,
but does not permit values to be added to or removed from attributes.
An insertable \TT{min::\EOL attr\_\EOL insptr}
permits read-write access to attribute values and flags
and also permits values to be added to or removed from attributes.

The functions for using a read-only \TT{min::\EOL attr\_\EOL ptr}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_ptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::attr_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_ptr}}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::obj_vec_ptr & vp )|
\LABEL{MIN::=ATTR_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt attr\_ptr}}\ARGBREAK
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_PTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_ptr & ap, int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_ptr & ap, min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_ptr & ap )| \\
\LABEL{MIN::RELOCATE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_OF_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}
    \verb|( min::attr_ptr ap )|
\LABEL{MIN::GET1_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_ptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::uns64  flags;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|  min::unsptr flag_count;|\ARGBREAK
    \verb|  min::unsptr reverse_attr_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::ATTR_INFO} \\
\ttmindex{name}{in {\tt min::attr\_info}}
\ttmindex{value}{in {\tt min::attr\_info}}
\ttmindex{flags}{in {\tt min::attr\_info}}
\ttmindex{value\_count}{in {\tt min::attr\_info}}
\ttmindex{flag\_count}{in {\tt min::attr\_info}}
\ttmindex{reverse\_attr\_count}{in {\tt min::attr\_info}}
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_attr\_info}\ARGBREAK
    \verb|( min::attr_info * out, min::unsptr n )|
\LABEL{MIN::SORT_ATTR_INFO} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{reverse\_attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::REVERSE_ATTR_INFO} \\
\ttmindex{name}{in {\tt min::reverse\_attr\_info}}
\ttmindex{value\_count}{in {\tt min::reverse\_attr\_info}}
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_reverse\_attr\_info}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n )|
\LABEL{MIN::SORT_REVERSE_ATTR_INFO} \\
\end{tabular}\end{indpar}

Attribute pointers are tied to an object, which is specified by
giving a vector pointer to the object to the constructor of the
attribute pointer.  The \TT{min::\EOL obj\_\EOL vec\_\EOL ptr\_\EOL of}
function can be used to retrieve the vector pointer used by
an attribute pointer.

Assigning a vector pointer to an attribute pointer
(via the `\TT{=}' assignment operator) reconstructs the
attribute pointer to point at the object pointed at by the vector
pointer.  This must be done whenever the vector pointer itself
is reassigned to point at a different object.  Once reassigned,
the effect of previous locate functions is lost.

\ikey{Locator functions}{locator function}
find attributes within an object and set the current
attribute name and reverse attribute name of an attribute pointer.
The \TT{min::\EOL locate} function sets the attribute name of the pointer.
If the `\TT{length}' argument is \underline{not} given, \TT{min::\EOL locate}
uses the complete attribute name.
The \TT{min::\EOL locatei} function does the
same thing as \TT{min::\EOL locate}
but is optimized for the case where the attribute
name has a single component that is an integer.\footnote{
In some implementations \TT{min::gen} is defined to be \TT{min::uns64},
and in these implementations \TT{int} and \TT{min::unsptr} are
incorrectly convertible to the
\TT{min::gen} type by a C++ implicit conversion.  As a consequence of this
the \TT{min::\EOL locatei} function must have a different name from the
\TT{min::\EOL locate} function.}

The form of the \TT{min::\EOL locate} function that takes a `\TT{length}'
argument exists only if the
\TT{MIN\_\EOL ALLOW\_\EOL PARTIAL\_\EOL ATTR\_\EOL LABELS}
(\pagref{MIN_ALLOW_PARTIAL_ATTR_LABELS}) macro is set to \TT{1}.
This form of \TT{min::\EOL locate} uses the longest initial segment of the
attribute name that locates an attribute that has a non-empty
multiset of values.  The
length of this initial segment is returned in the `\TT{length}'
argument.  If \TT{0} is returned in `\TT{length}',
no initial segment having a non-empty multiset of values was found.

The \TT{min::\EOL locate\_reverse} function sets the reverse attribute name of
a pointer.  This can take the special value \TT{min::NONE()} or
\TT{min::ANY()}, as noted above.  A call to \TT{min::\EOL locate} or
\TT{min::\EOL locatei} sets the
reverse attribute name to \TT{min::NONE()}.

Both the \TT{min::\EOL locate} and \TT{min::\EOL locate\_reverse}
functions take name
arguments that are labels (\itemref{LABELS}).  If an atom (number or
string) is given instead, this is treated as the equivalent of
a label whose only element is the atom.

If an insertable attribute pointer \TT{ap1} is used
to add or remove attribute values or set or clear attribute flags,
every other attribute pointer \TT{ap2}
to the object will become \mkey{invalid}{attribute pointer}
(\pagref{INSERTABLE-ATTRIBUTE-FUNCTIONS})
until a \TT{min::\EOL locate} or
\TT{min::\EOL relocate} function is called for \TT{ap2}.  The later
function is equivalent to repeating the calls to \TT{min::\EOL locate},
and if necessary \TT{min::\EOL reverse\_\EOL locate}, that positioned
\TT{ap2} to where it was before \TT{ap1} was used to modify the object.
Note that simply calling \TT{min::\EOL locate}
and \TT{min::\EOL reverse\_\EOL locate} on \TT{ap1} will
\underline{not} add or remove attribute values or set or clear attribute flags.

It is an \underline{\bf undetected error}
to use an invalid attribute pointer.  Note, however, that for \TT{ap2}
to become invalid as above, it must share the object vector pointer
with \TT{ap1}, as otherwise an error will be detected when either
\TT{ap1}'s vector pointer or \TT{ap2}'s vector pointer is created.

Note that \underline{no} special functions need to be called when an attribute
value is updated using \TT{min::\EOL update} on
an updatable attribute pointer (\pagref{UPDATABLE-ATTRIBUTE-FUNCTIONS}).

\ikey{Accessor functions}{accessor function}
can be used for reading attribute values and flags.
For the purposes of describing these functions,
an attribute pointer is considered to point at the attribute
named by the pointer's attribute name, and the reverse attribute
pointed at by the pointer's attribute and reverse attribute names,
unless the latter are \TT{min::NONE()} or \TT{min::ANY()}.
If the \TT{min::\EOL locate} function has never been called to set
these names it is an error to call an accessor
function for the pointer.

The value multiset pointed at by a pointer is that of the attribute pointed
at if the reverse attribute name is \TT{min::NONE()}, or is that of
the reverse attribute pointed at if the reverse attribute name is not
\TT{min::NONE()} or \TT{min::ANY()}.
If the reverse attribute name is \TT{min::ANY()}
\label{REVERSE-ATTRIBUTE-NAME-ANY} the value multiset is
the set of all values associated with any reverse attribute name, but
this \TT{min::ANY()}
value set can only be read by the 3-argument \TT{min::get}
function, and made empty by the \TT{min::\EOL set\RESIZE}
function with 0 new values (see \pagref{MIN::SET_DELETE_ANY}).
It is an error to attempt any other access to this \TT{min::ANY()} value set.

The flag set pointed at by a pointer is that of the attribute pointed
at regardless of the setting of the reverse attribute name.
If there are $N$ control codes in a flag set, $N$\TT{*VSIZE} flags are
represented by the set, and any flag with number $\geq N$\TT{*VSIZE} is
read as zero.  `High order' control codes may contain all zero flags,
and such zero high order control code may be removed when an object
is reorganized.

Attributes whose value and flag sets have never been set are treated
as if they have empty value multisets and flag control code lists.
Similarly reverse attributes
whose value multisets have never been set are treated as having empty value
multisets.

The 3-argument \TT{min::\EOL get} function gets the values in the value
multiset pointed at and stores them in the `\TT{out}' vector.
The total number of values in the value
multiset is returned (regardless of the value of \TT{n}).
The argument \TT{n}, the length of `\TT{out}',
is the maximum number of values that may be returned in `\TT{out}'.
If there are more then \TT{n} values, only the first \TT{n}
are returned in `\TT{out}'.
If \TT{n==0} the function just returns
the number of values in the value multiset.

The 1-argument \TT{min::\EOL get} function assumes that there is exactly
one value in the value multiset
and returns that value, or returns the special value
\TT{min::NONE()} (\pagref{MIN::NONE}) if the value multiset is empty,
or returns the special value
\TT{min::MULTI\_VALUED} (\pagref{MIN::MULTI_VALUED}) if the value multiset
has more than one value.

The \TT{min::\EOL get\_\EOL flags}
function returns the control codes in the flag set pointed at and stores
these in the \TT{min::gen} vector `\TT{out}'.
The total number of control codes in the flag set is returned
(regardless of the value of \TT{n}).
The argument \TT{n}, the length of `\TT{out}',
is the maximum number of control codes that may be returned in `\TT{out}'.
If there are more then \TT{n} control codes, only the first \TT{n}
are returned in `\TT{out}'.
If \TT{n==0} the function just returns
the number of control codes in the flag set.

In all of this, high order zero control codes are treated as if
they did not exist (control codes are stored lowest order first
in `\TT{out}').  If there are no non-zero flags, no control codes
are stored in `\TT{out}', and \TT{0} is returned as the number of
control codes.

In the `\TT{out}' vector, flag $N$ is the bit selected by mask $2^K$
in the vector element with index $I$, where $K=N~\mbox{mod}~\mbox{\TT{VSIZE}}$
and $I=\mbox{floor}(N/\mbox{\TT{VSIZE}})$.
If there are $J$ control codes
in the flag set, and $N\geq J*\mbox{\TT{VSIZE}}$, then
flag $N$ is zero.

The \TT{min::\EOL test\_\EOL flag} function returns the value
of flag \TT{n}.

The attribute names for an object form a list ordered in an implementation
dependent fashion.  
The \TT{min::\EOL get\_\EOL attrs} function gets information about each
attribute in this list.  The information about an attribute is stored in a
\TT{min::\EOL attr\_\EOL info} structure and includes the attribute
name in the \TT{name} member,
the number of values in the attribute value multiset in the \TT{value\_count}
member, the number of control codes in the attribute flag set in
the \TT{flag\_count} member, and the number of associated
reverse attribute names which have non-empty value multisets in the
\TT{reverse\_attr\_count} member.

In addition, the \TT{value} member is set to the attribute value if there
is exactly one value, or to \TT{min::\EOL NONE()} if there is no value,
or to \TT{min::\EOL MULTI\_\EOL VALUED()} if there is more than one value,
and the \TT{flags} member is set to the low order 64 bits of the flags
(or to \TT{0} if there are no flags).

If a name has only one component that is an {\em atom}, the name is returned
as that {\em atom}; all other names are returned as {\em labels}.

At least one of the three counts must be
non-zero for an attribute, or else the attribute is treated as if it
were not in the list of all attribute names.  In computing
\TT{flag\_count}, high order zero control codes are treated as if they
did not exist, and the value of \TT{flag\_count} is the
same as the value that would be returned by \TT{min::\EOL get\_\EOL flags}.

Attributes accessed through the attribute vector are not returned unless
the \TT{include\_\EOL attr\_\EOL vec} argument is \TT{true}.  These are
just the attributes whose name is a small integer
\TT{i} with \TT{0 <= i < m}, where \TT{m} is the size of the object
attribute vector.
If the \TT{MIN\_\EOL ALLOW\_\EOL PARTIAL\_\EOL ATTR\_\EOL LABELS}
macro is set to \TT{1}, any attribute whose name is a label beginning
with such an integer is also not returned.

The \TT{min::\EOL attr\_\EOL info} structs are stored in an \TT{n}
element vector `\TT{out}'
that should be allocated to the stack.  If there are more than
\TT{n} structs, only the first \TT{n}
are returned, but the total number available is returned as the value of
the \TT{min::\EOL get\_\EOL attrs} function, and this should be used
to retry with a larger `\TT{out}' vector.

The implementation dependent order of the \TT{attr\_info}
values returned by \TT{min::\EOL get\_\EOL attrs} may change if attribute
values are added to or removed from the object or
attribute flags are set or cleared, or if the object is reorganized.
The \TT{min::\EOL sort\_\EOL attr\_\EOL info} function can be used
to sort by attribute name the
vector returned by \TT{min::\EOL get\_\EOL attrs}.
The \TT{min::\EOL compare} function, \pagref{MIN::COMPARE},
is used to determine the ordering of names.

The \TT{min::\EOL get\_\EOL reverse\_\EOL attrs}
function is analogous but involves the list of
reverse attribute names associated
with a particular object and attribute name stored in the attribute
pointer.
\TT{min::locate\ldots} must be used to set the attribute name to be used.
There is a \TT{min::\EOL reverse\_\EOL
attr\_\EOL info} struct for each reverse attribute name, and there is only
one count member in this, the \TT{value\_count} member that is the number
of values in the value multiset of the reverse attribute pointed at.
A reverse attribute name with an empty value multiset is treated as if it
were not in the list of reverse attribute names.
The \TT{value} member is the reverse attribute value if there is only one
value, or is \TT{min::\EOL MULTI\_\EOL VALUED()} otherwise.

Updatable attribute pointers can set existing values as well as perform
the operations of read-only attribute pointers.
The functions for using a \TT{min::\EOL attr\_\EOL updptr}
are:\label{UPDATABLE-ATTRIBUTE-FUNCTIONS}

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_updptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::ATTR_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::attr_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::obj_vec_updptr & vp )|
\LABEL{MIN::=ATTR_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::obj_vec_updptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_OF_ATTR_UPDPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_updptr ap )|
\LABEL{MIN::GET1_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_UPDPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_UPDPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

Functions defined for read-only attribute pointers are also
applicable to updatable attribute pointers with the
same results.  However, updatable attribute pointers
can\underline{not} be converted to be read-only attribute pointers
(unlike the situation with vector pointers).

The \TT{min::\EOL update} function requires that the current
value multiset have a single value and that it be the value multiset
of an attribute, and not a reverse attribute.
This function replaces the single value, returning the previous value.
It is an error if the value multiset is empty or has more than one
value,
or if the attribute pointer
reverse attribute name is not \TT{min::NONE()}.
It is an error if the new value is not a legal attribute value
(see \pagref{MIN::IS_ATTR_LEGAL}).

Insertable attribute pointers can remove and insert values and
set and clear flags,
as well as perform the operations of updatable attribute pointers.
The functions for using a
\TT{min::\EOL attr\_\EOL insptr}
are:\label{INSERTABLE-ATTRIBUTE-FUNCTIONS}

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_insptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::attr_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_insptr}}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::obj_vec_insptr & vp )|
\LABEL{MIN::=ATTR_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::obj_vec_insptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt attr\_insptr}}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_OF_ATTR_INSPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_insptr ap )|
\LABEL{MIN::GET1_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_INSPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_INSPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::SET1_OF_ATTR_INSPTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ONE1} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ALL1} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{set\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::SET_FLAG} \\
\verb|bool min::| & \MINKEY{clear\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::CLEAR_FLAG} \\
\verb|bool min::| & \MINKEY{flip\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::FLIP_FLAG} \\
\end{tabular}\end{indpar}

Functions defined for updatable attribute pointers are also
applicable to insertable attribute pointers with the
same results.  However, insertable attribute pointers
can\underline{not} be converted to be updatable or read-only attribute pointers
(unlike the situation with vector pointers).

The \TT{min::\EOL set\RESIZE}
function sets all the values in the value multiset the
attribute pointer is pointing at, deleting any previous values.
For 3-argument \TT{min::\EOL set\RESIZE}
the new values are given in the `\TT{in}' vector, and
the number of values is given in \TT{n}.  If \TT{n} is zero, all
values are deleted.
For 2-argument \TT{min::\EOL set\RESIZE} there is one new value given as an
argument, unless \TT{v} is \TT{min::NONE()},
in which case there are no new values and all previous values are simply
deleted.

For the \TT{min::\EOL set\RESIZE} function
\label{MIN::SET_DELETE_ANY}
the pointer's reverse attribute name can be \TT{min::NONE()}
but cannot be \TT{min::ANY()}, with the exception of the case
where all values are being deleted.  If the reverse attribute name
is \TT{min:ANY()} and the \TT{min::\EOL set\RESIZE} function is called to
delete all previous values,
all double arrows with the current attribute name and any
reverse attribute name are deleted.

The \TT{min::\EOL add\_\EOL to\_\EOL set\RESIZE} function
adds values to the multiset set of values,
but adds each value if and only if the value is not already in the multiset,
using \TT{==} to compare values for equality.
The \TT{min::\EOL add\_\EOL to\_\EOL multiset\RESIZE} function
adds values even if they are already in the multiset.
Both functions have a 3-argument version with a vector of new values,
and a 2-argument version with a single new value.  In the latter case
if \TT{v} is \TT{min::NONE()} there is no new value and the function
is a no-operation.
For these functions the pointer's reverse attribute name
can be \TT{min::NONE()}
but cannot be \TT{min::ANY()}.

It is an error if an attribute value to be stored by a \TT{min::set},
\TT{min::\EOL add\_\EOL to\_\EOL set}
or \TT{min::\EOL add\_\EOL to\_\EOL multiset}
is not a legal attribute value
(see \pagref{MIN::IS_ATTR_LEGAL}) or if the pointer's reverse attribute
name is not \TT{min::NONE()} and the value is not a pointer to an object.

The \TT{min::\EOL remove\_\EOL one} function
removes values from the multiset set of values, removing only one copy of
each value,
using \TT{==} to compare values for equality.
The \TT{min::\EOL remove\_\EOL all} function
removes all copies of each value  
from the multiset of values (it may be less efficient if
the multiset is actually a set).
Both functions have a 3-argument version with a vector of values to remove,
and a 2-argument version with a single value to remove.  In the latter case
if \TT{v} is \TT{min::NONE()} there is no value to remove and the function
is a no-operation.  These functions return the number of values actually
removed from the multiset of values.
For these functions the pointer's reverse attribute name
can be \TT{min::NONE()} but cannot be \TT{min::ANY()}.

If the attribute pointer is pointing at a multiset of values
associated with a reverse attribute name,
the values represent double arrows.
In this case, let the object whose attribute value is being set or removed
be $O_1$, the pointer attribute name be $N$, the pointer reverse
attribute name be $R$, and the object being pointed at by the value
being set or removed be $O_2$.
Then when the value is set or removed, the corresponding value that is
an attribute value of $O_2$ with name $R$, reverse name $N$, and target $O_1$
will be set or removed.
That is, the other end of the double arrow will also be set or removed.
In the unusual special case where $O_1=O_2$ and also $N=R$, only one value
is set or removed, so the value will not be duplicated when set and is
assumed to be unduplicated when removed.

The \TT{min::\EOL set\_\EOL flags\RESIZE} function sets the control codes
of the flag set the attribute pointer points at.
The new control codes are given in the `\TT{in}' vector which
has length \TT{n}: see the discussion of
\TT{min::\EOL get\_\EOL flags} on \pagref{MIN::GET_FLAGS_OF_ATTR}
for the format of this vector.
If the previous flag set had more control codes that the new flag
set, the extra control codes will be retained but will be zeroed.
If \TT{n} is zero, all existing control codes are zeroed.
When the object is reorganized, high order zero control codes will
be deleted.

The function \TT{min::\EOL set\_\EOL some\_\EOL flags\RESIZE},
\TT{min::\EOL clear\_\EOL some\_\EOL flags},
and \TT{min::\EOL flip\_\EOL some\_\EOL flags}
can be used to alter flags.  If the bit corresponding
to the flag is on in the `\TT{in}' vector, it is set, cleared,
or flipped, respectively.

The \TT{min::\EOL set\_\EOL flag\RESIZE},
\TT{min::\EOL clear\_\EOL flag},
and \TT{min::\EOL flip\_\EOL flag}
functions can be used to alter a single flag whose number is
given as the argument \TT{n}.  The flag is set, cleared,
or flipped, respectively.  The previous value of the flag is
returned.

\subsubsubsection{Object Attribute Short-Cuts}
\label{OBJECT ATTRIBUTE SHORT-CUTS}

The following functions use vector and attribute pointers
internally to access a single attribute.  They are inefficient
if more than one attribute of an object needs to be accessed,
or if the attribute that needs to be accessed needs to be
accessed more than once.

These functions execute the same operations and
return the same values as the corresponding functions on a
\TT{min::attr\_insptr} insertable attribute pointer
pointing at the \TT{obj} argument
and located using the \TT{attr} argument as attribute label
(\pagref{INSERTABLE-ATTRIBUTE-FUNCTIONS}), with two differences:
\begin{enumerate}
\item
When possible a \TT{min::attr\_ptr}
or \TT{min::attr\_updptr} is used instead of a
\TT{min::\EOL attr\_\EOL insptr}.  This
permits functions that do not modify
the object to be used on
a public object (\pagref{MIN::PUBLISH}), and also
improves efficiency slightly.
\item
When the \TT{obj} argument is \underline{not} a pointer
to an object (\TT{min::\EOL is\_\EOL obj} is false),
the short-cut 2-argument \TT{min::\EOL get} function
returns \TT{min::\EOL NONE()} and
the short-cut 4-argument \TT{min::\EOL get} function
returns \TT{0}.
\end{enumerate}

With this in mind, the short-cut functions are:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen obj, min::gen attr )|
\LABEL{MIN::GET1_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::gen obj, min::gen attr )|
\LABEL{MIN::GET_OF_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_GEN} \\
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::gen obj, min::gen attr )|
\LABEL{MIN::GET_FLAGS_OF_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::SET1_OF_GEN} \\
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_SET_OF_GEN} \\
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET_OF_GEN} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET_OF_GEN} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET_OF_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ONE1_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ALL1_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL_OF_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_GEN} \\
\verb|void min::| & \MINKEY{set\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS_OF_GEN} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS_OF_GEN} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS_OF_GEN} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{set\_flag\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::SET_FLAG_OF_GEN} \\
\verb|bool min::| & \MINKEY{clear\_flag\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::CLEAR_FLAG_OF_GEN} \\
\verb|bool min::| & \MINKEY{flip\_flag\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::FLIP_FLAG_OF_GEN} \\
\end{tabular}\end{indpar}

\subsubsection{Graph Typed Objects}
\label{GRAPH-TYPED-OBJECTS}

A \key{graph typed object}\index{typed object!graph}
is a pair of objects:
the \mkey{graph type}{of typed object}\index{type!graph type}
which provides attribute labels and some attribute values,
and the \mkey{context}{of graph typed object}
which provides variables that give other attribute values.  The graph type
contains variable values that are \TT{min::gen} indices which
act as indirect pointers to the
variables in the context.
The context contains a pointer to the graph type most commonly paired
with the context.
By abuse of language the context may be
called a `graph typed object'.

Graph typed objects may be introduced in two different ways.  In the first
method the context is given the
\minkey{OBJ\_\EOL CONTEXT}\label{MIN::OBJ_CONTEXT} flag
and its first variable points at the graph type.  In the second method
the graph typed object is represented by a \TT{min::gen} value pointing at
a stub of \minkey{GTYPED\_\EOL PTR}\label{MIN::GTYPED_PTR} type
that in turn points at an auxilary stub
of \minkey{GTYPED\_\EOL PTR\_\EOL AUX}\label{MIN::GTYPED_PTR_AUX} type
that holds two pointers
to stubs: one pointing at the graph type and the second pointing at the context.
The graph type is pointed at by the control of the auxilary stub,
and the context is pointed at by the value of the auxilary stub.
An auxilary stub is necessary in order to allow garbage collection
of the stubs (the control of the primary stub is reserved for GC use).
This second method of introducing graph typed objects allows a context
to be viewed with several different graph types.

Typed objects make use of two kinds of indirect pointer.  The first is
just a single index\label{INDEX} general value
(\itemref{GENERAL-VALUES})
in the graph type
that holds the index of a
variable vector element.  This always refers to a variable in the context.
The second is a \TT{min::gen} pointer general value
(\itemref{POINTER-GENERAL-VALUES})
pointing at a
a variable in a context.
This second kind of index pointer is only supported when it is stored in
context variables.

If an attribute value is an indirect
pointer, the indirection is taken to the variable element referred to.
If that in turn has an indirect pointer value, that indirection is also
taken, to any depth.

Graph type objects and contexts are given the
\TT{min::\EOL OBJ\_\EOL PUBLIC} flag (\pagref{OBJ_PUBLIC}),
so it is not possible to add attributes to a graph type, context, or
graph type object.  It is also not allowed for a graph type
or graph typed object to have attributes
with more than one value or attributes with double arrow values.

Graph types are objects with the
\minkey{OBJ\_\EOL GTYPE}\label{MIN::OBJ_GTYPE} flag.
The first variable of a graph
type is an integer that bounds the indices stored in the graph type.
That is, this integer is the maximum plus \TT{1} of
all the indices  stored in the graph type.
Strictly speaking, a graph type is an object that is the root of a tree
of objects, all of which must
have the \minkey{OBJ\_\EOL GTYPE} flag and be the root of a graph subtype.

\subsubsubsection{Creating Graph Typed Objects}
\label{CREATING-GRAPH-TYPED-OBJECTS}

To make a new graph type, first construct the graph making use of
\TT{min::\EOL new\_\EOL index\_\EOL gen} (\pagref{MIN::NEW_INDEX_GEN})
to reference variables in the context.  Then execute the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_gtype} \verb|( min::gen gtype )|
\LABEL{MIN::NEW_GTYPE} \\
\end{tabular}\end{indpar}

This compacts the object's in the graph rooted at the \TT{gtype} argument,
makes them public by setting their
\TT{min::\EOL OBJ\_\EOL PUBLIC} flags (\pagref{OBJ_PUBLIC}),
sets the first variable of the \TT{gtype} object to one plus the
maximum index in the graph,
and sets this object's \TT{min::\EOL OBJ\_\EOL GTYPE} flag.
It is permissible for some subgraphs to already
be graph types before this function is called.
The function returns the \TT{gtype} argument if the new graph type
contains no errors,
and otherwise returns \TT{min::\EOL ERROR()} and writes an
error message into \TT{min::\EOL error\_\EOL message}
(\pagref{ERROR_MESSAGE}).
Errors include:
\begin{indpar}\begin{enumerate}
\item The graph type contains a public object that is not already a graph type.
\item The graph type contains a cycle.
\item The graph type contains an attribute with more than one value.
\item The graph type contains an attribute with a double arrow value.
\item The graph type contains a \TT{min::gen} index value with index \TT{0}
(which would mean that the graph type would point to itself via the
context first variable).
\item The graph type contains a \TT{min::gen} index value larger
than \TT{MIN\_\EOL CONTEXT\_\EOL SIZE\_\EOL LIMIT}.
\end{enumerate}\end{indpar}

Error checking makes use of:

\begin{indpar}[0.2in]\begin{tabular}{p{2.1in}p{3.5in}}
\TTKEY{MIN\_CONTEXT\_SIZE\_LIMIT}	& Maximum number of variables in
                                          a context.  Defaults to \TT{4096}.
\LABEL{MIN_CONTEXT_SIZE_LIMIT}
\end{tabular}\end{indpar}

To make a new context with a given graph type, execute the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_context} \verb|( min::gen gtype )|
\LABEL{MIN::NEW_CONTEXT} \\
\end{tabular}\end{indpar}

The new context is returned.
The new context has the number of variables specified by the graph
type, and the first of these is set to point at the graph type.
All the other variables are set to \TT{min::\EOL UNDEFINED()}
(\pagref{MIN::UNDEFINED}).

\subsubsubsection{Pointers to Graph Typed Objects}
\label{POINTERS-TO-GRAPH-TYPED-OBJECTS}

Attribute pointers to objects that might be graph typed
must be created by one of the following:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{attr\_ptr} \verb|ap|\ARGBREAK
	  \verb|( min::gen obj )|
\LABEL{MIN::ATTR_PTR_OF_OBJ} \\
\verb|min::attr_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_ptr}}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen obj )|
\LABEL{MIN::=ATTR_PTR_OF_OBJ} \\
(constructor)~\verb|min::|
	& \MINKEY{attr\_updptr} \verb|ap|\ARGBREAK
	  \verb|( min::gen obj )|
\LABEL{MIN::ATTR_UPDPTR_OF_OBJ} \\
\verb|min::attr_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen obj )|
\LABEL{MIN::=ATTR_UPDPTR_OF_OBJ} \\
\end{tabular}\end{indpar}

The argument \TT{obj} may by an object or may be a \TT{GTYPED\_\EOL PTR}
pointer (see above).  If it is an object, it must be public,
even if it is not a context with a graph type.
Creating an attribute pointer this way creates vector pointers inside
the attribute pointer.  If \TT{obj} is \underline{not} a graph typed object,
the vector pointer created inside the attribute pointer can be accessed by the
\TT{min::\EOL obj\_\EOL vec\_\EOL ptr\_\EOL of} function
(see \pagref{MIN::OBJ_VEC_PTR_OF_ATTR_PTR}
and \pagref{MIN::OBJ_VEC_PTR_OF_ATTR_UPDPTR}).
If \TT{obj} is a graph typed object, the two vector pointers created
inside the attribute pointer can be accessed by:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::obj_vec_ptr & min::|
	& \MINMKEY{graph\_obj\_vec\_ptr\_of}{of {\tt attr\_ptr}}\ARGBREAK
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::GRAPH_OBJ_VEC_PTR_OF_ATTR_PTR} \\
\verb|min::obj_vec_updptr & min::|
	& \MINMKEY{graph\_obj\_vec\_ptr\_of}{of {\tt attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::GRAPH_OBJ_VEC_PTR_OF_ATTR_UPDPTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINMKEY{context\_obj\_vec\_ptr\_of}{of {\tt attr\_ptr}}\ARGBREAK
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::CONTEXT_OBJ_VEC_PTR_OF_ATTR_PTR} \\
\verb|min::obj_vec_updptr & min::|
	& \MINMKEY{context\_obj\_vec\_ptr\_of}{of {\tt attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::CONTEXT_OBJ_VEC_PTR_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

The following functions can be used to determine if \TT{obj} was a
graph typed object or not:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINMKEY{is\_gtyped}{of {\tt attr\_ptr}}
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::IS_GTYPED_OF_ATTR_PTR} \\
\verb|bool min::|
	& \MINMKEY{is\_gtyped}{of {\tt attr\_updptr}}
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::IS_GTYPED_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

The usual attribute pointer creation functions that take a vector
pointer as argument
(see \pagref{MIN::ATTR_PTR_OF_OBJ_VEC_PTR},
\pagref{MIN::ATTR_UPDPTR_OF_OBJ_VEC_UPDPTR},
and \pagref{MIN::ATTR_INSPTR_OF_OBJ_VEC_INSPTR})
cannot be used to create
\TT{min::list\_xxxptr} or \TT{min::\EOL attr\_xxxptr} pointers
pointing at contexts (i.e., objects with
the \TT{OBJ\_\EOL CONTEXT} flag set).
Nor can they be used to create
\TT{min::\EOL list\_\EOL updptr} or
\TT{min::\EOL attr\_\EOL updptr} pointers
pointing at graph types (i.e., objects with
the \TT{OBJ\_\EOL GTYPE} flag set).
Nor can they be used to create of \TT{min::xxxx\_insptr} pointers
pointing at contexts or graph types (i.e., objects with
the \TT{OBJ\_\EOL PUBLIC} flag set).

When used with attribute pointers created with the above functions,
single argument
\TT{min::\EOL get} follows the indirect pointers that are index \TT{min::gen}
values, treating these as indices of variables in the graph typed object's
contest,
and also follows indirect pointers that are 
\TT{min::gen} values pointing at \TT{min::\EOL PTR}
stubs \underline{provided} these are stored in context variables.
The \TT{min::update} function
follows these same indirect pointers, and requires that the location
stored into be a context variable.

The \TT{min::update} function \underline{cannot} be used to store
a \TT{min::\EOL PTR} type \TT{min::\EOL gen} value.  Instead,
the single argument \TT{min::\EOL get} function stores information
in the attribute pointer that can be returned by the following function
(provided no other \TT{min::\EOL get} function execution on the
attribute pointer intervenes):

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::ptr<min::gen> min::|
	& \MINMKEY{get\_ptr\_of}{of {\tt attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::GET_PTR_OF_ATTR_UPDPTR} \\
\end{tabular}\end{indpar}

This function returns
a \TT{min::\EOL ptr<min::gen>} pointer pointing to the variable whose
value the \TT{min::\EOL get} returned, provided this value equaled
\TT{min::\EOL UNDEFINED()}.
Otherwise a null \TT{min::\EOL ptr<min::gen>} pointer is returned.

\subsubsubsection{Graph Typed Object Maintenance}
\label{GRAPH-TYPED-OBJECT-MAINTENANCE}

The following functions can be used to read and set the
\TT{min::\EOL OBJ\_\EOL GTYPE}
and \TT{min::\EOL OBJ\_\EOL CONTEXT} flags.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{gtype\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::GTYPE_FLAG_OF_OBJ_VEC_PTR} \\
\verb|bool min::| & \MINKEY{context\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::CONTEXT_FLAG_OF_OBJ_VEC_PTR} \\
\verb|void min::| & \MINKEY{set\_gtype\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::SET_GTYPE_FLAG_OF_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{set\_context\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::SET_CONTEXT_FLAG_OF_OBJ_VEC_INSPTR} \\
\end{tabular}\end{indpar}

The functions that set the flags also set the \TT{min::\EOL OBJ\_\EOL PUBLIC}
flag and set the insertable object vector pointer
to \TT{min::\EOL NULL\_\EOL STUB}, as an insertable object vector
pointer is not allowed to point at a public object.

\subsubsection{Printing Object General Values}
\label{PRINTING-OBJECT-GENERAL-VALUES}

The format for printing object \TT{min::gen} values is:

\begin{indpar}[1em]
\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{obj\_format}}%
\LABEL{MIN::OBJ_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::uns32                           obj_op_flags;|%
\ttmindex{obj\_op\_flags}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  const min::gen_format *              element_format;|%
\ttmindex{element\_format}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  const min::gen_format *              top_element_format;|%
\ttmindex{top\_element\_format}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  const min::gen_format *              quote_element_format;|%
\ttmindex{quote\_element\_format}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  const min::gen_format *              label_format;|%
\ttmindex{label\_format}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  const min::gen_format *              value_format;|%
\ttmindex{value\_format}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  const min::gen_format *              initiator_format;|%
\ttmindex{initiator\_format}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  const min::gen_format *              separator_format;|%
\ttmindex{separator\_format}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  const min::gen_format *              terminator_format;|%
\ttmindex{terminator\_format}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::str_classifier                  mark_classifier;|%
\ttmindex{mark\_classifier}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::gen                             quote_type;|%
\ttmindex{quote\_type}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_empty;|%
\ttmindex{obj\_empty}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_bra;|%
\label{OBJ_BRA}%
\ttmindex{obj\_bra}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::pstring                         obj_braend;|%
\ttmindex{obj\_braend}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::pstring                         obj_ketbegin;|%
\ttmindex{obj\_ketbegin}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::pstring                         obj_ket;|%
\label{OBJ_KET}%
\ttmindex{obj\_ket}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_sep;|%
\label{OBJ_SEP}%
\ttmindex{obj\_sep}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_attrbegin;|%
\ttmindex{obj\_attrbegin}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::pstring                         obj_attrsep;|%
\ttmindex{obj\_attrsep}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_attreol;|%
\ttmindex{obj\_attreol}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_attreq;|%
\ttmindex{obj\_attreq}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_attrneg;|%
\ttmindex{obj\_attrneg}{in {\tt min::obj\_format}}\ARGBREAK
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  const min::flag_format *             flag_format;|%
\ttmindex{flag\_format}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  const min::uns64                     hide_flags;|%
\ttmindex{hide\_flags}{in {\tt min::obj\_format}}
\end{tabular}

\bigskip

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
    \verb|  min::pstring                         obj_valbegin;|%
\ttmindex{obj\_valbegin}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::pstring                         obj_valsep;|%
\ttmindex{obj\_valsep}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::pstring                         obj_valend;|%
\ttmindex{obj\_valend}{in {\tt min::obj\_format}}\ARGBREAK
    \verb|  min::pstring                         obj_valreq;|%
\ttmindex{obj\_valreq}{in {\tt min::obj\_format}}
\end{tabular}

\end{indpar}

\TT{obj\_format.obj\_op\_flags}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 min::| & \MINKEY{PREFERRED\_ID}
\LABEL{MIN::PREFERRED_ID_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{ENABLE\_COMPACT}
\LABEL{MIN::ENABLE_COMPACT_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DEFERRED\_ID}
\LABEL{MIN::DEFERRED_ID_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{ISOLATED\_LINE}
\LABEL{MIN::ISOLATED_LINE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{EMBEDDED\_LINE}
\LABEL{MIN::EMBEDDED_LINE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{NO\_TRAILING\_TYPE}
\LABEL{MIN::NO_TRAILING_TYPE} \\
\verb|const min::uns32 min::| & \MINKEY{ENABLE\_LOGICAL\_LINE}
\LABEL{MIN::ENABLE_LOGICAL_LINE} \\
\verb|const min::uns32 min::| & \MINKEY{ENABLE\_INDENTED\_PARAGRAPH}
\LABEL{MIN::ENABLE_INDENTED_PARAGRAPH} \\
\end{tabular}\end{indpar}


\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{flag\_format}}
\LABEL{MIN::FLAG_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::pstring                         flag_prefix;|%
\ttmindex{flag\_prefix}{in {\tt min::flag\_format}}\ARGBREAK
    \verb|  min::pstring                         flag_postfix;|%
\ttmindex{flag\_postfix}{in {\tt min::flag\_format}}\ARGBREAK
    \verb|  min::packed_vec_ptr<min::ustring>    flag_names;|%
\ttmindex{flag\_names}{in {\tt min::flag\_format}}\ARGBREAK
    \verb|};|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt const min::flag\_format
                   min::\MINKEY{standard\_attr\_flag\_format}:}%
\LABEL{MIN::STANDARD_ATTR_FLAG_FORMAT}\ARGBREAK
\verb|min::left_square_leading_always_pstring    // flag_prefix   "["|\ARGBREAK
\verb|min::trailing_always_right_square_pstring  // flag_postfix  "]"|\ARGBREAK
\verb|min::standard_attr_flag_names              // flag_names|\ARGBREAK
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{l}
\verb|min::packed_vec_ptr<min::ustring> min::|%
    \MINKEY{standard\_\EOL attr\_\EOL flag\_\EOL names}
\LABEL{MIN::STANDARD_ATTR_FLAG_NAMES} \\
\verb|    // Names of flags numbered 0, 1, 2, ... 63 are:| \\
\verb|    //     * + - / @ & # = $ % < > a ... z A ... Z| \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const unsigned min::| &
    \MINKEY{standard\_\EOL attr\_\EOL a\_\EOL flag} \verb|= 12|
\LABEL{MIN::STANDARD_ATTR_a_FLAG} \\
\verb|const unsigned min::| &
    \MINKEY{standard\_\EOL attr\_\EOL A\_\EOL flag} \verb|= 38|
\LABEL{MIN::STANDARD_ATTR_A_FLAG} \\
\verb|const unsigned min::| &
    \MINKEY{standard\_\EOL attr\_\EOL hide\_\EOL flag} \verb|=|
    \verb|38 + 'H' - 'A'|
\LABEL{MIN::STANDARD_ATTR_HIDE_FLAG} \\
\verb|const min::64 min::| &
    \MINKEY{standard\_\EOL attr\_\EOL hide\_\EOL flags} \verb|=|\ARGBREAK
    \verb|1ull << min::standard_attr_hide_flag|
\LABEL{MIN::STANDARD_ATTR_HIDE_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{flag\_parser}}
\LABEL{MIN::FLAG_PARSER}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::uns32 ( * flag_parser_function )|\ARGBREAK
    \verb|       ( min::uns32 * flag_numbers,|\ARGBREAK
    \verb|         char * text_buffer,|\ARGBREAK
    \verb|         const min::flag_parser * flag_parser );|%
\ttmindex{flag\_parser\_function}{in {\tt min::flag\_parser}}\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  // Members beyond this point are used by|\ARGBREAK
    \verb|  // min::standard_flag_parser.|\ARGBREAK
    \verb||\ARGBREAK
    \verb|  const min::uns32 *  flag_map;|%
\ttmindex{flag\_map}{in {\tt min::flag\_parser}}\ARGBREAK
    \verb|  min::uns32          flag_map_length;|%
\ttmindex{flag\_map\_length}{in {\tt min::flag\_parser}}\ARGBREAK
    \verb|};|
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|const min::uns32 * min::| &
    \MINKEY{standard\_\EOL attr\_\EOL flag\_\EOL map}
\LABEL{MIN::STANDARD_ATTR_FLAG_MAP} \\
\verb|const min::uns32 min::| &
    \MINLKEY{standard\_\EOL attr\_\EOL flag}{\_\EOL map\_\EOL length}
\LABEL{MIN::STANDARD_ATTR_FLAG_MAP_LENGTH} \\
\verb|const min::uns32 min::| &
    \MINKEY{NO\_\EOL FLAG} \verb|= 0xFFFFFFFF|
\LABEL{MIN::NO_FLAG} \\
\end{tabular} \\
\begin{tabular}{l}
\verb|    // If min::standard_attr_flag_names[F] == "\x01\x01" "C"| \\
\verb|    // then min::standard_attr_flag_map[C] == F| \\
\verb|    // else min::standard_attr_flag_map[C] == min::NO_FLAG| \\
\end{tabular}\end{indpar}

\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt const min::flag\_parser
                   min::\MINKEY{standard\_attr\_flag\_parser}:}%
\LABEL{MIN::STANDARD_ATTR_FLAG_PARSER}\ARGBREAK
\verb|min::standard_flag_parser            // flag_parser_function|\ARGBREAK
\verb|min::standard_attr_flag_map          // flag_map|\ARGBREAK
\verb|min::standard_attr_flag_map_length   // flag_map_length|\ARGBREAK
\end{tabular}

\begin{indpar}[1em]

\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{compact\_obj\_format}:}%
\LABEL{MIN::COMPACT_OBJ_FORMAT}\ARGBREAK
\verb|  min::ENABLE_COMPACT                    // obj_op_flags|\ARGBREAK
\verb|+ min::DEFFERED_ID|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::element_gen_format                  // element_format|\ARGBREAK
\verb|NULL                                     // top_element_format|\ARGBREAK
\verb|min::always_quote_gen_format             // quote_element_format|\ARGBREAK
\verb|min::value_gen_format                    // value_format|\ARGBREAK
\verb|min::name_gen_format                     // label_format|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::leading_always_gen_format           // initiator_format|\ARGBREAK
\verb|min::trailing_always_gen_format          // separator_format|\ARGBREAK
\verb|min::trailing_always_gen_format          // terminator_format|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::standard_str_classifier             // mark_classifier|\ARGBREAK
\verb|min::doublequote                         // quote_type|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::left_curly_right_curly_pstring      // obj_empty|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::left_curly_leading_pstring          // obj_bra|\ARGBREAK
\verb|min::trailing_vbar_leading_pstring       // obj_braend|\ARGBREAK
\verb|min::trailing_vbar_leading_pstring       // obj_ketbegin|\ARGBREAK
\verb|min::trailing_right_curly_pstring        // obj_ket|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::space_if_none_pstring               // obj_sep|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::trailing_always_colon_space_pstring // obj_attrbegin|\ARGBREAK
\verb|min::trailing_always_comma_space_pstring // obj_attrsep|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::erase_all_space_colon_pstring       // obj_attreol|\ARGBREAK[0in]
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::space_equal_space_pstring           // obj_attreq|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::no_space_pstring                    // obj_attrneg|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::standard_attr_flag_format           // flag_format|\ARGBREAK
\verb|min::standard_attr_hide_flags            // hide_flags|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::left_curly_star_space_pstring       // obj_valbegin|\ARGBREAK
\verb|min::trailing_always_comma_space_pstring // obj_valsep|\ARGBREAK
\verb|min::space_star_right_curly_pstring      // obj_valend|\ARGBREAK
\verb|min::space_equal_space_pstring           // obj_valreq|\ARGBREAK
\end{tabular}

\end{indpar}

\begin{indpar}[1em]

\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINLKEY{top}{\_obj\_format}:}%
\LABEL{MIN::TOP_OBJ_FORMAT}\ARGBREAK
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::ENABLE_COMPACT                      // obj_op_flags|\ARGBREAK
\end{tabular}

\end{indpar}

\begin{indpar}[1em]

\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINLKEY{line}{\_obj\_format}:}%
\LABEL{MIN::LINE_OBJ_FORMAT}\ARGBREAK
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|  min::ENABLE_COMPACT                    // obj_op_flags|\ARGBREAK
\verb|+ min::ENABLE_LOGICAL_LINE|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::paragraph_gen_format                // top_element_format|\ARGBREAK
\end{tabular}

\end{indpar}

\begin{indpar}[1em]

\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{paragraph\_obj\_format}:}%
\LABEL{MIN::PARAGRAPH_OBJ_FORMAT}\ARGBREAK
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|  min::ENABLE_COMPACT                    // obj_op_flags|\ARGBREAK
\verb|+ min::ENABLE_INDENTED_PARAGRAPH|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::line_gen_format                     // top_element_format|\ARGBREAK
\end{tabular}

\end{indpar}

\begin{indpar}[1em]

\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{embedded\_line\_obj\_format}:}%
\LABEL{MIN::EMBEDDED_LINE_OBJ_FORMAT}\ARGBREAK
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|  min::EMBEDDED_LINE                     // obj_op_flags|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::null_str_classifier                 // mark_classifier|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|NULL                                     // obj_empty|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|NULL                                     // obj_attrbegin|\ARGBREAK
\verb|NULL                                     // obj_attrsep|\ARGBREAK
\end{tabular}

\end{indpar}

\begin{indpar}[1em]

\begin{tabular}{r@{}l}\hspace*{0.1in} \\[-3ex]
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{isolated\_line\_obj\_format}:}%
\LABEL{MIN::ISOLATED_LINE_OBJ_FORMAT}\ARGBREAK
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|  min::ISOLATED_LINE                     // obj_op_flags|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::id_gen_format                       // element_format|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|min::null_str_classifier                 // mark_classifier|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|NULL                                     // obj_empty|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|NULL                                     // obj_bra|\ARGBREAK
\verb|NULL                                     // obj_braend|\ARGBREAK
\verb|NULL                                     // obj_ketbegin|\ARGBREAK
\verb|NULL                                     // obj_ket|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|NULL                                     // obj_attrbegin|\ARGBREAK
\verb|NULL                                     // obj_attrsep|\ARGBREAK
\end{tabular}

\vspace{-4ex}\begin{tabular}{r@{}l}\hspace*{0.1in}\ARGBREAK
\verb|0                                        // hide_flags|\ARGBREAK
\end{tabular}


\end{indpar}

An object is printed as the ID `\TT{@}{\em <object-id>}' if
the object has an {\em object-id} in \TT{printer->\EOL id\_\EOL map}
and the \ttikey{PREFERRED\_\EOL ID}{PREFERRED\_EOL}
object format operation flag is on.
Objects may be given {\em object-ids} by
the {\TT min::map} function: see \pagref{MIN::MAP_OF_ID_MAP}.

Otherwise the object is printed in `\mkey{compact format}{for printing object}'
if all of the following are true:
\begin{enumerate}

\item The \ttikey{ENABLE\_\EOL COMPACT}{ENABLE\_COMPACT}
object format operation flag is on.

\item The object has no attributes other than \TT{.type},
\TT{.initiator}, \TT{.terminator}, \TT{.sep\-a\-ra\-tor},
and attributes with a \TT{hide\_\EOL flag}.

\item No attribute other than those with a \TT{hide\_\EOL flag}
has multiple values, flags, or reverse attributes (double arrows).

\item The value of any attribute
that does not have a \TT{hide\_\EOL flag}
is a string or label whose elements are all strings,
except that:
\begin{enumerate}
\item An \TT{.initiator} value may be \TT{min::\EOL LOGICAL\_\EOL LINE()}
if the \ttikey{ENABLE\_\EOL LOGICAL\_\EOL LINE}{ENABLE\_LOGICAL\_LINE}
object format operation
flag is on.
\item A \TT{.terminator} value may be \TT{min::\EOL INDENTED\_\EOL PARAGRAPH()}
if the \TT{ENABLE\_\EOL IN\-DENT\-ED\_\EOL PARAGRAPH}%
\ttlindex{ENABLE\_INDENTED\_}{PARAGRAPH}
object format operation
flag is on.
\end{enumerate}

\item If the object has an \TT{.initiator} or \TT{.terminator}
attribute, it has \underline{both}, and has no \TT{.type}.

\end{enumerate}

Otherwise, if the \ttikey{DEFERRED\_\EOL ID}{DEFERRED\_ID}
object format operation flag is on
and the object has an {\em object-id} in \TT{printer->\EOL id\_\EOL map}
the object is printed as the ID `\TT{@}{\em <object-id>}'.

Otherwise the
object is printed in `\mkey{isolated line format}{for printing object}'
if the \ttikey{ISOLATED\_\EOL LINE}{ISOLATED\_LINE}
object format operation flag.

Otherwise the
object is printed in `\mkey{embedded line format}{for printing object}'
if the \ttikey{EMBEDDED\_\EOL LINE}{EMBEDDED\_LINE}
object format operation flag is on.

Otherwise, when none of the above apply, the object is printed in
`\mkey{normal format}{for printing object}'.

The compact format has several variants:
\begin{enumerate}
\item The `\key{logical line compact format}' is used if
the object has an \TT{.initiator} equal to \TT{min::\EOL LOGICAL\_\EOL LINE()},
the object has no \TT{.separator},
and the \ttikey{ENABLE\_\EOL LOGICAL\_\EOL LINE}%
               {ENABLE\_LOGICAL\_LINE}
object format operation
flag is on.

\item Otherwise the `\lkey{indented paragraph}{compact format}' is used if
the object has a \TT{.terminator} equal to
\TT{min::\EOL INDENTED\_\EOL PARAGRAPH()}, the object has no \TT{.separator},
the \TT{ENABLE\_\EOL IN\-DENT\-ED\_\EOL PARAGRAPH}%
\ttlindex{ENABLE\_INDENTED\_}{PARAGRAPH}
object format operation
flag is on,
and the object is being printed as the last element of a containing
object that is being printed in logical line compact format and has
2 or more elements and a \TT{.terminator} equal to \TT{"<LF>"},

\item Otherwise the `\key{bracketed compact format}'
is used if the object has an \TT{.initiator} and \TT{.terminator}.

\item Otherwise the `\key{empty compact format}' is used if the object has
no elements and no \TT{.type}.  Note that the object may have a
\TT{.separator} which will not be printed.

\item Otherwise the `\key{quote compact format}' is used if
the object has a \TT{.type} equal to the object format
\TT{quote\_\EOL type} and the object has no \TT{.separator}.

\item Otherwise the `\key{default compact format}' is used.
In this case the object has a \TT{.type} other than
\TT{quote\_\EOL type}, no \TT{.initiator}, 
no \TT{.terminator}, but may have a \TT{.separator}.

\end{enumerate}


Keeping these formats and variants in mind,
the members of a \TT{min::obj\_format} are:

\begin{itemlist}[0.2in]

\item[\ttmkey{obj\_op\_flags}{in {\tt min::obj\_format}}]~\\
This is the logical OR of any of the following flags:

\begin{indpar}[0.2in]\begin{itemlist}[0.2in]

\item[\ttmkey{PREFERRED\_ID}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]\vspace{-1ex}
\item[\ttmkey{ENABLE\_COMPACT}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]\vspace{-1ex}
\item[\ttmkey{DEFERRED\_ID}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]\vspace{-1ex}
\item[\ttmkey{ISOLATED\_LINE}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]\vspace{-1ex}
\item[\ttmkey{EMBEDDED\_LINE}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]\vspace{-1ex}
\item[\ttmkey{ENABLE\_LOGICAL\_LINE}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]\vspace{-1ex}
\item[\ttmkey{ENABLE\_INDENTED\_PARAGRAPH}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]\vspace{-1ex}~\\
These flags determine the format the object is printed in.
See text above.

\item[\ttmkey{NO\_TRAILING\_TYPE}%
    {in {\tt obj\_\EOL format.obj\_\EOL op\_\EOL flags}}]~\\
This flag suppresses printing the type in the closing bracket
of a non-\TT{.ini\-ti\-ator} compact format object and an embedded line
format object.  That is, if the type is \TT{T}, this flag
replaces \TT{|T\}} with \TT{|\}}.  This flag has \underline{no} effect
on compact format objects printed as per the \TT{mark\_\EOL classifier}
as \TT{\{T\ldots T\}} without any `\TT{|}'s.

\end{itemlist}\end{indpar}

\item[\ttmkey{element\_format}{in {\tt min::obj\_format}}]
\item[\ttmkey{label\_format}{in {\tt min::obj\_format}}]\vspace{-2ex}
\item[\ttmkey{value\_format}{in {\tt min::obj\_format}}]\vspace{-2ex}~\\
These are the \TT{min::gen\_format}'s used to print the
object vector elements,
attribute labels, and attribute values, respectively, in all formats
except empty compact, quote compact, logical line compact,
and indented paragraph compact.

\TT{Label\_\EOL format} is also used to print \TT{.type} values $T$
printed as types, e.g., in the forms `\TT{\{$T$|}' and `\TT{|$T$\}}',
and not as attribute values.

\underline{None} of these members may be \TT{NULL}.

\item[\ttmkey{quote\_element\_format}{in {\tt min::obj\_format}}]~\\
The is the \TT{min::gen\_format} used to print object elements
in quote compact format.  No attributes are printed in this format.

\item[\ttmkey{top\_element\_format}{in {\tt min::obj\_format}}]~\\
The is the \TT{min::gen\_format} used to print object elements
in logical line and indented paragraph compact formats.
No attributes are printed in these formats, which are used for
objects that represent lines and paragraphs and are not inside
any other kinds of objects.

\item[\ttmkey{initiator\_format}{in {\tt min::obj\_format}}]
\item[\ttmkey{separator\_format}{in {\tt min::obj\_format}}]\vspace{-2ex}
\item[\ttmkey{terminator\_format}{in {\tt min::obj\_format}}]\vspace{-2ex}~\\
These are the \TT{min::gen\_format}'s used to print the
\TT{.initiator} and \TT{.terminator} in bracketed compact
format, and the \TT{.separator} in compact or normal format.
\TT{Separator\_\EOL format} should never be \TT{NULL}, and the
other members must be not be \TT{NULL} if compact
format is enabled.

\item[\ttmkey{mark\_classifier}{in {\tt min::obj\_format}}]~\\
\label{MARK_CLASSIFIER}
This is a \TT{min::str\_classifier} used to classify
a \TT{.type} string value \TT{T} to see if
a compact object printout of the
form `\TT{\{T|}\ldots\TT{|\}}' may be replaced by `\TT{\{T}\ldots\TT{T\}}',
and to classify the two strings in a \TT{.type} label value \TT{[< T1 T2 >]}
to see if a compact object printout of the
form `\TT{\{[< T1 T2 >]|}\ldots\TT{|\}}' may be replaced by
`\TT{\{T1}\ldots\TT{T2\}}',
See \pagref{MARK_CLASSIFIER_USAGE}.

\item[\ttmkey{quote\_type}{in {\tt min::obj\_format}}]~\\
If an object being printed in compact format has \TT{.type} attribute
equal to \TT{quote\_\EOL type} and does not have
\TT{.initiator}, \TT{.separator}, or \TT{.terminator} attributes,
the object is printed in quote compact format
as a list of its elements with each element
being printed using the \TT{quote\_\EOL element\_\EOL format}.
This is typically used to replace \TT{\{"~...~"\}} by
\TT{"..."}.

\item[\ttmkey{obj\_empty}{in {\tt min::obj\_format}}]~\\
This is the \TT{min::pstring} printed in empty compact format
to represent an empty object that has no elements and no attributes
other than \TT{.position} and \TT{.separator}.  E.g., `\TT{\{\}}'.

\item[\ttmkey{obj\_bra}{in {\tt min::obj\_format}}]
\item[\ttmkey{obj\_braend}{in {\tt min::obj\_format}}]\vspace{-2ex}
\item[\ttmkey{obj\_ketbegin}{in {\tt min::obj\_format}}]\vspace{-2ex}
\item[\ttmkey{obj\_ket}{in {\tt min::obj\_format}}]\vspace{-2ex}~\\
These are the \TT{min::pstring}'s printed to bracket
object elements and attributes in compact, normal, and embedded line format.
E.g., `\TT{\{}', `\TT{|}', `\TT{|}', and `\TT{\}}'.

\item[\ttmkey{obj\_sep}{in {\tt min::obj\_format}}]~\\
This member serves as the object element separator in compact
or normal format when the object does
not have a \TT{.separator} attribute.  E.g., a single space.

\item[\ttmkey{obj\_attrbegin}{in {\tt min::obj\_format}}]
\item[\ttmkey{obj\_attrsep}{in {\tt min::obj\_format}}]\vspace{-2ex}~\\
These are the \TT{min::pstring}'s printed in normal format to introduce
an object attribute list (e.g., `\TT{:}')
and separate attributes in that list. (e.g., `\TT{,}').

\item[\ttmkey{obj\_attreol}{in {\tt min::obj\_format}}]~\\
This is the \TT{min::pstring} printed in embedded line and isolated line
formats just after the object elements
to introduce the indented paragraph containing the object attributes.
E.g., `\TT{:}'.

\item[\ttmkey{obj\_attreq}{in {\tt min::obj\_format}}]~\\
This is the \TT{min::pstring} printed to
separate an attribute label from its value.  E.g., `\TT{=}'.

\item[\ttmkey{obj\_attrneg}{in {\tt min::obj\_format}}]~\\
This is the \TT{min::pstring} printed to indicate
negation of attributes whose value is \TT{FALSE}.
Attributes with value \TT{TRUE} are printed as just
the attribute label with no following \TT{obj\_\EOL attreq} or value.
Attributes with value \TT{FALSE} are printed as just
\TT{obj\_\EOL attrneg} followed by
the attribute label with no following \TT{obj\_\EOL attreq} or value.
E.g., `\TT{no\textvisiblespace}'.

\item[\ttmkey{flag\_format}{in {\tt min::obj\_format}}]~\\
This format is used to print attribute flag names.  Its value may
\underline{not} be \TT{NULL}.  See \pagref{ATTRIBUTE-FLAG-NAMES}.

WARNING: \TT{flag\_format->flag\_names} is
\underline{not} locatable by the ACC, and its value must therefore be
stored elsewhere in a locatable variable.  It is expected that values of
\TT{flag\_\EOL format->\EOL flag\_\EOL names} will never be garbage
collected and will be pointed at by
\TT{static min::\EOL locatable\_\EOL var} variables.

\item[\ttmkey{hide\_flags}{in {\tt min::obj\_format}}]~\\
If an object attribute has any of these flags, the attribute is ignored
and not printed when the object is printed.  This member is a bit
mask for flags \TT{0} through \TT{63}.  It is standardly set so the
`\TT{H}' flag hides attributes (such as \TT{.position}).

\item[\ttmkey{obj\_valbegin}{in {\tt min::obj\_format}}]
\item[\ttmkey{obj\_valsep}{in {\tt min::obj\_format}}]\vspace{-2ex}
\item[\ttmkey{obj\_valend}{in {\tt min::obj\_format}}]\vspace{-2ex}~\\
These are the \TT{min::pstring}'s printed to surround and
separate values of an attribute that has more than one
value.  E.g., `\TT{\{*}', `\TT{,}', and `\TT{*\}}'.

\item[\ttmkey{obj\_valreq}{in {\tt min::obj\_format}}]~\\
This is a \TT{min::pstring} printed to separate a reverse
attribute value or list of reverse attribute values from
their reverse attribute label, which follows this \TT{min::pstring}.
E.g., `\TT{<=}'.

\end{itemlist}

Whenever an object is printed using an object format, the printer
format is first saved, automatic
breaks are disabled by \TT{min::\EOL no\_\EOL auto\_\EOL break},
and a break is set by \TT{min::set\_\EOL break} before
the object is printed.  The printer format is restored after the
object is printed.

In \mkey{bracketed compact format}{of printed object}, where there are
\TT{.initiator} and \TT{.terminator} attributes, the only one of the
above \TT{pstring}'s that might be used is \TT{obj\_sep}, which is
used if there is no \TT{.separator} attribute.
If
\begin{center}
\begin{tabular}{lcl}
\TT{.initiator}		& is	& \TT{"["} \\
\TT{.separator}		& is	& \TT{","} \\
\TT{.terminator}	& is	& \TT{"]"} \\
\end{tabular}
\end{center}
then the object is printed in the format:
\begin{center}
\TT{[} $\ell$ {\em <element>}
    \OPEN{} {\em ta} \TT{,} \TT{\textvisiblespace} {\em <element>} \CLOSE\STAR{}
    {\em t} \TT{]}
\end{center}
where
\begin{center}
\begin{tabular}{lcl}
$\ell$			& is	& \TT{min::leading} \\
{\em ta}		& is	& \TT{min::trailing\_always} \\
\TT{\textvisiblespace}	& is	& a single space character \\
{\em t}			& is	& \TT{min::trailing} \\
\end{tabular}
\end{center}

The indent is saved and set by \TT{min::save\_\EOL indent} just before
printing the first element (and restored by \TT{min::\EOL restore\_\EOL indent}
after printing the object), and a break is set by
\TT{min::set\_break} just before printing every element but the first.
If the \TT{.separator} attribute is missing, then
`{\em ta} \TT{,} \TT{\textvisiblespace}' is replaced by what
is printed by \TT{obj\_sep}, which would be a single space
character for all the above object formats for which compact
printing is enabled.  If there is no \TT{.type} attribute,
\TT{T} is omitted, as in `\TT{\{|\ldots|\}}'.

In \mkey{empty compact format}{of printed object}, where there are
are no elements and no attributes other than \TT{.separator} and
attributes with a \TT{hide\_\EOL flag},
just \TT{obj\_empty} is printed, which for the above compact
enabled object formats is just `\TT{\{\}}'.

In \mkey{quote compact format}{of printed object}, where there are
are no attributes other than \TT{.type}
and attributes with a \TT{hide\_\EOL flag},
with \TT{.type} being equal to \TT{quote\_\EOL type},
the object elements are just printed using
\TT{quote\_\EOL element\_\EOL format} with elements being
separated by a single space.  A break is set by
\TT{min::set\_\EOL break} just before each element is printed.

Typically \TT{quote\_\EOL type} is set
to \TT{min::\EOL doublequote} which is just the string consisting
of a single \TT{"}, and \TT{quote\_\EOL element\_\EOL format} is set to
\TT{min::\EOL always\_\EOL quote\_\EOL gen\_\EOL format}, so
if the object \TT{.type} is \TT{"} and the object
elements are strings, just the elements are printed as quoted
strings.  Thus instead of printing a one element object
as \TT{\{"<Q>"|\ldots|"<Q>"\}}, the object prints as \TT{"\ldots"}.

In \mkey{logical line compact format}{of printed object},%
\label{LOGICAL-LINE-COMPACT-FORMAT}
where there are
are no attributes other than \TT{.initiator}, \TT{.terminator},
and attributes with a \TT{hide\_\EOL flag},
the \TT{.initiator} is equal to \TT{min::\EOL LOGICAL\_\EOL LINE()},
the object elements are just printed using
\TT{top\_\EOL element\_\EOL format} with elements being
separated by a single space.
A break is set by
\TT{min::set\_\EOL break} just before each element is printed.

If there is a \TT{.terminator} not equal to \TT{"<LF>"}, that
is printed just after the line.
In this case the line is called a \key{terminated line}.

Note that nothing is done before the first element to indent
the line and \underline{no} end of line is output after the line.
Lines are elements of other objects whose format is supposed to
supply pre-line indentation and post-line end of lines, or they
are the ends of top level lines that supply pre-line indentation
and post-line end of lines.

In \lmkey{indented paragraph}{compact format}{of printed object},%
\label{INDENTED-PARAGRAPH-COMPACT-FORMAT}
there are
are no attributes other than \TT{.ini\-ti\-ator}, \TT{.terminator},
and attributes with a \TT{hide\_\EOL flag},
the \TT{.terminator} is equal to \TT{min::\EOL INDENTED\_\EOL PARAGRAPH()},
and the object is the last element of a non-terminated line printed with
logical line compact format which has
at least one line element preceding
the paragraph.  First single spaces are erased from the end of the
current line by \TT{min::\EOL print\_\EOL erase\_\EOL space}, then 
\TT{min::\EOL trailing\_\EOL always} is printed,
followed by the \TT{.initiator}, followed by \TT{min::eol}, and lastly the
object elements are printed using \TT{top\_\EOL element\_\EOL format}.

The elements of a paragraph are supposed to be lines printed in
logical line compact format, and elements which are not thus are printed as if
they were one element non-terminated lines.
Define a \key{line group} as a maximal sequence of terminated lines followed
by a non-terminated line, or a maximal sequence of terminated lines at the end
of a paragraph.
Because the paragraph is the last thing in a containing line group, the indent
at the beginning of the paragraph is already set to 4 plus the indent
of the paragraph's containing line group, so the indent is already
correctly set.  A paragraph is itself a sequence of line groups,
and in indented paragraph compact format each of these is preceded by
executing \TT{min::\EOL indent}, \TT{min::\EOL save\_\EOL indent},
and \TT{min::\EOL place\_\EOL indent(4)} in order and followed by
executing \TT{min::\EOL restore\_\EOL indent}.  This indents the beginning of
the line group and indents continuations of the line group beyond the beginning
of the line group.  Lastly, the lines in a line group are separated
by single spaces, and \TT{min::\EOL bol} is executed at the end of
the paragraph.

An empty paragraph prints nothing but \TT{obj\_\EOL paragraph\_\EOL begin}
followed by \TT{min::eol}.

In \mkey{default compact format}{of printed object}, where there are
are no attributes other than \TT{.type}, \TT{.sep\-a\-ra\-tor},
and attributes with a \TT{hide\_\EOL flag},
and none of the above compact formats apply.
Then if

\begin{center}
\begin{tabular}{lcl}
\TT{obj\_bra}		& is	& \TT{"\{"} \\
\TT{obj\_braend}	& is	& \TT{"|"} \\
\TT{obj\_ketbegin}	& is	& \TT{"|"} \\
\TT{obj\_ket}		& is	& \TT{"\}"} \\
\TT{.type}		& is	& \TT{"T"} \\
\TT{.separator}		& is	& \TT{","} \\
\end{tabular}
\end{center}
where \TT{T} is a string that is \underline{not} a mark as described
below, then the format is
\begin{center}
\TT{\{}\TT{T}\TT{|} {\em <element>}
    \OPEN{} {\em ta} \TT{,} \TT{\textvisiblespace} {\em <element>} \CLOSE\STAR{}
    \TT{|}\TT{T}\TT{\}}
\end{center}
which is as for the bracketed compact format above
except that `\TT{[} $\ell$' has been replaced
by `\TT{\{T|}' where `\TT{\{}' is what \TT{obj\_\EOL bra} prints and
`\TT{|}' is what \TT{obj\_\EOL braend} prints, and
`{\em t} \TT{]}' has been replaced
by `\TT{|T\}}' where `\TT{|}' is what \TT{obj\_\EOL ketend} prints and
`\TT{\}}' is what \TT{obj\_\EOL ket} prints.
If any explicit
spaces, leading spaces, or trailing spaces
are to be printed, these must be encoded in
the \TT{obj\_}\ldots{} \TT{pstring}'s.

If in this format if there is no \TT{.type} attribute, it is omitted, as in
`\TT{\{|\ldots|\}}'.  If there is a \TT{.type} attribute \TT{"T"} and
the \TT{NO\_\EOL TRAILING\_\EOL TYPE}
object format operation flag on, then \TT{T} is omitted from `\TT{|T\}}' which
becomes `\TT{|\}}'.

If instead \TT{mark\_\EOL classifier}\label{MARK_CLASSIFIER_USAGE} is not
\TT{NULL} and \TT{T} is a string
whose \TT{mark\_\EOL classifier} defined
string class has the \TT{min::\EOL IS\_\EOL MARK} flag, then the format becomes
\begin{center}
\TT{\{}\TT{T} {\em <element>}
    \OPEN{} {\em ta} \TT{,} \TT{\textvisiblespace} {\em <element>} \CLOSE\STAR{}
    \TT{T}\TT{\}}
\end{center}
which is the same as above but with the \TT{|}'s omitted.
E.g., if \TT{"+"} is a \TT{.type} value whose \TT{mark\_\EOL classifier} string
class has the \TT{min::\EOL IS\_\EOL MARK} flag,
the format is `\TT{\{+}\ldots\TT{+\}}'.

If instead \TT{mark\_\EOL classifier} is not
\TT{NULL} and the \TT{.type} attribute is a two element label created by
\TT{min::new\_\EOL lab\_\EOL gen("T1","T2")} and
\TT{T1} and \TT{T2} are strings whose \TT{mark\_\EOL classifier} computed
string classes either
\underline{both} have the \TT{min::\EOL IS\_\EOL MARK} flag, or
\TT{"T1"}'s string class has the \TT{min::\EOL IS\_\EOL LEADING} flag and
\TT{"T2"}'s string class has the \TT{min::\EOL IS\_\EOL TRAILING} flag,
then the format is
\begin{center}
\TT{\{}\TT{T1} {\em <element>}
    \OPEN{} {\em ta} \TT{,} \TT{\textvisiblespace} {\em <element>} \CLOSE\STAR{}
    \TT{T2}\TT{\}}
\end{center}
in which \TT{T1} is used with the opening bracket and \TT{T2} is used
with the closing bracket.
E.g., if \TT{min::\EOL new\_\EOL lab\_\EOL gen("<",">")} is a \TT{.type}
value with both \TT{"<"} and \TT{">"} being strings whose
\TT{mark\_\EOL classifier} string classes both have the
\TT{min::\EOL IS\_\EOL MARK} flag, the format is `\TT{\{<}\ldots\TT{>\}}'.

Note that if the `\TT{|}'s (i.e., \TT{obj\_\EOL braend} and
\TT{obj\_\EOL ketbegin}) are omitted by the action of
\TT{mark\_\EOL classifier}, then the \TT{NO\_\EOL TRAILING\_\EOL TYPE}
object format operation flag has \underline{no} effect.

\ikey{Normal format}{normal format!of printed object}, in which there
are attributes other than \TT{.type}, \TT{.separator}, and \TT{.posi\-tion}
that are to be printed as attributes,
is like default compact format except that if:
\begin{center}
\begin{tabular}{lcl}
\TT{obj\_attrbegin}	& is	& \TT{": "} \\
\TT{obj\_attrsep}	& is	& \TT{", "} \\
\TT{obj\_attreq}	& is	& \TT{" = "} \\
\TT{obj\_attrneg}	& is	& \TT{"no "} \\
\end{tabular}
\end{center}
then `\TT{\{T|}' is replace by
\begin{center}
\TT{\{}\TT{T}\TT{:\textvisiblespace} {\em <attribute>}
    \OPEN{} \TT{,\textvisiblespace} {\em attribute} \CLOSE\STAR{} \TT{|}
\end{center}
where
\begin{center}
\begin{tabular}{rcl}
{\em attribute} & ::= & {\em attribute-label-and-flags}
                        \TT{\textvisiblespace=\textvisiblespace}
			{\em attribute-value} \\
		& $|$ & {\em attribute-label-and-flags} \\
		& $|$ & \TT{no\textvisiblespace}
		        {\em attribute-label-and-flags} \\
\end{tabular}
\end{center}

Here the attribute label in {\em attribute-label-and-flags} is printed with
\TT{label\_\EOL format} and the flags are printed with \TT{flags\_\EOL format}.
See \pagref{ATTRIBUTE-FLAG-NAMES} for  more detail on printing the flags.
The {\em attribute-value} is printed with with \TT{value\_\EOL format}.
What would be `{\em attribute-label-and-flags} \TT{= TRUE}' is replaced by
just `{\em attribute-label-and-flags}\,', and what
would be `{\em attribute-label-and-flags} \TT{= FALSE}' is replaced by
just `\TT{no }{\em attribute-label-and-flags}\,'.

The \mkey{embedded line format}{of printed object} prints the object
on separate lines, but is indented for use where the object is an
element of some containing object.  If
\begin{center}
\begin{tabular}{lcl}
\TT{obj\_bra}		& is	& \TT{"\{"} \\
\TT{obj\_braend}	& is	& \TT{"|"} \\
\TT{obj\_sep}		& is	& \TT{" "} \\
\TT{obj\_ketbegin}	& is	& \TT{"|"} \\
\TT{obj\_ket}		& is	& \TT{"\}"} \\
\TT{.type}		& is	& \TT{"T"} \\
\TT{obj\_attreol}	& is	& \TT{":"} \\
\TT{obj\_attreq}	& is	& \TT{" = "} \\
\TT{obj\_attrneg}	& is	& \TT{"no "} \\
\end{tabular}
\end{center}
then the object in embedded line format has the form:
\begin{center}
\begin{tabular}{l}
\TT{\{T|} {\em element}
          \OPEN{} \textvisiblespace {\em element} \CLOSE\STAR{}\TT{:} \\
~~~~{\em attribute} \\
~~~~\ldots\ldots\ldots \\
~~~~{\em attribute} \\
\TT{|T\}} \\
\end{tabular}
\end{center}

The object begins as if it were in default compact format, but
any \TT{.separator} attribute is \underline{not} used
to separate elements (\TT{obj\_\EOL sep} is used), and the
list of elements is terminated by \TT{obj\_\EOL attreol} (\TT{:} here)
which introduces an indented paragraph with one attribute per line,
so that \TT{obj\_\EOL attrsep} is \underline{not} used.
The object printout begins with a \TT{min::\EOL indent} operation and
ends with a \TT{min::\EOL eol} operation.
If there are no attributes other than \TT{.type},
in particular no \TT{.separator} attribute,
\TT{obj\_\EOL attreol} (\TT{:} here) is \underline{not} printed and
embedded line format is identical to normal format except for
the \TT{min::\EOL indent} and \TT{min::\EOL eol} operations.

The \mkey{isolated line format}{of printed object} prints the object
on separate lines, and is indented for use when the object is
isolated and \underline{not} inside a containing object,
as when the object is printed when flushing an identifier map
(\itemref{PRINTING-USING-AN-IDENTIFIER-MAP}).  If
\begin{center}
\begin{tabular}{lcl}
\TT{obj\_sep}		& is	& \TT{" "} \\
\TT{obj\_attreol}	& is	& \TT{":"} \\
\TT{obj\_attreq}	& is	& \TT{" = "} \\
\TT{obj\_attrneg}	& is	& \TT{"no "} \\
\end{tabular}
\end{center}
then the object in isolated line format has the form:
\begin{center}
\begin{tabular}{l}
{\em element}
          \OPEN{} \textvisiblespace {\em element} \CLOSE\STAR{}\TT{:} \\
~~~~{\em attribute} \\
~~~~\ldots\ldots\ldots \\
~~~~{\em attribute} \\
\end{tabular}
\end{center}

Here \underline{every} attribute, including \TT{.type} and \TT{.separator},
is output on its own indented subparagraph line.
The output ends with a \TT{min::\EOL eol} operation,
but does \underline{not} begin with any special printer operation.  If
there are no attributes, the indented paragraph and its introducing
`\TT{:}' are omitted, but the output ends with \TT{min::\EOL eol}.
If there are no attributes and no elements, nothing is output but the
\TT{min::\EOL eol}.

Attribute flags\label{ATTRIBUTE-FLAG-NAMES}
are printed immediately after the attribute's label
if the attribute has any flags, according to the \TT{flag\_\EOL format}.
If:
\begin{center}
\begin{tabular}{lcl}
\TT{flag\_format->flag\_prefix}		& is	& \TT{"["} \\
\TT{flag\_format->flag\_postfix}	& is	& \TT{"]"} \\
\TT{flag\_format->flag\_names}		& is
			    & \TT{min::standard\_attr\_flag\_names} \\
\end{tabular}
\end{center}

then the attribute label and flags are printed in the format:

\newcommand{\TTBS}[1]{\TT{\textbackslash#1}}
\begin{center}
\begin{tabular}{rcl}
{\em attribute-label-and-flags} & ::= & {\em attribute-label}
                                        {\em attribute-flags}\QMARK{} \\
{\em attribute-flags}
    & ::= & \TT{[}{\em attribute-flag-name}$^\star$\TT{]} \\
{\em attribute-flag-name} & ::= &
        \TT{*} $|$ \TT{+} $|$ \TT{-} $|$ \TT{/} $|$ \TT{@}
    $|$ \TT{\&} $|$ \TT{\#} $|$ \TT{=} $|$ \TT{\$}
    $|$ \TT{\%} $|$ \TT{<} $|$ \TT{>} \\
& $|$ & \TT{a} $|$ \ldots{} $|$ \TT{z} $|$ \TT{A} $|$ \ldots{} $|$ \TT{Z} \\
& $|$ & \TT{,}{\em flag-number}
\end{tabular}
\end{center}

Here {\em attribute-flag-names} are listed in the order of their flag number,
where the correspondence given
by \TT{min::\EOL standard\_\EOL attr\_\EOL flag\_\EOL names} is
\begin{center}
\begin{tabular}{r@{~correspond to flag numbers~}l}
\TT{*} \ldots{} \TT{>} & \TT{0} \ldots{} \TT{11} \\
\TT{a} \ldots{} \TT{z} & \TT{12} \ldots{} \TT{37} \\
\TT{A} \ldots{} \TT{Z} & \TT{38} \ldots{} \TT{63} \\
\end{tabular}
\end{center}

Note these names are chosen so that any sequence of them forms
a string whose \TT{min::stan\-dard\_\EOL str\_\EOL classifier} string
class has the \TT{min::\EOL IS\_\EOL GRAPHIC} flag and does
\underline{not} have the \TT{min::\EOL NEEDS\_\EOL QUOTES} flag.

Character strings that are sequences of {\em attribute-flag-names}
can be parsed by applying a \key{flag parser} using the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{parse\_flags}\ARGBREAK
    \verb|( min::uns32 * flag_numbers,|\ARGBREAK
    \verb|  char * text_buffer,|\ARGBREAK
    \verb|  const min::flag_parser * flag_parser )|
\LABEL{MIN::PARSE_FLAGS} \\
\end{tabular}\end{indpar}

This function takes its input character string from the \TT{text\_\EOL buffer}
argument, outputs the flag numbers whose names are in this character
string in the \TT{flag\_\EOL numbers} vector, and returns the length
of this vector (i.e., number of flag numbers output).
The \TT{flag\_\EOL numbers} vector \underline{must have}
a length
at least as great as the length of (number of characters in) the
input \TT{text\_\EOL buffer}, as the parser may output
one flag number per character input, but cannot output more.
If there are no errors, the function sets
\TT{text\_\EOL buffer} to the empty string, but if there are errors,
it sets it to a string of the form
\begin{center}
{\em error-character-sequence}
    \{ \TT{,} {\em error-character-sequence} \}\STAR{}
\end{center}
which is made from the input \TT{text\_\EOL buffer} by replacing
every string of correctly interpreted characters by a single comma,
and lastly deleting any beginning or ending comma,
leaving sequences of incomprehensible
characters separated by commas.  Incomprehensible characters are ignored
by the parser.

Flag parsers accept sequences of digits as flag numbers,
provided commas are used to separate these from each other and from other
flag names.  Commas used to separate flag names are ignored.
Digits and commas cannot be used in a flag names.

The first element of a \TT{min::flag\_parser}
(\pagref{MIN::FLAG_PARSER})
is a function that executes
\TT{min::\EOL parse\_\EOL flags}, so a \TT{min::flag\_\EOL parser}
is in effect a closure.  The usual first element is the address of
the function:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{standard\_flag\_parser}\ARGBREAK
    \verb|( min::uns32 * flag_numbers,|\ARGBREAK
    \verb|  char * text_buffer,|\ARGBREAK
    \verb|  const min::flag_parser * flag_parser )|
\LABEL{MIN::STANDARD_FLAG_PARSER} \\
\end{tabular}\end{indpar}

This function assumes that flag names are of the form
\TT{"\textbackslash x01\textbackslash x01" "C"} for some single
UNICODE character \TT{C}, and uses
\begin{center}
\verb|flag_parser->flag_map[C]|
\end{center}
as the flag number associated with \TT{C}.
The value \TT{min::\EOL NO\_\EOL FLAG} is used to indicate there
is no flag number associated with \TT{C}.  Also, if
\begin{center}
\verb|C >= flag_parser->flag_map_length|
\end{center}
then there is no flag number associated with \TT{C}.

The \TT{min::standard\_attr\_flag\_parser}
(\pagref{MIN::STANDARD_ATTR_FLAG_PARSER})
parses character strings
that contain flag names taken from \TT{min::\EOL standard\_\EOL
attr\_\EOL flag\_\EOL names}.  Thus if this parser is given
the \TT{text\_\EOL buffer} input `\TT{*a(b)\_c34,200,5d}' the
flag numbers output would be 0, 12, 13, 14, 200, 15 and the
\TT{text\_\EOL buffer} output would be `\TT{(,)\_,34,5}'.

The following function can be used to print object general values:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_obj}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen obj,|\ARGBREAK
    \verb|  const min::obj_format * obj_format,|\ARGBREAK
    \verb|  min::uns32 obj_op_flags )|
\LABEL{MIN::PRINT_OBJ} \\
\end{tabular}\end{indpar}

This function prints the object using the given \TT{obj\_\EOL format}
with \TT{obj\_\EOL format->obj\_\EOL op\_\EOL flags} replaced by
the \TT{obj\_\EOL op\_\EOL flags} argument.  Either or both of the
last two arguments may be omitted as in

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_obj}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen obj,|\ARGBREAK
    \verb|  const min::obj_format * obj_format )|
\LABEL{MIN::PRINT_OBJ_WITHOUT_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_obj}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen obj,|\ARGBREAK
    \verb|  min::uns32 obj_op_flags )|
\LABEL{MIN::PRINT_OBJ_WITHOUT_FORMAT} \\
\end{tabular}\end{indpar}

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|min::printer min::| & \MINKEY{print\_obj}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen obj )|\ARGBREAK
\LABEL{MIN::PRINT_OBJ_BARE} \\
\end{tabular}\end{indpar}

If \TT{obj\_format} is omitted,
\begin{center}
\TT{printer->print\_format.gen\_format->obj\_format}
\end{center}
is used in its place.  If \TT{obj\_op\_flags} is omitted,
\TT{obj\_\EOL format->obj\_\EOL op\_\EOL flags} is used
in its place.

The expression `\TT{printer~<{}<~min::pgen(v)}' is equivalent to
\begin{center}
\TT{min::print\_obj(printer,v)}
\end{center}
if \TT{v} is an object.


\subsection{TBD Obsolete}

Old stuff to be deleted as it is incorporated elsewhere.

The \TT{min::gen\_format} members are:

\begin{itemlist}[0.4in]

\item[\ttmkey{str\_max\_length}{in {\tt min::gen\_format}}]~\\
This member is only enabled if \TT{STR\_\EOL ID\_\EOL FLAG} is on.
In this case \TT{min::gen} string values that have length greater
than \TT{str\_\EOL max\_\EOL length} have an identifier i allocated
in \TT{printer->\EOL id\_\EOL map} and are printed as `\TT{@}i'.

\end{itemlist}

Strictly for testing purposes, in situations where \TT{min::printer}'s
are not working, general values can be printed to \TT{std::ostreams}:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<{}<}{of {\tt std::ostream \&}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::gen g )|
\LABEL{OPERATOR<<_OF_OSTREAM_AND_GEN} \\
\end{tabular}\end{indpar}

Objects print as `\TT{new\_stub\_gen (} {\em address} \TT{)}',
but other \TT{min::gen} values print in a reasonable way.

\begin{indpar}[0.1in]\begin{itemlist}[0.4in]


\item[\ttmkey{STR\_ID\_FLAG}{of {\tt min::gen\_format} flag}]~\\
If set, \TT{min::gen} string values that have length greater
than \TT{str\_\EOL max\_\EOL length} (see below)
have an identifier i allocated
in \TT{printer->\EOL id\_\EOL map} and are printed as `\TT{@}i'.
Otherwise string values are printed normally.

\end{itemlist}\end{indpar}

\section{Code and Execution}

\subsection{Execution Flags}
\label{EXECUTION-FLAGS}

TBD: relocation flag

\section{TBD Implementation Ideas}


\subsection{Stack and not Ephemeral}

Instead of ephemeral, we use stack objects.  A stack stub is a stub that
is only reachable from pointers in the stack.   When a stack stub
pointer (as a general value) is stored in a non-stack object, the price
of tracing what it points at to make its target non-stack is paid.
This is a logical time to pay this cost.

\section{To Do}

\clearpage

\appendix

\centerline{\Large \bf Appendices}

\section{C/C++ Interface}
\label{C/C++-Interface}

{
\renewcommand{\LABEL}[1]{\dotfill~\pagref{#1}}
\renewcommand{\TT}[1]{{\tt #1}}
\renewcommand{\TTKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\TTMKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\TTBMKEY}[2]{{\tt ~~[#1]~~}}
\renewcommand{\TTDMKEY}[2]{{\tt ~~.#1~~}}
\renewcommand{\TTOMKEY}[3]{{\tt ~~operator~~#2~~}}
\renewcommand{\TTMOKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\TTARMKEY}[2]{{\tt ~~->#1~~}}
\renewcommand{\MINKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MINLKEY}[2]{{\tt ~~#1#2~~}}
\renewcommand{\MINIKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\MINMKEY}[2]{{\tt ~~#1~~}}
\renewcommand{\MUPKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\ttkey}[1]{{\tt ~~#1~~}}

\newcommand{\INDEXHEADER}[1]{{\bf #1}:\vspace{1ex}}
\newlength{\TABULARLEN}
\newenvironment{TABULAR}[1]%
  {\setlength{\TABULARLEN}{6.2in}
   \addtolength{\TABULARLEN}{-#1}
   \begin{tabular}{@{}r@{}l@{}}
   \hspace*{#1} & \hspace*{\TABULARLEN} \\[-4ex]}%
  {\end{tabular}}

Unless otherwise noted, this interface is defined by \verb|min.h|.

\INDEXHEADER{Abbreviations}

These are to be included in user's code, and are \underline{not}
in \verb|min|\ldots\verb|.h| files.

\begin{indpar}[0.2in]
\begin{tabular}{@{}p{6.2in}@{}}
\verb|#define MUP  min::unprotected|
\LABEL{MUP} \\
\verb|#define MOS  min::os|
\LABEL{MOS} \\
\verb|#define MACC min::acc|
\LABEL{MACC} \\
\verb|#define MINT min::internal|
\LABEL{MINT} \\
\end{tabular}
\end{indpar}

\INDEXHEADER{Compilation Macros}

These are in \verb|min_parameters.h|.

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_NO\_PROTECTION}
\LABEL{MIN_NO_PROTECTION} \\
\TTKEY{MIN\_IS\_COMPACT}
\LABEL{MIN_IS_COMPACT} \\
\TTKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\TTKEY{MIN\_IS\_LOOSE}
\LABEL{MIN_IS_LOOSE}	 \\
\TTKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
\LABEL{MIN_MAX_NUMBER_OF_STUBS} \\
\TTKEY{MIN\_STUB\_BASE}
\LABEL{MIN_STUB_BASE} \\
\TTKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS} \\
\TTKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS} \\
\TTKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\TTKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS}
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\TTKEY{MIN\_CONTEXT\_SIZE\_LIMIT}
\LABEL{MIN_CONTEXT_SIZE_LIMIT} \\
\end{tabular}

\end{indpar}

\INDEXHEADER{Assert Macros and Functions}

\begin{indpar}[0.2in]

These are in \verb|min_parameters.h|.

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_ASSERT($e$,...)}
\LABEL{MIN_ASSERT} \\
\TTKEY{MIN\_ASSERT\_CALL\_ON\_FAIL($e$,...)}
\LABEL{MIN_ASSERT_CALL_ON_FAIL} \\
\TTKEY{MIN\_ASSERT\_CALL\_ALWAYS($e$,...)}
\LABEL{MIN_ASSERT_CALL_NEVER} \\
\TTKEY{MIN\_ASSERT\_CALL\_NEVER($e$,...)}
\LABEL{MIN_ASSERT_CALL_ALWAYS} \\
\TTKEY{MIN\_REQUIRE($e$)}
\LABEL{MIN_REQUIRE} \\
\TTKEY{MIN\_CHECK($e$)}
\LABEL{MIN_CHECK} \\
\TTKEY{MIN\_ABORT(...)}
\LABEL{MIN_ABORT} \\
\end{tabular}

\begin{TABULAR}{1.2in}
\verb|void ( * min::| & \MINKEY{assert\_hook} \verb|)|\ARGBREAK
    \verb|( bool value,|\ARGBREAK
    \verb|  const char * expression,|\ARGBREAK
    \verb|  const char * file_name, unsigned line_number,|\ARGBREAK
    \verb|  const char * function_name,|\ARGBREAK
    \verb|  const char * message_format, ... )|
\LABEL{MIN::ASSERT_HOOK} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{standard\_assert}\ARGBREAK
    \verb|( bool value,|\ARGBREAK
    \verb|  const char * expression,|\ARGBREAK
    \verb|  const char * file_name, unsigned line_number,|\ARGBREAK
    \verb|  const char * function_name,|\ARGBREAK
    \verb|  const char * message_format, ... )|
\LABEL{MIN::STANDARD_ASSERT} \\
\verb|bool min::| & \MINKEY{assert\_print} \verb|= false|
\LABEL{MIN::ASSERT_PRINT} \\
\verb|bool min::| & \MINKEY{assert\_throw} \verb|= false|
\LABEL{MIN::ASSERT_THROW} \\
\verb|bool min::| & \MINKEY{assert\_abort} \verb|= true|
\LABEL{MIN::ASSERT_ABORT} \\
\verb|struct min::| & \MINKEY{assert\_exception} \verb|{ }|
\LABEL{MIN::ASSERT_EXCEPTION} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Numeric Types}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{uns8}
\LABEL{MIN::UNS8} \\
\verb|min::| & \MINKEY{int8}
\LABEL{MIN::INT8} \\
\verb|min::| & \MINKEY{uns16}
\LABEL{MIN::UNS16} \\
\verb|min::| & \MINKEY{int16}
\LABEL{MIN::INT16} \\
\verb|min::| & \MINKEY{uns32}
\LABEL{MIN::UNS32} \\
\verb|min::| & \MINKEY{int32}
\LABEL{MIN::INT32} \\
\verb|min::| & \MINKEY{float32}
\LABEL{MIN::FLOAT32} \\
\verb|min::| & \MINKEY{uns64}
\LABEL{MIN::UNS64} \\
\verb|min::| & \MINKEY{int64}
\LABEL{MIN::INT64} \\
\verb|min::| & \MINKEY{float64}
\LABEL{MIN::FLOAT64} \\
\verb|min::| & \MINKEY{unsptr}
\LABEL{MIN::UNSPTR} \\
\verb|min::| & \MINKEY{intptr}
\LABEL{MIN::INTPTR} \\
\verb|min::| & \MINKEY{unsgen}
\LABEL{MIN::UNSGEN} \\
\verb|min::| & \MINKEY{Uchar}
\LABEL{MIN::UCHAR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{General Value Types and Constants}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{stub}
\LABEL{MIN::STUB} \\
\verb|min::| & \MINKEY{gen}
\LABEL{MIN::GEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.0in}
\verb|typedef |
	& \verb|min::uns32|
	  \verb|min::|\MINKEY{unsgen}\COMPACT
\LABEL{MIN::COMPACT_UNSGEN} \\
\verb|typedef |
	& \verb|min::uns64|
	  \verb|min::|\MINKEY{unsgen}\LOOSE
\LABEL{MIN::LOOSE_UNSGEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.0in}
\verb|const unsigned min::| & \MINKEY{TSIZE}
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
\LABEL{MIN::VSIZE}
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Stub Type Codes}\label{STUB-TYPE-CODE-LIST}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|const int min::| & \MINKEY{DEALLOCATED}
\LABEL{MIN::DEALLOCATED} \\
\verb|const int min::| & \MINKEY{PREALLOCATED}
\LABEL{MIN::PREALLOCATED} \\
\verb|const int min::| & \MINKEY{NUMBER}
\LABEL{MIN::NUMBER} \\
\verb|const int min::| & \MINKEY{SHORT\_STR}
\LABEL{MIN::SHORT_STR} \\
\verb|const int min::| & \MINKEY{LONG\_STR}
\LABEL{MIN::LONG_STR} \\
\verb|const int min::| & \MINKEY{LABEL}
\LABEL{MIN::LABEL} \\
\verb|const int min::| & \MINKEY{PACKED\_STRUCT}
\LABEL{MIN::PACKED_STRUCT} \\
\verb|const int min::| & \MINKEY{PACKED\_VEC}
\LABEL{MIN::PACKED_VEC} \\
\verb|const int min::| & \MINKEY{TINY\_OBJ}
\LABEL{MIN::TINY_OBJ} \\
\verb|const int min::| & \MINKEY{SHORT\_OBJ}
\LABEL{MIN::SHORT_OBJ} \\
\verb|const int min::| & \MINKEY{LONG\_OBJ}
\LABEL{MIN::LONG_OBJ} \\
\verb|const int min::| & \MINKEY{HUGE\_OBJ}
\LABEL{MIN::HUGE_OBJ} \\
\verb|const int min::| & \MINKEY{LIST\_AUX}
\LABEL{MIN::LIST_AUX} \\
\verb|const int min::| & \MINKEY{SUBLIST\_AUX}
\LABEL{MIN::SUBLIST_AUX} \\
\verb|const int min::| & \MINKEY{GTYPED\_PTR}
\LABEL{MIN::GTYPED_PTR} \\
\verb|const int min::| & \MINKEY{GTYPED\_PTR\_AUX}
\LABEL{MIN::GTYPED_PTR_AUX} \\
\verb|const int min::| & \MINKEY{VAR\_PTR}
\LABEL{MIN::PTR} \\
\verb|const int min::| & \MINKEY{VAR\_PTR\_AUX}
\LABEL{MIN::PTR_AUX} \\
\end{TABULAR}
\end{indpar}

\INDEXHEADER{Stub Related Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|int min::| & \MINKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MIN::TYPE_OF} \\
\verb|int MUP::| & \MUPKEY{type\_of} \verb|( const min::stub * s )|
\LABEL{MUP::TYPE_OF} \\
\verb|int min::| & \MINKEY{type\_of} \verb|( min::gen v )|
\LABEL{MIN::TYPE_OF_GEN} \\
\verb|bool min::| & \MINKEY{is\_collectible} \verb|( int type )|
\LABEL{MIN::IS_COLLECTIBLE} \\[1ex]
\verb|void min::| & \MINKEY{interrupt\REL} \verb|( void )|
\LABEL{MIN::INTERRUPT} \\
\verb|void min::| & \MINKEY{deallocate\REL} \verb|( const min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\verb|bool min::| & \MINKEY{is\_deallocated} \verb|( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED} \\
\verb|void MUP::| & \MUPKEY{stub\_swap}\ARGBREAK
    \verb|( const min::stub * s1,|\ARGBREAK
    \verb|  const min::stub * s2 )|
\LABEL{MUP::STUB_SWAP} \\
\verb|min::gen min::| & \MINKEY{new\_preallocated\_gen}
    \verb|( min::uns64 id )|
\LABEL{MIN::NEW_PREALLOCATED_GEN} \\
\verb|bool min::| & \MINKEY{is\_preallocated}
    \verb|( min::gen g )|
\LABEL{MIN::IS_PREALLOCATED} \\
\verb|min::uns64 min::| & \MINKEY{id\_of\_preallocated}
    \verb|( min::gen g )|
\LABEL{MIN::ID_OF_PREALLOCATED} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{gen} \verb|( void )|
\LABEL{MIN::GEN_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::==_OF_GEN} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::gen}}\ARGBREAK
      \verb|( min::gen g1, min::gen g2 )|
\LABEL{MIN::!=_OF_GEN} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_stub} \verb|( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::| & \MINKEY{is\_direct\_float\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::| & \MINKEY{is\_direct\_int\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::| & \MINKEY{is\_direct\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::| & \MINKEY{is\_index} \verb|( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::| & \MINKEY{is\_control\_code} \verb|( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::| & \MINKEY{is\_special} \verb|( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::| & \MINKEY{is\_list\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_sublist\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_indirect\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::| & \MINKEY{is\_aux} \verb|( min::gen v )|
\LABEL{MIN::IS_AUX} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|const min::stub * | & \MINKEY{NULL\_STUB}
\LABEL{MIN::NULL_STUB} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * min::| & \MINKEY{stub\_of}\ARGBREAK
                        \verb|( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of} \verb|( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen min::| & \MINKEY{new\_stub\_gen} \verb|( const min::stub * s )|
\LABEL{MIN::NEW_STUB_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE} \verb|( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen} \verb|( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen\COMPACT} \verb|( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int min::| & \MINKEY{gen\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::| & \MUPKEY{new\_gen} \verb|( min::unsgen value )|
\LABEL{MUP::NEW_GEN} \\
\verb|min::unsgen MUP::| & \MUPKEY{value\_of} \verb|( min::gen value )|
\LABEL{MUP::VALUE_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of} \verb|( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::|
    & \MUPKEY{direct\_int\_of\COMPACT} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of} \verb|( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of} \verb|( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of} \verb|( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of} \verb|( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of} \verb|( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of} \verb|( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::| & \MUPKEY{new\_stub\_gen} \verb|( const min::stub * s )|
\LABEL{MUP::NEW_STUB_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_float\_gen\LOOSE} \verb|( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_int\_gen\COMPACT} \verb|( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen} \verb|( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::| & \MUPKEY{new\_index\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_control\_code\_gen} \verb|( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_special\_gen} \verb|( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_list\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_sublist\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_indirect\_aux\_gen} \verb|( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen} \verb|( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\

\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Subtype Codes}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_INT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_FLOAT}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::| & \MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::| & \MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::| & \MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Special Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{MISSING()}
\LABEL{MIN::MISSING} \\
\verb|min::gen min::| & \MINKEY{NONE()}
\LABEL{MIN::NONE} \\
\verb|min::gen min::| & \MINKEY{DISABLED()}
\LABEL{MIN::DISABLED} \\
\verb|min::gen min::| & \MINKEY{ENABLED()}
\LABEL{MIN::ENABLED} \\
\verb|min::gen min::| & \MINKEY{ANY()}
\LABEL{MIN::ANY} \\
\verb|min::gen min::| & \MINKEY{MULTI\_VALUED()}
\LABEL{MIN::MULTI_VALUED} \\
\verb|min::gen min::| & \MINKEY{UNDEFINED()}
\LABEL{MIN::UNDEFINED} \\
\verb|min::gen min::| & \MINKEY{SUCCESS()}
\LABEL{MIN::SUCCESS} \\
\verb|min::gen min::| & \MINKEY{FAILURE()}
\LABEL{MIN::FAILURE} \\
\verb|min::gen min::| & \MINKEY{ERROR()}
\LABEL{MIN::ERROR} \\
\verb|min::gen min::| & \MINKEY{LOGICAL\_LINE()}
\LABEL{MIN::LOGICAL_LINE} \\
\verb|min::gen min::| & \MINKEY{INDENTED\_PARAGRAPH()}
\LABEL{MIN::INDENTED_PARAGRAPH} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Body References}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T & const location )|
\LABEL{MUP::NEW_REF_OF_LOCATION} \\
\verb|min::|\MINKEY{ref<T>}\verb| MUP::| & \MUPKEY{new\_ref<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_REF_OF_OFFSET} \\
\verb|min::|\MINKEY{ref<T>}\verb| min::| & \MINKEY{new\_ref}\ARGBREAK
    \verb|( T & location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_REF} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * MUP::| & \MUPKEY{ZERO\_STUB}
\LABEL{MUP::ZERO_STUB} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * const r| & \TTDMKEY{s}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_STUB} \\
\verb|min::unsptr const r| & \TTDMKEY{offset}{in {\tt min::ref<T>}}
\LABEL{MIN::REF_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T const & value )| \\
\LABEL{MIN::=REF_OF_T} \\
\verb|min::ref<T> const & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  min::ref<T> const & r2 )|
\LABEL{MIN::=REF_OF_REF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|T |
    & \TTOMKEY{T}{{\tt T}}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_TO_T} \\
\verb|T |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::ref<T>}}\ARGBREAK
	  \verb|( min::ref<T> const & r )|
\LABEL{MIN::REF_->} \\
\verb|T & |
	& \TTOMKEY{\textasciitilde}{\textasciitilde}{of {\tt min::ref<T>}}%
		\ARGBREAK
	  \verb|( min::ref<T> const & r )| ~~ [unprotected]
\LABEL{MIN::TILDE_OF_REF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::==REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( T v, min::ref<T> const & r )|
\LABEL{MIN::==T_AND_REF} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r, T v )|
\LABEL{MIN::!=REF_AND_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( T v, min::ref<T> &const  r )|
\LABEL{MIN::!=T_AND_REF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  const min::stub * s )|
\LABEL{MIN::==REF_AND_STUB} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r,|\ARGBREAK
      \verb|  const min::stub * s )|
\LABEL{MIN::!=REF_AND_STUB} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Body Pointers}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{ptr<T>} \verb| p|
\LABEL{MIN::PTR_OF_T} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  T * location )|
\LABEL{MUP::NEW_PTR_OF_LOCATION} \\
\verb|min::|\MINKEY{ptr<T>}\verb| MUP::| & \MUPKEY{new\_ptr<T>}\ARGBREAK
    \verb|( const min::stub * s,|\ARGBREAK
    \verb|  min::unsptr offset )|
\LABEL{MUP::NEW_PTR_OF_OFFSET} \\
\verb|min::|\MINKEY{ptr<T>}\verb| min::| & \MINKEY{new\_ptr}\ARGBREAK
    \verb|( T * location )| \\
    & where \TT{location} is \underline{not} relocatable
\LABEL{MIN::NEW_PTR} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::stub * const p| & \TTDMKEY{s}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_STUB} \\
\verb|min::unsptr const p| & \TTDMKEY{offset}{in {\tt min::ptr<T>}}
\LABEL{MIN::PTR_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ptr<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ptr<T> & p,|\ARGBREAK
      \verb|  min::ptr<T> const & p2 )|
\LABEL{MIN::=PTR_OF_PTR}
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool |
	& \TTOMKEY{bool}{bool}{of {\tt min::ptr<T>}}
	  \verb|( min::ptr<T> const & p )|
\LABEL{MIN::BOOL_OF_PTR} \\
\verb|min::ptr<T> min::|
	& \MINKEY{null\_ptr<T>} \verb|()|
\LABEL{MIN::NULL_OF_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|T * |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::ptr<T>}}\ARGBREAK
	  \verb|( min::ptr<T> const & p )|
\LABEL{MIN::PTR_->} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}{of {\tt min::ref<T>}}\ARGBREAK
      \verb|( min::ref<T> const & r )|
\LABEL{MIN::=AMPERSAND_OF_REF_OF_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{*}{*}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p )|
\LABEL{MIN::=*_OF_PTR_OF_T} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<T> p| & \TTBMKEY{i}{of {\tt min::ptr}}
\LABEL{MIN::PTR_[]} \\
\verb|min::ptr<T> p|
    & \TTMOKEY{+}{of {\tt min::ptr}}\verb|i|
\LABEL{MIN::PTR_+} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|T * |
	& \TTOMKEY{\textasciitilde}{\textasciitilde}%
	  {of {\tt min::ptr<T>}}\ARGBREAK
	  \verb|( min::ptr<T> const & p )| ~ [unprotected]
\LABEL{MIN::TILDE_OF_PTR} \\
\verb|min::ptr<T> |
	& \MINKEY{ptr<T>}\ARGBREAK
	  \verb|( min::ptr<S> const & p )| ~ [unprotected]
\LABEL{MIN::PTR_OF_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool |
    & \TTOMKEY{<}{<}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1,|\ARGBREAK
      \verb|  min::ptr<T> const & p2 )|
\LABEL{MIN::<_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{++}{++}{of {\tt min::ptr<T>}}%
    \hspace*{1.3in} [postfix {\tt ++}]\ARGBREAK
      \verb|( min::ptr<T> & p, int )|
\LABEL{MIN::POSTFIX_++_OF_PTR_OF_T} \\
\verb|min::ptr<T> |
    & \TTOMKEY{--}{-{}-}{of {\tt min::ptr<T>}}%
    \hspace*{1.3in} [prefix {\tt --}]\ARGBREAK
      \verb|( min::ptr<T> & p )|
\LABEL{MIN::PREFIX_--_OF_PTR_OF_T} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\verb|bool |
    & \TTOMKEY{==}{==}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::==_OF_PTR_OF_T} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}{of {\tt min::ptr<T>}}\ARGBREAK
      \verb|( min::ptr<T> const & p1, min::ptr<T> const & p2 )|
\LABEL{MIN::!=_OF_PTR_OF_T} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Body Copy Macros}

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_STACK\_COPY} \verb|( type, name, length, source )|
\LABEL{MIN_STACK_COPY}
\end{tabular}

\end{indpar}


\INDEXHEADER{ACC Locatable Types}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|class min::| & \MINKEY{locatable\_var<T>} \TT{: public T} \\
    & use \TT{min::stub\_ptr} for \TT{T} instead of \TT{const min::stub *}
\LABEL{MIN::LOCATABLE_VAR_BASECLASS} \\
\end{TABULAR}

\begin{TABULAR}{3.7in}
\verb|typedef min::locatable<min::gen> min::| & \MINKEY{locatable\_gen}
\LABEL{MIN::LOCATABLE_GEN} \\
\verb|typedef min::locatable<min::stub_ptr> min::|
    & \MINKEY{locatable\_stub\_ptr}
\LABEL{MIN::LOCATABLE_STUB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{3.2in}
\multicolumn{2}{l}{In compact implementation:} \\
~~~~\verb|typedef min::locatable_gen  min::| & \MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\multicolumn{2}{l}{In loose implementation:} \\
~~~~\verb|typedef min::gen  min::| & \MINKEY{locatable\_num\_gen}
\LABEL{MIN::LOCATABLE_NUM_GEN_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb| var ( void )|
\LABEL{MIN::LOCATABLE_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( min::locatable_var<T> const & var )|
\LABEL{MIN::LOCATABLE_VAR_OF_VAR} \\
\verb|(constructor) min::| & \MINKEY{locatable\_var<T>}\ARGBREAK
    \verb|var ( T const & value )|
\LABEL{MIN::LOCATABLE_VAR_OF_VALUE} \\
\end{TABULAR}

\begin{TABULAR}{2.1in}
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  min::locatable_var<T> const & var2 )|
\LABEL{MIN::=LOCATABLE_VAR_OF_LOCATABLE_VAR} \\
\verb|min::locatable_var<T> & |
    & \TTOMKEY{=}{=}{of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var,|\ARGBREAK
      \verb|  T const & value )|
\LABEL{MIN::=LOCATABLE_VAR_OF_VALUE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<T const> |
    & \TTOMKEY{min::ref<T const>}{min::ref<T const>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::CONST_LOCATABLE_VAR_TO_REF_CONST_T} \\
\verb|min::ref<T> |
    & \TTOMKEY{min::ref<T>}{min::ref<T>}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::LOCATABLE_VAR_TO_REF_T} \\
\verb|min::ptr<T const> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> const & var )|
\LABEL{MIN::AMPERSAND_CONST_LOCATABLE_VAR} \\
\verb|min::ptr<T> |
    & \TTOMKEY{\&}{\&}%
              {of {\tt min::locatable\_var<T>}}\ARGBREAK
      \verb|( min::locatable_var<T> & var )|
\LABEL{MIN::AMPERSAND_LOCATABLE_VAR} \\
\end{TABULAR}

\bigskip

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_REF} \verb|( type, name, ctype )|
\LABEL{MIN_REF}
\end{tabular}

\end{indpar}


\INDEXHEADER{ACC Stub Pointer Write Update Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * s2 )|
\LABEL{MUP::ACC_WRITE_STUB_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_GEN_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
          \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  min::gen g )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_UPDATE} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::stub * const * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_STUB_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_GEN_VEC_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update}\ARGBREAK
	  \verb|( const min::stub * s1,|\ARGBREAK
	  \verb|  const min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_NUM_GEN_VEC_UPDATE} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{Unprotected Stub Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub} \verb|( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub} \verb|( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\verb|void MUP::| & \MUPKEY{free\_aux\_stub} \verb|( min::stub * s )|
\LABEL{MUP::FREE_AUX_STUB} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Read/Write Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of} \verb|( const min::stub * s )|
\LABEL{MUP::VALUE_OF_STUB} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of} \verb|( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{ptr\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PTR_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_value\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of}\ARGBREAK
      \verb|( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of}\ARGBREAK
      \verb|( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_ptr\_of}\ARGBREAK
      \verb|( min::stub * s, void * p )|
\LABEL{MUP::SET_PTR_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Control Functions}

\begin{indpar}[0.2in]


\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of} \verb|( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}\ARGBREAK
      \verb|( const min::stub * s, min::uns64 flags )|
\LABEL{MUP::TEST_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_control\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of}\ARGBREAK
      \verb|( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of}\ARGBREAK
      \verb|( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator}\ARGBREAK
      \verb|( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value}\ARGBREAK
      \verb|( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub}\ARGBREAK
      \verb|( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int MUP::| & \MUPKEY{locator\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub}\ARGBREAK
      \verb|( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control} \verb|( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
[1ex]
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type}\ARGBREAK
      \verb|( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control} \verb|( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Control Flags}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|const min::uns64 MUP::| & \MUPKEY{STUB\_ADDRESS}
\LABEL{MIN::STUB_ADDRESS}\\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Body Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|void MUP::|
    & \MUPKEY{new\_body} \verb|( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body}\ARGBREAK
      \verb|    ( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of} \verb|( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\verb|void * & MUP::| & \MUPKEY{ptr\_ref\_of}
	      \verb|( min::stub * s )| 
\LABEL{MUP::PTR_REF_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\ARGBREAK
    \verb|    ( min::stub * s,|\ARGBREAK
    \verb|      min::unsptr new_size,|\ARGBREAK
    \verb|      min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_ptr\_ref}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_PTR_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\verb|void MUP::| & \MUPKEY{retype\_resize\_body}\ARGBREAK
	     \verb|( MUP::resize_body & rb,|\ARGBREAK
	     \verb|  int new_type )| 
\LABEL{MUP::RETYPE_RESIZE_BODY} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{UNICODE Characters}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.4in}
\verb|typedef min::uns32 min::| & \MINKEY{Uchar}
\LABEL{MIN::UCHAR} \\
\verb|const min::Uchar min::|
    & \MINKEY{UNKNOWN\_UCHAR}
\LABEL{MIN::UNKNOWN_UCHAR} \\
\verb|const min::Uchar min::|
    & \MINKEY{SOFTWARE\_NL}
\LABEL{MIN::SOFTWARE_NL} \\
\verb|const min::Uchar min::|
    & \MINKEY{NO\_UCHAR} \verb|= 0xFFFFFFFF|
\LABEL{MIN::UNICODE::NO_UCHAR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::Uchar min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( const char * & s, const char * ends )|
\LABEL{MIN::UTF8_TO_UNICODE} \\
\verb|unsigned min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb|( char * & s, min::Uchar c )|
\LABEL{MIN::UNICODE_TO_UTF8} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
    & \MINKEY{utf8\_to\_unicode}\ARGBREAK
      \verb|( min::Uchar * & u, const min::Uchar * endu,|\ARGBREAK
      \verb|  const char * & s, const char * ends )|
\LABEL{MIN::UTF8_STR_TO_UNICODE_STR} \\
\verb|min::unsptr min::|
    & \MINKEY{unicode\_to\_utf8}\ARGBREAK
      \verb| ( char * & s, const char * ends,|\ARGBREAK
      \verb|   const min::Uchar * & u,|\ARGBREAK
      \verb|   const min::Uchar * endu )|
\LABEL{MIN::UNICODE_STR_TO_UTF8_STR} \\
\end{TABULAR}

\INDEXHEADER{UNICODE Data Base}

\begin{TABULAR}{2.4in}
\verb|min::uns16 min::|
    & \MINKEY{Uindex} \verb|( min::Uchar c )|
\LABEL{MIN::UINDEX} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::ustring min::|
    & \MINKEY{unicode::name}\verb|[i]|
\LABEL{MIN::UNICODE::NAME} \\
\verb|min::ustring min::|
    & \MINKEY{unicode::picture}\verb|[i]|
\LABEL{MIN::UNICODE::PICTURE} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::Uchar min::|
    & \MINKEY{unicode::character}\verb|[i]|
\LABEL{MIN::UNICODE::CHARACTER} \\
\verb|const min::uns16 min::|
    & \MINKEY{unicode::index\_limit}
\LABEL{MIN::UNICODE::INDEX_LIMIT} \\
\end{TABULAR}

\INDEXHEADER{UNICODE Character Flags}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 printer->|
    & \MINKEY{print\_format.char\_flags}\verb|[i]|
\LABEL{MIN::PRINT_FORMAT.CHAR_FLAGS} \\
\verb|const min::uns32 * min::|
    & \MINKEY{standard\_char\_flags}
\LABEL{MIN::STANDARD_CHAR_FLAGS} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_GRAPHIC}
\LABEL{MIN::IS_GRAPHIC} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_CONTROL}
\LABEL{MIN::IS_CONTROL} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_UNSUPPORTED}
\LABEL{MIN::IS_UNSUPPORTED} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_NON\_GRAPHIC} =\ARGBREAK
    \verb|  min::IS_CONTROL|\ARGBREAK
    \verb|+ min::IS_UNSUPPORTED|
\LABEL{MIN::IS_NON_GRAPHIC} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_HSPACE}
\LABEL{MIN::IS_HSPACE} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_VHSPACE}
\LABEL{MIN::IS_VHSPACE} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_NON\_SPACING}
\LABEL{MIN::IS_NON_SPACING} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_SP}
\LABEL{MIN::IS_SP} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_BHSPACE}
\LABEL{MIN::IS_BHSPACE} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{CONDITIONAL\_BREAK}
\LABEL{MIN::CONDITIONAL_BREAK} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_LEADING}
\LABEL{MIN::IS_LEADING} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_TRAILING}
\LABEL{MIN::IS_TRAILING} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_SEPARATOR}
\LABEL{MIN::IS_SEPARATOR} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_REPEATER}
\LABEL{MIN::IS_REPEATER} \\
\verb|const min::uns32 min::| & \MINKEY{NEEDS\_QUOTES}
\LABEL{MIN::NEEDS_QUOTES} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_MARK}
\LABEL{MIN::IS_MARK} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{IS\_ASCII}
\LABEL{MIN::IS_ASCII} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_LATIN1}
\LABEL{MIN::IS_LATIN1} \\
\end{TABULAR}

\INDEXHEADER{UNICODE Support Control}

\begin{TABULAR}{2.4in}
\verb|inline min::uns32 min::| & \MINKEY{char\_flags}\ARGBREAK
      \verb|( const min::uns32 * char_flags,|\ARGBREAK
      \verb|  min::support_control sc,|\ARGBREAK
      \verb|  min::Uchar c )|
\LABEL{MIN::CHAR_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|struct     min::| & \MINKEY{support\_\EOL control}
\LABEL{MIN::SUPPORT_CONTROL_STRUCT} \\
\verb|{               | \\
\verb|     min::uns32 |
	& \TTMKEY{support\_mask}{in {\tt min::support\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{unsupported\_char\_flags}{in {\tt min::support\_control}} \\
\verb|}               | \\
\end{TABULAR}

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::uns32
    min::\MINKEY{ALL\_CHARS} = \TT{0xFFFFFFFF}}
\LABEL{MIN::ALL_CHARS} \\
\multicolumn{2}{l}{\tt const min::support\_control
    min::\MINKEY{ascii\_support\_control} =}\ARGBREAK[0.5in]
	\verb|{ min::IS_ASCII, min::IS_UNSUPPORTED };|
\LABEL{MIN::ASCII_SUPPORT_CONTROL} \\
\multicolumn{2}{l}{\tt const min::support\_control
    min::\MINKEY{latin1\_support\_control} =}\ARGBREAK[0.5in]
	\verb|{ min::IS_LATIN1 + min::IS_ASCII, min::IS_UNSUPPORTED };|
\LABEL{MIN::LATIN1_SUPPORT_CONTROL} \\
\multicolumn{2}{l}{\tt const min::support\_control
    min::\MINKEY{support\_all\_support\_control} =}\ARGBREAK[0.5in]
	\verb|{ min::ALL_CHARS, min::IS_UNSUPPORTED };|
\LABEL{MIN::SUPPORT_ALL_SUPPORT_CONTROL} \\
\end{TABULAR}

\INDEXHEADER{String Classifiers}

\begin{TABULAR}{2.5in}
\verb|typedef min::uns32 ( * min::| & \MINKEY{str\_classifier}
                                      \verb| )|\ARGBREAK
      \verb|( const min::uns32 * char_flags,|\ARGBREAK
      \verb|  min::support_control sc,|\ARGBREAK
      \verb|  min::unsptr n,|\ARGBREAK
      \verb|  min::ptr<const min::Uchar> p )|
\LABEL{MIN::STR_CLASSIFIER} \\
\end{TABULAR}

\begin{TABULAR}{1.5in}
\multicolumn{2}{l}{\tt const min::str\_classifier} \\
\verb|    min::| & \MINKEY{standard\_str\_classifier}
\LABEL{MIN::STANDARD_STR_CLASSIFIER} \\
\multicolumn{2}{l}{\tt const min::str\_classifier} \\
\verb|    min::|
    & \MINKEY{quote\_separator\_str\_classifier}
\LABEL{MIN::QUOTE_SEPARATOR_STR_CLASSIFIER} \\
\multicolumn{2}{l}{\tt const min::str\_classifier} \\
\verb|    min::|
    & \MINKEY{quote\_separator\_and\_mark\_str\_classifier}
\LABEL{MIN::QUOTE_SEPARATOR_AND_MARK_STR_CLASSIFIER} \\
\multicolumn{2}{l}{\tt const min::str\_classifier} \\
\verb|    min::| & \MINKEY{quote\_all\_str\_classifier}
\LABEL{MIN::QUOTE_ALL_STR_CLASSIFIER} \\
\multicolumn{2}{l}{\tt const min::str\_classifier} \\
\verb|    min::| & \MINKEY{null\_str\_classifier}
\LABEL{MIN::NULL_STR_CLASSIFIER} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{0} (no flags)
\LABEL{NO_FLAGS_CLASSIFIER} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_GRAPHIC}
\LABEL{IS_GRAPHIC_CLASSIFIER} \\
\verb|const min::uns32 min::| & \MINKEY{NEEDS\_QUOTES}
\LABEL{NEEDS_QUOTES_CLASSIFIER} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_LEADING}
\LABEL{IS_LEADING_CLASSIFIER} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_TRAILING}
\LABEL{IS_TRAILING_CLASSIFIER} \\
\verb|const min::uns32 min::| & \MINKEY{IS\_MARK}
\LABEL{IS_MARK_CLASSIFIER} \\
\end{TABULAR}

\INDEXHEADER{UNICODE Strings}

\begin{TABULAR}{3.0in}
\verb|typedef const min::uns8 * min::| & \MINKEY{ustring}
\LABEL{MIN::USTRING} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::uns32 min::|
    & \MINKEY{ustring\_length}\ARGBREAK
      \verb|( min::ustring s )|
\LABEL{MIN::USTRING_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{ustring\_columns} \ARGBREAK
      \verb|( min::ustring s )|
\LABEL{MIN::USTRING_COLUMNS} \\
\verb|const char * min::|
    & \MINKEY{ustring\_chars} \ARGBREAK
      \verb|( min::ustring s )|
\LABEL{MIN::USTRING_CHARS} \\
\end{TABULAR}

\INDEXHEADER{UNICODE Name Tables}

\begin{TABULAR}{2.4in}
(type) \verb|min::| & \MINKEY{unicode\_name\_table}
\LABEL{MIN::UNICODE_NAME_TABLE} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{{\tt min::unicode\_name\_table
                        min::}\MINKEY{init\REL}}\ARGBREAK
    \verb|( min::ref<min::unicode_name_table> table,|\ARGBREAK
    \verb|  const min::uns32 * char_flags =|\ARGBREAK
    \verb|            min::standard_char_flags,|\ARGBREAK
    \verb|  min::uns32 flags = min::ALL_CHARS,|\ARGBREAK
    \verb|  min::uns32 extras = 10 )|
\LABEL{MIN::INIT_OF_UNICODE_NAME_TABLE} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|void min::| & \MINKEY{add}\ARGBREAK
    \verb|( min::unicode_name_table table,|\ARGBREAK
    \verb|  const char * name,|\ARGBREAK
    \verb|  min::Uchar c,|\ARGBREAK
    \verb|  bool replace_allowed = false )|
\LABEL{MIN::ADD_OF_UNICODE_NAME_TABLE} \\
\verb|min::Uchar min::| & \MINKEY{find}\ARGBREAK
    \verb|( min::unicode_name_table table,|\ARGBREAK
    \verb|  const char * name)|
\LABEL{MIN::FIND_OF_UNICODE_NAME_TABLE} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT} \verb|( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_num} \verb|( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL}  \verb|( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of} \verb|( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of} \verb|( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash} \verb|( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{floathash} \verb|( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 MUP::| & \MUPKEY{float\_of} \verb|( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{String Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb|( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb|( min::ptr<const char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
	\verb|( min::ptr<const char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_CONST_PTR_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb|( min::ptr<char> p )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
	\verb|( min::ptr<char> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_WITH_N} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( const min::Uchar * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<const min::Uchar> p,|\ARGBREAK
      \verb|  min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_CONST_UNICODE} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb|( min::ptr<min::Uchar> p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_OF_PTR_OF_UNICODE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|int min::| & \MINKEY{is\_str} \verb|( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\
\verb|char * min::| & \MINKEY{strcpy} \verb|( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::| & \MINKEY{strncpy}\ARGBREAK
                      \verb|( char * p,|\ARGBREAK
		      \verb|  min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\
\verb|int min::| & \MINKEY{strcmp} \verb|( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::| & \MINKEY{strncmp}\ARGBREAK
                   \verb|( const char * p,|\ARGBREAK
		   \verb|  min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns64 min::| & \MINKEY{strhead} \verb|( min::gen v )|
\LABEL{MIN::STRHEAD_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash}\ARGBREAK
      \verb|( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int32 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::int64 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT64} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns32 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS32} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
    \verb|( min::uns64 & value, min::gen g,|\ARGBREAK
    \verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS64} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float32 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT32} \\
\verb|bool min::| & \MINKEY{strto} \verb|( min::float64 & value, min::gen g )|
\LABEL{MIN::STRTO_FLOAT64} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{String Pointers}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( const min::stub * s )|
\LABEL{MIN::STR_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{str\_ptr}\verb| sp ( void )|
\LABEL{MIN::STR_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.3in}
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp, min::gen v )|
\LABEL{MIN::=_STR_PTR_OF_GEN} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1,|\ARGBREAK
      \verb|  min::str_ptr const & sp2 )|
\LABEL{MIN::=_STR_PTR_OF_STR_PTR} \\
\verb|min::str_ptr & |
    & \TTOMKEY{=}{=}{of {\tt min::str\_ptr}}\ARGBREAK
      \verb|( min::str_ptr & sp1, const min::stub * s )|
\LABEL{MIN::=_STR_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|operator |
    & \MINKEY{bool} \verb|( min::str_ptr const & sp )|
\LABEL{BOOL_OF_STR_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{0.75in}
\verb|char sp|
    & \TTBMKEY{i}{of {\tt min::str\_ptr}} --- for \TT{min::unsptr i}
\LABEL{MIN::[]_OF_STR_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.4in}
\verb|min::ptr<const char> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::str_ptr const & sp )|
\LABEL{MIN::BEGIN_PTR_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{strlen} \verb|( min::gen v )|
\LABEL{MIN::STRLEN_OF_STR_PTR} \\
\verb|min::uns32 min::| & \MINKEY{strhash} \verb|( min::str_ptr const & sp )|
\LABEL{MIN::STRHASH_OF_STR_PTR} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\ARGBREAK
      \verb|( char * p, min::str_ptr const & sp )|
\LABEL{MIN::STRCPY_OF_STR_PTR} \\
\verb|char * min::|
    & \MINKEY{strncpy}\ARGBREAK
      \verb|( char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp,|\ARGBREAK
      \verb|  min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_STR_PTR} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp )|
\LABEL{MIN::STRCMP_OF_STR_PTR} \\
\verb|int min::|
    & \MINKEY{strncmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_ptr const & sp,|\ARGBREAK
      \verb|  min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_STR_PTR} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::int64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_INT64_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::uns64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp, min::unsptr & i,|\ARGBREAK
	\verb|  int base = 0 )|
\LABEL{MIN::STRTO_UNS64_OF_STR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float32 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp,|\ARGBREAK
	\verb|  min::unsptr & i )|
\LABEL{MIN::STRTO_FLOAT32_OF_STR_PTR} \\
\verb|bool min::| & \MINKEY{strto}\ARGBREAK
	\verb|( min::float64 & value,|\ARGBREAK
	\verb|  min::str_ptr const & sp,|\ARGBREAK
	\verb|  min::unsptr & i )|
\LABEL{MIN::STRTO_FLOAT64_OF_STR_PTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{String Unprotected Functions}

\begin{indpar}[0.2in]


\begin{TABULAR}{1.8in}
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( min::str_ptr const & sp )|
\LABEL{MUP::STR_OF_STR_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of} \verb|( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of} \verb|( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Labels}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MIN::LAB_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( min::stub * s )|
\LABEL{MIN::LAB_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MIN::LAB_PTR_OF_VOID} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt min::lab\_ptr}}\ARGBREAK
          \verb|( min::lab_ptr const & labp )|
\LABEL{MIN::LAB_PTR_TO_MIN_STUB} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp, min::gen v )|
\LABEL{MIN::=_LAB_PTR_OF_GEN} \\
\verb|min::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt min::lab\_ptr}}\ARGBREAK
	  \verb|( min::lab_ptr & labp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_LAB_PTR_OF_STUB} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.6in}
\verb|min::gen labp|
    & \TTBMKEY{i}{of {\tt min::lab\_ptr}} --- for \TT{min::uns32 i}
\LABEL{MIN::[]_OF_LAB_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.6in}
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{begin\_ptr\_of}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{end\_ptr\_of}\ARGBREAK
	  \verb|( min::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_LAB_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( min::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_LAB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen} \verb|( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash} \verb|( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\ARGBREAK
    \verb|( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|const min::uns32 min::| & \MINKEY{labhash\_initial} \verb|= 1009|
\LABEL{MIN::LABHASH_INITIAL} \\
\verb|const min::uns32 min::| & \MINKEY{labhash\_factor}
    \verb|= 65599**10 (mod 2**32)|
\LABEL{MIN::LABHASH_FACTOR} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\ARGBREAK
    \verb|( min::uns32 hash, min::uns32 h )|
\LABEL{MIN::LABHASH_INCREMENTAL} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  const min::stub * s, min::uns32 n )|
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{labncpy}\ARGBREAK
	  \verb|( min::gen * p,|\ARGBREAK
	  \verb|  min::gen v, min::uns32 n )|
\LABEL{MIN::LAB_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( const min::gen * p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<const min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR_CONST} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb|( min::ptr<min::gen> p,|\ARGBREAK
    \verb|  min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN_OF_PTR} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2 )|
\LABEL{MIN::NEW_LAB_GEN_OF_2_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3 )|
\LABEL{MIN::NEW_LAB_GEN_OF_3_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3,|\ARGBREAK
     \verb|  const char * s4 )|
\LABEL{MIN::NEW_LAB_GEN_OF_4_STRS} \\
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
     \verb|( const char * s1,|\ARGBREAK
     \verb|  const char * s2,|\ARGBREAK
     \verb|  const char * s3,|\ARGBREAK
     \verb|  const char * s4,|\ARGBREAK
     \verb|  const char * s5 )|
\LABEL{MIN::NEW_LAB_GEN_OF_5_STRS} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_lab} \verb|( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::gen v )|
\LABEL{MUP::LAB_PTR_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( min::stub * s )|
\LABEL{MUP::LAB_PTR_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_ptr}%
	  \verb| labp ( void )|
\LABEL{MUP::LAB_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::lab\_ptr}}\ARGBREAK
          \verb|( MUP::lab_ptr const & labp )|
\LABEL{MUP::LAB_PTR_TO_MIN_STUB} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, min::gen v )|
\LABEL{MUP::=_LAB_PTR_OF_GEN} \\
\verb|MUP::lab_ptr & | &
	  \TTOMKEY{=}{=}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp, const min::stub * s )|
\LABEL{MUP::=_LAB_PTR_OF_STUB} \\
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt MUP::lab\_ptr}}\ARGBREAK
	  \verb|( MUP::lab_ptr const & labp,|\ARGBREAK
	  \verb|  min::uns32 i )|
\LABEL{MUP::[]_OF_LAB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{2.6in}
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{begin\_ptr\_of}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::BEGIN_PTR_OF_MUP_LAB_PTR} \\
\verb|min::ptr<const min::gen> min::|
	& \MINKEY{end\_ptr\_of}\ARGBREAK
	  \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::END_PTR_OF_MUP_LAB_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::|
	& \MINKEY{lablen} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::LENGTH_OF_MUP_LAB_PTR} \\
\verb|min::uns32 min::|
	& \MINKEY{labhash} \verb|( MUP::lab_ptr & labp )|
\LABEL{MIN::HASH_OF_MUP_LAB_PTR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Names}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_name} \verb|( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash} \verb|( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare} \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\verb|min::int32 min::| & \MINKEY{is\_subsequence}\ARGBREAK
    \verb|( min::gen v1, min::gen v2 )|
\LABEL{MIN::IS_SUBSEQUENCE} \\
\verb|min::gen min::| & \MINKEY{new\_name\_gen}
    \verb|( const char * s )|
\LABEL{MIN::NEW_NAME_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_name\_gen}
    \verb|( min::ptr<const char> s )|
\LABEL{MIN::NEW_NAME_GEN_OF_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen min::| & \MINKEY{TRUE}
\LABEL{MIN::TRUE} \\
\verb|min::gen min::| & \MINKEY{FALSE}
\LABEL{MIN::FALSE} \\
\verb|min::gen min::| & \MINKEY{empty\_str}
\LABEL{MIN::EMPTY_STR} \\
\verb|min::gen min::| & \MINKEY{empty\_lab}
\LABEL{MIN::EMPTY_LAB} \\
\verb|min::gen min::| & \MINKEY{doublequote}
\LABEL{MIN::DOUBLEQUOTE} \\
\verb|min::gen min::| & \MINKEY{line\_feed}
\LABEL{MIN::LINE_FEED} \\
\verb|min::gen min::| & \MINKEY{colon}
\LABEL{MIN::COLON} \\
\verb|min::gen min::| & \MINKEY{semicolon}
\LABEL{MIN::SEMICOLON} \\
\verb|min::gen min::| & \MINKEY{dot\_initiator}
\LABEL{MIN::DOT_INITIATOR} \\
\verb|min::gen min::| & \MINKEY{dot\_separator}
\LABEL{MIN::DOT_SEPARATOR} \\
\verb|min::gen min::| & \MINKEY{dot\_terminator}
\LABEL{MIN::DOT_TERMINATOR} \\
\verb|min::gen min::| & \MINKEY{dot\_type}
\LABEL{MIN::DOT_TYPE} \\
\verb|min::gen min::| & \MINKEY{dot\_position}
\LABEL{MIN::DOT_POSITION} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Structures}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct<S>} \verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_with\_base<S,B>}
		\verb|pstype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * stub_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT_TYPE_WITH_BASE} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::| & \MINKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{TABULAR}

\begin{TABULAR}{3.0in}
\verb|min::gen pstype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\verb|const min::stub * pstype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_struct}} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_STUB} \\
\verb|min::uns32 pstype|
    & \TTDMKEY{subtype}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_SUBTYPE} \\
\verb|const char * const pstype.|
    & \TTDMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{gen\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISP} \\
\verb|const min::uns32 * const pstype|
    & \TTDMKEY{stub\_\EOL disp}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_DISP} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_STRUCT_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype}\ARGBREAK
	  \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_SUBTYPE} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr<S>} \verb|psp|
	  \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_ptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_ptr<S> & psp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
          \verb|( min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_TO_MIN_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::ptr<S const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_->} \\
\verb|min::ref<S const> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_ptr}}\ARGBREAK
	  \verb|(min::packed_struct_ptr<S> const & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_*} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr<S>} \verb|psup|\ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_struct\_updptr<S> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_struct\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_struct_updptr<S> & psup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::ptr<S> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_struct\_udpptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_->} \\
\verb|min::ref<S> |
	& \TTOMKEY{*}{*}{of {\tt min::packed\_struct\_updptr}}\ARGBREAK
	  \verb|( min::packed_struct_updptr<S> const & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_*} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Vectors}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|struct min::| & \MINKEY{packed\_vec\_header<L>}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const min::uns32 control;|\ARGBREAK
    \verb|  const L length;|\ARGBREAK
    \verb|  const L max_length;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PACKED_VEC_HEADER} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_with\_base<E,H,B,L>}
		\verb|pvtype|\ARGBREAK
	  \verb|( const char * name,|\ARGBREAK
	  \verb|  const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * element_stub_disp|\ARGBREAK
	  \verb|                           = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|  const min::uns32 * header_stub_disp = NULL )|
\LABEL{MIN::PACKED_VEC_TYPE_WITH_BASE} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}} \verb|( void )|
\LABEL{PACKED_VEC_NEW_STUB_VOID} \\
\verb|min::gen pvtype|
    & \TTDMKEY{new\_\EOL gen}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\verb|const min::stub * pvtype|
    & \TTDMKEY{new\_\EOL stub}{in {\tt min::packed\_vec}}\ARGBREAK
	  \verb|( L max_length,|\ARGBREAK
	  \verb|  L length = 0,|\ARGBREAK
	  \verb|  E const * vp = NULL )|
\LABEL{PACKED_VEC_NEW_STUB_MAX_LENGTH} \\
\end{TABULAR}

\begin{TABULAR}{3.0in}
\verb|const char * const pvtype| & \TTDMKEY{subtype}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_SUBTYPE} \\
\verb|const char * const pvtype| & \TTDMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{header\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL gen\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISP} \\
\verb|const min::uns32 * const pvtype| & \TTDMKEY{element\_\EOL stub\_\EOL disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_DISP} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::uns32 pvtype| & \TTDMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 pvtype| & \TTDMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 pvtype| & \TTDMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_GEN} \\
\verb|min::uns32 min::|
	& \MINKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MIN::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|min::uns32 MUP::|
	& \MUPKEY{packed\_subtype\_of} \verb|( const min::stub * s )|
\LABEL{MUP::PACKED_VEC_SUBTYPE_OF_STUB} \\
\verb|const char * min::|
	& \MINKEY{name\_of\_packed\_subtype}\ARGBREAK
	  \verb|( min::uns32 subtype )|
\LABEL{MIN::NAME_OF_PACKED_VEC_SUBTYPE} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\verb|min::| & \verb|packed_vec<char>| \ARGBREAK
	\verb|min::| \MINKEY{char\_packed\_vec\_type}
\LABEL{MIN::CHAR_PACKED_VEC_TYPE} \\
\verb|min::| & \verb|packed_vec<min::uns32>| \ARGBREAK
	\verb|min::| \MINKEY{uns32\_packed\_vec\_type}
\LABEL{MIN::UNS32_PACKED_VEC_TYPE} \\
\verb|min::| & \verb|packed_vec<const char *>| \ARGBREAK
	\verb|min::| \MINKEY{const\_char\_ptr\_packed\_vec\_type}
\LABEL{MIN::CONST_CHAR_PTR_PACKED_VEC_TYPE} \\
\verb|min::| & \verb|packed_vec<min::gen>| \ARGBREAK
	\verb|min::| \MINKEY{gen\_packed\_vec\_type}
\LABEL{MIN::GEN_PACKED_VEC_TYPE} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_ptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvp|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_PTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_ptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_ptr<E,H,L> & pvp,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_PTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
          \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_TO_MIN_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::ptr<H const> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_->} \\
\verb|min::ref<H const> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_ptr}}\ARGBREAK
	  \verb|( min::packed_vec_ptr<E,H,L> const & pvp )|
\LABEL{MIN::PACKED_VEC_PTR_*} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|const min::uns32 pvp| & \TTARMKEY{length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_LENGTH} \\
\verb|const L pvp| & \TTARMKEY{max\_length}{in {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_MAX_LENGTH} \\
\verb|min::ref<E const> pvp| & \TTBMKEY{i}{of {\tt min::packed\_vec\_ptr}}
\LABEL{MIN::PACKED_VEC_PTR_[]} \\
\verb|min::ptr<E const> pvp|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_ptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_PTR_+} \\
\verb|min::ptr<E const> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_PTR} \\
\verb|min::ptr<E const> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_ptr<E,H,L> pvp )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_PTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvup|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDPTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_updptr<E,H,L> \&
	\TTOMKEY{=}{=}{of {\tt min::packed\_vec\_updptr}}}\ARGBREAK[1.5in]
	  \verb|( min::packed_vec_updptr<E,H,L> & pvup,|\ARGBREAK[1.5in]
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_UPDPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::ptr<H> |
	& \TTOMKEY{->}{->}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_->} \\
\verb|min::ref<H> |
	& \TTOMKEY{*}{*}%
	          {of {\tt min::packed\_vec\_updptr}}\ARGBREAK
	  \verb|( min::packed_vec_updptr<E,H,L> const & pvup )|
\LABEL{MIN::PACKED_VEC_UPDPTR_*} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::ref<E> pvup| & \TTBMKEY{i}{of {\tt min::packed\_vec\_updptr}}
\LABEL{MIN::PACKED_VEC_UPDPTR_[]} \\
\verb|min::ptr<E> pvup|
    & \TTMOKEY{+}{of {\tt min::packed\_vec\_updptr}}\verb|i|
\LABEL{MIN::PACKED_VEC_UPDPTR_+} \\
\verb|min::ptr<E>  min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::BEGIN_PTR_OF_PACKED_VEC_UPDPTR} \\
\verb|min::ptr<E> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::packed_vec_updptr<E,H,L> pvup )|
\LABEL{MIN::END_PTR_OF_PACKED_VEC_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insptr}\ARGBREAK
	  \verb|      <E,H=min::packed_vec_header<min::uns32>,|\ARGBREAK
	  \verb|         L=min::uns32>|\ARGBREAK
	  \verb|      pvip|\ARGBREAK
	  \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSPTR_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  min::gen v )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_GEN} \\
\multicolumn{2}{l}{\tt min::packed\_vec\_insptr<E,H,L> \&\
    \TTOMKEY{=}{=}{of {\tt min::packed\_vec\_insptr}}}\ARGBREAK[1.5in]
      \verb|( min::packed_vec_insptr<E,H,L> & pvip,|\ARGBREAK[1.5in]
      \verb|  const min::stub * s )|
\LABEL{MIN::=_PACKED_VEC_INSPTR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::ref<E> min::|
	& \MINKEY{push\RESIZE} \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_PUSH} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E const * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<const E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR_CONST} \\
\verb|void min::|
	& \MINKEY{push\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_PUSH_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|E min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\verb|void min::|
	& \MINKEY{pop}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 n, min::ptr<E> vp )|
\LABEL{MIN::PACKED_VEC_POP_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{resize\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve\RESIZE}\ARGBREAK
	  \verb|( packed_vec_insptr<E,H,L> pvip,|\ARGBREAK
	  \verb|  min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Files}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::file_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{file}
\LABEL{MIN::FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{3.4in}
\verb|min::packed_vec_insprt<char> file| & \TTARMKEY{buffer}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER} \\
\verb|min::uns32 file| & \TTARMKEY{buffer->length}{in {\tt min::file}}
\LABEL{MIN::FILE_BUFFER_LENGTH} \\
\verb|min::uns32 file| & \TTARMKEY{end\_offset}{in {\tt min::file}}
\LABEL{MIN::FILE_END_OFFSET} \\
\verb|min::uns32 file| & \TTARMKEY{end\_count}{in {\tt min::file}}
\LABEL{MIN::FILE_END_COUNT} \\
\verb|min::uns32 file| & \TTARMKEY{file\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_FILE_LINES} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL line\_\EOL number}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_NUMBER} \\
\verb|min::uns32 file|
    & \TTARMKEY{next\_\EOL offset}{in {\tt min::file}}
\LABEL{MIN::FILE_NEXT_LINE_OFFSET} \\
\verb|min::packed_vec_insptr<min::uns32> file|
    & \TTARMKEY{line\_index}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_INDEX} \\
\end{TABULAR}

\begin{TABULAR}{3.4in}
\verb|min::uns32 file| & \TTARMKEY{spool\_lines}{in {\tt min::file}}
\LABEL{MIN::FILE_SPOOL_LINES} \\
\verb|min::uns32 file| & \TTARMKEY{line\_display}{in {\tt min::file}}
\LABEL{MIN::FILE_LINE_DISPLAY} \\
\end{TABULAR}

\begin{TABULAR}{3.4in}
\verb|std::istream * file| & \TTARMKEY{istream}{in {\tt min::file}}
\LABEL{MIN::FILE_ISTREAM} \\
\verb|min::file file| & \TTARMKEY{ifile}{in {\tt min::file}}
\LABEL{MIN::FILE_IFILE} \\
\verb|std::ostream * file| & \TTARMKEY{ostream}{in {\tt min::file}}
\LABEL{MIN::FILE_OSTREAM} \\
\verb|min::printer file| & \TTARMKEY{printer}{in {\tt min::file}}
\LABEL{MIN::FILE_PRINTER} \\
\verb|min::file file| & \TTARMKEY{ofile}{in {\tt min::file}}
\LABEL{MIN::FILE_OFILE} \\
\verb|min::gen file| & \TTARMKEY{file\_name}{in {\tt min::file}}
\LABEL{MIN::FILE_FILENAME} \\
\end{TABULAR}


\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{init\RESIZE}\ARGBREAK
    \verb|( min::ref<min::file> file )|
\LABEL{MIN::INIT_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_line\_display\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display )|
\LABEL{MIN::INIT_PRINT_FLAGS_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_\EOL file\_\EOL name\REL}\ARGBREAK
	     \verb|( min::ref<min::file> file,|\ARGBREAK
             \verb|  min::gen file_name )|
\LABEL{MIN::INIT_FILE_NAME_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_ostream\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_ofile\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ofile )|
\LABEL{MIN::INIT_OFILE_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_printer\REL}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::printer printer )|
\LABEL{MIN::INIT_PRINTER_OF_FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{ALL\_LINES}
\LABEL{MIN::ALL_LINES} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{init\_\EOL input\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_stream\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  std::istream & istream,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STREAM_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::file ifile,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_FILE_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<const char> string )|\ARGBREAK
\LABEL{MIN::LOAD_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::ptr<char> string )|\ARGBREAK
\LABEL{MIN::LOAD_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{load\_string\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  const char * string )|\ARGBREAK
\LABEL{MIN::LOAD_CHAR_PTR_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::|
    & \MINKEY{load\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::gen file_name )|\ARGBREAK
\LABEL{MIN::LOAD_NAMED_FILE_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<const char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CONST_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::ptr<char> string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_STRING_OF_FILE} \\
\verb|void min::|
    & \MINKEY{init\_input\_string\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  const char * string,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_CHAR_PTR_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{init\_input\_named\_file\RESIZE}\ARGBREAK
          \verb|( min::ref<min::file> file,|\ARGBREAK
	  \verb|  min::gen file_name,|\ARGBREAK
	  \verb|  min::uns32 line_display = 0,|\ARGBREAK
	  \verb|  min::uns32 spool_lines = min::ALL_LINES )|
\LABEL{MIN::INIT_INPUT_NAMED_FILE_OF_FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{NO\_LINE}
\LABEL{MIN::NO_LINE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{next\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::NEXT_LINE_OF_FILE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::REMAINING_OFFSET} \\
\verb|min::uns32 min::|
    & \MINKEY{remaining\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::REMAINING_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{skip\_\EOL remaining} \verb|( min::file file )|
\LABEL{MIN::SKIP_REMAINING} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL length} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_LENGTH} \\
\verb|min::uns32 min::|
    & \MINKEY{partial\_\EOL offset} \verb|( min::file file )|
\LABEL{MIN::PARTIAL_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{file\_\EOL is\_\EOL complete} \verb|( min::file file )|
\LABEL{MIN::FILE_IS_COMPLETE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{line}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number )|
\LABEL{MIN::LINE_OF_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{flush\_spool\RESIZE}\ARGBREAK
	  \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 line_number =|\ARGBREAK
	  \verb|      min::NO_LINE )|
\LABEL{MIN::FLUSH_SPOOL} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{rewind}\ARGBREAK
	\verb|( min::file file,|\ARGBREAK
	\verb|  min::uns32 line_number = 0 )|
\LABEL{MIN::REWIND_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE} \verb|( min::file file )|
\LABEL{MIN::END_LINE_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{complete\_file} \verb|( min::file file )|
\LABEL{MIN::COMPLETE_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{end\_line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::END_LINE_FILE_WITH_OFFSET} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL file\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  bool copy_completion = true )|
\LABEL{MIN::FLUSH_FILE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{flush\_\EOL line\RESIZE}\ARGBREAK
          \verb|( min::file file,|\ARGBREAK
	  \verb|  min::uns32 offset )|
\LABEL{MIN::FLUSH_LINE} \\
\verb|min::uns32 min::|
    & \MINKEY{flush\_remaining\RESIZE} \verb|( min::file file )|
\LABEL{MIN::FLUSH_REMAINING} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<{}<}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{OSTREAM_OPERATOR<<_OF_FILE} \\
\verb|min::file |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::file ofile,|\ARGBREAK
      \verb|  min::file ifile )|
\LABEL{FILE_OPERATOR<<_OF_FILE} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::file}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file )|
\LABEL{PRINTER_OPERATOR<<_OF_FILE} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Identifier Maps}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|typedef min::|
	& \verb|packed_vec_ptr|\ARGBREAK
	  \verb|    < min::gen,|\ARGBREAK
	  \verb|      min::id_map_header<min::uns32> >|\ARGBREAK
	  \verb|min::|\MINKEY{id\_\EOL map}
\LABEL{MIN::ID_MAP} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::id_map min::| & \MINKEY{init\REL}
    \verb|( min::ref<min::id_map> map )|
\LABEL{MIN::INIT_OF_ID_MAP} \\
\end{TABULAR}

\begin{TABULAR}{3.2in}
\verb|min::ref<const min::gen> map| & \TTBMKEY{id}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_[]} \\
\verb|const min::uns32 map->| & \TTMKEY{length}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_LENGTH} \\
\verb|min::uns32 map->| & \TTMKEY{occupied}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_OCCUPIED} \\
\verb|min::uns32 map->| & \TTMKEY{next}{of {\tt min::id\_map}}
\LABEL{MIN::ID_MAP_NEXT} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|min::uns32 min::| & \MINKEY{find\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g )|
\LABEL{MIN::FIND_OF_ID_MAP} \\
\verb|min::uns32 min::| & \MINKEY{find\_\EOL or\_\EOL add\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g )|
\LABEL{MIN::FIND_OR_ADD_OF_ID_MAP} \\
\verb|void min::| & \MINKEY{map\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g,|\ARGBREAK
    \verb|  const min::gen_format * f = NULL )|
\LABEL{MIN::MAP_OF_ID_MAP} \\
\verb|void min::| & \MINKEY{insert\REL}\ARGBREAK
    \verb|( min::id_map map,|\ARGBREAK
    \verb|  min::gen g,|\ARGBREAK
    \verb|  min::uns32 id )|
\LABEL{MIN::INSERT_OF_ID_MAP} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Printers}

\begin{indpar}[0.2in]

\begin{TABULAR}{3.4in}
\verb|min::locatable_var<min::printer> min::| & \MINKEY{error\_\EOL message}
\LABEL{MIN::ERROR_MESSAGE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|typedef min::|
	& \verb|packed_struct_updptr<min::printer_struct>|\ARGBREAK
	  \verb|    min::|\MINKEY{printer}
\LABEL{MIN::PRINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::printer min::| & \MINKEY{init\REL}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  min::file file = min::NULL_STUB )|
\LABEL{MIN::INIT_OF_PRINTER} \\
\verb|min::printer min::| & \MINKEY{init\_ostream\RESIZE}\ARGBREAK
    \verb|( min::ref<min::printer> printer,|\ARGBREAK
    \verb|  std::ostream & ostream )|
\LABEL{MIN::INIT_OSTREAM_OF_PRINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|min::file printer->| & \TTMKEY{file}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_FILE} \\
\verb|std::ostream * printer->| & \TTMKEY{ostream}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_OSTREAM} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|struct    min::| & \MINKEY{line\_\EOL break}
\LABEL{MIN::LINE_BREAK_STRUCT} \\
\verb|{              | \\
\verb|    min::uns32 | & \TTMKEY{offset}{in {\tt min::line\_break}} \\
\verb|    min::uns32 | & \TTMKEY{column}{in {\tt min::line\_break}} \\
\verb|    min::uns32 | & \TTMKEY{line\_length}{in {\tt min::line\_break}} \\
\verb|    min::uns32 | & \TTMKEY{indent}{in {\tt min::line\_break}} \\
\verb|}              | \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{4.0in}
\verb|const min::uns32 printer->| & \TTMKEY{column}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_COLUMN} \\
\verb|const min::line_break printer->|
    & \TTMKEY{line\_break}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK} \\
\verb|const min::packed_vec_insptr<min::line_break>  | \\
\verb|printer->|
    & \TTMKEY{line\_break\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_LINE_BREAK_STACK} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|const min::line_break min::|
    & \TTKEY{default\_\EOL line\_\EOL break}
\LABEL{MIN::DEFAULT_LINE_BREAK} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.8in}
\verb|struct                 min::| & \MINKEY{print\_\EOL format}
\LABEL{MIN::PRINT_FORMAT_STRUCT} \\
\verb|{                           | \\
\verb|               min::uns32   |
	& \TTMKEY{op\_flags}{in {\tt min::print\_format}} \\
\verb|               min::uns32 * |
	& \TTMKEY{char\_flags}{in {\tt min::print\_format}} \\
\verb|       min::support_control|
	& \TTMKEY{support\_control}{in {\tt min::print\_format}} \\
\verb|       min::display_control|
	& \TTMKEY{display\_control}{in {\tt min::print\_format}} \\
\verb|         min::break_control|
	& \TTMKEY{break\_control}{in {\tt min::print\_format}} \\
\verb|   min::char_name_format *|
	& \TTMKEY{char\_name\_format}{in {\tt min::print\_format}} \\
\verb|          min::gen_format *|
	& \TTMKEY{gen\_format}{in {\tt min::print\_format}} \\
\verb|          min::gen_format *|
	& \TTMKEY{id\_map\_gen\_format}{in {\tt min::print\_format}} \\
\verb|}                           | \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{3.2in}
\verb|const min::print_format printer->|
    & \TTMKEY{print\_format}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT} \\
\verb|const min::packed_vec_insptr    | \\
\verb|<min::print_format>  | \\
\verb|printer->|
    & \TTMKEY{print\_format\_stack}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_PRINT_FORMAT_STACK} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.8in}
\verb|const min::print_format min::|
    & \TTKEY{default\_\EOL print\_\EOL format}
\LABEL{MIN::DEFAULT_PRINT_FORMAT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.8in}
\verb|min::file printer->|
    & \TTMKEY{id\_\EOL map}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP} \\
\verb|min::uns32 printer->|
    & \TTMKEY{\EOL id\_\EOL map->\EOL next}{in {\tt min::printer}}
\LABEL{MIN::PRINTER_ID_MAP_NEXT} \\
\end{TABULAR}

\bigskip

{\tt print\_format.op\_flags}:

\medskip

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{EXPAND\_HT}
\LABEL{MIN::EXPAND_HT_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_EOL}
\LABEL{MIN::DISPLAY_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_PICTURE}
\LABEL{MIN::DISPLAY_PICTURE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DISPLAY\_NON\_GRAPHIC}
\LABEL{MIN::DISPLAY_NON_GRAPHIC_FLAG} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ON\_EOL}
\LABEL{MIN::FLUSH_ON_EOL_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{FLUSH\_ID\_MAP\_ON\_EOM}
\LABEL{MIN::FLUSH_ID_MAP_ON_EOM_FLAG} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const min::uns32 min::| & \MINKEY{FORCE\_SPACE}
\LABEL{MIN::FORCE_SPACE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{FORCE\_PGEN}
\LABEL{MIN::FORCE_PGEN_FLAG} \\
\end{TABULAR}

\bigskip

\TT{print\_format.support\_control}:
\dotfill \pagref{MIN::SUPPORT_CONTROL_STRUCT}

\bigskip

\TT{print\_format.display\_control}:

\medskip

\begin{TABULAR}{2.8in}
\verb|struct     min::| & \MINKEY{display\_\EOL control}
\LABEL{MIN::DISPLAY_CONTROL_STRUCT} \\
\verb|{               | \\
\verb|     min::uns32 |
	& \TTMKEY{display\_char}{in {\tt min::display\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{display\_suppress}{in {\tt min::display\_control}} \\
\verb|}               | \\
\end{TABULAR}

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::display\_control
    min::~{graphic\_and\_hspace\_display\_control} =}\ARGBREAK[0.5in]
	\verb|{ min::IS_HSPACE  + min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_AND_HSPACE_DISPLAY_CONTROL} \\
\multicolumn{2}{l}{\tt const min::display\_control
    min::~{graphic\_only\_display\_control} =}\ARGBREAK[0.5in]
	\verb|{ min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_ONLY_DISPLAY_CONTROL} \\
\multicolumn{2}{l}{\tt const min::display\_control
    min::~{graphic\_and\_vhspace\_display\_control} =}\ARGBREAK[0.5in]
	\verb|{ min::IS_VHSPACE + min::IS_GRAPHIC, 0 };|
\LABEL{MIN::GRAPHIC_AND_VHSPACE_DISPLAY_CONTROL} \\
\multicolumn{2}{l}{\tt const min::display\_control
    min::~{display\_all\_display\_control} =}\ARGBREAK[0.5in]
	\verb|{ min::ALL_CHARS, 0 };|
\LABEL{MIN::DISPLAY_ALL_DISPLAY_CONTROL} \\
\end{TABULAR}

\bigskip

\TT{print\_format.break\_control}:

\medskip

\begin{TABULAR}{2.4in}
\verb|struct     min::| & \MINKEY{break\_\EOL control}
\LABEL{MIN::BREAK_CONTROL_STRUCT} \\
\verb|{               | \\
\verb|     min::uns32 |
	& \TTMKEY{break\_before}{in {\tt min::break\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{break\_after}{in {\tt min::break\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{conditional\_break}{in {\tt min::break\_control}} \\
\verb|     min::uns32 |
	& \TTMKEY{conditional\_columms}{in {\tt min::break\_control}} \\
\verb|}               | \\
\end{TABULAR}

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINKEY{no\_auto\_break\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ 0, 0, 0, 0 };|
\LABEL{MIN::NO_AUTO_BREAK_BREAK_CONTROL} \\
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINKEY{break\_after\_space\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ min::IS_BHSPACE, 0, 0, 0 };|
\LABEL{MIN::BREAK_AFTER_SPACE_BREAK_CONTROL} \\
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINKEY{break\_before\_all\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ 0, min::ALL_CHARS, 0, 0 };|
\LABEL{MIN::BREAK_BEFORE_NON_SPACE_BREAK_CONTROL} \\
\multicolumn{2}{l}{\tt const min::break\_control
    min::\MINKEY{break\_after\_hyphens\_break\_control} =}\ARGBREAK[1.0in]
\verb|{ min::IS_BHSPACE, 0, min::CONDITIONAL_BREAK, 4 };|
\LABEL{MIN::BREAK_AFTER_HYPHENS_BREAK_CONTROL} \\
\end{TABULAR}

\bigskip

\TT{print\_format.char\_name\_format}:

\medskip

\begin{TABULAR}{2.8in}
\verb|struct               min::|
    & \MINKEY{char\_\EOL name\_\EOL format}
\LABEL{MIN::CHAR_NAME_FORMAT_STRUCT} \\
\verb|{                         | \\
\verb|     min::ustring |
	& \TTMKEY{char\_name\_prefix}{in {\tt min::char\_name\_format}} \\
\verb|     min::ustring |
	& \TTMKEY{char\_name\_postfix}{in {\tt min::char\_name\_format}} \\
\verb|}                         | \\
\end{TABULAR}

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::char\_name\_format
    min::\MINKEY{standard\_char\_name\_format} =}\ARGBREAK[1.0in]
\verb|{ (min::ustring) "\x01\x01" "<",|\ARGBREAK[1.0in]
\verb|  (min::ustring) "\x01\x01" ">" };|
\LABEL{MIN::STANDARD_CHAR_NAME_FORMAT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, const char * s )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR_*} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::ptr<const char> s )|
\LABEL{PRINTER_OPERATOR<<_OF_PTR_CONST_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::ptr<char> s )|
\LABEL{PRINTER_OPERATOR<<_OF_PTR_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::str_ptr const & s )|
\LABEL{PRINTER_OPERATOR<<_OF_STR_PTR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, char c )|
\LABEL{PRINTER_OPERATOR<<_OF_CHAR} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int32 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::int64 i )|
\LABEL{PRINTER_OPERATOR<<_OF_INT64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns32 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS32} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::uns64 u )|
\LABEL{PRINTER_OPERATOR<<_OF_UNS64} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::float64 f )|
\LABEL{PRINTER_OPERATOR<<_OF_FLOAT64} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}{of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::op const & op )|
\LABEL{OPERATOR<<_OF_PRINTER_OP} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{eol}
\LABEL{MIN::EOL} \\
\verb|const min::op min::| & \MINKEY{flush}
\LABEL{MIN::FLUSH} \\
\verb|const min::op min::| & \MINKEY{bol}
\LABEL{MIN::BOL} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|std::ostream & |
    & \TTOMKEY{<<}{<{}<}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( std::ostream & out,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{OSTREAM_OPERATOR<<_OF_PRINTER} \\
\verb|min::file |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  min::printer printer )|
\LABEL{FILE_OPERATOR<<_OF_PRINTER} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer oprinter,|\ARGBREAK
      \verb|  min::printer iprinter )|
\LABEL{PRINTER_OPERATOR<<_OF_PRINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|min::op min::|
    & \MINKEY{punicode} \verb|( min::Uchar c )|
\LABEL{MIN::PUNICODE} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  const min::Uchar * str )|
\LABEL{MIN::PUNICODE_BUFFER} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  min::ptr<const min::Uchar> str )|
\LABEL{MIN::PUNICODE_BUFFER_CONST_PTR} \\
\verb|min::op min::|
    & \MINKEY{punicode}\ARGBREAK
      \verb|( min::unsptr length,|\ARGBREAK
      \verb|  min::ptr<min::Uchar> str )|
\LABEL{MIN::PUNICODE_BUFFER_PTR}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|min::op min::|
    & \MINKEY{pint}\ARGBREAK
	  \verb|( min::int32 i,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PINT32} \\
\verb|min::op min::|
    & \MINKEY{pint}\ARGBREAK
	  \verb|( min::int64 i,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PINT64} \\
\verb|min::op min::|
    & \MINKEY{puns}\ARGBREAK
	  \verb|( min::uns32 u,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PUNS32} \\
\verb|min::op min::|
    & \MINKEY{puns}\ARGBREAK
	  \verb|( min::uns64 u,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PUNS64} \\
\verb|min::op min::|
    & \MINKEY{pfloat}\ARGBREAK
	  \verb|( min::float64 f,|\ARGBREAK
	  \verb|  const char * printf_format )|
\LABEL{MIN::PFLOAT64} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::|
    & \MINKEY{pwidth}\ARGBREAK
         \verb|( min::uns32 & column,|\ARGBREAK
         \verb|  const char * s, min::unsptr n,|\ARGBREAK
         \verb|  const min::print_format & print_format )|
\LABEL{MIN::PWIDTH_OF_STRING}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::|
    & \MINKEY{printf\_op}\verb|<unsigned length>|\ARGBREAK
          \verb|( const char * format, ... )|
\LABEL{MIN::PRINTF_OP} \\
\verb|const min::op min::| & \MINKEY{pnop}
\LABEL{MIN::PNOP} \\
\end{TABULAR}

\bigskip

\INDEXHEADER{Adjusting Printer Parameters}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::|
    & \MINKEY{save\_print\_format}
\LABEL{MIN::SAVE_PRINT_FORMAT} \\
\verb|const min::op min::|
    & \MINKEY{restore\_print\_format}
\LABEL{MIN::RESTORE_PRINT_FORMAT}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|min::op min::|
    & \MINKEY{set\_\EOL line\_length}\ARGBREAK
      \verb|( min::uns32 line_length )|
\LABEL{MIN::SET_LINE_LENGTH} \\
\verb|min::op min::|
    & \MINKEY{set\_\EOL indent}\ARGBREAK
      \verb|( min::uns32 indent )|
\LABEL{MIN::SET_INDENT} \\
\verb|min::op min::|
    & \MINKEY{set\_print\_op\_flags}\ARGBREAK
      \verb|( min::uns32 print_op_flags )|
\LABEL{MIN::SET_PRINT_OP_FLAGS} \\
\verb|min::op min::|
    & \MINKEY{clear\_print\_op\_flags}\ARGBREAK
      \verb|( min::uns32 print_op_flags )|
\LABEL{MIN::CLEAR_PRINT_OP_FLAGS}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{expand\_ht}
\LABEL{MIN::EXPAND_HT} \\
\verb|const min::op min::| & \MINKEY{noexpand\_ht}
\LABEL{MIN::NOEXPAND_HT}
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{display\_eol}
\LABEL{MIN::DISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_eol}
\LABEL{MIN::NODISPLAY_EOL} \\
\verb|const min::op min::| & \MINKEY{display\_picture}
\LABEL{MIN::DISPLAY_PICTURE} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_picture}
\LABEL{MIN::NODISPLAY_PICTURE} \\
\verb|const min::op min::| & \MINKEY{display\_non\_graphic}
\LABEL{MIN::DISPLAY_NON_GRAPHIC} \\
\verb|const min::op min::| & \MINKEY{nodisplay\_non\_graphic}
\LABEL{MIN::NODISPLAY_NON_GRAPHIC} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{flush\_on\_eol}
\LABEL{MIN::FLUSH_ON_EOL} \\
\verb|const min::op min::| & \MINKEY{noflush\_on\_eol}
\LABEL{MIN::NOFLUSH_ON_EOL} \\
\verb|const min::op min::| & \MINKEY{flush\_id\_map\_on\_eom}
\LABEL{MIN::FLUSH_ID_MAP_ON_EOM} \\
\verb|const min::op min::| & \MINKEY{noflush\_id\_map\_on\_eom}
\LABEL{MIN::NOFLUSH_ID_MAP_ON_EOM}
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{force\_space}
\LABEL{MIN::FORCE_SPACE} \\
\verb|const min::op min::| & \MINKEY{noforce\_space}
\LABEL{MIN::NOFORCE_SPACE} \\
\verb|const min::op min::| & \MINKEY{force\_pgen}
\LABEL{MIN::FORCE_PGEN} \\
\verb|const min::op min::| & \MINKEY{noforce\_pgen}
\LABEL{MIN::NOFORCE_PGEN} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{ascii}
\LABEL{MIN::ASCII} \\
\verb|const min::op min::| & \MINKEY{latin1}
\LABEL{MIN::LATIN1} \\
\verb|const min::op min::| & \MINKEY{support\_all}
\LABEL{MIN::SUPPORT_ALL} \\
\verb|min::op min::|
    & \MINKEY{set\_support\_control}\ARGBREAK
          \verb|( const min::support_control & sc )|
\LABEL{MIN::SET_SUPPORT_CONTROL}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{graphic\_and\_hspace}
\LABEL{MIN::GRAPHIC_AND_HSPACE} \\
\verb|const min::op min::| & \MINKEY{graphic\_only}
\LABEL{MIN::GRAPHIC_ONLY} \\
\verb|const min::op min::| & \MINKEY{graphic\_and\_vhspace}
\LABEL{MIN::GRAPHIC_AND_VHSPACE} \\
\verb|const min::op min::| & \MINKEY{display\_all}
\LABEL{MIN::DISPLAY_ALL} \\
\verb|min::op min::|
    & \MINKEY{set\_display\_control}\ARGBREAK
          \verb|( const min::display_control & dc )|
\LABEL{MIN::SET_DISPLAY_CONTROL}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{no\_auto\_break}
\LABEL{MIN::NO_AUTO_BREAK} \\
\verb|const min::op min::| & \MINKEY{break\_after\_space}
\LABEL{MIN::BREAK_AFTER_SPACE} \\
\verb|const min::op min::| & \MINKEY{break\_before\_all}
\LABEL{MIN::BREAK_BEFORE_ALL} \\
\verb|const min::op min::| & \MINKEY{break\_after\_hyphens}
\LABEL{MIN::BREAK_AFTER_HYPHENS} \\
\verb|min::op min::|
    & \MINKEY{set\_break\_control}\ARGBREAK
          \verb|( const min::break_control & bc )|
\LABEL{MIN::SET_BREAK_CONTROL}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{verbatim}
\LABEL{MIN::VERBATIM} \\
\verb|min::op min::|
    & \MINKEY{set\_line\_display}\ARGBREAK
      \verb|( min::uns32 line_display )|
\LABEL{MIN::SET_LINE_DISPLAY}
\end{TABULAR}

\INDEXHEADER{Printer Line Breaks}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{set\_\EOL break}
\LABEL{MIN::SET_BREAK} \\
\verb|const min::op min::| & \MINKEY{left} \verb|( min::uns32 width )|
\LABEL{MIN::LEFT} \\
\verb|const min::op min::| & \MINKEY{right} \verb|( min::uns32 width )|
\LABEL{MIN::RIGHT} \\
\verb|const min::op min::| & \MINKEY{reserve} \verb|( min::uns32 width )|
\LABEL{MIN::RESERVE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{indent}
\LABEL{MIN::INDENT} \\
\verb|const min::op min::| & \MINKEY{eol\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::EOL_IF_AFTER_INDENT} \\
\verb|const min::op min::| & \MINKEY{spaces\_\EOL if\_\EOL before\_\EOL indent}
\LABEL{MIN::SPACES_IF_BEFORE_INDENT} \\
\verb|const min::op min::| & \MINKEY{space\_\EOL if\_\EOL after\_\EOL indent}
\LABEL{MIN::SPACE_IF_AFTER_INDENT} \\
\verb|const min::op min::| & \MINKEY{space\_\EOL if\_\EOL none}
\LABEL{MIN::SPACE_IF_NONE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{erase\_\EOL space}
\LABEL{MIN::ERASE_SPACE} \\
\verb|const min::op min::| & \MINKEY{erase\_\EOL all\_\EOL space}
\LABEL{MIN::ERASE_ALL_SPACE} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::|
    & \MINKEY{save\_line\_break}
\LABEL{MIN::SAVE_LINE_BREAK} \\
\verb|const min::op min::|
    & \MINKEY{restore\_line\_break}
\LABEL{MIN::RESTORE_LINE_BREAK} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::|
    & \MINKEY{save\_indent}
\LABEL{MIN::SAVE_INDENT} \\
\verb|const min::op min::|
    & \MINKEY{restore\_indent}
\LABEL{MIN::RESTORE_INDENT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const min::op min::| & \MINKEY{bom}
\LABEL{MIN::BOM} \\
\verb|const min::op min::| & \MINKEY{eom}
\LABEL{MIN::EOM} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::op min::|
    & \MINKEY{place\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::PLACE_INDENT} \\
\verb|min::op min::|
    & \MINKEY{adjust\_\EOL indent} \verb|( min::int32 offset )|
\LABEL{MIN::ADJUST_INDENT} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Leading and Trailing Separators}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::op min::| & \MINKEY{leading}
\LABEL{MIN::LEADING} \\
\verb|min::op min::| & \MINKEY{trailing}
\LABEL{MIN::TRAILING} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::op min::| & \MINKEY{leading\_always}
\LABEL{MIN::LEADING_ALWAYS} \\
\verb|min::op min::| & \MINKEY{trailing\_always}
\LABEL{MIN::TRAILING_ALWAYS} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printer Strings}

\begin{indpar}[0.2in]

\begin{TABULAR}{3.0in}
\verb|typedef min::printer (* min::| & \MINKEY{pstring}\verb|)|\ARGBREAK
	    \verb|( min::printer printer )|
\LABEL{MIN::PSTRING} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::pstring}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::pstring pstring )|
\LABEL{PRINTER_OPERATOR<<_OF_PSTRING} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::printer min::| & \MINKEY{print\_item}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  const char * p,|\ARGBREAK
	\verb|  min::unsptr n,|\ARGBREAK
	\verb|  min::uns32 columns,|\ARGBREAK
	\verb|  min::uns32 str_class =|\ARGBREAK
	\verb|      min::IS_GRAPHIC )|
\LABEL{MIN::PRINT_ITEM} \\
\verb|min::printer min::| & \MINKEY{print\_space}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  min::unsptr n = 1 )|
\LABEL{MIN::PRINT_SPACE} \\
\verb|min::printer min::| & \MINKEY{print\_space\_if\_none}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_SPACE_IF_NONE} \\
\verb|min::printer min::| & \MINKEY{print\_leading}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_LEADING} \\
\verb|min::printer min::| & \MINKEY{print\_erase\_space}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  min::uns32 n = 1 )|
\LABEL{MIN::PRINT_ERASE_SPACE} \\
\verb|min::printer min::| & \MINKEY{print\_trailing}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_TRAILING} \\
\verb|min::printer min::| & \MINKEY{print\_leading\_always}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_LEADING_ALWAYS} \\
\verb|min::printer min::| & \MINKEY{print\_trailing\_always}\ARGBREAK
	\verb|( min::printer printer )|
\LABEL{MIN::PRINT_TRAILING_ALWAYS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::printer min::| & \MINKEY{print\_item\_preface}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  min::uns32 str_class )|
\LABEL{MIN::PRINT_ITEM_PREFACE} \\
\verb|min::printer min::| & \MINKEY{print\_chars}\ARGBREAK
	\verb|( min::printer printer,|\ARGBREAK
	\verb|  const char * p,|\ARGBREAK
	\verb|  min::unsptr n,|\ARGBREAK
	\verb|  min::uns32 columns )|
\LABEL{MIN::PRINT_CHARS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::printer min::| & \MINKEY{print\_ustring}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::ustring s )|
\LABEL{MIN::PRINT_USTRING} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printing File Lines and Phrases}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  min::uns32 first, min::uns32 last )|
\LABEL{MIN::PLINE_NUMBERS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::pline_numbers const & pline_numbers )|
\LABEL{PRINTER_OPERATOR<<_OF_PLINE_NUMBERS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|struct min::| & \MINKEY{position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::uns32 line;|\ARGBREAK
    \verb|  min::uns32 offset;|\ARGBREAK
    \verb|};|
\LABEL{MIN::POSITION_STRUCT} \\
\end{TABULAR}

\begin{TABULAR}{2.2in}
\verb|const min::position min::| & \MINKEY{MISSING\_POSITION}\ARGBREAK
    \verb|= { 0xFFFFFFFF, 0xFFFFFFFF }|
\LABEL{MIN::MISSING_POSITION} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool |
    & \TTOMKEY{==}{==}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR==_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{!=}{!=}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR!=_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{<}{<}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR<_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{<=}{<=}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR<=_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{>}{>}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR>_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{>=}{>=}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p1,|\ARGBREAK
      \verb|  const min::position & p2 )|
\LABEL{OPERATOR>=_OF_POSITION} \\
\verb|bool |
    & \TTOMKEY{(bool)}{(bool)}%
              {of {\tt min::position}}\ARGBREAK
      \verb|( const min::position & p )|
\LABEL{OPERATOR(bool)_OF_POSITION} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|struct min::| & \MINKEY{phrase\_\EOL position}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::position begin;|\ARGBREAK
    \verb|  min::position end;|\ARGBREAK
    \verb|};|
\LABEL{MIN::PHRASE_POSITION_STRUCT} \\
\end{TABULAR}

\begin{TABULAR}{1.7in}
\verb|(constructor) min::| & \MINKEY{pline\_numbers}\ARGBREAK
    \verb|( min::file file,|\ARGBREAK
    \verb|  const min::phrase_position|\ARGBREAK
    \verb|        & position )|
\LABEL{MIN::PLINE_NUMBERS_OF_PHRASE_POSITION} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\_\EOL column\RESIZE}\ARGBREAK
      \verb|( min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  const min::print_format & print_format )|
\LABEL{MIN::PRINT_LINE_COLUMN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL line\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::uns32 line_number,|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_LINE_WITH_FLAGS} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::|
    & \MINKEY{print\_\EOL phrase\_\EOL lines\RESIZE}\ARGBREAK
      \verb|( min::printer printer,|\ARGBREAK
      \verb|  min::uns32 line_display,|\ARGBREAK
      \verb|  min::file file,|\ARGBREAK
      \verb|  min::phrase_position const & position,|\ARGBREAK
      \verb|  char mark = '^',|\ARGBREAK
      \verb|  const char * blank_line =|\ARGBREAK
      \verb|      "<BLANK-LINE>",|\ARGBREAK
      \verb|  const char * end_of_file =|\ARGBREAK
      \verb|      "<END-OF-FILE>",|\ARGBREAK
      \verb|  const char * unavailable_line =|\ARGBREAK
      \verb|      "<UNAVAILABLE-LINE>" )|
\LABEL{MIN::PRINT_PHRASE_LINES_WITH_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\verb|typedef min::|
	& \verb|packed_vec_ptr<min::phrase_position_vec_header,|\\&
	  \verb|               min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec}
\LABEL{MIN::PHRASE_POSITION_VEC} \\
\verb|typedef min::|
	& \verb|packed_vec_insptr<min::phrase_position_vec_header,|\\&
	  \verb|                  min::phrase_position>|\\&
	  \verb|    min::|\MINKEY{phrase\_position\_vec\_insptr}
\LABEL{MIN::PHRASE_POSITION_VEC_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.8in}
\verb|min::| 
  & \verb|phrase_position_vec_insptr min::|\MINKEY{init\RESIZE}\ARGBREAK
    \verb|( min::ref<min::phrase_position_vec_insptr> vec,|\ARGBREAK
    \verb|  min::file file,|\ARGBREAK
    \verb|  min::phrase_position const & position,|\ARGBREAK
    \verb|  min::uns32 max_length )|
\LABEL{MIN::INIT_OF_PHRASE_POSITION_VEC} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.6in}
\verb|const min::uns32 vpp| & \TTARMKEY{length}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_LENGTH} \\
\verb|const min::file vpp| & \TTARMKEY{file}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_FILE} \\
\verb|min::phrase_position vpp| & \TTARMKEY{position}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_POSITION} \\
\verb|min::phrase_position vpp| & \TTBMKEY{i}%
    {in {\tt min::phrase\_\EOL position\_\EOL vec}}
\LABEL{MIN::PHRASE_POSITION_VEC_ELEMENT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.6in}
\verb|min::phrase_position_vec min::| & \MINKEY{position\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::POSITION_OF_OBJECT_VEC_PTR} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printing General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::op min::| & \MINKEY{pgen} \verb|( min::gen v )|
\LABEL{MIN::PGEN} \\
\verb|min::printer |
    & \TTOMKEY{<<}{<{}<\RESIZE}%
              {of {\tt min::printer}}\ARGBREAK
      \verb|( min::printer printer, min::gen v )|
\LABEL{PRINTER_OPERATOR<<_OF_GEN} \\
\verb|min::op min::|
    & \MINKEY{pgen}\ARGBREAK
	  \verb|( min::gen v,|\ARGBREAK
	  \verb|  const min::gen_format * gen_format )|
\LABEL{MIN::PGEN_WITH_GEN_FORMAT} \\
\verb|min::op min::|
    & \MINKEY{set\_gen\_format}\ARGBREAK
	  \verb|( const min::gen_format * gen_format )|
\LABEL{MIN::SET_GEN_FORMAT} \\
\verb|min::op min::| & \MINKEY{pgen\_name} \verb|( min::gen v )|
\LABEL{MIN::PGEN_NAME} \\
\verb|min::op min::| & \MINKEY{pgen\_quote} \verb|( min::gen v )|
\LABEL{MIN::PGEN_QUOTE} \\
\verb|min::op min::| & \MINKEY{pgen\_never\_quote} \verb|( min::gen v )|
\LABEL{MIN::PGEN_NEVER_QUOTE} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{print\_gen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::PRINT_GEN} \\
\verb|min::printer min::| & \MINKEY{print\_gen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  const min::gen_format * f )|
\LABEL{MIN::PRINT_GEN_WITH_FORMAT} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.2in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{gen\_format}}
\LABEL{MIN::GEN_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::printer ( * pgen )|\ARGBREAK
    \verb|       ( min::printer printer,|\ARGBREAK
    \verb|         min::gen v,|\ARGBREAK
    \verb|         const min::gen_format * gen_format );|%
\ttmindex{pgen}{in {\tt min::gen\_format}}\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  // Members beyond this point may be moved and|\ARGBREAK
    \verb|  // new members may be added.|\ARGBREAK
    \verb||\ARGBREAK
    \verb|  const min::num_format *  num_format;|%
\ttmindex{num\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::str_format *  str_format;|%
\ttmindex{str\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::lab_format *  lab_format;|%
\ttmindex{lab\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::special_format *  special_format;|%
\ttmindex{special\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|  const min::obj_format *  obj_format;|%
\ttmindex{obj\_format}{in {\tt min::gen\_format}}\ARGBREAK
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{element\_gen\_format}:}
\LABEL{MIN::ELEMENT_GEN_FORMAT}\ARGBREAK[0in]
\verb|& min::standard_pgen                    // pgen |\ARGBREAK[0in]
\verb|min::long_num_format                    // num_format|\ARGBREAK[0in]
\verb|min::quote_separator_str_format         // str_format|\ARGBREAK[0in]
\verb|min::bracket_lab_format                 // lab_format|\ARGBREAK[0in]
\verb|min::bracket_special_format             // special_format|\ARGBREAK[0in]
\verb|min::compact_obj_format                 // obj_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{top\_gen\_format}:}
\LABEL{MIN::TOP_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::top_obj_format                     // obj_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{value\_gen\_format}:}
\LABEL{MIN::VALUE_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::quote_all_str_format               // str_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{id\_map\_gen\_format}:}
\LABEL{MIN::ID_MAP_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::quote_separator_and_mark_str_format // str_format|\ARGBREAK[0in]
\verb|min::isolated_line_obj_format           // obj_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{name\_gen\_format}:}
\LABEL{MIN::NAME_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::quote_separator_and_mark_str_format // str_format|\ARGBREAK[0in]
\verb|min::name_lab_format                    // lab_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{leading\_always\_gen\_format}:}
\LABEL{MIN::LEADING_ALWAYS_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::standard_str_format                // str_format|\ARGBREAK[0in]
\verb|min::leading_always_lab_format          // lab_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{trailing\_always\_gen\_format}:}
\LABEL{MIN::TRAILING_ALWAYS_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::standard_str_format                // str_format|\ARGBREAK[0in]
\verb|min::trailing_always_lab_format         // lab_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{always\_quote\_gen\_format}:}
\LABEL{MIN::ALWAYS_QUOTE_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::quote_all_str_format               // str_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{never\_quote\_gen\_format}:}
\LABEL{MIN::NEVER_QUOTE_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|NULL                                    // str_format|\ARGBREAK[0in]
\verb|min::name_lab_format                    // lab_format|\ARGBREAK[0in]
\verb|min::name_special_format                // special_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{line\_gen\_format}:}
\LABEL{MIN::LINE_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::line_obj_format                    // obj_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt const min::gen\_format *
                   min::\MINKEY{paragraph\_gen\_format}:}
\LABEL{MIN::PARAGRAPH_GEN_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::element_gen_format except for:|\ARGBREAK[0in]
\verb|min::paragraph_obj_format               // obj_format|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{standard\_pgen}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  const min::gen_format * gen_format )|
\LABEL{MIN::STANDARD_PGEN} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printing Numeric General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{num\_format}}
\LABEL{MIN::NUM_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const char *        int_printf_format;|%
\ttmindex{int\_printf\_format}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  min::float64        non_float_bound;|%
\ttmindex{non\_float\_bound}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  const char *        float_printf_format;|%
\ttmindex{float\_printf\_format}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  const min::uns32 *  fraction_divisors;|%
\ttmindex{fraction\_divisors\_format}{in {\tt min::num\_format}}\ARGBREAK
    \verb|  min::float64        fraction_accuracy;|%
\ttmindex{fraction\_accuracy}{in {\tt min::num\_format}}\ARGBREAK
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{const min::num\_format *
                   min::\MINKEY{short\_num\_format}:}
\LABEL{MIN::SHORT_NUM_FORMAT}\ARGBREAK
\verb|"%.0f"                  // int_printf_format|\ARGBREAK
\verb|1e7                     // non_float_bound|\ARGBREAK
\verb|"%.6g"                  // float_printf_format|\ARGBREAK
\verb|NULL                    // fraction_divisors|\ARGBREAK
\verb|0                       // fraction_accuracy|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{const min::num\_format *
                   min::\MINKEY{fraction\_num\_format}:}
\LABEL{MIN::FRACTION_NUM_FORMAT}\ARGBREAK
\verb|"%.0f"                  // int_printf_format|\ARGBREAK
\verb|1e7                     // non_float_bound|\ARGBREAK
\verb|"%.6g"                  // float_printf_format|\ARGBREAK
\verb|min::standard_divisors  // fraction_divisors|\ARGBREAK
\verb|1e-9                    // fraction_accuracy|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{const min::num\_format *
                   min::\MINKEY{long\_num\_format}:}
\LABEL{MIN::LONG_NUM_FORMAT}\ARGBREAK
\verb|"%.0f"                  // int_printf_format|\ARGBREAK
\verb|1e15                    // non_float_bound|\ARGBREAK
\verb|"%.15g                  // float_printf_format|\ARGBREAK
\verb|NULL                    // fraction_divisors|\ARGBREAK
\verb|0                       // fraction_accuracy|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{const min::uns32 *
                   min::\MINKEY{standard\_divisors}:}\ARGBREAK
\verb|2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,|\ARGBREAK
\verb|16, 32, 64, 128, 256, 512, 1024, 0|\ARGBREAK
\LABEL{MIN::STANDARD_DIVISORS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{print\_num}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::float64 value,|\ARGBREAK
    \verb|  const min::num_format *|\ARGBREAK
    \verb|        num_format = NULL )|
\LABEL{MIN::PRINT_NUM} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printing String General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{str\_format}}
\LABEL{MIN::STR_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::str_classifier   quote_control;|%
\ttmindex{quote\_control}{in {\tt min::str\_format}}\ARGBREAK
    \verb|  min::quote_format     quote_format;|%
\ttmindex{quote\_format}{in {\tt min::str\_format}}\ARGBREAK
    \verb|  min::display_control  display_control;|%
\ttmindex{display\_control}{in {\tt min::str\_format}}\ARGBREAK
    \verb|  min::uns32            id_strlen;|%
\ttmindex{id\_strlen}{in {\tt min::str\_format}}\ARGBREAK
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\TTKEY{MIN\_ID\_STRLEN} &
    \verb|  // == 21, minimum effective value for id_strlen.|\ARGBREAK
\LABEL{MIN_ID_STRLEN}
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.1in}
\multicolumn{2}{l}{const min::str\_format *
    min::\MINKEY{standard\_str\_format}:}
\LABEL{MIN::STANDARD_STR_FORMAT}\ARGBREAK
\verb|min::standard_str_classifier           // str_classifier|\ARGBREAK
\verb|min::standard_quote_format             // quote_format|\ARGBREAK
\verb|min::graphic_only_display_control      // display_control|\ARGBREAK
\verb|MIN_ID_STRLEN                          // id_strlen|
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.1in}
\multicolumn{2}{l}{const min::str\_format *
                   min::\MINLKEY{quote\_separator}{\_str\_format}:}
\LABEL{MIN::QUOTE_SEPARATOR_STR_FORMAT}\ARGBREAK
\verb|// Same as min::standard_str_format except for:|\ARGBREAK
\verb|min::quote_separator_str_classifier    // str_classifier|\ARGBREAK
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.1in}
\multicolumn{2}{l}{const min::str\_format *
                   min::\MINLKEY{quote\_separator\_and\_mark}{\_str\_format}:}
\LABEL{MIN::QUOTE_SEPARATOR_AND_MARK_STR_FORMAT}\ARGBREAK
\verb|// Same as min::standard_str_format except for:|\ARGBREAK
\verb|min::quote_separator_and_mark_str_classifier // str_classifier|\ARGBREAK
\verb|0                                            // id_strlen|
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.1in}
\multicolumn{2}{l}{const min::str\_format *
                   min::\MINKEY{quote\_all\_str\_format}:}
\LABEL{MIN::QUOTE_ALL_STR_FORMAT}\ARGBREAK
\verb|// Same as min::standard_str_format except for:|\ARGBREAK
\verb|min::quote_all_str_classifier                // str_classifier|\ARGBREAK
\verb|0                                            // id_strlen|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{quote\_format}}
\LABEL{MIN::QUOTE_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::ustring    str_prefix;|%
\ttmindex{str\_prefix}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|  min::ustring    str_postfix;|%
\ttmindex{str\_postfix}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|  min::ustring    str_postfix_name;|%
\ttmindex{str\_postfix\_name}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|  min::ustring    str_concatenator;|%
\ttmindex{str\_concatenator}{in {\tt min::quote\_format}}\ARGBREAK
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.5in}
\multicolumn{2}{l}{\tt const min::quote\_format
                   min::\MINKEY{standard\_quote\_format}:}
\LABEL{MIN::STANDARD_QUOTE_FORMAT}\ARGBREAK
\verb|(min::ustring) "\x01\x01" "\""   // str_prefix|\ARGBREAK
\verb|(min::ustring) "\x01\x01" "\""   // str_postfix|\ARGBREAK
\verb|(min::ustring) "\x03\x03" "<Q>"  // str_postfix_name|\ARGBREAK
\verb|(min::ustring) "\x01\x01" "#"    // str_concatenator|\ARGBREAK
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{print\_str}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min:gen str,|\ARGBREAK
    \verb|  const min::str_format *|\ARGBREAK
    \verb|        str_format = NULL )|
\LABEL{MIN::PRINT_STR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{print\_cstring}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  const char * str,|\ARGBREAK
    \verb|  const min::str_format *|\ARGBREAK
    \verb|        str_format = NULL )|
\LABEL{MIN::PRINT_CSTRING} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{print\_unicode}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::unsptr n,|\ARGBREAK
    \verb|  min::ptr<const min::Uchar> p,|\ARGBREAK
    \verb|  const min::str_format *|\ARGBREAK
    \verb|        str_format = NULL )|
\LABEL{MIN::PRINT_UNICODE} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printing Label General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{lab\_format}}
\LABEL{MIN::LAB_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::pstring         lab_prefix;|%
\ttmindex{lab\_prefix}{in {\tt min::lab\_format}}\ARGBREAK
    \verb|  min::pstring         lab_separator;|%
\ttmindex{lab\_separator}{in {\tt min::lab\_format}}\ARGBREAK
    \verb|  min::pstring         lab_postfix;|%
\ttmindex{lab\_postfix}{in {\tt min::lab\_format}}\ARGBREAK
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{name\_lab\_format}:}
\LABEL{MIN::NAME_LAB_FORMAT}\ARGBREAK
\verb|NULL                                     // lab_prefix|\ARGBREAK
\verb|min::space_if_none_pstring               // lab_separator " "|\ARGBREAK
\verb|NULL                                     // lab_postfix|\ARGBREAK
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{leading\_always\_lab\_format}:}
\LABEL{MIN::LEADING_ALWAYS_LAB_FORMAT}\ARGBREAK
\verb|NULL                                     // lab_prefix|\ARGBREAK
\verb|min::leading_always_pstring              // lab_separator|\ARGBREAK
\verb|     // Equivalent to printer << min::leading|\ARGBREAK
\verb|NULL                                     // lab_postfix|\ARGBREAK
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{trailing\_always\_lab\_format}:}
\LABEL{MIN::TRAILING_ALWAYS_LAB_FORMAT}\ARGBREAK
\verb|NULL                                     // lab_prefix|\ARGBREAK
\verb|min::trailing_always_pstring             // lab_separator|\ARGBREAK
\verb|     // Equivalent to printer << min::trailing|\ARGBREAK
\verb|NULL                                     // lab_postfix|\ARGBREAK
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::lab\_format
                   min::\MINKEY{bracket\_lab\_format}:}
\LABEL{MIN::BRACKET_LAB_FORMAT}\ARGBREAK
\verb|min::left_square_angle_space_pstring     // lab_prefix    "[< "|\ARGBREAK
\verb|min::space_if_none_pstring               // lab_separator " "|\ARGBREAK
\verb|min::space_angle_right_square_pstring    // lab_postfix   " >]"|\ARGBREAK
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printing Special General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.1in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{special\_format}}
\LABEL{MIN::SPECIAL_FORMAT}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::pstring                         special_prefix;|%
\ttmindex{special\_prefix}{in {\tt min::special\_format}}\ARGBREAK
    \verb|  min::pstring                         special_postfix;|%
\ttmindex{special\_postfix}{in {\tt min::special\_format}}\ARGBREAK
    \verb|  min::packed_vec_ptr<min::ustring>    special_names;|%
\ttmindex{special\_names}{in {\tt min::special\_format}}\ARGBREAK
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::special\_format
                   min::\MINKEY{name\_special\_format}:}
\LABEL{MIN::NAME_SPECIAL_FORMAT}\ARGBREAK
\verb|NULL                                     // special_prefix|\ARGBREAK
\verb|NULL                                     // special_postfix|\ARGBREAK
\verb|min::standard_special_names              // special_names|\ARGBREAK
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt const min::special\_format
                   min::\MINKEY{bracket\_special\_format}:}
\LABEL{MIN::BRACKET_SPECIAL_FORMAT}\ARGBREAK
\verb|min::left_square_dollar_space_pstring    // special_prefix   "[$ "|\ARGBREAK
\verb|min::space_dollar_right_square_pstring   // special_postfix  " $]"|\ARGBREAK
\verb|min::standard_special_names              // special_names|\ARGBREAK
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<min::ustring>
    min::\MINKEY{standard\_\EOL special\_\EOL names}}
\LABEL{MIN::STANDARD_SPECIAL_NAMES}\ARGBREAK
\verb|// Names of specials 0xFFFFFF - 0 .. 0xFFFFFF - 9 are:|\ARGBREAK
\verb|//     MISSING  NONE  DISABLED  ENABLED  ANY  MULTI_VALUED|\ARGBREAK
\verb|//     UNDEFINED  SUCCESS  FAILURE  ERROR|\ARGBREAK
\verb|//     LOGICAL_LINE INDENTED_PARAGRAPH|
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Printing Using An Identifier Map}

\begin{indpar}[0.2in]

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::printer min::| & \MINKEY{map\_id}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::MAP_ID} \\
\verb|min::printer min::| & \MINKEY{print\_id}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::PRINT_ID} \\
\verb|min::id_map min::|
    & \MINKEY{set\_\EOL id\_\EOL map\RESIZE}\ARGBREAK
    \verb|( <min::printer printer,|\ARGBREAK
    \verb|  min::id_map map = min::NULL_STUB )|
\LABEL{MIN::SET_ID_MAP_OF_PRINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.1in}
\verb|min::op min::| & \MINKEY{flush\_\EOL one\_\EOL id}
\LABEL{MIN::FLUSH_ONE_ID} \\
\verb|min::op min::| & \MINKEY{flush\_\EOL id\_\EOL map}
\LABEL{MIN::FLUSH_ID_MAP} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.7in}
\verb|min::printer min::| & \MINKEY{print\_one\_id}
\LABEL{MIN::PRINT_ONE_ID}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\verb|min::printer min::| & \MINKEY{print\_id\_map}
\LABEL{MIN::PRINT_ID_MAP}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.7in}
\verb|min::printer min::| & \MINKEY{print\_mapped\_id}
\LABEL{MIN::PRINT_MAPPED_ID}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::uns32 ID,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\verb|min::printer min::| & \MINKEY{print\_mapped}
\LABEL{MIN::PRINT_MAPPED}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen v,|\ARGBREAK
    \verb|  min::id_map id_map = min::NULL_STUB,|\ARGBREAK
    \verb|  const min::gen_format * gen_format = NULL )| \\
\end{TABULAR}

\bigskip

\end{indpar}

\bigskip

\INDEXHEADER{Object Creation}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}\ARGBREAK
    \verb|( min::unsptr unused_size,|\ARGBREAK
    \verb|  min::unsptr hash_size = 0,|\ARGBREAK
    \verb|  min::unsptr variables_size = 0 )|
\LABEL{MIN::NEW_OBJ_GEN} \\
\verb|bool min::| & \MINKEY{is\_obj} \verb|( min::gen v )|
\LABEL{MIN::IS_OBJ}
\end{TABULAR}

\end{indpar}

\bigskip


\INDEXHEADER{Object Flags}\label{OBJECT-FLAGS-LIST}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|const int min::| & \MINKEY{OBJ\_PRIVATE}
\LABEL{MIN::OBJ_PRIVATE} \\
\verb|const int min::| & \MINKEY{OBJ\_PUBLIC}
\LABEL{MIN::OBJ_PUBLIC} \\
\verb|const int min::| & \MINKEY{OBJ\_GTYPE}
\LABEL{MIN::OBJ_GTYPE} \\
\verb|const int min::| & \MINKEY{OBJ\_CONTEXT}
\LABEL{MIN::OBJ_CONTEXT} \\
\end{TABULAR}
\end{indpar}

\INDEXHEADER{Object Maintenance}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND}
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COPY} \\
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::COPY_UNUSED} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COPY_VEC_PTR} \\
\verb|min::gen min::| & \MINKEY{copy\REL}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::COPY_UNUSED_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE}
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::gen object,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE} \\
\verb|void min::| & \MINKEY{compact\REORG}
    \verb|( min::gen object )|
\LABEL{MIN::COMPACT} \\
\verb|void min::| & \MINKEY{publish\REORG}
    \verb|( min::gen object )|
\LABEL{MIN::PUBLISH}
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::| & \MINKEY{private\_flag\_of}
    \verb|( min::gen object )|
\LABEL{MIN::PRIVATE_FLAG_OF} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}
    \verb|( min::gen object )|
\LABEL{MIN::PUBLIC_FLAG_OF}
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Protected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.9in}
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr} \verb|vp ( min::gen v )|
\LABEL{MIN::OBJ_VEC_PTR_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}
       \verb|vp ( const min::stub * s )|
\LABEL{MIN::OBJ_VEC_PTR_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{obj\_vec\_ptr}
       \verb|vp ( void )|
\LABEL{MIN::OBJ_VEC_PTR_OF_VOID}
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_MIN_STUB} \\
	& \TTOMKEY{bool}{bool}%
	  {of {\tt MUP::obj\_vec\_ptr}}\ARGBREAK
          \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::OBJ_VEC_PTR_TO_BOOL} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_GEN} \\
\verb|min::obj_vec_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_PTR_OF_STUB}
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
\verb|min::unsptr min::| & \MINKEY{var\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::VAR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::AUX_SIZE_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_OBJ_VEC_PTR}
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
\verb|min::gen | & \MINKEY{var}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{hash}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{attr}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_PTR} \\
\verb|min::gen | & \MINKEY{aux}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
    \verb|  min::unsptr aux_ptr )|
\LABEL{MIN::AUX_OF_OBJ_VEC_PTR}
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|min::gen |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::[]_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr min::| & \MINKEY{size\_of}
          \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::SIZE_OF_OBJ_VEC_PTR}
\end{TABULAR}

\begin{TABULAR}{2.6in}
\verb|min::ptr<const min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_ptr}}\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::ptr<const min::gen> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_PTR}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.9in}
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|
    \verb|( min::gen v )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|
    \verb|( min::stub * s )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_updptr} \verb|vp|
    \verb|( void )|
\LABEL{MIN::OBJ_VEC_UPDPTR_OF_VOID}
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_updptr}}\ARGBREAK
          \verb|( min::obj_vec_updptr const & vp )|
\LABEL{MIN::OBJ_VEC_UPDPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_GEN} \\
\verb|min::obj_vec_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_UPDPTR_OF_STUB}
\end{TABULAR}

\medskip

\begin{TABULAR}{1.9in}
\verb|min::ref<min::gen> | & \MINKEY{var}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::VAR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{hash}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::HASH_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{attr}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::ATTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ref<min::gen> | & \MINKEY{aux}\ARGBREAK
    \verb|( min::obj_vec_updptr & vp,|\ARGBREAK
    \verb|  min::unsptr index )|
\LABEL{MIN::AUX_OF_OBJ_VEC_UPDPTR}
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|min::ref<min::gen> |
	& \TTOMKEY{[ ]}{[ ]}{of {\tt min::obj_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::[]_OF_OBJ_VEC_UPDPTR}
\end{TABULAR}

\begin{TABULAR}{2.1in}
\verb|min::ptr<min::gen> |
	& \TTOMKEY{+}{+}{of {\tt min::obj\_vec\_updptr}}\ARGBREAK
	  \verb|( min::obj_vec_updptr const & vp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::+_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINKEY{begin\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::BEGIN_PTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::ptr<min::gen> min::|
    & \MINKEY{end\_ptr\_of}\ARGBREAK
      \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::END_PTR_OF_OBJ_VEC_UPDPTR}
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.9in}
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|
    \verb|( min::gen v )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|
    \verb|( min::stub * s )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{obj\_vec\_insptr} \verb|vp|
    \verb|( void )|
\LABEL{MIN::OBJ_VEC_INSPTR_OF_VOID}
\end{TABULAR}


\medskip

\begin{TABULAR}{1.9in}
	& \TTOMKEY{min::stub}{const min::stub *}%
	  {of {\tt MUP::obj\_vec\_insptr}}\ARGBREAK
          \verb|( min::obj_vec_insptr const & vp )|
\LABEL{MIN::OBJ_VEC_INSPTR_TO_MIN_STUB} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  min::gen v )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_GEN} \\
\verb|min::obj_vec_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::obj\_vec\_insptr}}\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
	  \verb|  const min::stub * s )|
\LABEL{MIN::=_OBJ_VEC_INSPTR_OF_STUB}
\end{TABULAR}

\medskip

\begin{TABULAR}{2.6in}
\verb|void min::ref<min::gen> min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_PUSH_OF_VEC_INSPTR} \\
\verb|void min::ref<min::gen> min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_PUSH_OF_VEC_INSPTR}
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n,|\ARGBREAK
      \verb|  const min::gen * p = NULL )|
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n,|\ARGBREAK
      \verb|  const min::gen * p = NULL )|
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|min::gen min::| & \MINKEY{attr\_pop}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_POP_OF_VEC_INSPTR} \\
\verb|min::gen min::| & \MINKEY{aux\_pop}
      \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::AUX_POP_OF_VEC_INSPTR}
\end{TABULAR}

\begin{TABULAR}{1.9in}
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
      \verb|  min::unsptr n, min::gen * p = NULL )|
\LABEL{MIN::AUX_POP_MULTIPLE_OF_VEC_INSPTR} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Vector Level Object Maintenance}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{resize\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{expand\RESIZE}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr unused_size )|
\LABEL{MIN::EXPAND_OBJ_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::| & \MINKEY{reorganize\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr hash_size,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::REORGANIZE_OBJ_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::| & \MINKEY{compact\REORG}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp,|\ARGBREAK
    \verb|  min::unsptr variable_size,|\ARGBREAK
    \verb|  min::unsptr unused_size,|\ARGBREAK
    \verb|  bool expand = true )|
\LABEL{MIN::COMPACT_AND_RESIZE_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{compact\REORG}
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::COMPACT_OBJ_VEC_INSPTR} \\
\verb|void min::| & \MINKEY{publish\REORG}
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::PUBLISH_OBJ_VEC_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{private\_flag\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PRIVATE_FLAG_OF_OBJ_VEC_PTR} \\
\verb|bool min::| & \MINKEY{public\_flag\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::PUBLIC_FLAG_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::| & \MINKEY{hash\_count\_of}\ARGBREAK
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::HASH_COUNT_OF} \\
\verb|void min::| & \MINKEY{set\_public\_flag\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::SET_PUBLIC_FLAG_OF} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Unprotected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|const min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb|( min::obj_vec_ptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_PTR} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb|( min::obj_vec_updptr & v )|
\LABEL{MUP::BASE_OF_OBJ_VEC_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::STUB_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::VAR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_OBJ_VEC_PTR} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}
    \verb|( min::obj_vec_ptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_OBJ_VEC_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_INSPTR} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb|( min::obj_vec_insptr & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_INSPTR} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Object List Level}

\begin{indpar}[0.2in]
\begin{TABULAR}{2.2in}
(macro) & \TTKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs}
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{TABULAR}
\end{indpar}

\bigskip

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|const min::gen min::| & \MINKEY{LIST\_END()}
\LABEL{MIN::LIST_END} \\
\verb|const min::gen min::|
    & \MINKEY{EMPTY\_SUBLIST()}
\LABEL{MIN::EMPTY_SUBLIST} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.2in}
\verb|bool min::|
	& \MINKEY{is\_list\_legal} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_LEGAL} \\
\end{TABULAR}

\end{indpar}

\bigskip

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
(constructor)~\verb|min::|
	& \MINKEY{list\_ptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::list_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::list\_ptr}}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::obj_vec_ptr & vp )|
\LABEL{MIN::=LIST_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt list\_ptr}}\ARGBREAK
	  \verb|( min::list_ptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_ptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_PTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist} \verb|( min::list_ptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{next} \verb|( min::list_ptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{peek} \verb|( min::list_ptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{current} \verb|( min::list_ptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh} \verb|( min::list_ptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh} \verb|( min::list_ptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_PTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of} \verb|( min::list_ptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_PTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|bool min::|
	& \MINKEY{is\_list\_end} \verb|( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist} \verb|( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
(constructor)~\verb|min::|
	& \MINKEY{list\_updptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::LIST_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::list_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::list\_updptr}}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::obj_vect_updptr & vp )|
\LABEL{MIN::=LIST_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::obj_vec_updptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt list\_updptr}}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_UPDPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_UPDPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb|( min::list_updptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_updptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_UPDPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.4in}
(constructor)~\verb|min::|
	& \MINKEY{list\_insptr} \verb|lp|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::LIST_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::list_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::list\_insptr}}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::obj_vect_insptr & vp )|
\LABEL{MIN::=LIST_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::obj_vec_insptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt list\_insptr}}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::OBJ_VEC_PTR_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_HASH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_COPY_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_ptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_PTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_updptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_UPDPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::list_insptr & lp2 )|
\LABEL{MIN::START_LIST_INSPTR_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_INSPTR} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::NEXT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::PEEK_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::CURRENT_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_INSPTR} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|( min::list_insptr & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen value )|
\LABEL{MIN::UPDATE_OF_LIST_INSPTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|bool min::|
	& \MINKEY{insert\_reserve\RESIZE}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr insertions,|\ARGBREAK
	  \verb|  min::unsptr elements = 0,|\ARGBREAK
	  \verb|  bool use_obj_aux_stubs =|\ARGBREAK
	  \verb|      min::use_obj_aux_stubs )|
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_AFTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{remove}\ARGBREAK
	  \verb|( min::list_insptr & lp,|\ARGBREAK
	  \verb|  min::unsptr n = 1 )|
\LABEL{MIN::REMOVE_FROM_LIST_INSPTR} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Object Attribute Level}

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS}
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}

\bigskip

\begin{TABULAR}{1.0in}
\verb|bool min::|
	& \MINKEY{is\_attr\_legal} \verb|( min::gen v )|
\LABEL{MIN::IS_ATTR_LEGAL} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
(constructor)~\verb|min::|
	& \MINKEY{attr\_ptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_ptr & vp )|
\LABEL{MIN::ATTR_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::attr_ptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_ptr}}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::obj_vec_ptr & vp )|
\LABEL{MIN::=ATTR_PTR_OF_OBJ_VEC_PTR} \\
\verb|min::obj_vec_ptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt attr\_ptr}}\ARGBREAK
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_PTR} \\
\end{TABULAR}

\begin{TABULAR}{1.0in}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}
	  \verb|( min::attr_ptr & ap, int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_ATTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_ptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}
	  \verb|( min::attr_ptr & ap )|
\LABEL{MIN::RELOCATE_ATTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_OF_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_ptr ap )|
\LABEL{MIN::GET1_OF_ATTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_ptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|struct min::| & \MINKEY{attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::uns64  flags;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|  min::unsptr flag_count;|\ARGBREAK
    \verb|  min::unsptr reverse_attr_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_attr\_info}\ARGBREAK
    \verb|( min::attr_info * out, min::unsptr n )|
\LABEL{MIN::SORT_ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.4in}
\verb|struct min::| & \MINKEY{reverse\_attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::gen    value;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|};|
\LABEL{MIN::REVERSE_ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n,|\ARGBREAK
     \verb|  min::attr_ptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_reverse\_attr\_info}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n )|
\LABEL{MIN::SORT_REVERSE_ATTR_INFO} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
(constructor)~\verb|min::|
	& \MINKEY{attr\_updptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_updptr & vp )|
\LABEL{MIN::ATTR_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::attr_updptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::obj_vec_updptr & vp )|
\LABEL{MIN::=ATTR_UPDPTR_OF_OBJ_VEC_UPDPTR} \\
\verb|min::obj_vec_updptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt attr\_updptr}}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_UPDPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_updptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_UPDPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_updptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_OF_ATTR_UPDPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_updptr ap )|
\LABEL{MIN::GET1_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_UPDPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_UPDPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n,|\ARGBREAK
     \verb|  min::attr_updptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_updptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_UPDPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
(constructor)~\verb|min::|
	& \MINKEY{attr\_insptr} \verb|ap|\ARGBREAK
	  \verb|( min::obj_vec_insptr & vp )|
\LABEL{MIN::ATTR_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::attr_insptr & |
	& \TTOMKEY{=}{=}{of {\tt min::attr\_insptr}}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::obj_vec_insptr & vp )|
\LABEL{MIN::=ATTR_INSPTR_OF_OBJ_VEC_INSPTR} \\
\verb|min::obj_vec_insptr & min::|
	& \MINMKEY{obj\_vec\_ptr\_of}{of {\tt attr\_insptr}}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::OBJ_VEC_PTR_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_ATTR_INSPTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb|( min::attr_insptr & ap,|\ARGBREAK
	  \verb|  min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_ATTR_INSPTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb|( min::attr_insptr & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_OF_ATTR_INSPTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::attr_insptr ap )|
\LABEL{MIN::GET1_OF_ATTR_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_FLAGS_OF_ATTR_INSPTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR_INSPTR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{get\_attrs}\ARGBREAK
     \verb|( min::attr_info * out, min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap,|\ARGBREAK
     \verb|  bool include_attr_vec = false )|
\LABEL{MIN::GET_ATTRS_OF_ATTR_INSPTR} \\
\verb|min::unsptr min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
     \verb|( min::reverse_attr_info * out,|\ARGBREAK
     \verb|  min::unsptr n,|\ARGBREAK
     \verb|  min::attr_insptr ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::SET1_OF_ATTR_INSPTR} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ONE1} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ALL1} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{set\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_ATTR_INSPTR} \\
\verb|void min::| & \MINKEY{set\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{set\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::SET_FLAG} \\
\verb|bool min::| & \MINKEY{clear\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::CLEAR_FLAG} \\
\verb|bool min::| & \MINKEY{flip\_flag\RESIZE}\ARGBREAK
    \verb|( min::attr_insptr ap,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::FLIP_FLAG} \\
\end{TABULAR}

\end{indpar}

\newpage

\INDEXHEADER{Object Attribute Short-Cuts}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen obj, min::gen attr )|
\LABEL{MIN::GET1_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb|( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|  min::gen obj, min::gen attr )|
\LABEL{MIN::GET_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_GEN} \\
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb|( min::gen * out, unsigned n,|\ARGBREAK
    \verb|  min::gen obj, min::gen attr )|
\LABEL{MIN::GET_FLAGS_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::UPDATE_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::SET1_OF_GEN} \\
\verb|void min::| & \MINKEY{set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_SET_OF_GEN} \\
\verb|void min::| & \MINKEY{add\_to\_set\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET_OF_GEN} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET_OF_GEN} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ONE1_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  min::gen v )|
\LABEL{MIN::REMOVE_ALL1_OF_GEN} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::| & \MINKEY{set\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_GEN} \\
\verb|void min::| & \MINKEY{set\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS_OF_GEN} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS_OF_GEN} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{set\_flag\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::SET_FLAG_OF_GEN} \\
\verb|bool min::| & \MINKEY{clear\_flag\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::CLEAR_FLAG_OF_GEN} \\
\verb|bool min::| & \MINKEY{flip\_flag\RESIZE}\ARGBREAK
    \verb|( min::gen obj, min::gen attr,|\ARGBREAK
    \verb|  unsigned n )|
\LABEL{MIN::FLIP_FLAG_OF_GEN} \\
\end{TABULAR}

\end{indpar}

\newpage

\INDEXHEADER{Printing Object General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{obj\_format}}%
\LABEL{MIN::OBJ_FORMAT}\ARGBREAK[0in]
    \verb|{|\ARGBREAK[0in]
    \verb|  min::uns32                           obj_op_flags;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              element_format;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              top_element_format;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              quote_element_format;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              label_format;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              value_format;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              initiator_format;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              separator_format;|\ARGBREAK[0in]
    \verb|  const min::gen_format *              terminator_format;|\ARGBREAK[0in]
    \verb|  min::str_classifier                  mark_classifier;|\ARGBREAK[0in]
    \verb|  min::gen                             quote_type;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_empty;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_bra;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_braend;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_ketbegin;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_ket;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_sep;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_attrbegin;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_attrsep;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_attreol;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_attreq;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_attrneg;|\ARGBREAK[0in]
    \verb|  const min::flag_format *             flag_format;|\ARGBREAK[0in]
    \verb|  const min::uns64                     hide_flags;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_valbegin;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_valsep;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_valend;|\ARGBREAK[0in]
    \verb|  min::pstring                         obj_valreq;|\ARGBREAK[0in]
\end{TABULAR}

\bigskip

\TT{obj\_format.obj\_op\_flags}:

\bigskip

\begin{TABULAR}{2.0in}
\verb|const min::uns32 min::| & \MINKEY{PREFERRED\_ID}
\LABEL{MIN::PREFERRED_ID_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{ENABLE\_COMPACT}
\LABEL{MIN::ENABLE_COMPACT_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{DEFERRED\_ID}
\LABEL{MIN::DEFERRED_ID_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{ISOLATED\_LINE}
\LABEL{MIN::ISOLATED_LINE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{EMBEDDED\_LINE}
\LABEL{MIN::EMBEDDED_LINE_FLAG} \\
\verb|const min::uns32 min::| & \MINKEY{NO\_TRAILING\_TYPE}
\LABEL{MIN::NO_TRAILING_TYPE} \\
\verb|const min::uns32 min::| & \MINKEY{ENABLE\_LOGICAL\_LINE}
\LABEL{MIN::ENABLE_LOGICAL_LINE} \\
\verb|const min::uns32 min::| & \MINKEY{ENABLE\_INDENTED\_PARAGRAPH}
\LABEL{MIN::ENABLE_INDENTED_PARAGRAPH} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{flag\_format}}
\LABEL{MIN::FLAG_FORMAT}\ARGBREAK[0in]
    \verb|{|\ARGBREAK[0in]
    \verb|  min::pstring                         flag_prefix;|\ARGBREAK[0in]
    \verb|  min::pstring                         flag_postfix;|\ARGBREAK[0in]
    \verb|  min::packed_vec_ptr<min::ustring>    flag_names;|\ARGBREAK[0in]
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::flag\_format
                   min::\MINKEY{standard\_attr\_flag\_format}:}%
\LABEL{MIN::STANDARD_ATTR_FLAG_FORMAT}\ARGBREAK[0in]
\verb|min::left_square_leading_always_pstring    // flag_prefix   "["|\ARGBREAK[0in]
\verb|min::trailing_always_right_square_pstring  // flag_postfix  "]"|\ARGBREAK[0in]
\verb|min::standard_attr_flag_names              // flag_names|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.0in}
\multicolumn{2}{l}{\tt min::packed\_vec\_ptr<min::ustring>}\\
\verb|min:: | & \MINKEY{standard\_\EOL attr\_\EOL flag\_\EOL names}
\LABEL{MIN::STANDARD_ATTR_FLAG_NAMES}\ARGBREAK
\verb|// Names of flags numbered 0, 1, 2, ... 63 are:|\ARGBREAK
\verb|//     * + - / @ & # = $ % < > a ... z A ... Z| \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|const unsigned min::| &
    \MINKEY{standard\_\EOL attr\_\EOL a\_\EOL flag} \verb|= 12|
\LABEL{MIN::STANDARD_ATTR_a_FLAG} \\
\verb|const unsigned min::| &
    \MINKEY{standard\_\EOL attr\_\EOL A\_\EOL flag} \verb|= 38|
\LABEL{MIN::STANDARD_ATTR_A_FLAG} \\
\verb|const unsigned min::| &
    \MINKEY{standard\_\EOL attr\_\EOL hide\_\EOL flag} \verb|=|
    \verb|38 + 'H' - 'A'|
\LABEL{MIN::STANDARD_ATTR_HIDE_FLAG} \\
\verb|const min::64 min::| &
    \MINKEY{standard\_\EOL attr\_\EOL hide\_\EOL flags} \verb|=|\ARGBREAK
    \verb|1ull << min::standard_attr_hide_flag|
\LABEL{MIN::STANDARD_ATTR_HIDE_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt struct
                       min::\MINKEY{flag\_parser}}
\LABEL{MIN::FLAG_PARSER}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::uns32 ( * flag_parser_function )|\ARGBREAK
    \verb|       ( min::uns32 * flag_numbers,|\ARGBREAK
    \verb|         char * text_buffer,|\ARGBREAK
    \verb|         const min::flag_parser * flag_parser );|%
\ttmindex{flag\_parser\_function}{in {\tt min::flag\_parser}}\ARGBREAK
    \verb||\\[-5ex]\ARGBREAK
    \verb|  // Members beyond this point are used by|\ARGBREAK
    \verb|  // min::standard_flag_parser.|\ARGBREAK
    \verb||\ARGBREAK
    \verb|  const min::uns32 *  flag_map;|%
\ttmindex{flag\_map}{in {\tt min::flag\_parser}}\ARGBREAK
    \verb|  min::uns32          flag_map_length;|%
\ttmindex{flag\_map\_length}{in {\tt min::flag\_parser}}\ARGBREAK
    \verb|};|
\end{TABULAR}

\bigskip

\begin{TABULAR}{2.4in}
\verb|const min::uns32 * min::| &
    \MINKEY{standard\_\EOL attr\_\EOL flag\_\EOL map}
\LABEL{MIN::STANDARD_ATTR_FLAG_MAP} \\
\verb|const min::uns32 min::| &
    \MINLKEY{standard\_\EOL attr\_\EOL flag}{\_\EOL map\_\EOL length}
\LABEL{MIN::STANDARD_ATTR_FLAG_MAP_LENGTH} \\
\verb|const min::uns32 min::| &
    \MINKEY{NO\_\EOL FLAG} \verb|= 0xFFFFFFFF|
\LABEL{MIN::NO_FLAG} \\
\end{tabular} \\
\begin{tabular}{l}
\verb|    // If min::standard_attr_flag_names[F] == "\x01\x01" "C"| \\
\verb|    // then min::standard_attr_flag_map[C] == F| \\
\verb|    // else min::standard_attr_flag_map[C] == min::NO_FLAG| \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::flag\_parser
                   min::\MINKEY{standard\_attr\_flag\_parser}:}%
\LABEL{MIN::STANDARD_ATTR_FLAG_PARSER}\ARGBREAK[0in]
\verb|min::standard_flag_parser            // flag_parser_function|%
						\ARGBREAK[0in]
\verb|min::standard_attr_flag_map          // flag_map|\ARGBREAK[0in]
\verb|min::standard_attr_flag_map_length   // flag_map_length|\ARGBREAK[0in]
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{compact\_obj\_format}:}%
\LABEL{MIN::COMPACT_OBJ_FORMAT}
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|  min::ENABLE_COMPACT                    // obj_op_flags|\ARGBREAK[0in]
\verb|+ min::DEFERRED_ID|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::element_gen_format                  // element_format|\ARGBREAK[0in]
\verb|NULL                                     // top_element_format|\ARGBREAK[0in]
\verb|min::always_quote_gen_format             // quote_element_format|\ARGBREAK[0in]
\verb|min::value_gen_format                    // value_format|\ARGBREAK[0in]
\verb|min::name_gen_format                     // label_format|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::leading_always_gen_format           // initiator_format|\ARGBREAK[0in]
\verb|min::trailing_always_gen_format          // separator_format|\ARGBREAK[0in]
\verb|min::trailing_always_gen_format          // terminator_format|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::standard_str_classifier             // mark_classifier|\ARGBREAK[0in]
\verb|min::doublequote                         // quote_type|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::left_curly_right_curly_pstring      // obj_empty|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::left_curly_leading_pstring          // obj_bra|\ARGBREAK[0in]
\verb|min::trailing_vbar_leading_pstring       // obj_braend|\ARGBREAK[0in]
\verb|min::trailing_vbar_leading_pstring       // obj_ketbegin|\ARGBREAK[0in]
\verb|min::trailing_right_curly_pstring        // obj_ket|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::space_if_none_pstring               // obj_sep|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::trailing_always_colon_space_pstring // obj_attrbegin|\ARGBREAK[0in]
\verb|min::trailing_always_comma_space_pstring // obj_attrsep|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::erase_all_space_colon_pstring       // obj_attreol|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::space_equal_space_pstring           // obj_attreq|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::no_space_pstring                    // obj_attrneg|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::standard_attr_flag_format           // flag_format|\ARGBREAK[0in]
\verb|min::standard_attr_hide_flags            // hide_flags|\ARGBREAK[0in]
\end{TABULAR}

\begin{TABULAR}{0.3in} & \hspace*{0in}
\verb|min::left_curly_star_space_pstring       // obj_valbegin|\ARGBREAK[0in]
\verb|min::trailing_always_comma_space_pstring // obj_valsep|\ARGBREAK[0in]
\verb|min::space_star_right_curly_pstring      // obj_valend|\ARGBREAK[0in]
\verb|min::space_less_than_equal_space_pstring // obj_valreq|\ARGBREAK[0in]
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINLKEY{top}{\_obj\_format}:}%
\LABEL{MIN::TOP_OBJ_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK[0in]
\verb|min::ENABLE_COMPACT                      // obj_op_flags|\ARGBREAK[0in]
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINLKEY{line}{\_obj\_format}:}%
\LABEL{MIN::LINE_OBJ_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK[0in]
\verb|  min::ENABLE_COMPACT                    // obj_op_flags|\ARGBREAK[0in]
\verb|+ min::ENABLE_LOGICAL_LINE|\ARGBREAK[0in]
\verb|min::paragraph_gen_format                // top_element_format|\ARGBREAK[0in]
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{paragraph\_obj\_format}:}%
\LABEL{MIN::PARAGRAPH_OBJ_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK[0in]
\verb|  min::ENABLE_COMPACT                    // obj_op_flags|\ARGBREAK[0in]
\verb|+ min::ENABLE_INDENTED_PARAGRAPH|\ARGBREAK[0in]
\verb|min::line_gen_format                     // top_element_format|\ARGBREAK[0in]
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{embedded\_line\_obj\_format}:}%
\LABEL{MIN::EMBEDDED_LINE_OBJ_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK[0in]
\verb|  min::EMBEDDED_LINE                     // obj_op_flags|\ARGBREAK[0in]
\verb|min::null_str_classifier                 // mark_classifier|\ARGBREAK[0in]
\verb|NULL                                     // obj_empty|\ARGBREAK[0in]
\verb|NULL                                     // obj_attrbegin|\ARGBREAK[0in]
\verb|NULL                                     // obj_attrsep|
\end{TABULAR}

\bigskip

\begin{TABULAR}{0.3in}
\multicolumn{2}{l}{\tt const min::obj\_format
                   min::\MINKEY{isolated\_line\_obj\_format}:}%
\LABEL{MIN::ISOLATED_LINE_OBJ_FORMAT}\ARGBREAK[0in]
\verb|// Same as min::compact_obj_format except for:|\ARGBREAK[0in]
\verb|  min::ISOLATED_LINE                     // obj_op_flags|\ARGBREAK[0in]
\verb|min::id_gen_format                       // element_format|\ARGBREAK[0in]
\verb|min::null_str_classifier                 // mark_classifier|\ARGBREAK[0in]
\verb|NULL                                     // obj_empty|\ARGBREAK[0in]
\verb|NULL                                     // obj_bra|\ARGBREAK[0in]
\verb|NULL                                     // obj_braend|\ARGBREAK[0in]
\verb|NULL                                     // obj_ketbegin|\ARGBREAK[0in]
\verb|NULL                                     // obj_ket|\ARGBREAK[0in]
\verb|NULL                                     // obj_attrbegin|\ARGBREAK[0in]
\verb|NULL                                     // obj_attrsep|\ARGBREAK[0in]
\verb|0                                        // hide_flags|
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::| & \MINKEY{parse\_flags}\ARGBREAK
    \verb|( min::uns32 * flag_numbers,|\ARGBREAK
    \verb|  char * text_buffer,|\ARGBREAK
    \verb|  const min::flag_parser * flag_parser )|
\LABEL{MIN::PARSE_FLAGS} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::uns32 min::| & \MINKEY{standard\_flag\_parser}\ARGBREAK
    \verb|( min::uns32 * flag_numbers,|\ARGBREAK
    \verb|  char * text_buffer,|\ARGBREAK
    \verb|  const min::flag_parser * flag_parser )|
\LABEL{MIN::STANDARD_FLAG_PARSER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
\verb|min::printer min::| & \MINKEY{print\_obj}\ARGBREAK
    \verb|( min::printer printer,|\ARGBREAK
    \verb|  min::gen obj,|\ARGBREAK
    \verb|  const min::obj_format * obj_format,|\ARGBREAK
    \verb|  min::uns32 obj_op_flags )|
\LABEL{MIN::PRINT_OBJ} \\
\end{TABULAR}

\end{indpar}


} % end of renewcommand for \LABEL, \{TT,MIN,MUP}KEY, etc.

\section{Operating System Interface}
\label{OPERATING-SYSTEM-INTERFACE}

The interface between MIN implementation code and the operating system
consists of standard C++/C functions available on all operating
systems, such as \verb|iostreams|, plus \ttkey{min::os}
namespace interface functions that are
declared in \verb|min_os.h| and defined in \verb|src/min_os.cc|.
This code division is intended to make it easy to port MIN to different
operating systems by placing all the code that must be
changed in the small \verb|src/min_os.cc| file.
\verb|min::os| is commonly abbreviated to
`\ttmkey{MOS}{abbreviates {\tt min::os}}'\label{MOS}
by including the following definition in code that accesses
the interface:

\begin{center}
\verb|#define  MOS  min::os|
\end{center}

Details of the \verb|min::os| interface are in \verb|min_os.h|.  The
following is an overview.

\subsection{Configuration Parameters}
\label{CONFIGURATION-PARAMETERS}

In UNIX the \ttkey{MIN\_CONFIG} environment variable value consists
of whitespace separated entries of the form `{\em name}\verb|=|{\em value}'
that specify configuration parameters, most of which control the
Allocator/Collector/Compactor.

\subsection{Memory Pools}

A memory pool is a contiguous block of pages of \underline{virtual}
memory.  Memory pools may be allocated, and it is possible to
specify that a pool being allocated has its starting address in
a particular range (e.g., so stub addresses can be limited to
44 bits).  Segments of memory pools may be freed, may be made
into inaccessible virtual memory, and may be made reaccessible.
Segments of memory pools may be moved by copying page table entries,
which is faster than copying bytes.

\section{Allocator/Collector/Compactor}
\label{ALLOCATOR/COLLECTOR/COMPACTOR}\label{ACC}

The \key{Allocator/Collector/Compactor}, or \ttkey{acc}, 
is a replaceable component of the MIN code, which should not
normally be accessed directly.  It can be controlled by parameters
passed to the program (see Configuration Parameters,
\pagref{CONFIGURATION-PARAMETERS}), or by defaults for these
provided at compile time in \verb|min_acc_parameters.h|.
Documentation for these parameters is in this last file.
The acc code is in the 
\verb|min::acc| namespace which is abbreviated to
`\ttmkey{MACC}{abbreviates {\tt min::acc}}'\label{MACC}
by including the following definition in acc code:

\begin{center}
\verb|#define  MACC  min::acc|
\end{center}

Details of the acc code are in \verb|min_acc.h|.  The
following is an overview.

TBD

\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}
