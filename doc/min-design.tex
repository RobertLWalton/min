% Minimal Descriptive Programming System Design
%
% File:         min-design.tex
% Author:       Bob Walton (walton@seas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttnbmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\minkey}[1]%
           {{\tt \bf min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minnbkey}[1]%
           {{\tt min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmkey}[2]%
           {{\tt \bf min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{{\tt \bf {\tt MUP}::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {{\tt \bf MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttindex{min::#1!#2}\ttindex{#1!#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}


\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newcommand{\ARGBREAK}{\\&{\tt ~~~~}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTNBKEY}[1]{\ttnbkey{#1}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MINKEY}[1]{{\tt \bf #1}\minindex{#1}}
\newcommand{\MINNBKEY}[1]{{\tt #1}\minindex{#1}}
\newcommand{\MUPKEY}[1]{{\tt \bf #1}\MUPindex{#1}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}

\begin{document}
        
\title{Internal Design\\[2ex]of the\\[2ex]
       Minimal\\Descriptive Programming\\System\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton}

\date{October 25, 2010}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the internal design of MIN,
the Minimal Descriptive Programming System.
This document is written for readers who wish to add C++ code
to a MIN implementation, or who wish to maintain an implementation.

A programming system provides run time and compile time support
for programming languages.
A programming system, such as MIN, is
built on top of an underlying programming system provided by the
implementation language, in this case C++.
MIN consists of a data store, of the single-thread execution system
inherited from C++, and of MIN compatible threads.
Other programming language specific
programming systems can be built on top of MIN.

A small number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{center}
\begin{tabular}{ll}
\ttmkey{acc}{abbreviation}	& allocator/collector/compactor
			          (\secref{ACC-INTERFACE},\secref{ACC}) \\
\ttmkey{aux}{abbreviation}	& auxiliary (\secref{AUXILIARY}) \\
\ttmkey{attr}{abbreviation}	& attribute (\secref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{DISP}{abbreviation}	& displacement (\pagref{MIN::DISP}) \\
\ttmkey{gen}{abbreviation}	& general value (\secref{GENERAL-VALUES}) \\
\ttmkey{insptr}{abbreviation}	& insertable pointer
				  (readwrite, push, pop pointer) \\
\ttmkey{int}{abbreviation}	& signed integer (\pagref{INT}) \\
\ttmkey{lab}{abbreviation}	& label (\secref{LABELS}) \\
\ttmkey{min}{abbreviation}	& the `{\tt min}' namespace (\pagref{min::}) \\
\ttmkey{MACC}{abbreviation}	& {\tt min::acc} (\pagref{MACC}) \\
\ttmkey{MIN}{abbreviation}	& the {\tt MIN\_} macro preface
				  (\pagref{MIN_}) \\
\ttmkey{MINT}{abbreviation}	& {\tt min::internal} (\pagref{MINT}) \\
\ttmkey{MOS}{abbreviation}	& {\tt min::os} (\pagref{MOS}) \\
\ttmkey{MUP}{abbreviation}	& {\tt min::unprotected} (\pagref{MUP}) \\
\ttmkey{num}{abbreviation}	& number (\pagref{NUMBERS}) \\
\ttmkey{obj}{abbreviation}	& object (\pagref{OBJECTS}) \\
\ttmkey{ptr}{abbreviation}	& pointer (usually readonly) \\
\ttmkey{str}{abbreviation}	& string (\pagref{STRINGS}) \\
\ttmkey{uns}{abbreviation}	& unsigned integer (\pagref{UNS}) \\
\ttmkey{updptr}{abbreviation}	& updatable pointer (i.e., readwrite pointer) \\
\ttmkey{var}{abbreviation}	& variable (\secref{OBJECT-VECTOR-LEVEL}) \\
\ttmkey{vec}{abbreviation}	& vector (\secref{OBJECT-VECTOR-LEVEL}) \\
\end{tabular}
\end{center}

\section{Interfaces}
\label{INTERFACES}

The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}
\verb|#include  <min.h>|
\end{center}

External MIN data and functions are placed in the
\ttnbmkey{min}{namespace}\label{min::} namespace.
There are some macros that can be defined to control compilation, and
these have names beginning with \ttnbkey{MIN\_}\label{MIN_}.

MIN has two interfaces:
the \key{protected interface}, which can be used
by C++ code to access MIN while maintaining the integrity
of MIN data, and the \key{unprotected interface}, which provides
more efficient access to MIN data but requires the user to
follow certain protocols to be sure that data are not damaged.

From the syntactic point of view the
only distinction between these interfaces is that the unprotected
interface is in the with \minkey{unprotected} namespace, whereas
the protected interface is in the \ttkey{min} namespace.  User code
that accesses the unprotected interface typically abbreviates the long
`{\tt min::unprotected::}' prefix to
`\ttnbmkey{MUP}{abbreviates {\tt min::unprotected}}{\tt ::}'\label{MUP}
by including the following definition:
\begin{center}
\verb|#define  MUP  min::unprotected|
\end{center}

In this document we will use the abbreviation `\verb|MUP|' for
`\verb|min::unprotected|'.
Note that namespace definitions such as the above are \underline{not}
included in \verb|min.h| or other MIN \verb|.h| files; they must
be included explicitly in \verb|.cc| files.

Most {\tt MUP} functions `produce \key{undefined results}' when their arguments
are out of legal range.
This means that when the arguments are out of range,
function execution may lose control and crash, or may produce result
values that are wrong or out of legal range.
When documentation of a {\tt MUP} function
states that particular argument range checks are not performed,
then the {\tt MUP} function always produces undefined results when its
arguments would not pass these checks,
unless the documentation explicitly says otherwise.

Most, but not all, of the protection provided by the protected interface
is obtained by the functions of that interface using the
{\tt MIN\_ASSERT} macro:

\begin{indpar}
\begin{tabular}{lp{4.0in}}
\TTNBKEY{MIN\_ASSERT}{\tt (}$e${\tt )}
	& By default defined as `{\tt assert(}$e${\tt )}' if
	  {\tt MIN\_PROTECT} is defined to be {\tt 1} (its default),
	  and defined to be a no operation otherwise.  Alternatively
	  may be defined by the compilation before
	  \verb|#include <min.h>|.
\LABEL{MIN_ASSERT}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{lp{4.0in}}
\TTNBKEY{MIN\_PROTECT}	& 1 (the default)
                          if {\tt MIN\_ASSERT} is to be mapped to
			  the C++ \ttkey{assert} macro if {\tt MIN\_ASSERT}
			  not otherwise defined; 0 to map {\tt MIN\_ASSERT}
			  to a no operation if it is not otherwise defined.
\LABEL{MIN_PROTECT} \\
\end{tabular}
\end{indpar}

By setting {\tt MIN\_PROTECT} to {\tt 0}, a compilation can optimize
debugged code, although this will remove the protection
provided by the protected interface.  Alternatively,
a compilation can provide its own definition for the
{\tt MIN\_ASSERT} macro,
such as a definition printing extra information
in case of an assertion failure.

The above macros ({\tt MIN\_ASSERT}, {\tt MIN\_PROTECT})
can be defined independently for each separately compiled
part of a program, but most \verb|MIN_| macros must be defined identically
for all separately compiled parts of a single program.

The following are the most commonly used compiler options that
redefine {\tt MIN\_} macros:

\begin{indpar}
\begin{tabular}{lll}
Macro Name		& Meaning	& Page Reference \\[1ex]
\verb|-DMIN_PROTECT=0|	& delete assert checks
					& \pagref{MIN_PROTECT} \\
\verb|-DMIN_IS_COMPACT=1|
			& make implementation compact
					& \pagref{MIN_IS_COMPACT} \\
\end{tabular}
\end{indpar}

The other compilation parameters involve technical details of
memory management.  For specifics see the file
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

Protected functions are in the \ttmkey{min}{namespace} namespace
and have names beginning with
`\ttmkey{min::}{in function name}', while
unprotected MIN functions are in the \ttmkey{min::unprotected}{namespace}
namespace and have names beginning with
`\ttnbmkey{min::unprotected::}{in function name}'.
The {\tt min} and {\tt min::unprotected} namespaces hold \underline{all}
the stable interfaces of the MIN implementation.

Code in \verb|min.h| that is not meant to be accessed
by users is in the following namespaces:

\begin{indpar}
\begin{tabular}{llp{4.0in}}
	    & Abbre- \\
Namespace   & viation   & Use
\\[1ex]
\tt min::os & \tt MOS	& Operating system independent interface to
			  operating system functions
			  not covered by C++ standards.
			  See Appendix \secref{MOS}.
\\[1ex]
\tt min::acc & \tt MACC & The part of the interface to the
			  Allocator/\EOL Collector/\EOL Compactor
			  that can be
			  changed when the acc is changed.
			  See Appendix \secref{ACC}.
\\[1ex]
\tt min::internal & \ttnbkey{MINT}\label{MINT}
		        & Interface to internal MIN code that can
			  be changed without notice at any time.
			  Not described in this document; see
			  {\tt .h} files.
\end{tabular}
\end{indpar}

\section{Data}

In defining MIN data the following number types are used to be sure
the size of each number is clear:
\begin{center}
\begin{tabular}{l@{~~~~~}p{4.5in}}
\minkey{uns8}	& unsigned 8-bit integer \\
\minkey{int8}	& signed 8-bit integer \\
\minkey{uns16}	& unsigned 16-bit integer \\
\minkey{int16}	& signed 16-bit integer \\
\minkey{uns32}	& unsigned 32-bit integer \\
\minkey{int32}	& signed 32-bit integer \\
\minkey{float32}	& 32-bit IEEE floating point number \\
\minkey{uns64}	& unsigned 64-bit integer \\
\minkey{int64}	& signed 64-bit integer \\
\minkey{float64}	& 64-bit IEEE floating point number \\
\minkey{unsptr}	& unsigned integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{intptr}	& signed integer of same length as a pointer (32 or 64 bits)
                  \\
\minkey{unsgen}	& unsigned integer of same length as a general value
                  (32 or 64 bits, see \secref{GENERAL-VALUES})
                  \\
\end{tabular}
\end{center}%
\LABEL{MIN::UNS8}%
\LABEL{MIN::INT8}%
\LABEL{MIN::UNS16}%
\LABEL{MIN::INT16}%
\LABEL{MIN::UNS32}%
\LABEL{MIN::INT32}%
\LABEL{MIN::FLOAT32}%
\LABEL{MIN::UNS64}%
\LABEL{MIN::INT64}%
\LABEL{MIN::FLOAT64}%
\LABEL{MIN::UNSPTR}%
\LABEL{MIN::INTPTR}%
\label{INT}%
\label{UNS}

Currently planned implementations of MIN assume a compiler that has
direct support for 64 bit integers.  It is possible, but not recommended,
to modify the implementations to use compilers without such support.

The heap data (i.e., data not in the stack)
of MIN is defined using C-compatible
\ttmkey{struct}{C compatible}'s
and \ttmkey{union}{C compatible}'s.  C++ implicitly guarantees the layout of
C-compatible \verb|struct|'s and \verb|union|'s to be C-compatible,
and C has implicit guarantees because of historical C code that
such data will not contain unnecessary unnamed padding.  Neither the
C or C++ standards guarantee the absence of unnecessary unnamed padding, but
MIN depends upon its absence, as does any code that reads and writes
binary files.

As a consequence of using only C-compatible \verb|struct|'s and
\verb|union|'s to define heap data, MIN does not use member functions
for such data.

\subsection{Stubs and Bodies}

MIN data memory consists of regions that contain stubs and regions
that contain bodies.  A region is a contiguous block
of memory, typically consisting of an integral number of hardware
pages.

\ikey{Stubs}{stub}
are small fixed size units of memory that cannot be relocated:
the usual stub size for MIN is 16 bytes.
Each object has a stub, and the address of the stub is in effect
the internal name of the object.  Some atoms (e.g., numbers, strings)
have stubs, and some (e.g., integers that are not large, and very short
strings) do not.

A stub is divided into an 8 byte \key{stub value}
and an 8 byte \key{stub control}.
The stub value can be a 64-bit IEEE floating point number,
an 8 {\tt char} string, or, as we will soon see, a pointer to a body.
It is also possible for a stub value to hold any other 8 bytes of information.

The stub control holds a 1 byte \key{type code} and other information used,
for example, by the allocator/collector/compactor (acc).

The type name of a stub is `\minkey{stub}', and a pointer to a stub
has type `\verb|min::stub *|'.\LABEL{MIN::STUB}
Protected functions can return `\verb|const min::stub *|' values,
but only unprotected functions can return `\verb|min::stub *|' values.

A \key{body} is a variable sized
\ttmkey{relocatable}{body}\label{RELOCATABLE-BODY}
block of memory
attached to a particular stub.  A stub may have a body attached to
it, in which case the stub value is a pointer to that body.
When certain functions are called,
any body can be moved and its corresponding stub value reset to
point at the new location of the body.
Functions with this property are called
`\key{relocating functions}'\label{RELOCATING-FUNCTIONS}
and are marked by {\REL} in documentation.  Included
are functions that allocate objects.
Obtaining a C++ pointer into a body is an unprotected operation, because
the pointer must be maintained if a relocating function is called.

\ikey{Interrupts}{interrupt!and relocation} can relocate bodies.
Therefore interrupts are only allowed
at specific points in the code.  The inline function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{interrupt\REL}\verb| ( void )|
\LABEL{MIN::INTERRUPT} \\
\end{tabular}\end{indpar}%
\index{interrupt!relocating}

checks an interrupt
flag, and if that is set, calls an out-of-line function to process
the interrupt.  The function returns {\tt true} if and only if
there was actually an interrupt (this should be used only
for optimization).

A body may be \mkey{deallocated}{by moving}
by moving it to unimplemented memory.  When this is done the
stub \mkey{type code}{reset on deallocation}
is reset to the value \minnbkey{DEALLOCATED}\LABEL{MIN::DEALLOCATED},
which indicates the body is deallocated.
The function that deallocates a body is:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{deallocate\REL}\verb| ( min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\end{tabular}\end{indpar}%
\index{deallocate!relocating}

Deallocation is considered to be a variant of relocation.
Relocating functions, those marked marked by {\REL} in documentation,
may also deallocate objects.

The {\tt min::is\_deallocated} function described on
\pagref{MIN::IS_DEALLOCATED}
can be used to test whether the body of a stub has been deallocated.

Bodies are always some multiple
of 8 bytes long, and are allocated on 8 byte boundaries.

\ikey{Protected functions}{protected function!using {\tt MIN\_ASSERT}}
that take a stub pointer as argument use
\ttnbmkey{MIN\_ASSERT}{in protected function} macros
(\pagref{MIN_ASSERT}) to check
the \mkey{type code}{checked by {\tt MIN\_ASSERT}}
of the stub and various lengths.  Unprotected functions
contain no such checks.

Memory consisting of unrelocatable stubs pointing at relocatable
bodies is called a `\key{stub/\EOL body memory}'.
Thus MIN has a stub/body memory.
The main advantages of stub/body memory are that relocation of bodies
can happen independently of other program activity, and bodies can be
deallocated by program command at any time.\footnote{
Stub/body memories are certainly not new.  For example, Kyoto COMMONLISP
used a stub/body implementation of arrays, and the author has heard about
implementations that go back to the late 1950's or early 60's: see
p33 of the author's thesis, R-CODE, A Very Capable Virtual Computer.}


\subsection{General Values}
\label{GENERAL-VALUES}

A general value can store any of:

\begin{center}
\begin{tabular}{l}
a direct atom value \\
a pointer to a stub \\
an auxiliary pointer \\
an index \\
a control code \\
a special value
\end{tabular}
\end{center}

General values are used as attribute names and values in
objects and as function arguments and return values.

General values that represent numbers or character strings
are called \skey{atom}s, because they have no subcomponents.
There are two kinds of atoms: \skey{direct atom}s that
are stored completely in a general value, and
\skey{indirect atom}s that are stored in a stub or in
a body pointed at by a stub, with the stub being pointed
at by a general value.

Efficiency aside, it does not matter
whether a general value stores a direct atom value or a pointer
to a stub holding an indirect atom value,
as atom values are immutable and cannot be changed.  Of course not all
atom values will fit into a general value, and those that do not must
be stored in stubs or in bodies pointed at by stubs.

An \key{auxiliary pointer} is an integer that is used by a general value
stored inside a body to point at some part, called an
\key{auxiliary},\label{AUXILIARY} of the same body.
There are several subtypes of auxiliary pointers storable in bodies.
See~\pagref{OBJECT-BODY-AUXILIARY-POINTER}.

An \key{index} is an integer that is used to give the index of a variable
that is an element of an object body.
See~\pagref{OBJECTS}.

A \key{control code} is an integer that represents flags and codes
stored in a general value.  Control codes can have different
interpretations in different contexts.
For example, see `Attribute Flags', \pagref{ATTRIBUTE-FLAGS}.

A \key{special value} is a unique value that has some
special meaning.  \verb|min::MISSING|, for example, is a special
value that may be input or output to indicate that data is missing,
and \verb|min::NONE| is a special value used only to
indicate that a function argument or result does not exist.
See \secref{SPECIAL-VALUES}.

There are two kinds of MIN implementation: `\key{compact}' and
`\key{loose}'.\label{COMPACT}\label{LOOSE}\label{COMPACT-OR-LOOSE}
A compact implementation uses 32-bit general values, while
a loose implementation uses 64-bit general values.
An implementation cannot use both 32-bit and 64-bit general values;
the implementation must use one or the other.

Some functions and constants are defined only for compact implementations,
and some only for loose implementations.  Those defined only for
compact implementations are marked
with the superscript {\COMPACT}\index{C@{\COMPACT}}
in this document.
Those defined only for
loose implementations are similarly marked
with the superscript {\LOOSE}\index{L@{\LOOSE}}.

The value of a compact implementation is that it uses less memory%
\footnote{However, double precision floating point numbers only
use less memory if each is replicated several times.},
but there may be a speed penalty.
The value of a loose implementation is that it may run faster, but
there is a memory penalty.  It is not clear what the speed difference
between the two implementations really is, so both implementations
are offered in order to decide the issue by experiment.

Also compact implementations do not permit more than
about $2^{32}$ objects to exist in memory at one time, whereas
loose implementations permit up to about $2^{44}$ objects.

\subsubsection{General Value Subtypes}
\label{GENERAL-VALUE-SUBTYPES}

A \key{general value} has type \minkey{gen}\LABEL{MIN::GEN} and
is a 32 or 64 bit aligned value that can be of one of the following
subtypes;

\begin{indpar}[3em]
a pointer to a stub \\
a 64-bit IEEE floating point direct number atom\LOOSE \\
a 28-bit direct integer atom\COMPACT \\
a 0-5 {\tt char} direct string atom\LOOSE \\
a 0-3 {\tt char} direct string atom\COMPACT \\
a VSIZE-bit index \\
a VSIZE-bit control code \\
a VSIZE-bit special value \\
a VSIZE-bit list auxiliary pointer \\
a VSIZE-bit sublist auxiliary pointer \\
a VSIZE-bit indirect auxiliary pointer
\end{indpar}
\hspace*{1in}\begin{minipage}{4.5in}
where \key{VSIZE} equals 24 for a compact implementation
and 40 for a loose implementation
\end{minipage}

Here {\COMPACT} subtypes are only implemented by compact
implementations, and {\LOOSE} subtypes are only implemented by
loose implementations (\pagref{COMPACT-OR-LOOSE}).

Numbers and character strings stored inside a \verb|min::gen| value are
called `\skey{direct atom}s\,'.  Numbers and character strings
stored in stubs or bodies which are pointed at by a
\verb|min::gen| value are called `\skey{indirect atom}s'.  An atom is
always stored in only one way by an implementation.  If a number will fit
into a direct atom, it is stored as a direct atom, and never as an
indirect atom.  Similarly if a character string will fit into a direct atom,
it is stored as a direct atom, and never as an indirect atom.

Analogously indirect atoms are stored in only one place in memory, so
two indirect numbers are equal if and only the \verb|min::gen| values
pointing at them point at the same place, and similarly
two indirect character strings are equal if and only
the \verb|min::gen| values pointing at them point at the same place.

Therefore two atoms are equal if and only if the \verb|min::gen| values
designating them are \verb|==| as 32-bit or 64-bit values.

General values that point at stubs hold stub addresses in a
packed format.  44 bits are available to store a stub address in a
64-bit general value, and 32 bits are available to store a stub address
in a 32-bit general value, but in the latter case the packed address must be
less than $2^{32}-2^{29}$ (the $2^{29}$ other 32 bit values are used to store
direct integers, auxiliary pointers, indices, control codes, and special
values).  There are three
\skey{stub address packing scheme}s,\label{STUB-ADDRESS-PACKING} and the fastest
is selected for each type of general value.  The scheme selection is
controlled by the following `\skey{stub address packing parameter}\,'
macros:

\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTNBKEY{MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum absolute address of any stub as an unsigned integer
	  constant.  See \pagref{MIN_MAX_ABSOLUTE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{lp{3.0in}}
\TTNBKEY{MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
	& The maximum address of any stub relative to a constant
	  stub base address, as an unsigned integer
	  constant.  See \pagref{MIN_MAX_RELATIVE_STUB_ADDRESS} for
	  defaults.
\end{tabular}\end{indpar}

The fastest scheme is the \key{absolute stub address} scheme,
where the absolute stub
address is stored.  For 64 bit general values this is
just a matter of inserting the stub address into the low order 44 bits
of the value.  For 32 bit general values this is just a matter of
using the stub address as the general value.
This scheme can be used if
{\tt MIN\_\EOL MAX\_\EOL ABSOLUTE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The second fastest scheme is the \key{relative stub address}
\label{RELATIVE-STUB-ADDRESS} scheme, where the
stub address relative to a constant \key{stub base}
address is stored.
The relation between the absolute and relative stub addresses is:

\begin{center}
stub absolute address = stub base + stub relative address
\end{center}

where `stub base' is a constant determined when the program is
initialized.
This scheme can be used if
{\tt MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

The slowest scheme is the \key{stub index} scheme, where the
relative stub address divided by the stub length is stored.
The stub length is chosen to be a power of 2 so that this
scheme will be efficient.  Again, this scheme can be used
if the relative address of the stub is not too large, but since
the stub length is 16, the relative address can be 16 times larger
for the stub index packing scheme than it is for the stub relative address
packing scheme.
Thus the index scheme can be used if
{\tt MIN\_\EOL MAX\_\EOL RELATIVE\_\EOL STUB\_\EOL ADDRESS/16}
can be stored in 44 bits for 64 bit general values, or is at most
$2^{32}-2^{29}-1$ for 32 bit general values.

Note that on machines that have 32 bit addresses (e.g.,
the IA32\footnote{Intel Architecture 32-bit, a.k.a, i386 machines.}
machines), there is little to gain by either the relative stub address
or stub index packing schemes,
so only the absolute stub address scheme should be used on such machines.

A 32-bit general value direct integer consists of a high order 4-bit
subtype code and a low order 28-bit signed integer stored in offset form,
so the true integer can be derived from the {\tt min::gen} value by
subtracting the {\tt min::gen} representation of zero.
The range of such a direct integer is the same as the range of a 28-bit
two's complement integer: $-2^{27}$ to $2^{27}-1$, inclusive.

Other 32-bit general values consist of a high order
8-bit subtype code and a low order 24-bit datum.
For most auxiliary pointer
general values the datum is a 24-bit auxiliary pointer
(see~\pagref{OBJECT-BODY-AUXILIARY-POINTER}
for a definition of auxiliary pointers).
For index and special values the datum is a 24-bit index.
For control code general values the datum is 24-bits that
contains flags and codes that have different interpretations in different
contexts.  And for direct string general values the datum
holds 0 to 3 8-bit {\tt char}'s.

For 64-bit general values that point at stubs, the high order 20 bits
are used as a subtype code.  For other 64-bit general values, the high
order 24 bits are the subtype code and the low order 40 bits are the datum.
The values chosen for these subtype codes make stub pointers, direct strings,
auxiliary pointers, indices, and control codes -- that is, all non-number
{\tt min::gen} values --
into IEEE Nan (Not-a-Number)
values that are never generated by hardware instructions.

For most auxiliary pointer general values the 40-bit datum is used to hold
a 40-bit auxiliary pointer.
For index and special values the datum holds a 40-bit index.
For control code general values the datum is a 40-bit control code;
and for direct string general values the datum holds 0-5 {\tt char}'s.

The {\tt min::gen} type has the alignment
properties of either {\tt min::uns32} or {\tt min::uns64},
and in many implementations is {\tt typedef}'ed to the appropriate one
of these two types.  Therefore a function that has only
{\tt min::gen} and non-{\tt min} (e.g. number and {\tt char *}) arguments
cannot be \ikey{overloaded}{overloading!rationale}\label{OVERLOADING-RATIONALE},
and must have a name beginning with `{\tt min::}'.
To avoid confusion, all MIN function names begin with `{\tt min::}'.

Many {\tt min::gen} values, which are 32 or 64 bits, are divided into a subtype,
either 8 or 24 bits, and a datum, either 24 or 40 bits.  In this context the
datum is called the `\mkey{value}{part of a {\tt min::gen} value}'.  The
following definitions are provided in {\tt min.h} to facilitate coding:

\begin{indpar}
\begin{tabular}{r@{}l@{\hspace*{2em}}l}
\verb|min::| & \MINKEY{unsgen}
	& typedef'ed to {\tt min::uns32}\COMPACT or {\tt min::uns64}\LOOSE
\LABEL{MIN::UNSGEN} \\
\verb|const unsigned min::| & \MINKEY{TSIZE}
	& Subtype size; equal to {\tt 8}\COMPACT or {\tt 24}\LOOSE.
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
	& Value size; equal to {\tt 24}\COMPACT or {\tt 40}\LOOSE.
\LABEL{MIN::VSIZE}
\end{tabular}
\end{indpar}


\subsubsection{General Value Compilation}
\label{GENERAL-VALUE-COMPILATION}

The decisions on whether an implementation is
compact or loose (\pagref{COMPACT-OR-LOOSE})
must be made before C++ code is compiled.
Decisions must also be made determining the stub address packing
parameters (\pagref{STUB-ADDRESS-PACKING}).
The following macros, which must be defined identically
for all separately compiled parts of a single program, describe
these decisions.  These macros are in two groups, first the macros
that are set by the programmer, and then the macros which by default
are computed from the settings of the first group of macros.
All these macros are defined in
\ttkey{min\_parameters.h}\ttindex{min\_parameters.h}.

The macros set by the programmer are:

\begin{indpar}\begin{tabular}{p{2.0in}p{3.5in}}
\TTNBKEY{MIN\_IS\_COMPACT}	& 1 if compact implementation; 0 if loose;
				  defaults to 0.
\LABEL{MIN_IS_COMPACT}
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{2.0in}p{3.5in}}
\TTNBKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
				& Maximum number of garbage collector
				  ephemeral levels allowed in
				  \underline{any} execution of the
				  compiled binary; defaults to 2.
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\end{tabular}\end{indpar}

The macros which are normally set to default values computed from
the above macro settings are:
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTNBKEY{MIN\_IS\_LOOSE}	& 1 if loose implementation; 0 if compact;
				  Must equal `\verb|! MIN_IS_COMPACT|\,'.
\LABEL{MIN_IS_LOOSE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTNBKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
				& The maximum number of stubs that can
				  exist in \underline{any} execution
				  of the compiled binary.  Defaults: \\
& \hspace*{1em}\begin{tabular}{ll}
if \verb|MIN_IS_COMPACT| = 1:	& $2^{28} - 2^{25}$ \\
else pointers are 32 bits:	& $2^{28}$ \\
else:				& $2^{40-4e}$ \\
\end{tabular} \\
& where \\
& ~~$e = max(0,\mbox{\tt MIN\_MAX\_EPHEMERAL\_LEVELS}-2)$.
\LABEL{MIN_MAX_NUMBER_OF_STUBS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.0in}p{3.5in}@{}}
\TTNBKEY{MIN\_STUB\_BASE}
	& The value of the `stub base' for relative addressing
          (see \pagref{RELATIVE-STUB-ADDRESS}).  If defined
          this must be a non-negative integer constant.  Defaults to
	  \verb|0| if \verb|MIN_MAX_NUMBER_OF_STUBS| is set by
	  default, and otherwise is left undefined.
\LABEL{MIN_STUB_BASE}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.5in}p{3.0in}@{}}
\TTNBKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}
	& The maximum address of any stub relative to the `stub base' (address
	  of the first stub), as an unsigned integer constant.  Default: \\
	& ~~\verb|16*MIN_MAX_NUMBER_OF_STUBS - 1|.
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS}
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{@{}p{2.5in}p{3.0in}@{}}
\TTNBKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}
	& The maximum absolute address of any stub.  Defaults: \\
	& ~~~~ if \verb|MIN_STUB_BASE| defined: \\
	& ~~~~~~~~ \verb|  MIN_STUB_BASE| \\
	& ~~~~~~~~ \verb|+ MIN_MAX_RELATIVE_STUB_ADDRESS| \\
	& ~~~~ else if \begin{tabular}[t]{@{}l@{}}
	               \verb|MIN_IS_COMPACT| = 1 and \\
		       pointers are 32 bits:
		       \end{tabular} \\
	& ~~~~~~~~ $2^{32}-2^{29}-1$ \\
	& ~~~~ else if pointers are 32 bits: \\
	& ~~~~~~~~ $2^{32}-1$ \\
	& ~~~~ else: \\
	& ~~~~~~~~ $2^{48}-1$
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS}
\end{tabular}
\end{indpar}

\subsubsection{General Value Functions}
\label{GENERAL-VALUE-FUNCTIONS}

The following functions return {\tt true} if a {\tt min::gen} datum is of the
indicated subtype and {\tt false} otherwise:

\begin{indpar}
\verb|bool min::|\MINKEY{is\_stub}\verb| ( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::|\MINKEY{is\_direct\_float\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::|\MINKEY{is\_direct\_int\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::|\MINKEY{is\_direct\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::|\MINKEY{is\_index}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::|\MINKEY{is\_control\_code}\verb| ( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::|\MINKEY{is\_special}\verb| ( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::|\MINKEY{is\_list\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::|\MINKEY{is\_sublist\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::|\MINKEY{is\_indirect\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::|\MINKEY{is\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_AUX}
\end{indpar}

For a 32-bit general value {\tt is\_direct\_float\LOOSE} is unimplemented.
For a 64-bit general value {\tt is\_direct\_int\COMPACT} is unimplemented.
The {\tt min::\EOL is\_\EOL aux} function returns true if the general
value is any auxiliary pointer (i.e., list, sublist, etc.).

The following protected functions return the value appropriate for a given
subtype, after checking the subtype with a {\tt MIN\_ASSERT} statement:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::stub * min::| & \MINKEY{stub\_of}\verb| ( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\
\end{tabular}\end{indpar}

Here the \verb|min::uns64| value returned by \minkey{direct\_str\_of}
should be overlaid by a union with a \verb|char[]| buffer, as in
the code:

\begin{indpar}\begin{verbatim}
union { min::uns64 str; char buf[6]; } u;
min::gen v;
. . . set v to a direct string value . . .
u.str = min::direct_str_of ( v );
cout << u.buf;
\end{verbatim}\end{indpar}

The {\tt min::direct\_str\_of} function merely copies the 3 or
5 {\tt char}'s of the {\tt min::gen} direct string value and
appends a NUL character.
It does this by writing an appropriate value into \verb|u.str|.

The \verb|min::|\ldots\verb|_aux_of|, the \verb|min::index_of| function,
the \verb|min::control_code_of| function,
and the {\tt min::\EOL spec\-ial\_\EOL index\_\EOL of} function all
return a 24-bit\COMPACT or 40-bit\LOOSE unsigned integer as a
{\tt min::unsgen} value.

The following unprotected functions return the value appropriate for a given
subtype, \underline{without} checking the subtype:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::| & \MUPKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{tabular}\end{indpar}

Note that \verb|MUP::stub_of| returns a `\verb|min::stub *|' pointer
whereas \verb|min::stub_of| returns a `\verb|const min::stub *|' pointer.

The {\tt MUP::\EOL aux\_\EOL of} function returns the auxiliary pointer
of any \verb|min::gen| value containing an auxiliary pointer (list,
sublist, or indirect).

New {\tt min::gen} values can be generated by the following protected
functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_gen}\verb| ( const min::stub * s )|
\LABEL{MIN::NEW_GEN_OF_STUB} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE}\verb| ( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen\COMPACT}\verb| ( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_str\_gen}\verb| ( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen}\verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{tabular}\end{indpar}

These protected functions check for argument range errors.  Stubs are
\underline{not} allocated by these functions, so an {\tt int}
argument to {\tt min::new\_direct\_int\_gen\COMPACT} must fit in 28 bits,
and the {\tt const char *} strings must be short enough to
fit into a direct string.  For {\tt min::new\_\EOL direct\_\EOL str\_\EOL gen}
with a second argument \verb|n|, a string longer than \verb|n| characters
is shortened to \verb|n| characters (analogously to \verb|strncpy| and
\verb|strncmp|).
The {\tt min::unsgen} arguments used to make auxiliary pointers, indices,
control codes, and special values must fit within {\tt min::VSIZE} bits.

The subtype codes used for 64-bit {\tt min::gen} direct string, stub pointer,
auxiliary pointer, index, control code, and special values
-- that is, all the non-numeric \verb|min::gen| values --
are chosen to avoid being the same as the high order bits of any
IEEE floating point number normally generated by the compiler,
run-time system, or program execution.  A {\tt min::float64}
input to {\tt min::new\_direct\_\EOL float\_\EOL gen} is assumed not to have
these subtype
codes, and no check is made for such, even by range-checking protected
functions.

The following unprotected functions are analogous but do not check for
range errors.

\begin{indpar}
\verb|min::gen MUP::|\MUPKEY{new\_gen}\verb| ( min::stub * s )|
\LABEL{MUP::NEW_GEN_OF_STUB} \\
\verb|min::gen MUP::|\MUPKEY{new\_direct\_float\_gen\LOOSE}%
    \verb| ( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_direct\_int\_gen\COMPACT}\verb| ( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_direct\_str\_gen}\verb| ( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_direct\_str\_gen}%
    \verb| ( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::|\MUPKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|\MUPKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN}
\end{indpar}

The following unprotected functions can be used to replace the data
(non-subtype) part of a \verb|min::gen| value that is \underline{not}
a pointer to a stub or a number (direct float or direct integer).
The intended use is for changing the value of an auxiliary pointer
in a general value, or the flags in a condition code.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen}\verb| ( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\
\end{tabular}\end{indpar}

The actual direct atom, stub pointer, auxiliary pointer, index,
and control code
{\tt min::gen} subtype codes
are implementation dependent.  The following constants equal these
subtype codes:

\begin{indpar}
\verb|const unsigned min::|\MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_FLOAT\LOOSE}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_INT\COMPACT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::|\MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::|\MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_PACKED\_AUX}
\LABEL{MIN::GEN_PACKED_AUX} \\
\verb|const unsigned min::|\MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::|\MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::|\MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::|\MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL}
\end{indpar}

\verb|min::GEN_ILLEGAL| is actually illegal as a subtype code but may
be returned by the following function which be used to retrieve
the subtype code field:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{gen\_subtype\_of}\verb| ( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{tabular}\end{indpar}

For 64-bit \verb|min::gen| values, this retrieves the high order
24 bits of the value, and then zeros any low order bits that are not
part of the subtype code (that is, the 64-bits are right shifted by
40 bits and then bits of the result that are not part of the
subtype, such as bits in a number, are zeroed).
For 32-bit \verb|min::gen| values, this retrieves
the high order 8 bits, and then zeros any low order bits that are not
part of the subtype code (similarly the 32-bits are right shifted by
24 bits, etc.).
\verb|min::GEN_ILLEGAL| is returned by this function if the \verb|min::gen|
value is not a legal general value.

\subsection{Special Values}
\label{SPECIAL-VALUES}

Special general values are \verb|min::gen| values that are unique
and not equal to any value that can be generated during
program execution.  Special general values are C/C++ {\tt const}
values, and are never to be used unless documentation specifies
a specific use.  They are used as return or argument
values by some functions.

The special values defined by MIN are:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::gen min::}\MINKEY{MISSING}]~%
	\LABEL{MIN::MISSING}\\
Denotes a missing value or an empty set of values, and may be input
or output and used as an attribute value.
\item[{\tt const min::gen min::}\MINKEY{NONE}]~%
	\LABEL{MIN::NONE}\\
Denotes a non-existent function value or result, and may not be
input or output or used as an attribute value or label.
\item[{\tt const min::gen min::}\MINKEY{ANY}]~%
	\LABEL{MIN::ANY}\\
Denotes any value from a set of values.
\item[{\tt const min::gen min::}\MINKEY{MULTI\_VALUED}]~%
	\LABEL{MIN::MULTI_VALUED}\\
Indicates a set of values has more than one element.
\item[{\tt const min::gen min::}\MINKEY{UNDEFINED}]~%
	\LABEL{MIN::UNDEFINED}\\
A value given to an object variable vector element
(\secref{TYPED-OBJECTS}) that has no value and can be indirected.
\item[{\tt const min::gen min::}\MINKEY{SUCCESS}]~%
	\LABEL{MIN::SUCCESS}\\
A value returned to indicate a function has succeeded.
\item[{\tt const min::gen min::}\MINKEY{FAILURE}]~%
	\LABEL{MIN::FAILURE}\\
A value returned to indicate a function has failed.
\end{list}
\end{indpar}

Special general values each have a unique \ikey{index}{of special value}
that identifies them relative to other special values.  These
indices are in the range $0$ through $2^{24}-1$.  The last 256 indices of this
range, $2^{24}-256$ through $2^{24}-1$ are reserved for use by the MIN
system.  Other special values can be created by other systems,
and indices near 0 are reserved for non-system users.

For efficiency reasons it is desirable for special values to be
compile time constants.  Because compilers generally do not run
inline functions at compile time, a macro is needed to compute special
values.  This macro is

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(macro) min::gen |
	& \TTNBKEY{MIN\_NEW\_SPECIAL\_GEN}\verb| ( i )|
\LABEL{MIN_NEW_SPECIAL_GEN} \\
\end{tabular}\end{indpar}

where \verb|i| is the index of the special value to be
created, and must be an unsigned integer compile time constant
expression.  This macro does \underline{not} check the range
of the index, and is unprotected in this sense.  A typical usage
would be

\begin{indpar}\begin{verbatim}
const min::gen MISSING = MIN_NEW_SPECIAL_GEN ( 0xFFFFFF );
\end{verbatim}\end{indpar}


\subsection{Stubs}
\label{STUBS}

General values may point at object stubs, which are 16 byte structures
that are \underline{not} relocated during execution.
Some stubs have pointers to object bodies, which can be
relocated during execution, either
because the object is being expanded or contracted, or because
memory is being compacted.

A stub contains an 8 byte stub value and an 8 byte stub control.

If the stub control is viewed as a 64 bit integer, its high order byte
is the type code.  The high order bit of this type code,
which is the high order
bit of the 64 bit stub control integer, is off if the stub is managed by
the allocator/collector/compactor (acc, of which the garbage collector is
a part).  In this case the stub is said to be `\key{collectible}'.
In the other case, where the bit is on, the stub is
said to be `\key{uncollectable}', and the stub is allocated and freed
by explicit calls to the acc, but is not garbage collected or compacted by the
acc.

If an stub has a body, its stub value is a pointer at that body.
Any pointer into a body is called a `body pointer'.

\subsubsection{Stub Type Codes}
\label{STUB-TYPE-CODES}

The \key{type code} of a stub may be returned by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{type\_of}\verb| ( const min::stub * s )|
\LABEL{MIN::TYPE_OF}
\end{tabular}\end{indpar}

A determination of whether or not a stub is collectible may be made
by applying the function

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_collectible}\verb| ( int type )|
\LABEL{MIN::IS_COLLECTIBLE}
\end{tabular}\end{indpar}

to the type code of the stub.  Notice that type codes are \underline{signed}
integers, so that negative type codes are uncollectable and positive type codes
are collectible.

A partial list of stub type codes is:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const int min::NUMBER}]~\\
Stub value is an IEEE 64-bit floating point number.
\item[{\tt const int min::SHORT\_STR}]~\\
Stub value is 0-8 \verb|const char| string, NUL padded.
\item[{\tt const int min::LONG\_STR}]~\\
Stub value is a pointer at a body of type {\tt min::long\_\EOL string}
that contains a \verb|const char| vector and its size. 
\item[{\tt const int min::DEALLOCATED}]~\\
Stub has a deallocated body.
\end{list}
\end{indpar}

A full list of stub type codes complete with page references
is given on \pagref{STUB-TYPE-CODE-LIST}.

\subsubsection{Stub Values}
\label{STUB-VALUES}

A stub contains a 64-bit \key{stub value}.  If the stub is collectible
(as determined by its type), the type of this value
is determined by the stub type code (\secref{STUB-TYPE-CODES}).
Otherwise the stub is typically attached to an object and the type of the stub
value is determined by how it is attached; in this case the type of the
stub value is most often just \verb|min::gen|.

Many stubs are immutable
and their stub values cannot be written after the stub has been created;
nevertheless we describe unprotected functions
below (\secref{UNPROTECTED-STUB-FUNCTIONS}) that
write these values.  Unprotected functions are also provided to obtain
body pointers from stubs when these are the stub values of the stubs.
This cannot be done by protected
functions as body pointers are relocatable and require special
programming be sure they are up-to-date (\secref{BODY-POINTERS}).

\subsubsection{Stub Control}
\label{STUB-CONTROL}

A stub contains a 64-bit \key{stub control}.  The high order 8 bits
of this is the stub type code, and the high order bit of this type
code determines whether the stub is collectible (bit is off)
or uncollectable (bit is on).

If the stub is collectible,
the stub control is used exclusively by the acc,
except for the type code, which is shared between the acc
and the rest of the system.  Such a control word is called
an `\key{acc control}\,'.  A typical (but not required)
organization of an acc control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 12-24 bits:	& acc flags \\
low order 44-32 bits:	& chain pointer \\
\end{tabular}
\end{center}

Here the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING})
that is used to build lists of allocated stubs which
the acc manages.

If a stub is uncollectable, its stub control, which is called
a `\key{non-acc control}\,', can be organized in different
ways according to the type code value.  The standard way of organizing
a non-acc stub control is:

\begin{center}
\begin{tabular}{ll}
high order 8 bits:	& type code \\
next 8 bits:		& subtype code \\
low order 48 bits:	& chain pointer or unsigned integer value \\
\end{tabular}
\end{center}

Again the chain pointer is a packed stub address
(see \pagref{STUB-ADDRESS-PACKING}),
but now it has enough bits to be packed with the fastest packing scheme.

A non-acc control may also be used outside a stub, say by the acc, and
in this case it may be alternatively organized as:

\begin{center}
\begin{tabular}{ll}
high order 16 bits:	& locator \\
low order 48 bits:	& stub pointer \\
\end{tabular}
\end{center}

The main use of uncollectable stubs is as auxiliary stubs.
An `\key{auxiliary stub}' is an uncollectable stub attached to an object.
When the object is garbage collected, the auxiliary stub is freed.  Auxiliary
stubs are a means of adding memory to an object without relocating the object.
For example, if the object stores 64-bit IEEE floating point numbers,
a chain of auxiliary stubs can be used to add memory to the object
for additional numbers.  Note that the auxiliary stub itself does not
contain information that tells the type of the value it stores;
one has to trace the reference from the object pointing at the
auxiliary stub to determine this type.  Usually auxiliary stub
values are \verb|min::gen| values.  See \secref{UNPROTECTED-STUB-FUNCTIONS}
for functions that can read and write auxiliary stubs.

\subsection{Body Pointers}
\label{BODY-POINTERS}

Bodies are relocatable
(\pagref{RELOCATABLE-BODY}) and and pointers into bodies,
called \skey{body pointer}s,
require special handling to
ensure that they are up-to-date.  There are two ways of managing
this: the protected way and the unprotected way.

Note also that deallocation of a body is treated as
reallocation of the body to inaccessible virtual memory.

\subsubsection{Protected Body Pointers}
\label{PROTECTED-BODY-POINTERS}

The protected way of handling body pointers
uses special pointer data that is adapted to
the type of datum being pointed at.  For example, the following
code can access any string:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some string
assert ( min::is_str ( x ) );
min::str_pointer xp ( x );
int length = min::strlen ( xp );
for ( int i = 0; i < length; ++ i )
{
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Here the \verb|str_pointer| datum is a \key{protected body pointer}.
For strings that are long enough to have a body, the
\verb|str_pointer| stores a pointer to the stub of the string,
and `\verb|xp[i]|' is an inline function that expands to
code that reads the body pointer from the stub and adds both
an appropriate constant offset and then the index `\verb|i|'
to that pointer in order to get the address of the character.

It might be thought that this is inefficient as the body pointer
is re-read from the stub for every different iteration of the `\verb|for|'
loop.  However, if no out-of-line functions are called in the
loop, an optimizing compiler will very often be able to eliminate
the excess reads and load the body pointer plus constant offset
into a register before the loop begins.  The key here is to
avoid out-of-line function calls, as for each such call the
optimizer must assume that the body pointer in the stub might
change.

Protected pointer types are provided for each type of object
that has a body.

\subsubsection{Unprotected Body Pointers}
\label{UNPROTECTED-BODY-POINTERS}

\ikey{Unprotected body pointers}{unprotected body pointer}%
\index{pointer!unprotected body}\index{body pointer!unprotected}
are C/C++ pointers that point directly into a body.
Functions that obtain body unprotected
pointers from stubs are unprotected (\verb|MUP|) functions because
the unprotected body pointers they return are invalidated
if the body pointed at
is relocated.

In order to track possible relocation,
names of functions that might relocate bodies are marked
with the superscript {\REL} in this document.
Relocation can only happen inside such \skey{relocating function}s
(\pagref{RELOCATING-FUNCTIONS}).

The following uses unprotected body pointers to point at a character
string stored in a body:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some long string
assert ( min::is_stub ( x ) );
const min::stub * xstub = min::stub_of ( x );
assert ( min::type_of ( xstub ) == min::LONG_STR );
MUP::long_str * xstr = MUP::long_str_of ( xstub );
const char * xp = MUP::str_of ( xstr );
int length = MUP::length_of ( xstr );
for ( int i = 0; i < length; ++ i )
{
    // Relocating functions must NOT be called in this loop.
    . . . xp[i] . . .
}
\end{verbatim}\end{indpar}

Strings are in fact of three types, `direct' which stores characters
in the general value, `short' which stores up to 8 characters in the stub
value, and `long' which stores more than 8 characters in the body.  The
above code only works for long strings (\pagref{LONG-STRING-STUB}).


When relocation happens inside a relocating function,
the `\key{relocated flag}\,'\label{RELOCATED-FLAG},
which is one of the execution flags
described in~\secref{EXECUTION-FLAGS}, is set.
Functions that use unprotected pointers must obey the following
protocol:

\begin{indpar}
save the relocated flag \\
\ldots\ldots \\
compute local variables containing unprotected body pointers \\
use these local variables \\
\ldots\ldots \\
to call a relocating function: \\
\hspace*{3em}\begin{tabular}{l}
    clear the relocated flag and call the relocating function \\
    if the relocated flag is now set: \\
    \hspace*{3em}\begin{tabular}{l}
	optionally check that object bodies pointed at \\
	\hspace*{3em}have not been deallocated (see \secref{DEALLOCATION}) \\
	set the saved relocated flag \\
	recompute all local variables containing unprotected body pointers \\
    \end{tabular} \\
\end{tabular} \\
\ldots\ldots \\
restore the saved relocated flag
\end{indpar}

When a function that calls relocating functions returns to its caller,
it must set the relocated
flag if that flag was set when the function started or if the
flag was set during function execution.

Relocating functions update body pointers that are not stored
in local variables, in particular those stored in stubs.
The local variables must then be recomputed from the pointers stored in
the stubs.

If a body is deallocated by a relocating function,
the stub's type will be changed to
{\tt min::\EOL DEALLOCATED}, and the body will be relocated to inaccessible
virtual memory so references to it will cause program terminating
memory fault.  For many stubs, this is the only possible 
type change.  However some bodies may not only be relocated, but
may be reorganized, causing their stub to change type.  An example
is objects, which can have stub type {\tt min::\EOL SHORT\_\EOL OBJ} or
{\tt min::\EOL LONG\_\EOL OBJ}, and may be reorganized during relocation to
become more compact.  Usually such stubs are marked when they
are in use by a function that calls relocating functions so that
they will not change type (except for deallocation) and their
bodies will not be reorganized.  For example, objects have a state
which indicates if protected object pointers are pointing at the
object.

If the example above is modified to call a relocating function
in its loop, the resulting code would be:
\begin{indpar}\begin{verbatim}
min::gen x = . . .  // set x to some long string
assert ( min::is_stub ( x ) );
const min::stub * xstub = min::stub_of ( x );
assert ( min::type_of ( xstub ) == min::LONG_STR );
MUP::long_str * xstr = MUP::long_str_of ( xstub );
const char * xp = MUP::str_of ( xstr );
int length = MUP::length_of ( xstr );
bool relocated = min::set_relocated_flag ( false );
for ( int i = 0; i < length; ++ i )
{
    . . . xp[i] . . .
    some_relocating_function ( . . . );
    if ( min::set_relocated_flag( false ) )
    {
        relocated = true;
        assert ( ! is_deallocated ( xstub ) );
        xstr = MUP::long_str_of ( xstub );
        xp = MUP::str_of ( xstr );
    }
    . . . xp[i] . . .
}
min::set_relocated_flag ( relocated );
\end{verbatim}\end{indpar}

The following functions get and set the relocated flag:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{relocated\_flag}\verb| ( void )|
\LABEL{MIN::RELOCATED_FLAG} \\
\verb|bool min::| & \MINKEY{set\_relocated\_flag}\verb| ( bool value )|
\LABEL{MIN::SET_RELOCATED_FLAG}
\end{tabular}\end{indpar}

The function to set the flag returns the flag's previous value.

A function that computes an unprotected pointer into a body does not
check the type code of the stub pointing at the body.  The type
code must be checked separately before the pointer is computed.  If the
pointer is being recomputed after possible relocation, the stub type
code may have to be checked.  For most stub types, the only check
required relates to the possibility that the body has been deallocated.

Code to handle relocating function calls and unprotected body
pointers has the general form:

\begin{indpar}\begin{verbatim}
... some_function ( ... )
{
    bool relocated = min::set_relocated_flag ( false );
    . . . . .
    const min::stub * s = min::stub_of ( ... );
    . . . . .
    assert ( ... == type_of ( s ) );
    MUP::some_body_type * p =
        MUP::some_function_returning_a_body_pointer ( s );
    . . . . . use p . . . . .
    some_relocating_function ( ... );
    if ( min::set_relocated_flag( false ) )
    {
        relocated = true;
        assert ( ! is_deallocated ( s ) );
        p = MUP::some_function_returning_a_body_pointer ( s );
    }
    . . . . . use p . . . . .
    min::set_relocated_flag ( relocated );
    return ...;
}
\end{verbatim}\end{indpar}

To simplify this code, the following is defined:

\begin{indpar}\begin{verbatim}
class min::relocated
{
public:
    bool relocated_flag;
    relocated ( void )
    {
        relocated_flag = min::set_relocated_flag ( false );
    }
    ~ relocated ( void )
    {
        min::set_relocated_flag ( relocated_flag );
    }
    operator bool ()
    {
        if ( min::set_relocated_flag ( false ) )
            return relocated_flag = true;
        else
            return false;
    }
}
\end{verbatim}\end{indpar}\LABEL{MIN::RELOCATED}

which permits the general code given above to be rewritten more conveniently
as:

\begin{indpar}\begin{verbatim}
... some_function ( ... )
{
    // relocated constructor saves the relocated flag.
    min::relocated relocated;
    . . . . .
    const min::stub * s = min::stub_of ( ... );
    . . . . .
    assert ( ... == type_of ( s ) );
    MUP::some_body_type * p =
        MUP::some_function_returning_a_body_pointer ( s );
    . . . . . use p . . . . .
    some_relocating_function ( ... );
    if ( relocated )
    {
        assert ( ! is_deallocated ( s ) );
        p = MUP::some_function_returning_a_body_pointer ( s );
    }
    . . . . . use p . . . . .
    return ...;
    // relocated deconstructor restores relocated flag.
}
\end{verbatim}\end{indpar}

\subsubsection{Deallocation}
\label{DEALLOCATION}

The operation of \ikey{deallocating a body}{deallocate!body}\index{deallocation}
is considered to be a relocation of the body.  The body pointer in the
stub is pointed at a `deallocated body' located in
inaccessible virtual memory, and the type code in the stub
is set to {\tt min::DEALLOCATED} (\pagref{MIN::DEALLOCATED}).

The following function tests whether a stub
has {\tt min::DEALLOCATED} type:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_deallocated}\verb| ( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED}
\end{tabular}\end{indpar}

This function just checks the stub type code to see if it equals
{\tt min::DEALLOCATED} (\pagref{MIN::DEALLOCATED}).

The inaccessible memory to which a {\tt min::DEALLOCATED} stub is
pointed is called the `\key{deallocated body}' of the stub.
Implementations typically provide a single block of inaccessible memory
which is used as the deallocated body of all {\tt min::DEALLOCATED} stubs.
The size of this will be large enough that any access to the body of
a {\tt min::DEALLOCATED} stub that was previously of a
standard stub type will cause a memory fault, because every such access is
checked to see if it does not go beyond the end of the body by using
data in a header at the beginning of the body,
and the size of the deallocated body is larger than the size of the header.

However, when recomputing pointers into a body after a relocating
function has been called the body header may not be reaccessed,
so in this case an explicit check that a body has not been deallocated
is necessary.

\subsection{Allocator/Collector/Compactor Interface}
\label{ACC-INTERFACE}

The garbage collector needs to be able to locate all
\verb|min::gen| values that are in use and that might
contain stub pointers.
When you write general
values into stubs or bodies, you need to call an acc function
to update garbage collection flags associated with stubs.
The first subsection of this
section specifies how these things are done, and includes
data types that must be used to hold \verb|min::gen|
values in static or stack memory, and functions that must
be called when a \verb|min::gen| value that might point
at a stub is written into a stub or body.

If you are implementing a new type of stub and maybe bodies
associated with that stub type, you need to use the unprotected
interface described in the subsequent subsections.
You need to be able to allocate stubs, read and write stub values,
and read and write stub types.  If you are allocating non-acc
stubs (i.e., stubs that are not garbage collected), then you
also need to be able to read and write the entire stub control
and to free the stubs.
If your stubs have bodies, you need to be able to allocate,
relocate, and deallocate the bodies.

\subsubsection{Storing General Values}
\label{STORING-GENERAL-VALUES}

General values that might contain stub pointers must be locatable
by the garbage collector (the collector part of the acc).  Since
in a compact implementation even double precision numbers are
represented by \verb|min::gen| values pointing at stubs, this means
the just about all general values must be locatable.  However,
in order to benefit loose implementations, a distinction is made
between \verb|min::gen| values known to be numeric and those
that might not be, so loose implementations can encounter less overhead
when dealing with numeric \verb|min::gen| values.

When \verb|min::gen| values are stored in static or stack memory, they
should be stored in vectors constructed and accessed using the following:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{static\_gen}%
    \verb|<min::unsptr size> vec ( void )|
\LABEL{MIN::STATIC_GEN} \\
\verb|(constructor) min::| & \MINKEY{static\_num\_gen}%
    \verb|<min::unsptr size> vec ( void )|
\LABEL{MIN::STATIC_NUM_GEN} \\
\verb|(constructor) min::| & \MINKEY{stack\_gen}%
    \verb|<min::unsptr size> vec ( void )|
\LABEL{MIN::STACK_GEN} \\
\verb|(constructor) min::| & \MINKEY{stack\_num\_gen}%
    \verb|<min::unsptr size> vec ( void )|
\LABEL{MIN::STACK_NUM_GEN} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen & min::| & \ttkey{operator [ ]}\ARGBREAK
                 \verb|( min::static_gen<> & vec, min::unsptr i )|
\LABEL{MIN::STATIC_GEN_OPERATOR[]} \\
\verb|min::gen & min::| & \ttkey{operator [ ]}\ARGBREAK
                 \verb|( min::static_num_gen<> & vec, min::unsptr i )|
\LABEL{MIN::STATIC_NUM_GEN_OPERATOR[]} \\
\verb|min::gen & min::| & \ttkey{operator [ ]}\ARGBREAK
                 \verb|( min::stack_gen<> & vec, min::unsptr i )|
\LABEL{MIN::STACK_GEN_OPERATOR[]} \\
\verb|min::gen & min::| & \ttkey{operator [ ]}\ARGBREAK
                 \verb|( min::stack_num_gen<> & vec, min::unsptr i )|
\LABEL{MIN::STACK_NUM_GEN_OPERATOR[]} \\
\end{tabular}\end{indpar}

An example usage is:

\begin{indpar}\begin{verbatim}
static min::static_gen<2> gpq;
static min::gen & p = gpq[0];
static min::gen & q = gpq[1];
. . . . . . . . . .
... some_function ( ... )
{
    min::stack_num_gen<3> g_area;
    min::gen & x = g_area[0];
    min::gen & y = g_area[1];
    min::gen & z = g_area[2];
    . . . use p, q, x, y, z . . .
}
\end{verbatim}\end{indpar}

Here \verb|p| and \verb|q| are static variables that may hold
any \verb|min::gen| values and \verb|x|, \verb|y|, and \verb|z|
are stack variables that may only hold numeric or {\tt min::\EOL MISSING}
\verb|min::gen| values.  These variables are called `\skey{acc locatable
variable}s'.  Such variables are always initialized to the value
{\tt min::\EOL MISSING}.
Static variables may also be global; i.e., they
can be defined without the `\verb|static|' keyword as long
as they are defined outside functions.

Importantly a \verb|min::gen| value need \underline{not} be stored
in a locatable variable if it can be located by the acc by some
other means.  For example, if it is stored in one locatable variable,
it need not be stored in another.  Or if a \verb|min::gen| value
$V$ is stored in an object pointed at by another \verb|min::gen|
value $P$, and $P$ is stored in a locatable variable, then $V$ need not
be stored in a locatable variable.

A very important rule is that when a function is called, the caller
must be sure every \verb|min::gen| value passed to the called
function can be located by the acc \underline{without} the called
function needing to store the value in a locatable variable.
For example, the caller can store the value in its own locatable
variable.  This is called the `\key{caller locating convention}.

Also \verb|min::gen| values need only be locatable by
the acc when a relocating function (\pagref{RELOCATING-FUNCTIONS})
is called.  In between such calls \verb|min::gen| values can be
stored in other places.

In addition to needing to locate \verb|min::gen| values, the acc
must be notified whenever a pointer to a collectible stub \verb|s2|
is stored in a collectible stub \verb|s1| or in a body or uncollectable
stub attached to \verb|s1|.  This is done by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update}\verb| ( min::stub * s1, min::stub * s2 )|
\LABEL{MUP::ACC_WRITE_STUB_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_update} \\
    & \verb|    ( min::stub * s1, min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_GEN_UPDATE} \\
\verb|void MUP::|
    & \MUPKEY{acc\_write\_num\_update} \\
    & \verb|    ( min::stub * s1, min::gen * p, min::unsptr n )|
\LABEL{MUP::ACC_WRITE_NUM_UPDATE} \\
\end{tabular}\end{indpar}

The last two of these functions look at all the \verb|min::gen|
values \verb|p[0]|, \ldots, \verb|p[n-1]|, and for each of these
that holds a pointer to a collectible stub \verb|s2|, the first of
the above functions is called.  The {\tt acc\_\EOL write\_\EOL
num\_\EOL update} function should only be used if all the
\verb|min::gen| values are numeric; in a loose implementation this
function is a no operation.

These \verb|min::acc_write_update| functions need and indeed
\underline{must not} be called if \verb|s1| is of
{\tt min::ACC\_\EOL FREE} type.  However \verb|min::gen| and
other pointers to stubs can be stored in such a stub and any
body or auxiliary stubs associated with it.

\subsubsection{Unprotected Stub Functions}
\label{UNPROTECTED-STUB-FUNCTIONS}

There are unprotected functions to allocate and free stubs, 
read and write stub values, and read, write, and modify
stub controls.


\subsubsubsection{Stub Allocation Functions}
\label{STUB-ALLOCATION-FUNCTIONS}

The following functions are used to allocate stubs:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub}\verb| ( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub}\verb| ( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\end{tabular}\end{indpar}

The \verb|min::new_acc_stub| function returns a garbage collectible (acc)
stub with its type set to \minkey{ACC\_FREE}.  A stub with this type
is invisible to the garbage collector; it will not be garbage collected,
and \verb|min::gen| values stored in it or its body will not be locatable
by the garbage collector.  The {\tt MUP::acc\_\EOL write\_\EOL update}
function should \underline{not} be called when \verb|min::gen| values
are stored in a stub with {\tt min::ACC\_\EOL FREE} type
or any body or auxiliary stub associated with it.
Furthermore, no \verb|min::gen| value locatable
by the garbage collector should point to a stub of {\tt min::ACC\_\EOL FREE}
type when a relocating function (\pagref{RELOCATING-FUNCTIONS}) is called.
The actions of changing
the type of the stub to another collectible type and storing a
\verb|min::gen| value pointing at the stub in a garbage collector
locatable variable should be taken together and not separated by any
call to a relocating function.

It is permissible to allocate and build a graph of stubs with
{\tt min::ACC\_\EOL FREE} type, calling stub and body allocators,
and then without calling any relocatable functions, change the types
of all the stubs to other collectible types, and store \verb|min::gen|
values pointing at a root set of the graph in locatable variables.

The \verb|min::new_aux_stub| function returns a non-acc (i.e.,
not garbage collectible)
stub with its type set to \minkey{AUX\_FREE}.  This kind of stub is
is \underline{not} freed by the garbage collector.  It must be
freed only by calling:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void MUP::| & \MUPKEY{new\_aux\_stub}\verb| ( min::stub * s )|
\LABEL{MUP::FREE_AUX_STUB} \\
\end{tabular}\end{indpar}

A non-acc stub is most often attached to an acc stub in such a way
that when the acc stub is garbage collected, the non-acc stub is
freed.  Such a non-acc stub is called an \key{auxiliary stub}, and
because most non-acc stubs are of this kind, functions dealing with
non-acc stubs have names containing `\ttkey{aux}' instead of
`\verb|non_acc|'.

\subsubsubsection{Stub Value Read/Write Functions}
\label{STUB-VALUE-READ-WRITE-FUNCTIONS}

The following functions read or write the stub value part of a stub:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::VALUE_OF} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{pointer\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::POINTER_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_value\_of}\verb| ( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of}\verb| ( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of}\verb| ( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_pointer\_of}\verb| ( min::stub * s, void * p )|
\LABEL{MUP::SET_POINTER_OF} \\
\end{tabular}\end{indpar}

Thus the stub value can be taken to be of type \verb|min::uns64|,
\verb|min::float64|, \verb|min::gen|, or
of some pointer type.

These functions do \underline{not} check type codes, nor do they check
that values read or written are within legal range for a particular
stub.  For example, a stub value that is not a floating point number can be
read by \verb|MUP::float_of| with undefined results.

\subsubsubsection{Stub Control Functions}
\label{STUB-CONTROL-FUNCTIONS}

The following functions read or write the stub control part of a stub:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|int min::| & \MINKEY{type\_of}\verb| ( const min::stub * s )| \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( const min::stub * s,| \\
      \verb|   min::uns64 flags )|
      \end{tabular}
\LABEL{MUP::TEST_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_control\_of}\verb| ( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of}\verb| ( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of}\verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of}\verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{tabular}\end{indpar}

The \verb|MUP::control_of| and \verb|MUP::set_control_of| functions
deal with the entire 64 bit stub control value of a stub.  The other
functions deal only with parts.

For acc stubs, only the type part of the control should be read or
written.  The other parts of the control are for use by the
acc, and should not be accessed by non-acc code,
in order to ensure that the acc is independent of other code.

The stub control in a stub is an example of a MIN \key{control value}.
A MIN control value holds a stub address or an unsigned integer
in its low order bits.  It may hold an 8 bit type code in its highest order
bits.  Any bits left over are flag bits, or if there is no 8 bit type
code, the high order 16 bits may be a signed integer field called the
`\mkey{locator}{field of control value}'
which is used only by some acc code.  Control values have type
\verb|min::uns64|.  Control values are used as stub controls, and
may be use in other places, e.g., by the acc to hold pointers from
a block that holds a body back to the stub pointing at the body.

Thus control values contain an address/value low order field, and optional
type code high order field, and flag bits.  There are two kinds of
control values: (ordinary) control values and acc control values.
Ordinary control values
have 48 bits for the address/value field, and either 8 bits for the type
and 8 bits for flags, or 16 bits for the locator.
Acc control values have 56 - G bits for a stub address, 8 bits
for the type, and G bits for the acc flags, where G is some value from 8
through 24.  The larger G, the more acc flags, which may permit the
garbage collector to be more efficient (e.g., to have more ephemeral
levels).

Addresses stored in a control value must be stub addresses, as only they
can be packed into less than 64 bits.

The control values used as stub controls do have a type code field which
can be read by \verb|min::type_of| (which is protected) and
written by \verb|MUP::set_type_of|.  For stub controls,
acc control values are used with
collectible types, and ordinary control values with
uncollectable types.

The flag bits are set, cleared, and tested individually.  They are
defined by constants of type \verb|min::uns64|, such as

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::uns64 MUP::}\MUPKEY{STUB\_ADDRESS}]~%
	\LABEL{MIN::STUB_ADDRESS}\\
Indicates that the address/value field of an ordinary (non-acc)
control holds a stub address.  This flag is only used for
uncollectable stubs whose control address/value field might
be either a stub address or an unsigned integer.
\end{list}
\end{indpar}

These flag constants are defined by expressions of the form

\begin{center}
\verb|( min::uns64(1) << |$K$\verb| )|
\end{center}

where

\begin{center}
\begin{tabular}{l@{~~~~~}l}
$M\leq K\leq 63$ & if there is no type code field \\
		 & (does not apply to stub controls) \\
$M\leq K\leq 55$ & if there is a type code field \\
\\
\multicolumn{2}{l}{$M$ is the size of the address/value field} \\
\\
$32\leq M\leq 48$ & depending on hardware \\
\end{tabular}
\end{center}

The above functions assume that any flag constants select bits
in a control value that are not inside the address/value field
or inside the type code field.

The flags in the stub control value of a stub can be tested, set, or
cleared by some of the above functions.
The \verb|MUP::test_flags_of| function
returns true if and only if the logical AND of the \verb|flags| arguments
and the flags in the stub's control is non-zero.  The \verb|MUP::set_flags_of|
function sets one or more individual flags by logically ORing its
argument into the stub's control, and the
\verb|MUP::clear_flags_of| function clears flags by logically ANDing
the complement of its argument into the stub's control.

The above functions do \underline{not} check type codes, nor do they check
that values read or written are within legal range for a particular
stub.  Thus a stub control value
can be written by \verb|MUP::set_control_of| even if the written
control datum is incompatible with the garbage collector implementation,
and may produce undefined results when the garbage collector
next executes.  Flag bits must not be inside the address/value field
or inside the type code field.

The high order byte of any control written by \verb|MUP::set_control_of|
is the type code, and the high order bit is clear if the stub is collectible
and set if the stub is uncollectable (\secref{STUB-CONTROL}).
Changing a stub from collectible to uncollectable or vice versa requires
removing or adding the stub to garbage collector lists that are threaded
through the pointer field of the stub control.  So one cannot simply
change the type code field of a stub from collectible to uncollectable
or vice versa.

Ordinary (non-acc) control values can be manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator}\verb| ( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value}\verb| ( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|int MUP::| & \MUPKEY{locator\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{tabular}\end{indpar}

The `{\tt new}' functions compute a control value,
the `{\tt renew}' functions modify control values
by inserting a new locator, value, or stub address, and
the other functions return the parts of a control value.
Here the 16-bit locator is represented as an \verb|int|
in the range from $-2^{15}$ through $2^{15}-1$.

None of these functions check the ranges of their arguments.

Acc control values can be manipulated by the following similar functions
(this is only done by acc code):

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,| \\
    & \verb|                     min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub} \\
    & \verb|    ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
\end{tabular}\end{indpar}

Either ordinary or acc control values can be
manipulated by the following functions:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type}\verb| ( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{tabular}\end{indpar}

Here the 8-bit type code is represented as an {\tt int} in
the range from $-128$ through $127$.

\subsubsection{Unprotected Body Functions}
\label{UNPROTECTED-BODY-FUNCTIONS}

The following functions allocate and deallocate bodies:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void MUP::|
    & \MUPKEY{new\_body}\verb| ( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body}\verb| ( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{tabular}\end{indpar}

Here \verb|n| is the size in bytes of the body to be allocated or deallocated.
The allocator is not required to remember the size of a body,
so when deallocating the body the caller must provide the same size
as was used to allocate the body.  The allocator will likely
run a check that will likely catch a wrong size, but it may not
be able to determine the right size.

Bodies are always aligned on 8 byte boundaries, but the size \verb|n|
need \underline{not} be a multiple of 8.

When a body is deallocated, the stub type is set to
\verb|min::DEALLOCATED| and the stub pointer is set to
point at a block of inaccessible memory.
As a special case, if the body size \verb|n| is zero,
{\tt MUP::\EOL deallocate\_\EOL body} does nothing
(see {\tt MIN::\EOL body\_\EOL size\_\EOL of} below).


The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\end{tabular}\end{indpar}

returns the size of the body, that is, the same size
as that passed to {\tt MUP::new\_\EOL body} when the
body was allocated.  This is necessary as the acc does
\underline{not} keep track of body sizes, and depends upon
this {\tt MUP::body\_\EOL size\_\EOL of} function to
find body sizes.  If the stub is deallocated (of type
\verb|min::DEALLOCATED|) or if the stub has no body,
\verb|0| is returned.  This enables the code
\begin{center}
\verb|MUP::deallocate_body ( s, MUP::body_size_of ( s ) )|
\end{center}

The function

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|void * & MUP::| & \MUPKEY{pointer\_ref\_of}%
	     \verb| ( min::stub * s )| 
\LABEL{MUP::POINTER_REF_OF_STUB} \\
\end{tabular}\end{indpar}

returns a pointer to a pointer to the body.
The first pointer points to a location P with a fixed address
(P is the stub value); P holds
a pointer to the body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS}).
Whenever the body is relocated the value of P is changed to
point to the new body location.

In order to change the size of a body, the following
can be used:

\begin{indpar}\begin{tabular}{@{}r@{}l@{}}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\\
    & \verb|    ( min::stub * s,| \\
    & \verb|      min::unsptr new_size, min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_pointer\_ref}%
	     \verb| ( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_POINTER_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}%
	     \verb| ( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\verb|void MUP::| & \MUPKEY{retype\_resize\_body}\ARGBREAK
	     \verb| ( MUP::resize_body & rb, int new_type )| 
\LABEL{MUP::RETYPE_RESIZE_BODY} \\
\end{tabular}\end{indpar}

When constructed the \verb|MUP::resize_body| datum allocates
a new body for a stub \verb|s|, and when deconstructed the datum
installs the new body in the stub \verb|s| while deallocating the
old body of \verb|s|.  Stub \verb|s|
is not altered until the {\tt MUP::\EOL resize\_\EOL body}
datum is deconstructed, and the {\tt MUP::\EOL abort\_\EOL resize\_\EOL body}
function can be used to abort the body resizing
and prevent stub \verb|s| from ever being altered.
The sizes of the old and new body of \verb|s| must be passed to
the {\tt MUP::\EOL resize\_\EOL body} constructor.

Given a {\tt MUP::\EOL resize\_\EOL body} datum \verb|rb|,
\begin{center}
\verb|MUP::new_body_pointer_ref ( rb )|
\end{center}
returns a pointer to a pointer to the new body.  The first pointer
points to a location P with a fixed address that exists as long
as the {\tt MUP::\EOL resize\_\EOL body} datum \verb|rb| exists.   P holds
a pointer to the new body, which may be relocated by a call to
a relocating function (\pagref{RELOCATING-FUNCTIONS})
as all bodies
can be, and will be pointed to by a changed value of P if it is
relocated.

After the new body is obtained, information should be copied from
the old body to the new body before the {\tt MUP::\EOL resize\_\EOL body}
datum is deconstructed.  The new body will not be touched by
the garbage collector while the {\tt MUP::\EOL resize\_\EOL body} datum
exists, but it may be relocated.  The existing stub \verb|s|
\underline{must} be protected from garbage collection and
its body protected from reorganization by the user while the
{\tt MUP::\EOL resize\_\EOL body} datum exists, but that body may
also be relocated.  \verb|s| must NOT be deallocated
while the {\tt MUP::\EOL resize\_\EOL body} datum exists, unless
{\tt MUP::\EOL abort\_\EOL resize\_\EOL body} has been called.

Normally the type of stub \verb|s| is not changed, but
if the {\tt MUP::\EOL retype\_\EOL resize\_\EOL body} function is called
with a new stub type value, that value will be installed in stub \verb|s|
if and when the new body is installed in stub \verb|s|.

\subsection{Numbers}
\label{NUMBERS}

A \key{number stub} is collectible, has \minnbkey{NUMBER}\LABEL{MIN::NUMBER}
stub type code, and has
an immutable \verb|min::float64| stub value that can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT}\verb| ( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{tabular}\end{indpar}

Number stubs exist only in compact implementations;
in loose implementations number atoms are stored exclusively
in direct number general values
(\secref{GENERAL-VALUE-SUBTYPES}).

General values that are numbers can be tested, created, and read
by the following protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_num}\verb| ( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of}\verb| ( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash}\verb| ( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\end{tabular}\end{indpar}

The \verb|min::is_num| function for a loose 64-bit \verb|min::gen| argument
is just another name for the \verb|min::is_direct_float| function of the same
argument.  For a compact 32-bit \verb|min::gen| argument the function returns
true if the argument is a direct integer or a stub pointer
pointing at a number stub.

The \verb|min::new_num_gen| function with \verb|min::float64| argument
and loose 64-bit \verb|min::gen| value
is just another name for {\tt min::new\_\EOL direct\_\EOL gen}, which
simply changes the type of its argument.
The \verb|min::new_num_gen| function with \verb|min::float64| argument
and compact 32-bit \verb|min::gen| value creates a direct integer
if the argument is an integer in the
require range; otherwise the function returns a \verb|min::gen| value
that is a pointer to a number stub.  If a pointer to a number stub is
to be returned and a number stub containing the argument value already exists,
a pointer to the existing stub is returned;
otherwise a new number stub is created and a pointer to it returned.
Therefore two 32-bit \verb|min::gen| values that represent equal numbers are
themselves \verb|==|.

The \verb|min::new_num_gen| function with an \verb|int| or \verb|min::unsptr|
argument does the
same thing as it would with its argument converted to a \verb|min::float64|
value, but is more efficient in the case where \verb|min::gen| values
are 32 bits and the argument is in the range of a direct integer general
value.

The \verb|min::float_of| function for a loose 64-bit \verb|min::gen|
argument is just another name for the \verb|min::direct_float_of| function
of the same argument, which after checking the subtype of the argument,
simply changes the type of the argument.
For a compact 32-bit \verb|min::gen| argument the
function returns any integer stored directly
in the argument converted to a 64-bit IEEE floating point number, or
returns the stub value for any number stub pointed at by the argument.
In this last case the stub type code is checked by a \verb|MIN_ASSERT|
statement to be sure the stub is a number stub.

The \verb|min::int_of| function does the same thing as the
\verb|min::float_of| followed by conversion to an \verb|int| value,
except that \verb|min::int_of| includes a check that the result
is a pure integer, without any fractional part, and is within the
range of the \verb|int| type, and
\verb|min::int_of| is more efficient when given a 32-bit direct integer
\verb|min::gen| argument.

Lastly, the \verb|min::numhash| function
returns the hash value of a \verb|min::gen|
value that is a number.  This value is computed by considering
the \verb|min::float_of| value of the number
to be a \underline{big endian} string of 8 characters and using the algorithm
on \pagref{HASH-ALGORITHM} to compute the hash value of this string.%
\label{NUMBER-HASH-ALGORITHM}

To permit hash values of arbitrary floating point numbers to be computed,
the following function is provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{floathash}\verb| ( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{tabular}\end{indpar}

The above \verb|min::float_of|, \verb|min::int_of|, and \verb|min::numhash|
functions of a \verb|min::gen| argument apply \verb|MIN_ASSERT| to check
that their argument is a number.  The following unprotected function assumes
that its argument is a number without doing any \verb|MIN_ASSERT| check:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN}
\end{tabular}\end{indpar}

\subsection{Strings}
\label{STRINGS}

In MIN all \skey{string}s\index{strings@strings}
are NUL terminated UTF-8 encoded UNICODE character strings.
\key{UTF-8} encodes 32-bit UNICODE characters in 1 to 6 \verb|char|'s.

All ASCII characters are encoded as themselves in
the UTF-8 encoding.  This implies that
all ASCII character strings are UTF-8 encoded character
strings with the same characters as their ASCII representation indicates.%
\footnote{ASCII character codes range from 0 through 127.  UTF-8 extends
this by assigning meaning to codes from 128 to 255.}

It is possible for a string to be miscoded UTF-8.  None
of the functions given below, including the protected functions,
check for this.

A MIN string value cannot store the NUL character as legal UTF-8.
But it is possible to use the `\key{modified UTF-8}' encoding instead of
strict UTF-8.  The difference is that strict UTF-8 encodes the NUL
character in a single byte as an ASCII NUL, whereas modified UTF-8
encodes the NUL character as the 2-byte string `\verb|0xC0,0x80|'
(which is not legal in strict UTF-8 because it is not the shortest
possible encoding of NUL in UTF-8).

There are two kinds of string stubs: short strings and long strings.
In addition, a string of up to 3 {\tt char}'s can be stored within a 32-bit
\verb|min::gen| value, and a string of up to 5 {\tt char}'s can be stored
within a 64-bit \verb|min::gen| value,
without using a stub
(see \secref{GENERAL-VALUE-SUBTYPES} and
\secref{GENERAL-VALUE-FUNCTIONS}).
Such strings are called \skey{direct string}s, while strings stored in
stubs or bodies which are pointed at by \verb|min::gen| values,
the short and long strings, are called \skey{indirect string}s.
A short string holds up to 8 characters inside the string stub
(there must be more characters than a direct string will hold).
A long string has an string body that holds the string characters
(there must be more than 8)
along with the string length and hash value.

All three kinds of strings, direct, short, and long, are immutable
and have hash values (\pagref{HASH-VALUE}).

\subsubsection{Protected String Functions}
\label{PROTECTED-STRING-FUNCTIONS}

There are protected functions accessing general values that denote
strings of any kind without distinction, and these are described next.
Unprotected functions that apply only to particular
types of string are described later in this section.

The following functions create new general string values:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb| ( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\end{tabular}\end{indpar}

The \verb|min::new_str_gen| functions copy the input string after the
manner of \verb|strcpy| and \verb|strncpy|, respectively.  That is,
they copy from \verb|p|
until a NUL is copied or \verb|n| characters have been copied, whichever
comes first.

When a string general value
is created, if the input string is short enough for the general value
to hold the string itself, a direct string general value is created.
Otherwise \verb|min::new_str_gen| searches to see if any equal string
exists.  If such a string exists, a pointer to the stub of the existing
string is returned in the new \verb|min::gen| value, and no new stub
is created.  Otherwise, if the input string is 8 or fewer {\tt char}'s,
a short string stub is created, and if the input string has more
than 8 {\tt char}'s, a long string stub and body are created.

Thus if two string \verb|min::gen| values are equal as
strings, they have \verb|==| \verb|min::gen| values.

The following functions test a \verb|min::gen| value to see if it
is a string and obtain information from
a string \verb|min::gen| value.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|int min::| & \MINKEY{is\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\[1ex]
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\verb| ( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::|
    & \MINKEY{strncpy}\verb| ( char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\[1ex]
\verb|int min::| & \MINKEY{strcmp}\verb| ( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::|
    & \MINKEY{strncmp} \\
    & \verb|    ( const char * p, min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\end{tabular}\end{indpar}

Five of these functions correspond to the standard C/C++
{\tt strlen}, {\tt strcpy}, {\tt strncpy}, {\tt strcmp},
and {\tt strncmp} functions, and differ
from these only in that instead of taking a {\tt char *} source string
argument, these functions take a {\tt min::gen} source argument.

To permit hash values of arbitrary strings to be computed,
without creating {\tt min::gen} values from them first,
the following functions are provided:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash}\verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{tabular}\end{indpar}

Both \verb|strhash| and \verb|strnhash| accept NUL terminated strings, but
\verb|strnhash| stops reading the string after the first \verb|n| characters
if none of these characters is NUL.

A string hash value is computed according to the following machine
independent algorithm:\label{HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = 0
n = length of string
for i = 1 through n:
    c = i'th char of string as unsigned 8 bit integer
    hash = ( hash * 65599 ) + c
if hash = 0, then hash = 2**32 - 1
\end{verbatim}\end{indpar}

where the final result is truncated to 32 bits.  The constant
is a prime such that multiplication by it may be turned into
shifts and adds by compilers: $65599=2^{16}+2^6-1$.
A hash value is never zero (so zero can be used to denote a missing hash value).

The low order bits of the hash value are random, so it can be
truncated to provide a random hash.

\subsubsection{Protected String Pointers}
\label{PROTECTED-STRING-POINTERS}

A read-only pointer to the characters of a string {\tt min::gen} value can
be obtained using the following functions to create and use
a \key{string pointer}:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{str\_pointer}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}\verb| ( min::str_pointer & sp, min::gen v )|
\LABEL{MIN::INIT_OF_STR_POINTER} \\[1ex]
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::str_pointer & sp )|
\LABEL{MIN::STRLEN_OF_STR_POINTER} \\
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( min::str_pointer & sp )|
\LABEL{MIN::STRHASH_OF_STR_POINTER} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\verb| ( char * p, min::str_pointer & sp )|
\LABEL{MIN::STRCPY_OF_STR_POINTER} \\
\verb|char * min::|
    & \MINKEY{strncpy}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( char * p,| \\
      \verb|   min::str_pointer & sp, min::unsptr n )| \\[1ex]
      \end{tabular}
\LABEL{MIN::STRNCPY_OF_STR_POINTER} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp}\verb| ( const char * p, min::str_pointer & sp )|
\LABEL{MIN::STRCMP_OF_STR_POINTER} \\
\verb|int min::|
    & \MINKEY{strncmp}%
      \begin{tabular}[t]{@{}l@{}}
      \verb|( const char * p,| \\
      \verb|  min::str_pointer & sp, min::unsptr n )| \\[1ex]
      \end{tabular}
\LABEL{MIN::STRNCMP_OF_STR_POINTER} \\[1ex]
\verb|const char      |
    & \ttkey{operator [ ]}\verb| ( min::str_pointer & sp, int index )|
\LABEL{MUP::[]_OF_STR_POINTER} \\
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( min::str_pointer & sp )|
\LABEL{MUP::STR_OF_STR_POINTER} \\
\end{tabular}\end{indpar}

The constructor creates a string pointer pointing to the {\tt char}'s
of the string specified by the \verb|min::gen| argument.  This argument
must be a direct string or a pointer to a short or long string stub.
The {\tt min::initialize} function can reset the string
pointer to point at a different \verb|min::gen| value.

The \verb|strlen|, \verb|strhash|, \verb|strcpy|, \verb|strncpy|,
\verb|strcmp|, and \verb|strncmp| functions retrieve the same information
about the string pointed at by a string pointer as they retrieve about
the string {\tt min::gen} value the pointer points at.

The {\tt MUP::str\_of} function returns a standard C++ pointer to the string,
taking care to ensure the vector of {\tt char}'s is NUL-terminated.
The value of {\tt min::str\_of} will become obsolete if the string is
relocated, and in particular, may become obsolete if a relocating
function is called.  This is why this function is unprotected.

The \verb|[ ]| operator can be used to access individual characters
in a string.  If {\tt sp} is a string pointer, `\verb|sp[i]|' is
shorthand for `\verb|MUP::str_of(sp)[i]|'.

For direct and short strings the string pointer, when it is created,
copies the string {\tt char}'s into a buffer internal to the string pointer,
in order to save the {\tt char}'s in a direct string value, or to
add a missing NUL to the end of the short string {\tt char} vector.
In long string cases no copying is done, and the string pointer
is essentially just a pointer to the string stub, which in turn points
at the string proper inside a relocatable string body.

\subsubsection{Unprotected String Functions}
\label{UNPROTECTED-STRING-FUNCTIONS}

The constructor

\begin{indpar}\begin{tabular}{r@{}l}
\verb|(constructor) MUP::| & \MUPKEY{str\_pointer}\verb| sp ( min::gen v )|
\LABEL{MUP::STR_POINTER_OF_GEN} \\
\end{tabular}\end{indpar}

is just like \verb|min::str_pointer| except that it assumes that
\verb|v| is a string (i.e., that {\tt min::\EOL is\_\EOL str(v)} is
true).  The {\tt min::\EOL initialize} function applied to an
unprotected string pointer also makes the same assumption.

The following unprotected functions
may be used to access the internals of short
and long strings.

A \key{short string stub}\label{SHORT-STRING-STUB} is collectible, has
\minnbkey{SHORT\_STR}\LABEL{MIN::SHORT_STR} stub type code, and has
an immutable {\tt min::\EOL uns64} stub value that holds a NUL padded
8 \verb|char| vector and can be read by

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns64 MUP::|
    & \MUPKEY{short\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::SHORT_STR_OF}
\end{tabular}\end{indpar}

This function does \underline{not} check the type of the stub \verb|s|.
The \verb|min::uns64| value returned by \MUPkey{short\_str\_of}
should be overlaid by a union with a \verb|char[ ]| buffer, as in

\begin{indpar}\begin{verbatim}
union { min::uns64 str; char buf[9]; } u;
min::stub * s1;
. . . set s1 to point at a short string stub . . .
u.str = MUP::short_str_of ( s1 );
u.buf[8] = 0;	// Be sure result is NUL terminated.
cout << u.buf;
\end{verbatim}\end{indpar}

Short string values are NUL (zero) padded 0 to 8 \verb|char|
strings.  To be sure any value read is NUL terminated, a NUL (zero)
must be stored after the value read, as is done by \verb|u.buf[8] = 0|
in the example.

A \key{long string stub}\label{LONG-STRING-STUB} is collectible, has
\minnbkey{LONG\_STR}\LABEL{MIN::LONG_STR} stub type code, and has
a value that is a pointer to a \MUPkey{long\_str} type body
which holds an arbitrary length NUL terminated \verb|char| string.

The long string body consists of the 32-bit length and 32-bit hash value
of the string, followed by a \verb|char|
vector containing the string proper with the terminating NUL.  The
\verb|char| vector is padded to a multiple of 8 bytes with NUL
bytes, but the terminating NUL and the padding are not included
in the length.

The following are unprotected functions to return a relocatable pointer to the
long string body, a relocatable pointer to the string itself,
and the length and hash of the string.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{tabular}\end{indpar}

These functions are unprotected because \verb|long_str *| pointers
are relocatable.


\subsection{Labels}
\label{LABELS}

Attribute labels are often atoms, i.e., single strings or numbers.
But they may be sequences of atoms.  Such sequences are represented by
\skey{label}s.\footnote{Labels could also be represented by
sublists stored inside objects (\pagref{LIST-LEVEL}), but each label tends to
be reused by many objects, and storing it inside each using object
would be inefficient.  In addition labels are useful as function arguments.}
Labels may also be elements of other labels.

A label is just a vector of name components, where a name
component is an atom or a label.  However, labels are immutable and
have the property that no two distinct label stubs can have equal vectors of
name components.  

Note that a label of one element
is distinct from the element itself and has a different
hash code.  Also note that labels can be elements of labels.  A programming
language may wish to require that the elements of labels be numbers or
strings, that numbers and strings be treated as labels of one element,
and that proper labels with one element not be created.  But the
\verb|min.h| code does not do this.

A \key{label stub}\label{LABEL-STUB} is collectible,
has \minnbkey{LABEL}\LABEL{MIN::LABEL} stub type code,
and has an immutable value.
The label value may be read by using {\tt min::\EOL lab\_\EOL pointer}'s:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{lab\_pointer}%
	  \verb| labp ( min::gen v )|
\LABEL{MIN::LAB_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_pointer}%
	  \verb| labp ( min::stub * s )|
\LABEL{MIN::LAB_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_pointer}%
	  \verb| labp ( void )|
\LABEL{MIN::LAB_POINTER_OF_VOID} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::lab_pointer & labp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_LAB_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::lab_pointer & labp,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_LAB_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::lab_pointer & labp )|
\LABEL{MIN::DEINITIALIZE_LAB_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const T & min::|
	& \ttkey{operator [ ]}\ARGBREAK
	  \verb| ( min::lab_pointer & labp,|\ARGBREAK
	  \verb|   min::uns32 i )|
\LABEL{MIN::LAB_POINTER[]} \\
\verb|min::uns32 min::|
	& \MINKEY{length\_of}\ARGBREAK
	  \verb| ( min::lab_pointer & labp )|
\LABEL{MIN::LENGTH_OF_LAB_POINTER} \\
\verb|min::uns32 min::|
	& \MINKEY{hash\_of}\ARGBREAK
	  \verb| ( min::lab_pointer & labp )|
\LABEL{MIN::HASH_OF_LAB_POINTER} \\
\end{tabular}\end{indpar}

Here \verb|v| or \verb|s| must point at the stub of a label,
and given a label pointer \verb|labp| pointing at
a label, \verb|labp[i]| is the \verb|i|+1's
element of the label, for
$0\leq$\verb|i|$<$\verb|min::length_of(labp)|,
where the {\tt min::\EOL length\_\EOL of} function
returns the number of elements in the label.
Note that \verb|labp[i]| is read-only, but one can take
its address, as in:
\begin{indpar}\begin{verbatim}
memcpy ( ..., & labp[0], sizeof ( T ) * min::length_of ( labp ) );
\end{verbatim}\end{indpar}

The form of constructor that has no argument creates a label pointer
that is not pointing at any label.
In this last case the label pointer must
be initialized by the {\tt min::\EOL initialize} function before the pointer
is used; use before initialization will give undefined results, though
attempts to access
label elements using the pointer usually result in memory faults.

The {\tt min::initialize} functions destruct the label pointer and then
reconstruct it.  The {\tt min::\EOL deinitialize} function destructs
the label pointer and leaves it not pointing at any object stub.
Use of such a destructed pointer is undefined, but attempts to access
label elements using it usually result in memory faults.

The length of a label is the number of elements (general values) in the label.
The length of a label may be read from a label pointer, or may be read
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{tabular}\end{indpar}

The hash value of a label may be computed from the label pointer, or
directly by the following functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{labhash}%
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{tabular}\end{indpar}

The last function computes the hash value for a label that could be created
from the given vector {\tt p} of {\tt n} general values, where each
general value is a name component.  The hash of a label is computed from
the hash of each of its elements using the following
machine independent algorithm:\label{LABEL-HASH-ALGORITHM}

\begin{indpar}\begin{verbatim}
hash = 1009
n = length of label
for i = 1 through n:
    h = hash of i'th element of label
    hash = ( hash * ( 65599 ** 10 ) ) + h
if hash = 0, then hash = 2**32 - 1
\end{verbatim}\end{indpar}

Comparing this with the hash algorithm for strings
on \pagref{HASH-ALGORITHM}, one sees that as long as
label elements are numbers and strings of fewer than 10 characters,
the hash of a label is equivalent to the hash of the
string made by concatenating a prefix and then the label elements, where each
string of fewer than 10 characters is padded to 10 characters
by prefacing it with NUL characters.  Note that
numbers are treated as 8 character strings; see
\pagref{NUMBER-HASH-ALGORITHM}.  The prefix is any 10 character string with
hash value {\tt 1009}.

Although label values are generally read using lab pointers,
a label value may be read by the protected functions:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   const min::stub * s )|
	  \end{tabular}
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   min::gen v )|
	  \end{tabular}
\LABEL{MIN::LAB_OF_GEN} \\
\end{tabular}\end{indpar}

These read an initial segment of the label vector into the location
addressed by {\tt p}.  If the label vector has {\tt n} or more elements,
the first {\tt n} elements are read.  Otherwise, as many elements as
the label vector has are read.  The number of elements read is returned
in any case.  The label can be denoted by either its stub address or
by a general value pointing at its stub address.

A label may be created by the following protected function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}%
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\end{tabular}\end{indpar}

Here {\tt p} must point to a vector of {\tt n} \verb|min::gen|
values that becomes the value vector of the label.  Each
\verb|min::gen| value must be a name component.
This function returns any existing label with elements equal to
those given by the function arguments, in preference to creating a new
label.  Thus two \verb|min::gen| label values with equal elements are
\verb|==|.

The following function returns true if and only if its argument is
a label:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_lab}\verb| ( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\end{tabular}\end{indpar}

The following unprotected constructors are just like their
protected versions except that they assume any \verb|min::gen|
value \verb|v| or \verb|min::stub *| value \verb|s| is a label:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_pointer}%
	  \verb| labp ( min::gen v )|
\LABEL{MUP::LAB_POINTER_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_pointer}%
	  \verb| labp ( min::stub * s )|
\LABEL{MUP::LAB_POINTER_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_pointer}%
	  \verb| labp ( void )|
\LABEL{MUP::LAB_POINTER_OF_VOID} \\
\end{tabular}\end{indpar}

The \verb|min::initialize| function applied to these unprotected
pointers also makes the same assumption.

\subsection{Names}
\label{NAMES}

A \key{name} is a
number (\secref{NUMBERS}),
string (\secref{STRINGS}),
or label (\secref{LABELS}), i.e., it is an atom or a label.
A name can also be viewed as
a sequence of \skey{name component}s, each of which is a number, string,
or label.
Names and name components are all immutable values which have an associated
hash value.

A number or string is used to represent a 1-component name whose
only component is the number or string.  Other names are represented
by labels whose elements are the components of the names.  A label whose
only component is a number or string is \underline{not}
used to represent a name, in order to ensure that each name has a unique
representation.

The following functions concern names:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{is\_name}\verb| ( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash}\verb| ( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare}\verb| ( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\end{tabular}\end{indpar}

The \verb|min::is_name| function returns true if and only if its argument is
a name (number, string, or label).

The \verb|min::hash| function returns a non-zero
\key{hash value}\label{HASH-VALUE} of its argument, which must be
a name.

The \verb|min::compare| function returns an integer $<0$, $=0$, or $>0$
according to whether its \verb|v1| argument is less than, equal to, or
greater than its \verb|v2| argument.
In this ordering numbers are
before strings, strings are before labels, and labels are before
any non-name values.  Numbers are ordered
numerically, strings are ordered lexicographically as per the
C language \verb|strcmp| function, and labels are ordered lexicographically
using the {\tt min::\EOL compare} function recursively to compare
label elements.  Non-name values are ordered by converting their
\verb|min::gen| values to bit strings and comparing the bit strings.
This means that \verb|min::gen| values that point at stubs are ordered
according to their stub addresses.

It is an error to pass a non-name argument to
either the \verb|min::hash| and \verb|min::compare| function.


\subsection{Printing General Values}
\label{PRINTING-GENERAL-VALUES}

A \verb|min::gen| value may be printed using the following:

\begin{indpar}[1em]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{pr}\\&{\tt ~~}
    \verb| ( min::gen v,|\\&{\tt ~~}
    \verb|   min::pr_format & f = min::default_pr_format )|
\LABEL{MIN::PR} \\
\verb|std::ostream & |
    & \TTKEY{operator \LESSTHAN\LESSTHAN}\\&{\tt ~~}
      \verb| ( std ostream & out, min::pr & prv )|
\LABEL{OPERATOR<<_OF_PR} \\[2ex]
\verb|struct min::| & \MINKEY{pr\_format}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const char * number_format;|\ARGBREAK
    \verb|  const char * str_prefix;|\ARGBREAK
    \verb|  const char * str_postfix;|\ARGBREAK
    \verb|  const char * lab_prefix;|\ARGBREAK
    \verb|  const char * lab_postfix;|\ARGBREAK
    \verb|  const char * special_prefix;|\ARGBREAK
    \verb|  const char * special_postfix;|\ARGBREAK
    \verb|  std::ostream & ( * pr_stub )|\ARGBREAK
    \verb|       ( std::ostream & out,|\ARGBREAK
    \verb|         const min::stub * s );|\ARGBREAK
    \verb|};|
\ttmindex{number\_format}{in {\tt min::pr\_format}}
\ttmindex{str\_prefix}{in {\tt min::pr\_format}}
\ttmindex{str\_postfix}{in {\tt min::pr\_format}}
\ttmindex{lab\_prefix}{in {\tt min::pr\_format}}
\ttmindex{lab\_postfix}{in {\tt min::pr\_format}}
\ttmindex{special\_prefix}{in {\tt min::pr\_format}}
\ttmindex{special\_postfix}{in {\tt min::pr\_format}}
\ttmindex{pr\_stub}{in {\tt min::pr\_format}}
\LABEL{MIN::PR_FORMAT} \\[2ex]
\verb|struct min::| & \MINKEY{default\_pr\_format}\verb| =|\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  "%.15g",     // number_format|\ARGBREAK
    \verb|  "`","'",     // str_prefix/postfix|\ARGBREAK
    \verb|  "[","]",     // lab_prefix/postfix|\ARGBREAK
    \verb|  "","",       // special_prefix/postfix|\ARGBREAK
    \verb|  NULL         // pr_stub|\ARGBREAK
    \verb|};|
\end{tabular}\end{indpar}

An example use is:
\begin{indpar}\begin{verbatim}
min::gen v = . . .
std::cout << "V = " << min::pr ( v ) << std::endl;
\end{verbatim}\end{indpar}\label{PR-EXAMPLE}

which prints the \verb|min::gen| value \verb|v| on a line
prefaced with `\verb|V = |'.

Printing is controlled by the \verb|min::pr_format| value.

Numbers are treated as \verb|min::float64| values printed according
to the {\tt prv.number\_\EOL format} value as interpreted by the
C \verb|sprintf| function.  The default uses \verb|%.15g|
to print 15 significant
digits with low order fraction \verb|0|'s omitted and exponential
notation used if there would be more than 15 integer digits.

Strings are printed as they are immediately preceded by
{\tt prv.str\_\EOL prefix} and followed by
{\tt prv.str\_\EOL postfix}.  The default is to enclose strings in
\verb|`'| quotes.

Labels are printed as comma separated lists of their elements preceded by
{\tt prv.lab\_\EOL prefix} and followed by
{\tt prv.lab\_\EOL postfix}.  The default is to enclose labels in
\verb|[ ]| brackets.

Special values \verb|min:XXXX| are printed as \verb|XXXX|
preceded by {\tt prv.special\_\EOL prefix} and followed by
{\tt prv.special\_\EOL postfix}.  The default is not to have any prefix
or postfix for special values.  For example, \verb|min::MISSING| prints
as just \verb|MISSING|.

Stubs other than numbers, strings, and labels
are printed as their stub type name followed by whatever
the {\tt prv.pr\_\EOL stub} function prints, if that function is
not \verb|NULL|.  The default is to just print the type name.
For example, a short object will print as just \verb|SHORT_OBJ|.

Auxiliary and index values print as the name of the value subtype followed
by the value index in parentheses.  Control codes are similar
but the control code value is printed in hexadecimal (preceded by
\verb|0x|).  Examples are \verb|LIST_AUX(35)| and
\verb|CONTROL_CODE(0x10)|.

Otherwise unrecognized values are printed as \verb|UNDEFINED_GEN| followed
by the \verb|min::gen| value viewed as a \verb|min::unsgen| value
printed in hexadecimal (prefaced by \verb|0x|) and surrounded with
parentheses.  For example, \verb|UNDEFINED_GEN(0xf4000000)|.


\subsection{Objects}
\label{OBJECTS}

An \key{object} is conceptually a hash table that maps
\skey{attribute name}s to \skey{attribute value}s.
An attribute name is a sequence of name components, which
are numbers, strings, and labels.
The part of the hash table that maps attribute names that are equal to
or begin with small unsigned integers is actually a vector.
An attribute value is a \verb|min::gen| datum.

Each map of an attribute name to an attribute value represents an
arrow in the data base.  Some arrows can be double arrows pointing
both to and from another object.
If the arrow is a double arrow,
a reverse direction label, called the \key{reverse attribute name}
is attached to the arrow, and the object at the other end of the
arrow has the same arrow but with directions and direction names reversed.

There can be several arrows with the same attribute name,
and even several arrows with both the same attribute name and the
same value.
There can be several double arrows with the same attribute name and
the same reverse attribute name, and even several double arrows with
the same names and target object.

Therefore an attribute name and reverse attribute name together name a
multi-set of values, where the reverse attribute name can be missing to
indicate that only single arrows are to be considered, and is present to
indicate that only double arrows are to be considered.
For single arrows the values are any \verb|min::gen| values, but for
double arrows the values are always other objects.
It is possible to add a value to one of these multi-sets
or delete a value from a
multi-set.  It is possible to delete an entire multi-set.
It is possible to treat a multi-set as a set, by adding a value
to it only if the value does not already occur in the multi-set.
When testing for value equality, {\tt ==} is normally used, as this tests for
equality of both name components and objects.

Flags, called \key{attribute flags}, can be attached to an attribute name.
Note that flags are attached to object attribute names, and not to arrows,
values, or reverse attribute names.

There are also typed objects, each of which is a pair of objects,
one called the type that is constant, is shared among many typed objects,
and contains attribute labels, and one called the
context, which contains a vector of \skey{variable}s that hold attribute
values.  Typed objects are described in more detail in
\secref{TYPED-OBJECTS}.

An object has a body that consists of the following 6 parts in
the order given:

\begin{center}
\begin{tabular}{l}
header \\
variable vector \\
hash table \\
attribute vector \\
unused area\\
auxiliary area
\end{tabular}
\end{center}

The \mkey{header}{of object} contains object flags
(including {\tt min::OBJ\_\EOL PRIVATE}, {\tt min::OBJ\_\EOL PUBLIC},
and {\tt min::OBJ\_\EOL TYPED})
and the sizes of the other 5 parts.
The \mkey{variable vector}{of object} stores the object's variables.
The \mkey{hash table}{of object}
stores attribute name/value pairs, for attributes whose names do not
begin with small unsigned integers.
The \mkey{attribute vector}{of object} stores attribute values
for attributes whose names begin with small unsigned integers.
The \mkey{auxiliary area}{of object}
stores elements of lists headed by hash table and attribute vector
elements, and any other data that would overflow a single
\verb|min::gen| value.
The \mkey{unused area}{of object}
provides for growth of the attribute vector and auxiliary area.

The variable vector and hash table are of fixed size;
their size can only be changed by resizing, reorganizing, and often relocating
the object body.  The attribute vector
grows up from the end of the hash table into the unused
area, and the auxiliary storage grows down from the end of the body into
the unused area.

A variable vector, hash table, and attribute vector element is accessed
using an index relative to the beginning of the vector or table that
contains the element.  Auxiliary area elements are accessed by
\skey{auxiliary pointer}s\label{OBJECT-BODY-AUXILIARY-POINTER}
that give the index of the element relative to the end of the
object body.  Auxiliary pointers with zero index do not address
a body vector element.
For more details see the {\tt var/\EOL hash/\EOL attr/\EOL aux}
functions on \pagref{MIN::VAR_OF_VEC_POINTER}, and their equivalents on
\pagref{OBJECT-VECTOR-EQUIVALENTS}.

An object may be grown or compacted by relocating and reorganizing its body.
It may be
grown to expand its unused area or hash table, or, less commonly,
its variable vector.  An object may be compacted to eliminate, or less
commonly to shrink, its unused area, and possibly to shrink its hash
table.

There are two kinds of objects: short and long.  A \key{short object}
has an 8 byte header that stores 16 bit unsigned sizes.
A \key{long object}
has a 16 byte header that stores 32 bit unsigned sizes.
Otherwise there is
no essential difference between a short and a long object.%
\footnote{Provision is made to permit future implement of two
additional kinds of objects, a \key{tiny object} with 4 byte header
and 8 bit unsigned sizes that can only be implemented for
compact implementations with 32 bit {\tt min::gen} values because
otherwise the header size would a 1/2, and
a \key{huge object}\label{HUGE_OBJECT}
with 32 byte header and 64 bit unsigned sizes that
can only be implemented for loose implementations with 64 bit
{\tt min::gen} values because otherwise auxiliary pointers would not
be able to point into the auxiliary area.}

An object body may be \smkey{relocate}d{object body}, which means the
body is simply copied to a new address, or
\smkey{reorganize}d{object body}, which means the object body is reformatted,
and possibly converted from short to long or vice versa.  Frequently an
object whose attribute labels and number of values for each label are no
longer subject to change will be compacted, to make it as small as possible,
and this is one kind of object body reorganization.
Objects are compacted by the `{\tt min::\EOL publish\REL}'
function that sets the
object {\tt OBJ\_\EOL PUBLISH} flag which prevents changes to the
attribute labels, attribute label flags, and number of attribute values
of an object.
Reorganization can also occur whenever an object is relocated,
provided that the {\tt OBJ\_\EOL PRIVATE} and
{\tt OBJ\_\EOL PUBLIC} object flags are not set.

The data structure of an object body can be viewed at any of three levels:
vector level (\secref{OBJECT-VECTOR-LEVEL}),
list level (\secref{OBJECT-LIST-LEVEL}),
and attribute level (\secref{OBJECT-ATTRIBUTE-LEVEL}).
The interfaces to all of these levels is protected.  In addition
there is an unprotected vector level interface
(\secref{OBJECT-UNPROTECTED-VECTOR-LEVEL}) and a
typed object interface (\secref{TYPED-OBJECTS}).

\subsubsection{Object Creation}
\label{OBJECT-CREATION}

An object header encodes the variables vector size,
hash table size, and total size of the object
indirectly using a logarithmic or pseudo-floating-point code.
Therefore not every variables vector size,
hash table size, or total size is supported.
In order to create an object it is necessary to determine possible
variable vector, hash table, and total sizes.

Note that all sizes are in \verb|min::gen| units.

The following functions return the smallest
possible size equal to or greater than the function argument,
\underline{unless} all possible sizes are less than the function argument,
in which case the largest possible size is returned.  The caller of
one of these functions must check the returned value to be sure it is
as large as the function argument.

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
    & \MINKEY{obj\_var\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_VAR_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_hash\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_HASH_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_total\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_TOTAL_SIZE} \\
\end{tabular}\end{indpar}

Maximum possible total, hash table, and variables vector
size values can be determined
by presenting these functions with the \verb|u| argument value
`\verb|min::unsptr(-1)|'.

All power of two sizes not larger than the maximum sizes are
supported.  In particular, hash table sizes that are powers
of two are supported, so hash values can be mapped to
hash table indices by simple masking.

An object can be created by the protected function:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}%
    \begin{tabular}[t]{@{}l@{}}
    \verb| ( min::unsptr unused_size,| \\
    \verb|   min::unsptr hash_size = 0,| \\
    \verb|   min::unsptr variable_size = 0 )| \\
    \end{tabular}
\LABEL{MIN::NEW_OBJ_GEN} \\
\end{tabular}\end{indpar}

The variables vector size of the returned object is the smallest possible
variables vector size that is at least as large as that given.
The hash table size of the returned object is the smallest possible
hash table size that is at least as large as that given.  The total
size of the returned object is the smallest possible total size
that is at least as large as the sum of
the actual variables vector size, the actual hash table size,
the unused area size given, and the header size.
Then the actual unused size is set by subtracting the other sizes from
the total size; this actual size is never smaller than the given size.
Note that if the given sizes of the variables vector and hash table
are powers of two
not greater than the maximums allowed, the corresponding actual sizes will
be equal to the given sizes.

The returned object is short if the given sizes are small enough.
Otherwise the object is long.
It is a fatal programming error if no possible hash table or total size
is large enough, but this is unlikely, given the large sizes allowed
by a long object.

The sizes allowed for short and long objects are implementation dependent.
The maximum sizes are available as the value of the following:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::unsptr min::| & \MINNBKEY{SHORT\_OBJ\_MAX\_VAR\_SIZE}
\LABEL{MIN::SHORT_OBJ_MAX_VAR_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{SHORT\_OBJ\_MAX\_HASH\_SIZE}
\LABEL{MIN::SHORT_OBJ_MAX_HASH_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{SHORT\_OBJ\_MAX\_TOTAL\_SIZE}
\LABEL{MIN::SHORT_OBJ_MAX_TOTAL_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{LONG\_OBJ\_MAX\_VAR\_SIZE}
\LABEL{MIN::LONG_OBJ_MAX_VAR_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{LONG\_OBJ\_MAX\_HASH\_SIZE}
\LABEL{MIN::LONG_OBJ_MAX_HASH_SIZE} \\
\verb|const min::unsptr min::| & \MINNBKEY{LONG\_OBJ\_MAX\_TOTAL\_SIZE}
\LABEL{MIN::LONG_OBJ_MAX_TOTAL_SIZE} \\
\end{tabular}\end{indpar}

{\tt MIN::LONG\_OBJ\_MAX\_TOTAL\_SIZE} is $2^{24}$ for a compact implementation
(as auxiliary pointers are 24 bits)
and $2^{32}$ for a loose implementation (as long object headers store at most
32 bit unused and auxiliary area offsets).%
\footnote{{\tt MIN::LONG\_OBJ\_MAX\_TOTAL\_SIZE} could be $2^{40}$ for
a loose implementation with 40 bit auxiliary pointers if
huge objects were implemented (\pagref{HUGE_OBJECT}).}
{\tt MIN::SHORT\_OBJ\_MAX\_TOTAL\_SIZE} is typically $2^{12}$ as having a
smaller header is not important for larger sizes and the left over header bits
are needed for flags.

The hash table of the returned object is filled with \verb|min::LIST_END|
values (\pagref{MIN::LIST_END}), and is therefore an empty hash table.
The variables vector is filled with \verb|min::UNDEFINED| values.
Unused area elements are initialized to some implementation defined
value like \verb|0| or \verb|min::NONE|.
The attribute vector and auxiliary areas of the returned object are
zero length, and all space not used by the header, hash table, and
variables vector is allocated to the unused area.
The attribute vector and auxiliary area can be
filled by `push' instructions described below
(\pagref{OBJECT_PUSH_FUNCTIONS}).

\subsubsection{Object Vector Level}
\label{OBJECT-VECTOR-LEVEL}

At the \key{vector level}, the object body is viewed as
a \key{body vector} of \verb|min::gen| values.
The entire body vector, except
for the header, consists of \verb|min::gen| elements of the
body vector.
A \key{body vector index} is an index of an element in this vector,
and ranges from 0
to one less than the total size of the object, which is the size of
the body vector.  The index 0 cannot be used, as it corresponds to the
header, which does not contain \verb|min::gen| values.
It can be used as a form of null pointer.

An auxiliary pointer index \verb|i| corresponds to the
body vector index \verb|total_size - i|, so \verb|i=1| corresponds
to the last element of the auxiliary area.
The 0 auxiliary pointer index corresponds to the location just
beyond the body vector and is not
usable as the index of auxiliary area element, so it
can also be used as a form of null pointer.

There are three kinds of vector level protected object pointers.
A read-only {\tt min::\EOL vec\_\EOL pointer} permits read-only access to body
vector elements.
A read-write or updatable
{\tt min::\EOL updatable\_\EOL vec\_\EOL pointer}
permits read-write access to body vector elements,
but does not permit pushing or popping elements from the
object's attribute vector or auxiliary area.
An insertable {\tt min::\EOL insertable\_\EOL vec\_\EOL pointer}
does permit these pushes and pops, in addition to permitting
read-write access to body vector elements.

An object has two flags that regulate the creation of vector level
pointers: \minnbkey{OBJ\_PRIVATE} and \minnbkey{OBJ\_PUBLIC}.
If an object has neither of these flags, an object vector pointer
to the object may be created, and this will set the \verb|min::OBJ_PRIVATE|
flag.  When the object vector pointer is destructed, this flag will be cleared.
While this flag is set, no other vector pointer to the object may be
created.  The object is therefore private to the code possessing the
vector pointer.

If an object has neither flag, its \verb|min::OBJ_PUBLIC| flag may be set
by calling the `{\tt min::\EOL publish\REL}' function
(\pagref{MIN::PUBLISH}).
When this is set, any number of read-only and read-write (updatable) vector
pointers to the object may be created, but no insertable vector pointers
to the object may be created.  Constructing and destructing
pointers in this case does not set or clear object flags.
The \verb|min::OBJ_PUBLIC| flag may not be cleared by
protected functions.  The idea here is that setting the \verb|min::OBJ_PUBLIC|
flag fixes the attribute label structure of the object, the flags attached
to attribute labels, and the size of
the value multiset of each attribute, but permits the existing values of an
attribute to be read or written.  This permits read-only and limited
read-write sharing of the object.

Note that object bodies can be relocated whenever a
relocating function (\pagref{RELOCATING-FUNCTIONS}) is called.
However object bodies may be reorganized by a relocating
function only if neither the
\verb|min::OBJ_PRIVATE| or \verb|min::OBJ_PUBLIC| flags are set.
Object bodies may also be reorganization when insertions are made
using the {\tt min::\EOL insert\_\EOL reserve\REL} function
(\pagref{MIN::INSERT_RESERVE}) on an insertable pointer,
or when the {\tt min::\EOL OBJ\_\EOL PUBLIC} flag is set on an object
by the {\tt min::\EOL publish\REL} function (\pagref{MIN::PUBLISH}).

\subsubsubsection{Protected Object Vector Pointers}
\label{PROTECTED-OBJECT-VECTOR-POINTERS}

A read-only \minkey{vec\_\EOL pointer}
to the body vector of an object with stub \verb|s| or with
general value \verb|v| pointing to its stub
may be created by the following functions:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{vec\_pointer}\verb| vp ( min::gen v )|
\LABEL{MIN::VEC_POINTER_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{vec\_pointer}%
       \verb| vp ( const min::stub * s )|
\LABEL{MIN::VEC_POINTER_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{vec\_pointer}%
       \verb| vp ( void )|
\LABEL{MIN::VEC_POINTER_OF_VOID} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|void min::|
    & \MINKEY{initialize}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::vec_pointer & vp,| \\
      \verb|   min::gen v )| \\
      \end{tabular}
\LABEL{MIN::INIT_OF_VEC_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::vec_pointer & vp,| \\
      \verb|   const min::stub * s )| \\
      \end{tabular}
\LABEL{MIN::INIT_OF_VEC_POINTER_OF_STUB} \\
\verb|void min::|
    & \MINKEY{deinitialize} \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::DEINIT_OF_VEC_POINTER_OF_STUB} \\
\end{tabular}\end{indpar}

The constructors point the new vector pointer at an object designated
by a \verb|min::gen| value or \verb|min::stub *| pointer, or in the
case of the constructor with no argument, leave the vector pointer
unpointed at any object.  In this last case the vector pointer must
be initialized by a {\tt min::\EOL initialize} function before it is
used; use before initialization will give undefined results, though
access to object elements will usually result in a memory
fault.

The {\tt min::initialize} functions destruct the vector pointer and then
reconstruct it.  The {\tt min::\EOL deinitialize} function destructs
the vector pointer and leaves it not pointing at any object stub.
Use of such a destructed pointer is undefined, but attempts to access
object elements usually result in memory faults.

The following protected functions may be used to discover information
about the object pointed at by a read-only {\tt min::vec\_pointer}:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|const min::stub * min::| & \MINKEY{stub\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::STUB_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{var\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::VAR_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::HASH_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::ATTR_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::AUX_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_VEC_POINTER} \\

\end{tabular}\end{indpar}\label{OBJECT_SIZE_FUNCTIONS}

Here the sizes are in \verb|min::gen| units.  When an object
body is reorganized, some of these sizes may change, but simply
relocating the object body does not change these sizes.

The following functions can be used for \underline{read-only}
access to object elements:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::gen | & \MINKEY{var}%
    \verb| ( min::vec_pointer & vp, min::unsptr index )|
\LABEL{MIN::VAR_OF_VEC_POINTER} \\
\verb|min::gen | & \MINKEY{hash}%
    \verb| ( min::vec_pointer & vp, min::unsptr index )|
\LABEL{MIN::HASH_OF_VEC_POINTER} \\
\verb|min::gen | & \MINKEY{attr}%
    \verb| ( min::vec_pointer & vp, min::unsptr index )|
\LABEL{MIN::ATTR_OF_VEC_POINTER} \\
\verb|min::gen | & \MINKEY{aux}%
    \verb| ( min::vec_pointer & vp, min::unsptr aux_pointer )|
\LABEL{MIN::AUX_OF_VEC_POINTER} \\

\end{tabular}\end{indpar}

Given a vector pointer \verb|vp|, \verb|min::var(vp,i)| can be used
to read the \verb|i+1|'st variable in the object pointed at
by \verb|vp|, for $0\leq i<\mbox{\tt min::var\_size\_of(vp)}$.
Similarly, \verb|min::hash(vp,i)| can be used
to read the \verb|i+1|'st hash table entry
for $0\leq i<\mbox{\tt min::hash\_size\_of(vp)}$,
\verb|min::attr(vp,i)| can be used
to read the \verb|i+1|'st attribute vector entry
for $0\leq i<\mbox{\tt min::attr\_size\_of(vp)}$.
\verb|min::aux(vp,p)| differs slightly in that it reads
the \verb|i|'th auxiliary area element ordering the
elements from the end of the auxiliary area to its beginning,
for $1\leq i\leq\mbox{\tt min::attr\_size\_of(vp)}$.
Auxiliary area indices are defined in this manner
so that an object body may be resized by simply
expanding or contracting its unused area, without modifying
the contents of the other parts of the object body.

A \minkey{updatable\_vec\_pointer} is like a \verb|min::vec_pointer|
but has additional functions which support writing object body vector
elements.  The additional functions for this type of pointer are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{updatable\_vec\_pointer}%
    \verb| vp ( min::gen v )|
\LABEL{MIN::UPDATABLE_VEC_POINTER_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{updatable\_vec\_pointer}%
    \verb| vp ( min::stub * s )|
\LABEL{MIN::UPDATABLE_VEC_POINTER_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{updatable\_vec\_pointer}%
    \verb| vp ( void )|
\LABEL{MIN::UPDATABLE_VEC_POINTER_OF_VOID} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{initialize}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::updatable_vec_pointer & vp,| \\
      \verb|   min::gen v )| \\
      \end{tabular}
\LABEL{MIN::INIT_OF_UPDATABLE_VEC_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::updatable_vec_pointer & vp,| \\
      \verb|   min::stub * s )| \\
      \end{tabular}
\LABEL{MIN::INIT_OF_UPDATABLE_VEC_POINTER_OF_STUB} \\
\verb|void min::|
    & \MINKEY{deinitialize}%
      \verb| ( min::updatable_vec_pointer & vp )|
\LABEL{MIN::DEINIT_OF_UPDATABLE_VEC_POINTER_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|void min::| & \MINKEY{set\_var}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::updatable_vec_pointer & vp,| \\
      \verb|   min::unsptr index,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_VAR_OF_UPDATABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{set\_hash}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::updatable_vec_pointer & vp,| \\
      \verb|   min::unsptr index,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_HASH_OF_UPDATABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{set\_attr}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::updatable_vec_pointer & vp,| \\
      \verb|   min::unsptr index,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_ATTR_OF_UPDATABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{set\_aux}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::updatable_vec_pointer & vp,| \\
      \verb|   min::unsptr aux_pointer,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::SET_AUX_OF_UPDATABLE_VEC_POINTER} \\

\end{tabular}\end{indpar}

A {\tt min::set\_var/\EOL hash/\EOL attr/\EOL aux}
function writes its \verb|min::gen|
value argument into the same body vector element as is read by the
corresponding {\tt min::\EOL var/\EOL hash/\EOL attr/\EOL aux} function.
The set function invokes the
{\tt min::\EOL acc\_\EOL write\_\EOL update}
Accumu\-la\-tor/\EOL Col\-lec\-tor/\EOL Com\-pac\-tor function
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}) that must
be called when a \verb|min::gen| value is written into an object.

A {\tt min::\EOL updatable\_\EOL vec\_\EOL pointer} may be automatically
downcast to a {\tt min::\EOL vec\_\EOL pointer}.  This means that
all the non-constructor functions applicable to
{\tt min::\EOL vec\_\EOL pointer}'s
are applicable to
{\tt min::\EOL updatable\_\EOL vec\_\EOL pointer}'s.
Exceptions are destructors, the {\tt min::\EOL ini\-tial\-ize}
functions, and the {\tt min::\EOL de\-ini\-tial\-ize} functions, which
will suffer a {\tt MIN\_\EOL ASSERT} error if applied to a
downcast object vector pointer.

A \minkey{insertable\_vec\_pointer} is like a
{\tt min::updatable\_\EOL vec\_\EOL pointer}
but has additional functions which support pushing or popping elements
from the end of the object body attribute vector or the beginning
of the object body auxiliary area and resizing the unused area and
variables vector portions of the object body.
The additional functions for this type of pointer are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|(constructor) min::| & \MINKEY{insertable\_vec\_pointer}%
    \verb| vp ( min::gen v )|
\LABEL{MIN::INSERTABLE_VEC_POINTER_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{insertable\_vec\_pointer}%
    \verb| vp ( min::stub * s )|
\LABEL{MIN::INSERTABLE_VEC_POINTER_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{insertable\_vec\_pointer}%
    \verb| vp ( void )|
\LABEL{MIN::INSERTABLE_VEC_POINTER_OF_VOID} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}
\verb|void min::|
    & \MINKEY{initialize}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::gen v )| \\
      \end{tabular}
\LABEL{MIN::INIT_OF_INSERTABLE_VEC_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::stub * s )| \\
      \end{tabular}
\LABEL{MIN::INIT_OF_INSERTABLE_VEC_POINTER_OF_STUB} \\
\verb|void min::|
    & \MINKEY{deinitialize}%
      \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MIN::DEINIT_OF_INSERTABLE_VEC_POINTER_OF_STUB} \\
\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|void min::| & \MINKEY{attr\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::ATTR_PUSH_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{attr\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   const min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\

\verb|void min::| & \MINKEY{aux\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::gen value )| \\
      \end{tabular}
\LABEL{MIN::AUX_PUSH_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{aux\_push}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   const min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\

\end{tabular}\end{indpar}\label{OBJECT_PUSH_FUNCTIONS}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|void min::| & \MINKEY{attr\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::gen & value )| \\
      \end{tabular}
\LABEL{MIN::ATTR_POP_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{attr\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\

\verb|void min::| & \MINKEY{aux\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::gen & value )| \\
      \end{tabular}
\LABEL{MIN::AUX_POP_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{aux\_pop}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::gen * p, min::unsptr n )| \\
      \end{tabular}
\LABEL{MIN::AUX_POP_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|bool min::| & \MINKEY{resize\REL}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::unsptr unused_size )| \\
      \end{tabular}
\LABEL{MIN::RESIZE_UNUSED_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{resize\REL}%
      \begin{tabular}[t]{@{}l@{}}
      \verb| ( min::insertable_vec_pointer & vp,| \\
      \verb|   min::unsptr unused_size,| \\
      \verb|   min::unsptr var_size )| \\
      \end{tabular}
\LABEL{MIN::RESIZE_UNUSED_AND_VAR_OF_INSERTABLE_VEC_POINTER} \\

\end{tabular}\end{indpar}

The push functions push values to the end of the attribute vector
and the beginning of the unused area.  The pop functions pop values
from the end of the attribute vector and the beginning of the unused
area.

There are two versions of each push or pop: one that
handles a single {\tt min::gen} value, and one that handles
{\tt n} values stored in a C/C++ vector pointed at by {\tt p}.
These latter push and pop functions preserve the order of the values in memory,
so \verb|p[0]| is pushed into or popped from a body vector location immediately
before the location into which \verb|p[1]| is pushed into or popped from, etc.
Thus the attribute vector push function pushes
in the order \verb|p[0]|, \verb|p[1]|, \verb|p[2]|, \ldots; while the
auxiliary vector push function pushes
in the order \verb|p[n-1]|, \verb|p[n-2]|, \verb|p[n-3]|, \ldots.
The order of the elements of {\tt p} in memory is the same
as the order of the elements in the object body.

The push functions fail (via \verb|MIN_ASSERT|) if the unused
area size is smaller
than the number of {\tt min::gen} values being pushed.
The size of the unused area can be determined by the
\verb|min::unused_size_of| function
(\pagref{MIN::UNUSED_SIZE_OF_VEC_POINTER}).
These push functions invoke the
{\tt min::\EOL acc\_\EOL write\_\EOL update}
Accumu\-la\-tor/\EOL Col\-lec\-tor/\EOL Com\-pac\-tor function
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}) that must
be called when a \verb|min::gen| value is written into an object.

The {\tt min::resize\REL} functions change the size of the unused
area and variables vector.  The sizes can be either increased or
decreased.  Elements added to the variables vector are added to
its end and initialized with the value {\tt min::\EOL UNDEFINED}.
The object body may be relocated by these functions in order to
resize it, and may be converted from a short object to a long
object or vice versa.  The sizes of the attribute vector and
auxiliary area are not changed, but can be changed by later pushes
and pops.
No change is made to object contents outside the unused
area, whose elements are reinitialized to some implementation defined
value like \verb|0| or \verb|min::NONE|.

The {\tt min::resize\REL} functions return \verb|true| if they
relocate the object's body, and \verb|false| if they do not.
They set the relocated flag (\pagref{RELOCATED-FLAG}) if they
relocate any \underline{other} body, but not if they just relocate
the body being resized.

It is \underline{not}
possible to resize the hash table with these functions because
this involves moving data from a hash table entry with a given index
to another hash table entry with a different index, and the vector level
does not have enough information to do this.  The hash table can be
resized at the
attribute level (\pagref{MIN::RESIZE_OF_ATTR}).

A {\tt min::\EOL insertable\_\EOL vec\_\EOL pointer} may be automatically
downcast to either a {\tt min::\EOL up\-datable\_\EOL vec\_\EOL pointer}
or a {\tt min::\EOL vec\_\EOL pointer}.  This means that
all the non-constructor functions applicable to
{\tt min::\EOL updatable\_\EOL vec\_\EOL pointer}'s or
{\tt min::\EOL vec\_\EOL pointer}'s are applicable to
{\tt min::\EOL insertable\_\EOL vec\_\EOL pointer}'s.
Exceptions are destructors, the {\tt min::\EOL ini\-tial\-ize}
functions, and the {\tt min::\EOL de\-ini\-tial\-ize} functions, which
will suffer a {\tt MIN\_\EOL ASSERT} error if applied to a
downcast object vector pointer.

\subsubsubsection{Unprotected Object Vector Level}
\label{OBJECT-UNPROTECTED-VECTOR-LEVEL}

Using unprotected functions, an object body can be treated
as a simple C/C++ vector of {\tt min::gen} values.  The
required functions are:

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|const min::gen * & MUP::| & \MUPKEY{base}%
    \verb| ( min::vec_pointer & v )|
\LABEL{MUP::BASE_OF_VEC_POINTER} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}%
    \verb| ( min::updatable_vec_pointer & v )|
\LABEL{MUP::BASE_OF_UPDATABLE_VEC_POINTER} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::vec_pointer & vp )|
\LABEL{MUP::STUB_OF_VEC_POINTER} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::VAR_OFFSET_OF_VEC_POINTER} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_VEC_POINTER} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_POINTER} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_POINTER} \\

\end{tabular}\end{indpar}

\begin{indpar}[0.2in]\begin{tabular}{r@{}l}

\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_INSERTABLE_VEC_POINTER} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MUP::AUX_OFFSET_OF_INSERTABLE_VEC_POINTER} \\

\end{tabular}\end{indpar}

The offset values returned by the above are those of the
variable vector({\tt var}), hash table({\tt hash}),
attribute vector({\tt attr}), unused area ({\tt unused}), 
and auxiliary area({\tt aux}).  These offsets are in \verb|min::gen|
units, and these offsets and the sizes returned by the functions
on page \pagref{OBJECT_SIZE_FUNCTIONS} are related by

\begin{center}
\begin{tabular}{rcl}
variable vector offset	& = & header size \\
hash table offset       & = & variable vector offset + variable vector size \\
attribute vector offset & = & hash table offset + hash table size \\
unused area offset      & = & attribute vector offset + attribute vector size \\
auxiliary area offset   & = & unused area offset + unused area size \\
total size              & = & auxiliary area offset + auxiliary area size \\
\end{tabular}
\end{center}

Note that when an object is reorganized all these values may
change, including the header size.

Note that the {\tt min::\EOL unused\_\EOL offset\_\EOL of} and
{\tt min::\EOL aux\_\EOL offset\_\EOL of} functions for a
{\tt min::\EOL insertable\_\EOL vector\_\EOL pointer} return an
lvalue.  For insertable pointers these offsets change when
values are pushed into or popped from the attribute vector or
auxiliary area.

The following are equivalences except for
the omission of {\tt MIN\_\EOL ASSERT} checks that the index \verb|i|
is not too large or two small (auxiliary area indices may not be 0),
checks that the unused area
is non-empty for pushes and that the attribute vector or auxiliary area
is non-empty for pops,
and calls to {\tt MUP::\EOL acc\_\EOL write\_\EOL update}
for set and push operations
(\pagref{MUP::ACC_WRITE_GEN_UPDATE}):

\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|var ( vp, i )| & $\equiv$
    & \verb|return base(vp)[var_offset_of(vp) + i]| \\
\verb|hash ( vp, i )| & $\equiv$
    & \verb|return base(vp)[hash_offset_of(vp) + i]| \\
\verb|attr ( vp, i )| & $\equiv$
    & \verb|return base(vp)[attr_offset_of(vp) + i]| \\
\verb|aux ( vp, i )| & $\equiv$
    & \verb|return base(vp)[total_size_of(vp) - i]| \\
\end{tabular}\end{indpar}\label{OBJECT-VECTOR-EQUIVALENTS}
\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|set_var ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[var_offset_of(vp) + i] = v| \\
\verb|set_hash ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[hash_offset_of(vp) + i] = v| \\
\verb|set_attr ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[attr_offset_of(vp) + i] = v| \\
\verb|set_aux ( vp, i, v )| & $\equiv$
    & \verb|base(vp)[total_size_of(vp) - i] = v| \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{rcl}
\hspace*{2.0in} \\[-3ex]
\verb|attr_push ( vp, v )| & $\equiv$
    & \verb|base(vp)[unused_offset_of(vp)++] = v| \\
\verb|attr_pop ( vp, v )| & $\equiv$
    & \verb|v = base(vp)[--unused_offset_of(vp)]| \\
\verb|aux_push ( vp, v )| & $\equiv$
    & \verb|base(vp)[--aux_offset_of(vp)] = v| \\
\verb|aux_pop ( vp, v )| & $\equiv$
    & \verb|v = base(vp)[aux_offset_of(vp)++]| \\
\end{tabular}\end{indpar}



Recall that there are two kinds of objects: short and long.
A \key{short object stub}\label{SHORT-OBJECT-STUB} is collectible, has
\minnbkey{SHORT\_OBJ}\LABEL{MIN::SHORT_OBJ} stub type code, and has
a value that is a pointer to a body with an 8 byte object header
that allows an object with total size up to $2^{16}$ \verb|min::gen|
values.
A \key{long object stub}\label{LONG-OBJECT-STUB} is collectible, has
\minnbkey{LONG\_OBJ}\LABEL{MIN::LONG_OBJ} stub type code, and has
a value that is a pointer to a body with a 16 byte object header
that allows an object with total size up to $2^{32}$ \verb|min::gen|
values.

The header is the only part of an object body that is
\underline{not} \verb|min::gen| values.  Even so it is
sized in \verb|min::gen| units; e.g., a short object header size
is {\tt 2} for a compact implementation and {\tt 1}
for a loose implementation (\pagref{COMPACT-OR-LOOSE}).

The header may contain implementation dependent information used
for optimization.  Most implementations do not store all the required
sizes directly.  For example, an implementation usually permits only
particular hash table sizes, and uses 7 bits for short objects
and 12 bits for long objects to encode a reference to a table
of hash table sizes.  Similarly and implementation typically stores
a total size as a 12 bits in a short object and as a 15 bit integer
mantissa and 5 bit exponent in a long object.
The {\tt min::\EOL OBJ\_\EOL PRIVATE},
{\tt min::\EOL OBJ\_\EOL PUBLIC},
and {\tt min::\EOL OBJ\_\EOL TYPED} flags are stored in bits made
available by these packed size encodings.
Additional implementation dependent
flags may be used to optimize garbage collection.
For example, objects which have auxiliary stubs
(\pagref{OBJECT-AUXILIARY-STUBS})
may be flagged, thereby identifying objects that need extra work
when deallocated or reorganized.

An implementation is not required to support all possible values of
the variables vector size, hash table size, or total size, but should support
values that permit objects that are read-only to be efficiently compacted.
Size values that are powers of two and not
greater than the maximum supported sizes must be supported.
Within the bounds set by these size values, arbitrary sizes
of the attribute vector, unused area, and auxiliary area must
be supported.



\subsubsection{Object List Level}
\label{OBJECT-LIST-LEVEL}

At the \key{list level},\label{LIST-LEVEL}
the body consists of two vectors whose
elements are lists.  The two vectors are the hash table, and the
attribute vector (the variable vector is ignored).
The elements of the lists are
\verb|min::gen| values other than the list or sublist auxiliary
pointers, and sublists.  The lists are constructed with
the help of the list and sublist auxiliary pointers:

\begin{center}
\begin{tabular}{lp{3in}}
\key{list auxiliary pointer} &
The list is continued at the target of the list auxiliary pointer.
\\[2ex]
\key{sublist auxiliary pointer}	&
A sublist starts at the target of the sublist auxiliary pointer.
\end{tabular}
\end{center}

Lists also make use of two constant values:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const min::gen min::}\MINKEY{LIST\_END}]~\LABEL{MIN::LIST_END}\\
The list ends here.
This actually equals a list auxiliary pointer with zero index.
\item[{\tt const min::gen min::}\MINKEY{EMPTY\_SUBLIST}]~%
	\LABEL{MIN::EMPTY_SUBLIST}\\
A list element value that represents an empty sublist.
This actually equals a sublist auxiliary pointer with zero index.
\end{list}
\end{indpar}

Each hash table or attribute vector element is a \key{list head}.
Each list head is a \key{list continuation}, which is an element of the
body vector that has a particular interpretation, described below.
However, not all list continuations are list heads.

A list continuation represents a final segment of a list.
If it has the value \verb|min::LIST_END|, the final segment is empty.
If the list continuation has a list auxiliary pointer value,
that pointer points at another list continuation that continues the list.
Otherwise the list continuation represents an element of the list,
and is called a \key{list element}.

A list element is an element of the list, and cannot be a list auxiliary
pointer or the special value \verb|min::LIST_END|.  But it can be
a sublist auxiliary pointer, or the special value \verb|min::EMPTY_SUBLIST|,
both of which denote a list element that is a sublist.

Given a list element, the rest of the list after the element begins with
a list continuation that has an index one less than that of the list
element within the object body vector, unless the list element is a
list head, in which case there is no next element, and the list has only
one element.  All list heads lie in the hash table or attribute vector,
so testing whether a list element is a list head can be done if just the
index of the list element in the body vector is known.

A list element
that is a sublist auxiliary pointer or the value \verb|min::EMPTY_SUBLIST|
represents a sublist, and is the \key{sublist head} of that sublist.  A
sublist head is a list element of the list containing a sublist,
but cannot be a list element of the sublist.
If it is a sublist auxiliary pointer,
it points at a list continuation of the sublist.  If it is the
value \verb|min::EMPTY_SUBLIST|, it represents an empty sublist.

There are several rules that the list level obeys that lead to
some efficiencies:

\begin{indpar}
{\bf No Superfluous {\tt \bf min::LIST\_END}'s}.%
\index{superfluous LIST_END@superfluous {\tt LIST\_END}}%
\label{NO-SUPERFLUOUS-LIST}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a \verb|min::LIST_END| value.

{\bf No Superfluous List Auxiliary Pointers}.%
\index{superfluous list auxiliary pointers}
A list or sublist auxiliary pointer may not point at an auxiliary
area element containing a list auxiliary pointer.

{\bf No List Sharing}.%
\index{list sharing}
Parts of lists may not be shared with other lists.  In other words,
there is only one way to reach any element of the auxiliary area.

Or more specifically, list and sublist
auxiliary pointers must point at elements of the auxiliary area,
two list or sublist auxiliary pointers are not permitted to point
at the same auxiliary
area element, and an auxiliary area element that is followed
in the auxiliary area by a list element may not be pointed at by
a list or sublist auxiliary pointer (because the following list element
in effect points at the auxiliary area element as being the
continuation of the list containing the following list element).
\end{indpar}

Thus if the one way to reach an element of
the auxiliary area is deleted, the element may be put on a list of
free elements for the auxiliary area.  As an optimization,
an implementation may use the unused area or space in the object's header
to hold a count of the freed elements as an aid to determine when to
reorganize the object.  It is even possible to establish a list of
free elements for reuse, but due to auxiliary area fragmentation this
may not be efficient.

As an optimization, \skey{auxiliary stub}s can be used in place of object
auxiliary area elements.  When this is done, the description of this
section must be modified as explained in \secref{OBJECT-AUXILIARY-STUBS}.

\subsubsubsection{List Pointers}
\label{LIST-POINTERS}

A \key{list pointer} can be used to move around in a object at
the list level.
There are three kinds of list pointers.
A read-only \verb|min::list_pointer| permits read-only access to list
elements.
A read-write or updatable {\tt min::\EOL updatable\_\EOL list\_\EOL pointer}
permits read-write access to list elements, but does not permit
adding or removing list elements.
An insertable {\tt min::\EOL insertable\_\EOL list\_\EOL pointer}
permits adding and removing elements, in addition to permitting
read-write access to elements.

Note that unlike vector pointers, you \underline{cannot} downcast more capable
list pointers to less capable list pointers.  E.g., an
{\tt min::\EOL insertable\_\EOL vec\_\EOL pointer} may be
explicitly or implicitly downcast to an
{\tt min::\EOL updatable\_\EOL vec\_\EOL pointer}
or {\tt min::\EOL vec\_\EOL pointer}, but 
a {\tt min::\EOL insertable\_\EOL list\_\EOL pointer} may \underline{not} be
explicitly or implicitly downcast to an
{\tt min::\EOL updat\-able\_\EOL list\_\EOL pointer}
or {\tt min::\EOL list\_\EOL pointer}.

The functions for using a read-only {\tt min::\EOL list\_\EOL pointer} are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{list\_pointer}\verb| lp ( min::vec_pointer & vp )|
\LABEL{MIN::LIST_POINTER_OF_VEC_POINTER} \\
\verb|min::vec_pointer & min::|
	& \MINKEY{vec\_pointer\_of}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::VEC_POINTER_OF_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_pointer & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_pointer & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_ATTR} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_COPY_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_COPY_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_COPY_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_SUBLIST_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::NEXT_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::PEEK_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::CURRENT_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_pointer & lp )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::list_pointer & lp )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_REFRESH_OF_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_POINTER} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{is\_list\_end}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{tabular}\end{indpar}

A list pointer is created to move around in a particular object.
Once created it can be started on a new list by one of the
\skey{start list function}s:
{\tt min::\EOL start\_\EOL hash}, {\tt min::\EOL start\_\EOL attr},
{\tt min::\EOL start\_\EOL copy}, or
the 2-argument {\tt min::\EOL start\_\EOL sublist}.
The {\tt min::\EOL next} function moves forward one element
in the current list,
while the {\tt min::\EOL peek} function returns the next element without
moving to it.
The list is always pointing at a current element, whose value is
returned by the {\tt min::\EOL current} function.

If the current element
is updated using {\tt min::\EOL update}
on another updatable or insertable list pointer,
the {\tt min::\EOL update\_\EOL refresh} function
must be used to reestablish the
current element's value,
which is \ikey{cached}{cache!list pointer}\label{LIST-POINTER-CACHE}
in the list pointer.
Similarly one of the {\tt min::\EOL\ldots\_refresh} functions may
need to be used when another pointer is used to insert elements into
or remove elements
from the object, though in some situations this is
not adequate and the list pointer must be restarted
with a {\tt min::\EOL start\_\dots} function.

A list pointer that has been created but not started by one of the
list start functions appears to be
at the end of an immutable empty list.

The {\tt min::\EOL start\_\EOL hash} function positions
a list pointer at the beginning of the
list whose head is at the given index within the hash table, treating the
hash table as a vector.  This function returns the value of the first
element of the list, or returns {\tt min::\EOL LIST\_\EOL END}
if the list is empty.
The index is usually the hash value of a name component
(number, string, or label),
modulo the size of the hash table,
but exactly how the index is computed is not determined by the object
list level.  Index 0 refers to the first element of the
hash table, and the maximum index is the size of the hash table minus 1.
The size of the hash table may be obtained from the
{\tt min::\EOL hash\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index.

The {\tt min::\EOL start\_\EOL attr} function is analogous except it is given
an index within the object attribute vector and positions the list pointer
at the beginning of the list whose head is the attribute vector element
at that index.  Index 0 refers to the first element of the attribute vector,
and the maximum index is the size of the attribute vector minus 1.
The size of the attribute vector may be obtained from the
{\tt min::\EOL attr\_\EOL size\_\EOL of} function.
The index is \underline{not} a body vector index.

The {\tt min::\EOL start\_\EOL copy} function
positions a list pointer ({\tt lp})
to the same place as another list pointer ({\tt lp2}).
The two list pointers must have been constructed from the same
vector pointer.
Also note that the list pointer {\tt lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before {\tt min::\EOL start\_\EOL copy} is executed.

The value of a list element can represent a sublist
(see the {\tt min::\EOL is\_\EOL sublist} function described below).
The 2-argument {\tt min::\EOL start\_\EOL sublist} function
positions a list pointer ({\tt lp})
to the first element of the sublist represented by the current
element of another list pointer ({\tt lp2}).
The current element of the second pointer must represent a sublist.
This function returns the value of the first element of
the sublist, or returns {\tt min::\EOL LIST\_\EOL END} if the sublist is empty.
The two list pointers must have been constructed from the same
vector pointer.
Also note that the list pointer {\tt lp2}
must be valid; that is, if it has been invalidated by
an update, remove, or insert, it must be made valid by a refresh or restart
before {\tt min::\EOL start\_\EOL sublist} is executed.

The 1-argument {\tt min::\EOL start\_\EOL sublist} function
positions a list pointer
to the first element of the sublist represented by the current
element of the pointer (it is equivalent to 2-argument
{\tt min::\EOL start\_\EOL sublist} with \verb|lp2|$\equiv$\verb|lp|).
Again the list pointer must be valid before this function is executed.

The {\tt min::\EOL next} function moves the list pointer
to the next list element of the
list the pointer points at, and returns the value of that
list element.  It returns {\tt min::\EOL LIST\_\EOL END} if there is
no next list element because the end of the list has been reached.
After the end of a list has been reached, additional
calls to {\tt min::next}
will do nothing but return {\tt min::\EOL LIST\_\EOL END}.

The {\tt min::\EOL peek} function returns the next element of the
list, i.e., the
same value as the {\tt min::\EOL next} function would return, but does not
change the element the list pointer is pointing at, i.e., does not
modify the list pointer.

The {\tt min::current} function just returns the value of the list
element the list pointer currently points at, or returns
{\tt min::\EOL LIST\_\EOL END}
if there is no such element because the pointer is at the end of a list.
This function does not modify the list pointer.

The {\tt min::update\_\EOL refresh}
function must be called for
a pointer that points at an element if the {\tt min::\EOL update} function
is used with \underline{another} pointer to the same object to update
the element, or if the element is a sublist head and a function is used
to remove the first element of the sublist or insert elements at the
beginning of the sublist or after the first element of the sublist.
The {\tt min::\EOL insert\_\EOL refresh} function must be called if the
{\tt min::\EOL insert\_\EOL reserve} function is used with \underline{another}
pointer to the same object and that function returned \verb|true| indicating
that it resized the object.  The 
{\tt min::\EOL insert\_\EOL reserve} function also does what the
{\tt min::\EOL update\_\EOL reserve} function does, and therefore it is
never necessary to call both functions.
There are also situations detailed on \pagref{RESTARTING_LIST_POINTER}
in which use of {\tt min::\EOL insert\_\EOL before},
{\tt min::\EOL insert\_\EOL after}, or
{\tt min::\EOL remove} with \underline{another} pointer to the same object
absolutely requires that the current pointer be
restarted by a {\tt min::\EOL start\_\ldots} function.

Determining whether a list pointer current element value
represents a sublist requires
the {\tt min::\EOL is\_\EOL sublist} function, which must check whether the
value is a sublist auxiliary pointer,
is the value {\tt min::\EOL EMPTY\_\EOL SUBLIST},
or is a pointer to a sublist auxiliary stub as described in
\secref{OBJECT-AUXILIARY-STUBS}.
The {\tt min::\EOL is\_\EOL empty\_\EOL sublist}
function, on the other hand, merely checks whether the value is
{\tt min::\EOL EMPTY\_\EOL SUBLIST}.

Determining whether a list pointer current element value
represents the end of a list can be done by
simply checking whether the value equals {\tt min::\EOL LIST\_\EOL END},
or can be done equivalently
with the {\tt min::\EOL is\_\EOL list\_\EOL end} function.

An {\tt min::updatable\_\EOL list\_\EOL pointer} allows read-write access to
list elements without permitting insertion or removal of elements
from lists.  The functions for using this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{updatable\_list\_pointer} \verb|lp| \\
	& \verb|    ( min::updatable_vec_pointer & vp )|
\LABEL{MIN::UPDATABLE_LIST_POINTER_OF_UPDATABLE_VEC_POINTER} \\
\multicolumn{2}{@{}l}{\tt min::updatable\_vec\_pointer \&} \\
\verb|min::|
	& \MINKEY{vec\_pointer\_of} \\
	& \verb|    ( min::updatable_list_pointer & lp )|
\LABEL{MIN::VEC_POINTER_OF_UPDATABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::updatable_list_pointer & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_HASH_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::updatable_list_pointer & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_ATTR_OF_UPDATABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_COPY_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_COPY_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_SUBLIST_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::START_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::NEXT_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::PEEK_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::CURRENT_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::updatable_list_pointer & lp )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_REFRESH_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::updatable_list_pointer & lp )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_REFRESH_OF_UPDATABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::HASH_SIZE_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::ATTR_SIZE_OF_UPDATABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::updatable_list_pointer & lp,| \\
	  \verb|   min::gen value )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_OF_UPDATABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}

Functions defined for read-only list pointers are also
applicable to updatable (read-write) list pointers with the
same results.  However, updatable list pointers
can\underline{not} be converted to be read-only list pointers
(unlike the situation with vector pointers).
Also note that {\tt min::start\_\EOL sublist} works when
\verb|lp2| is a read-only list pointer, but {\tt min::start\_\EOL copy}
does not.

The {\tt min::update} function can be used to replace the
value of the current element of a list.
Neither the previous value of the element nor the
new value of the element may be {\tt min::\EOL LIST\_\EOL END},
and neither may represent a sublist (even an empty sublist).

If a list pointer {\tt lp2} points at a element that is
{\tt min::update} using a different updatable list pointer {\tt lp1},
then {\tt lp2} will be invalid until
{\tt min::\EOL update\_\EOL refresh(lp2)},
{\tt min::\EOL insert\_\EOL refresh(lp2)}, or
{\tt min::\EOL start\_\ldots(lp2,\ldots)}
has been executed.

Inserting and removing elements from a list requires yet another
kind of list pointer, a {\tt min::insert\-able\_\EOL list\_\EOL pointer}.
The functions defined for this are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{insertable\_list\_pointer} \verb|lp| \\
	& \verb|    ( min::insertable_vec_pointer & vp )|
\LABEL{MIN::INSERTABLE_LIST_POINTER_OF_INSERTABLE_VEC_POINTER} \\
\multicolumn{2}{@{}l}{\tt min::insertable\_vec\_pointer \&} \\
\verb|min::|
	& \MINKEY{vec\_pointer\_of} \\
	& \verb|    ( min::insertable_list_pointer & lp )|
\LABEL{MIN::VEC_POINTER_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_hash}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_HASH_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp,| \\
	  \verb|   min::unsptr index )|
	  \end{tabular}
\LABEL{MIN::START_ATTR_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_COPY_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_SUBLIST_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::START_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::NEXT_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::PEEK_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::CURRENT_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_REFRESH_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_REFRESH_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::HASH_SIZE_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::ATTR_SIZE_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{update}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp,| \\
	  \verb|   min::gen value )| \\
	  \end{tabular}
\LABEL{MIN::UPDATE_OF_INSERTABLE_LIST_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{insert\_reserve\REL}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp,| \\
	  \verb|   min::unsptr insertions,| \\
	  \verb|   min::unsptr elements = 0,| \\
	  \verb|   bool use_obj_aux_stubs =| \\
	  \verb|       min::use_obj_aux_stubs )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp,| \\
	  \verb|   min::gen * p, min::unsptr n )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp,| \\
	  \verb|   min::gen * p, min::unsptr n )| \\
	  \end{tabular}
\LABEL{MIN::INSERT_AFTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::|
	& \MINKEY{remove}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::insertable_list_pointer & lp,| \\
	  \verb|   min::unsptr n = 1 )|
	  \end{tabular}
\LABEL{MIN::REMOVE_FROM_INSERTABLE_LIST} \\
\end{tabular}\end{indpar}

Functions defined for updatable (and read-only) list pointers are also
applicable to insertable list pointers with the
same results.  However, insertable list pointers
can\underline{not} be converted to be updatable or read-only list pointers
(unlike the situation with vector pointers).
Note that {\tt min::start\_\EOL sublist} works when
\verb|lp2| is a read-only or updatable
list pointer, but {\tt min::start\_\EOL copy}
does not.

Also, there is one function, {\tt min::update}, that can do more for
an insertable list pointer than it can for an updatable list pointer.  For
an insertable list pointer (but not for an updatable list pointer)
the current value replaced by {\tt min::update}
may be a sublist, and/or the replacing value may be
{\tt min::\EOL EMPTY\_\EOL SUBLIST}.  Thus {\tt min::update} can be used
to remove a sublist or to create an empty sublist.

Making insertions in object lists requires reservation of the necessary
space first, in order to be sure that a sequence of insertions will
all succeed.
The {\tt min::insert\_reserve} function reserves space for the given number
of insertion function calls and the given total number of list elements
to be inserted.  If the later is {\tt 0}, the default, it is taken to
be equal to the number of insertion function calls.  If space is not
reserved for insertion function calls in this way, the calls will be
in error.

The {\tt min::insert\_reserve\REL} function may resize the body of
the object in which space is being reserved
(using {\tt min::\EOL resize},
\pagref{MIN::RESIZE_UNUSED_OF_INSERTABLE_VEC_POINTER}).
It returns \verb|true| if it
resizes the object's body, and \verb|false| if it does not.
It sets the relocated flag (\pagref{RELOCATED-FLAG}) if it
resizes the body and must relocate any \underline{other} body,
but not if it just resizes and possibly relocates
the body of the object in which space is being reserved.
It returns \verb|false| if it relocates the body but does
\underline{not} resize it.

Only one pointer at a time
for a given object may have an effective reservation.
Each call to {\tt min::\EOL insert\_reserve} for a list pointer
to an object invalidates all previous calls to
{\tt min::\EOL insert\_reserve} for any list pointer
to the same object.  Errors in this regard involving two different
list pointers will be detected if insufficient memory is reserved,
but not otherwise.

Note that {\tt min::\EOL insert\_reserve} is the only list pointer
function that may cause a relocation and/or resizing of
the object pointed at, and if a resizing occurs (i.e., if \verb|true|
is returned),
all other list pointers to the same object
become invalid and must be refreshed by
a call to {\tt min::\EOL insert\_\EOL refresh}.

The {\tt min::\EOL insert\_reserve} function can increase the size of the object
if it is insufficient, or instead it can depend upon using
object auxiliary stubs (\secref{OBJECT-AUXILIARY-STUBS}) if the object
runs out of space, in which case {\tt min::\EOL insert\_reserve} must be sure
there are sufficient free stubs to satisfy the insertion calls.  The
last argument to {\tt min::\EOL insert\_reserve} determines which strategy is
used.  It defaults to the value of \minkey{use\_obj\_aux\_stubs}
(see \pagref{MIN::USE_OBJ_AUX_STUBS}).%
\footnote{But if the auxiliary stub code is not compiled in, the last
argument is treated as if it was always {\tt false}:
see {\tt MIN\_\EOL USE\_\EOL OBJECT\_\EOL AUX\_\EOL STUBS} on
\pagref{MIN_USE_OBJ_AUX_STUBS}.}

The {\tt min::\EOL insert\_before} function inserts list elements
just before the current position of a list pointer and positions the
list pointer to the first element inserted.
The {\tt min::\EOL insert\_after} function inserts list elements just after the
current position and leaves the pointer position unchanged (pointing at
the element before the first inserted element).
If the list pointer is at the end of list,
{\tt min::\EOL insert\_before} inserts the elements at the end of the list, and
{\tt min::\EOL insert\_after} is in error.
The elements are specified by a length {\tt n}
vector {\tt p} of {\tt min::gen} values.
\verb|p[0]| is inserted into the list before \verb|p[1]|, etc.
If \verb|n=0| elements are to be inserted, both insert
functions are no operations.

To insert a sublist, first insert {\tt min::\EOL EMPTY\_SUBLIST}, then
position the pointer to the sublist and use
{\tt min::\EOL start\_sublist} to enter the sublist, and then use
{\tt min::\EOL insert\_before} to insert the elements of the sublist.
Also, as noted above, you can use {\tt min::\EOL update} with an
insertable pointer to change
the current element to {\tt min::\EOL EMPTY\_\EOL SUBLIST}.

A sequence of instructions that begins with a
call to {\tt min::\EOL insert\_reserve} and ends with the last
list insertion function for which the beginning call made a reservation
is called a `\key{list insertion sequence}'.  A list insertion sequence
must not contain any call to
a relocating (\REL) function (\pagref{RELOCATING-FUNCTIONS}), aside from
the beginning call to {\tt min::\EOL insert\_reserve}.  In particular, there can
be no call to {\tt min::\EOL interrupt\REL} (\pagref{MIN::INTERRUPT}) and no
second call to {\tt min::\EOL insert\_reserve\REL}.  There can be calls to
create and position list pointers, and to read, update, and remove
list elements.

If {\tt min::\EOL insert\_\EOL before}
or {\tt min::\EOL insert\_\EOL after}
are used to insert elements at the beginning of a sublist or elements
just after the first element of a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to {\tt min::\EOL update\_\EOL refresh} or
{\tt min::\EOL insert\_\EOL refresh} or restarted with a call to a
{\tt min::\EOL start\_\ldots} function.

The {\tt min::\EOL remove} function can be used to remove
{\tt n} consecutive elements
of a list, the first of which is the element currently pointed at by
the list pointer.
After removal, the list pointer points at the first element after the
elements removed, or at the end of the list if there is no such element.
If there are fewer than {\tt n} elements in the list at and after
the list pointer current element, then there is no error, but all the
elements at and after the current element are removed, and the list
pointer is pointed at the end of the list.  The returned value is the
number of elements actually removed (and is less than {\tt n} if the
list was too short).  Element removal requires no reservation.

If {\tt min::\EOL remove} is used to remove the first element of
a sublist,
all list pointers pointing at the sublist viewed as an element
inside its containing list
become invalid and must be refreshed by
a call to {\tt min::\EOL update\_\EOL refresh} or
{\tt min::\EOL insert\_\EOL refresh} or restarted with a call to a
{\tt min::\EOL start\_\ldots} function.

If an insertable list pointer {\tt lp2} is used to add or remove
elements or remove sublists, and there is another list pointer {\tt lp1}
pointing at the same object, then {\tt lp1} is invalidated and must
be restarted with a
{\tt min::\EOL start\_}\,\ldots function\label{RESTARTING_LIST_POINTER}
if {\tt lp1} is pointing at:

\begin{enumerate}
\item an element that is removed
\item an element in a removed sublist
\item the end of a removed sublist
\item an element adjacent to an element that is inserted or removed
\item the end of a list whose last element is inserted or removed
\item the first element of a sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\item the end of an empty sublist
      when that sublist, viewed as an element of the list containing
      it, is adjacent in that containing list to
      an element that is inserted into or removed from that containing list
\end{enumerate}

The effects can be subtle
and not obvious: for example, using {\tt lp2} to insert before or after
a list element that is an empty sublist can invalidate {\tt lp1}
if {\tt lp1} points at the end of that empty sublist.

The invalidation of {\tt lp1} in the above situations
is \underline{not} a detectable error.

\begin{quote}
\key{List Implementation Note}:\label{LIST-IMPLEMENTATION-NOTE}
In order to enforce the `No Superfluous' rules on 
\pagref{NO-SUPERFLUOUS-LIST}, {\tt MUP::insertable\_list\_pointer}'s keep
track of the location of any auxiliary pointer
(or equivalent as per \secref{OBJECT-AUXILIARY-STUBS})
pointing a the current
element.  Insertions before or after the current element may change
this auxiliary pointer, and may move the current element to another
location.  Otherwise insertions replace the current element
by an auxiliary pointer (or equivalent)
pointing at a vector of elements (or equivalent),
one of which is a copy of the replaced element.
This last is done for insertions after the single element of a one
element list headed in the hash table or attribute vector.
Any insertion before the end of a list of such a single element list
is transformed into an insertion after the list's single element.
\end{quote}

The various list pointer types are instances of
\verb|MUP::|\MUPKEY{list\_pointer\_type} defined as follows:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|typedef MUP::|
	& \verb|list_pointer_type<min::vec_pointer>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_pointer}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_pointer_type<min::updatable_vec_pointer>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_updatable\_pointer}\verb|;| \\
\verb|typedef MUP::|
	& \verb|list_pointer_type<min::insertable_vec_pointer>|\ARGBREAK
	  \verb|min::|\MINKEY{list\_insertable\_pointer}\verb|;| \\
\end{tabular}\end{indpar}

It is important not to instantiate {\tt MUP::list\_pointer\_type}
with any parameter that is not a vector pointer type (which is why
it is unprotected).

\subsubsubsection{Object Auxiliary Stubs}
\label{OBJECT-AUXILIARY-STUBS}

As an optimization, \skey{object auxiliary stub}s\index{auxiliary stub!object}
can be used instead of object
auxiliary area elements.  Object auxiliary stubs are a way of adding
list elements to
an object whose unused area has been exhausted, without relocating the
object.  Object auxiliary stubs
are considered to be \skey{extension}s of the object.
If the object is later relocated, it can be reorganized to
eliminate the use of any object auxiliary stubs that extend the object
by moving information from these into a new larger object auxiliary area.

The code implementing object auxiliary stubs can be compiled into a program
or left out of a program according to the setting of the macro:


\begin{indpar}
\begin{tabular}{l}
\TTNBKEY{MIN\_USE\_OBJ\_AUX\_STUBS} \\
~~~~~ 1 if code to use object auxiliary stubs is to be compiled; \\
~~~~~ 0 if this code is not to be compiled; the default.
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\end{tabular}
\end{indpar}

If compiled, the code can be enabled or disabled by setting the
following variable:

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs} \\
& ~~~~\verb|true| to enable use of object auxiliary stubs; the default \\
& ~~~~\verb|false| to disable use of object auxiliary stubs
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{tabular}\end{indpar}

The value of an object
auxiliary stub is treated like an auxiliary area element value that is
always a list element, and is never a list auxiliary pointer
or a \verb|min::LIST_END| value.  However, as a list element,
the value may be a sublist auxiliary pointer (or equivalent, see below)
or a \verb|min::EMPTY_SUBLIST| value.

The control of an object auxiliary stub is treated like an auxiliary
area element value that is always a list auxiliary pointer
or a \verb|min::LIST_END| value, and is never a list element.

The value and control of an object auxiliary stub are treated like
consecutive elements of the object auxiliary area, with the control
preceding the value in the area, and therefore
following the value in list order.

An object auxiliary stub has one of the following two uncollectable stub type
codes:

\begin{indpar}
\begin{list}{}{}
\item[{\tt const int min::}\MINKEY{LIST\_AUX}]~%
	\LABEL{MIN::LIST_AUX}\\
A \verb|min::gen| value or stub control
pointing at this stub behaves like a list pointer.
\item[{\tt const int min::}\MINKEY{SUBLIST\_AUX}]~%
	\LABEL{MIN::SUBLIST_AUX}\\
A \verb|min::gen| value pointing at this stub behaves like a sublist pointer.
\end{list}
\end{indpar}

Any stub pointer to an object auxiliary stub of type \minnbkey{LIST\_AUX}
is treated as a list auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \verb|min::gen| values or in auxiliary stub controls.

Any stub pointer to an object auxiliary stub of type \minnbkey{SUBLIST\_AUX}
is treated as a sublist auxiliary pointer.  Such stub pointers may be stored in
auxiliary area \verb|min::gen| values or in auxiliary stub \verb|min::gen|
values.

Thus the following rules are obeyed:

\begin{indpar}

{\bf \minnbkey{LIST\_AUX} stubs}.
An auxiliary area element
holding a \verb|min::gen| value that points at a stub $S$
of type \verb|min::LIST_AUX| is the equivalent of a list auxiliary
pointer pointing at the list element that is stub $S$'s value.

If the control of an object auxiliary stub holds a stub pointer, that pointer
must point at an object auxiliary stub $S$ of type \verb|min::LIST_AUX| and the
control is the equivalent of a list auxiliary pointer pointing at
the list element that is stub $S$'s value.

{\bf \minnbkey{SUBLIST\_AUX} stubs}.
An auxiliary area element holding a \verb|min::gen| value that points at
a stub $S$
of type \verb|min::SUBLIST_AUX| is the equivalent of a sublist auxiliary
pointer pointing at the list element that is stub $S$'s value.

An object auxiliary stub \verb|min::gen| value that points at
a stub $S$ of type {\tt min::\EOL SUBLIST\_\EOL AUX}
is the equivalent of a sublist auxiliary
pointer pointing at the list element that is stub $S$'s value.

{\bf Values of Object Auxiliary Stubs}.%
\index{value!of object auxiliary stub}
An object auxiliary stub value is always a list element, and can never
be a list auxiliary pointer value, a \verb|min::gen| value pointing at
a stub of type \verb|min::LIST_AUX|, or a \verb|min::LIST_END| value.

However, it can be a sublist auxiliary pointer value, a \verb|min::gen|
value pointing at a stub of type \verb|min::SUBLIST_AUX|, or a
\verb|min::EMPTY_SUBLIST| value.

{\bf Controls of Object Auxiliary Stubs}.%
\index{control!of object auxiliary stub}
An object auxiliary stub control is never a list element, and must
be a list auxiliary pointer value, a stub pointer value pointing at
a stub of type \verb|min::LIST_AUX|, or a \verb|min::LIST_END| value.

{\bf Pointers to Object Auxiliary Stubs}.%
\index{pointer!to object auxiliary stub}
Every object auxiliary stub is pointed at by a \verb|min::gen|
value or by the control of another object auxiliary stub.  There is
only one such pointer pointing at each object auxiliary stub.
A \verb|min::gen| value pointing at an object auxiliary stub $S$
must the the value of an auxiliary area element or the value of
an object auxiliary stub, and in this latter case $S$ must be of type
\verb|min::SUBLIST_AUX|.

\end{indpar}

Object auxiliary stubs
must obey the object list level rules on \pagref{NO-SUPERFLUOUS-LIST}.
This means, for example, that a list auxiliary pointer cannot point
at an auxiliary area element that holds a \verb|min::gen| value
pointing at an object auxiliary stub of type \verb|min::LIST_AUX|,
as this would be equivalent to a list auxiliary pointer pointing at an
element holding another list auxiliary pointer.

The use of object auxiliary stubs by an implementation is hidden from
the user of MIN by object list level functions.  There are no functions
for dealing explicitly with object auxiliary stubs.  There are, however,
functions to read and write stubs of all kinds in
\secref{UNPROTECTED-STUB-FUNCTIONS}, though the only use of these functions on
object auxiliary stubs would be for debugging.

\subsubsection{Typed Objects}
\label{TYPED-OBJECTS}

A \key{typed object} is a pair of objects: the \mkey{type}{of typed object}
which provides attribute labels, and the \mkey{context}{of typed object}
which provides variables that give attribute values.  The type
contains variable indices that act as indirect pointers to the
variables in the context.  By abuse of language the context may be
called the `typed object'.

Typed objects may be introduced in two different ways.  In the first
method the context is given the {\tt min::\EOL OBJ\_\EOL TYPED} flag
and its first variable points at the type.  In the second method
the typed object is represented by a stub of {\tt min::\EOL TYPED\_\EOL OBJECT}
type which in turn points at an auxiliary stub that holds two pointers
to stubs: one pointing at the type and the second pointing at the context.
The type is pointed at by the control of the auxiliary stub, the context
is pointed at by the value of the auxiliary stub.

Typed objects make use of two kinds of indirect pointer.  The first is
just a single index \verb|min::gen| value that holds the index of a
variable vector element.  This always refers to a variable in the context.
The second is an indirect \verb|min::gen| value that points at a pair
of values in an auxiliary area: the first being an index \verb|min::gen|
value and the second a pointer-to-object-stub \verb|min::gen| value.
This refers the the variable vector element of the object pointed to
that is indexed by the given index.  If an attribute value is an indirect
pointer, the indirection is taken to the variable element referred to.
If that in turn has an indirect pointer value, that indirection is also
taken, to any depth.

\subsubsection{Object Attribute Level}
\label{OBJECT-ATTRIBUTE-LEVEL}

At the \key{attribute level}\,, the object is a map from attribute-names to
flags and multi-sets of values and from attribute-name/reverse-attribute-name
pairs to multi-sets of values.
Here names are sequences of name components, which are
numbers, strings, or labels.  The object map is stored in a set of lists which
are entries in the hash table or attribute vector.  These lists have
one of two syntaxes depending upon the setting of the following macro:

\begin{indpar}
\begin{tabular}{l}
\TTNBKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS} \\
~~~~~ 1 if partial attribute labels are supported; \\
~~~~~ 0 if partial attribute labels are not supported.
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}
\end{indpar}

If partial attribute labels are supported, the attribute name given to
a function that locates an attribute may be too long,
and the function will use only an initial segment of that name,
returning the length of that segment.

If partial attribute names are \underline{not} supported
the object lists have the syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em hash-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em vector-list}
\\[1ex]
\emkey{hash-list} ::= {\em attribute-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{vector-list} ::= {\em attribute-descriptor-option}
\\[1ex]
\emkey{attribute-name-descriptor-pair} ::=
    {\em attribute-name } {\em attribute-descriptor}
\\[1ex]
\emkey{attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{attribute-descriptor} ::= {\em value} $|$ {\em attribute-sublist}
\\[1ex]
\emkey{attribute-sublist} ::=
    {\em value}$\,^\star$ {\em double-arrow-sublist-option} {\em flag-set}
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

Here the syntactic categories represent \verb|min::gen| values
or lists or sublists
of \verb|min::gen| values in the sense of the object list level.

An {\em X-list} is a list, in the sense of the object list level.  Thus
a {\em hash-list} and {\em vector-list} are lists.

An {\em X-sublist} is a sublist, in the sense of the object list level, which
is to say it is a list that is an element of another list.  Thus
{\em attribute-sublists} and {\em double-arrow-sublists} are sublists.

An {\em X-option} is an optional element of a list that is an {\em X} if
it is not omitted.

Everything else is a single list element or
a sequence of elements in some list or sublist.
{\em X-pairs} are sequences of two elements.
{\em Flag-sets} are sequences of {\em control-codes}.

An {\em atom} is a \verb|min::gen| number or string.
An {\em label} is a \verb|min::gen| label.
An {\em object} is a \verb|min::gen| value pointing at an object stub.
A {\em control-code} is a \verb|min::gen| control code value.
An {\em index} is a \verb|min::gen| index value.
An {\em indirect-auxiliary} is a \verb|min::gen| indirect auxiliary value.

The above form of object map maps an {\em attribute-name} to a list of
{\em values}, a list of flag {\em control codes}, and a optional
{\em double-arrow-sublist}.  This last maps {\em reverse-attribute-names}
to lists of values.

The lists of {\em values} here represent multisets of {\em values}.
That is, the
order of the {\em values} in the list is not meaningful.
Similarly the order of {\em attribute-name-descriptor-pairs}
in a {\em hash-list}
or the order of {\em double-arrow-name-descriptor-pairs}
in a {\em double-arrow-sublist} is not meaningful.
On the other hand, a {\em flag-set} is actually an ordered list
of {\em control-codes}; here order matters.

A {\em hash-list} is simply a list of alternating {\em attribute-names}
and {\em attribute-descriptors}.
The long form of an {\em attribute-descriptor} is an
{\em attribute-sublist} that gives  a possibly empty list of {\em values},
an optional {\em double-arrow-sublist}, and a possibly empty
list of flag control codes.
If the {\em attribute-sublist}
would be nothing but a one element list containing
a single {\em value}, a common case, the {\em attribute-sublist}
may be replaced by this single
{\em value}, in the interests of optimizing memory.

An empty {\em attribute-sublist} is equivalent to a missing
{\em attribute-name-descriptor-pair}.
{\em Attri\-bute-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

A {\em vector-list} may either be empty or have exactly one element.
If it has one element, that element is
the {\em attribute-descriptor} which is associated with the
{\em attribute-name} that equals the vector index of the
attribute vector element in which the {\em vector-list} is stored.
If a vector index has no associated attribute, either its
{\em vector-list} can be empty, or its
{\em attribute-descriptor} can be the empty sublist.

{\em Attribute-names} can be either {\em atoms} or {\em labels}.
If an {\em attribute-name} is an integer {\em atom}
that is in the range of a legal
attribute vector index then a {\em vector-list} with one element that is
an {\em attribute-descriptor}
is put in the attribute vector element
indexed by the integer.
Otherwise an {\em attribute-name-descriptor-pair} containing
the {\em attribute-name} is put
in the {\em hash-list} of the object's hash table entry whose index
in the hash table
equals the hash of the {\em attribute-name} modulo the length of the
hash table.

A {\em double-arrow-sublist} is 
simply a sublist of alternating {\em reverse-attribute-names}
and {\em value-multisets}.  The former are just like {\em attribute-names}
and the latter are just like {\em attribute-descriptors} that have no
flag control codes or {\em double-arrow-sublists}.

An empty {\em value-multiset} is equivalent to a missing
{\em double-arrow-name-descriptor-pair}.
{\em Dou\-ble-arrow-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are \underline{not} supported, multi-component
attribute names are represented in object data lists as labels.
Thus an {\em attribute-name} is an {\em atom} if it represents a 1-component
attribute name, and a {\em label} if it represents a several component
attribute name, or if it represents a 1-component name whose one component
is itself a label.

In the interests of compatibility with the case where partial attribute
names are supported, {\em attribute-names} and {\em reverse-attribute-names}
that are {\em labels} whose sole element is an {\em atom} are not
permitted in the object data lists, and when functions are presented with
such names, the functions replace them with their sole element, namely the
{\em atom}.  In addition, {\em attribute-names} that are labels with no elements
are forbidden, for reasons of compatibility.

If partial attribute names \underline{are} supported
the object lists have the following alternative syntax:

\begin{indpar}
\emkey{hash-table-entry} ::= {\em node-list}
\\[1ex]
\emkey{attribute-vector-entry} ::= {\em vector-list}
\\[1ex]
\emkey{node-list} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{vector-list} ::= {\em node-descriptor-option}
\\[1ex]
\emkey{node-name-descriptor-pair} ::=
    {\em attribute-name-component } {\em node-descriptor}
\\[1ex]
\emkey{attribute-name-component} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{node-descriptor} ::= {\em value} $|$ {\em node-sublist}
\\[1ex]
\emkey{node-sublist}
    \begin{tabular}[t]{@{}r@{~}l@{}}
    ::= & {\em value}$\,^\star$
          {\em flag-set} \\
    $|$ & {\em value}$\,^\star$
          {\em child-sublist}
	  {\em double-arrow-sublist-option}
	  {\em flag-set}
    \end{tabular}
\\[1ex]
\emkey{child-sublist} ::= {\em node-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-sublist} ::=
    {\em double-arrow-name-descriptor-pair}$\,^\star$
\\[1ex]
\emkey{double-arrow-name-descriptor-pair} ::=
    {\em reverse-attribute-name } {\em value-multiset}
\\[1ex]
\emkey{reverse-attribute-name} ::= {\em atom } $|$ {\em label}
\\[1ex]
\emkey{value-multiset} ::= {\em value} $|$ {\em value-sublist}
\\[1ex]
\emkey{value-sublist} ::= {\em value}$\,^\star$
\\[1ex]
\emkey{flag-set} ::= {\em control-code}$\,^\star$
\\[1ex]
\emkey{value} ::= {\em atom} $|$ {\em label} $|$ {\em object}
                             $|$ {\em indirect-pointer}
\\[1ex]
\emkey{indirect-pointer} ::= {\em index} $|$ {\em indirect-auxiliary}
\end{indpar}

This differs from the previous representation in that the object map
is represented by a tree of nodes,
where each node is labeled by an {\em attribute-name-component}.
An {\em attribute-name} is viewed as a sequence of
{\em attribute-name-components}, so the {\em attribute-name}
defines a path in the tree from the root to a node.
Each node has an associated {\em node-descriptor} that
contains the node {\em values},
optional {\em double-arrow-sublist}, and flag control codes,
which are associated
with the {\em attribute-name} that names the path from the root to the
node.  The {\em node-descriptor} also may contain
an optional {\em child-sublist}
which describes the children of the node in the tree.

A {\em hash-table-entry} is a {\em node-list} that gives alternating
{\em attribute-name-component}/\EOL {\em node-\EOL de\-scrip\-tor} pairs for
children of the object root node.  A {\em attribute-vector-entry}
just describes one node that is a child of the root, namely the node
whose {\em attribute-name-component} equals the vector index of the
{\em attribute-vector-entry} in the object's attribute vector.
For a node that is a child of the object root,
if the child node's {\em attribute-name-component} is an integer in the legal
range of the object's attribute vector indices, then the child node's
{\em node-descriptor} is stored in the {\em vector-list}
that is stored in the object's attribute vector element.
A {\em vector-list} is either empty or is a one element list whose element is a
{\em node-descriptor}.  If a vector index is not the first component of
any of the object's attribute names, then the corresponding {\em vector-list}
can either be empty or can consist of just an empty {\em node-descriptor}
{\em node-sublist}.

For a child of the root whose name component is not a legal attribute
vector index, its {\em attribute-name-component} and
{\em node-descriptor} is placed in the {\em hash-table-entry}
whose index in the object's hash table equals the hash of the
{\em attribute-name-component} modulo the length of the hash table.

A {\em node-descriptor} that consists of nothing but a single {\em value}
can be represented by just that {\em value}; otherwise it is represented
by a {\em node-sublist}.  If this last contains a sublist, the first
such sublist must
be the {\em child-sublist}, which has the same structure as a {\em node-list}
and describes the children of the node.  Otherwise neither the
{\em child-sublist} nor the {\em double-arrow-sublist} can be present.
Note that to avoid ambiguity it is not permitted to omit the
{\em child-sublist} without also omitting
the {\em double-arrow-sublist}, but the
{\em child-sublist} can be empty.  Except for these details
the {\em node-descriptor} structure is the same was as that of the
{\em attribute-descriptor} in the case where partial attribute names are
not allowed.  The {\em double-arrow-sublist} structure is exactly
the same.

An empty {\em node-sublist} is equivalent to a missing
{\em node-name-descriptor-pair}.
{\em Node-name-descriptor-pairs} are not
removed from the object until the object is completely reorganized,
in order to avoid invalidating other attribute pointers referencing the object.

When partial attribute names are supported, an attribute name is viewed
as a sequence of {\em attribute-name-components}.  If this sequence is
a single {\em atom}, function arguments representing the name can be
either this {\em atom} or a {\em label} whose only element is the {\em atom}.
Otherwise function arguments must be non-empty
{\em labels} whose elements are the {\em attribute-name-components}.
Note that zero length attribute names are forbidden.

\ikey{Attribute flags}{attribute flag!representation}\label{ATTRIBUTE-FLAGS}
are represented by a {\em flag-set} in an {\em attribute-sublist} or
{\em node-sublist}.
The {\em flag-set} is a sequence of \verb|min::gen|
control codes.

The flags are numbered 0, 1, 2, \ldots.  Flag $N$ corresponds to
the bit in the $I+1$'st control code
selected by the mask $2^K$ where $I=\mbox{floor}(N/\mbox{\tt VSIZE})$,
$K=N~\mbox{mod}~\mbox{\tt VSIZE}$, where {\tt VSIZE},
the number of bits in a control code integer,
is the value of the \verb|min::VSIZE| constant (\pagref{MIN::VSIZE}),
which is 24 if \verb|min::gen|
values are 32-bits, and 40 if \verb|min::gen| values are 64-bits.
A flag is set for an attribute name if and only if its corresponding
bit is present and set and in the attribute's {\em flag-set}.
If a flag's bit is not present in the {\em flag-set}, the flag is
treated as if its bit were present and cleared.

\subsubsubsection{Attribute Pointers}
\label{ATTRIBUTE-POINTERS}

An \key{attribute pointer} can be used to access attribute
flags and values
in an object.
An attribute pointer stores an attribute name
and a reverse attribute name.  The latter can take the special
values {\tt min::NONE} and {\tt min::ANY}.  The attribute name designates
the object attribute pointed at by the attribute pointer.
The flag set pointed at is always
the flag set of this attribute, regardless of the setting of the
reverse attribute name.  The attribute name and
reverse attribute name together designate the
value multiset pointed at.  If the reverse attribute name
is {\tt min::NONE}, the value multiset pointed at is the set of all values
\underline{not} associated with any reverse attribute name.  If the
reverse attribute name is {\tt min::ANY},
the value multiset is the set of all
values that are associated with any reverse attribute name.
Otherwise the value multiset pointed at is the set of values
associated with the reverse attribute name stored in the pointer.

There are three kinds of attribute pointers.
A read-only {\tt min::\EOL attr\_\EOL pointer}
permits read-only access to attribute values and flags.
An updatable {\tt min::\EOL updatable\_\EOL attr\_\EOL pointer}
permits read-write access to attribute values, and read-only access
to flags, but does not permit values to be added or removed from attributes.
An insertable {\tt min::\EOL insertable\_\EOL attr\_\EOL pointer}
permits read-write access to attribute values and flags
and also permits values to be added or removed from attributes.

The functions for using a read-only {\tt min::\EOL attr\_\EOL pointer}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|MUP::|
	& \MUPKEY{attr\_pointer}\verb| ap ( min::vec_pointer & vp )|
\LABEL{MUP::ATTR_POINTER_OF_VEC_POINTER} \\
\verb|void min::|
	& \MINKEY{locate}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_pointer & ap,| \\
	  \verb|   min::gen name )|
	  \end{tabular}
\LABEL{MIN::LOCATE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_pointer & ap, int name )|
	  \end{tabular}
\LABEL{MIN::LOCATEI_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_pointer & ap, min::unsptr name )|
	  \end{tabular}
\LABEL{MIN::LOCATEI_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_pointer & ap,| \\
	  \verb|   min::unsptr & length, min::gen name )|
	  \end{tabular}
\LABEL{MIN::LOCATE_PARTIAL_ATTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_pointer & ap,| \\
	  \verb|   min::gen reverse_name )|
	  \end{tabular}
\LABEL{MIN::LOCATE_REVERSE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::attr_pointer & ap )| \\
	  \end{tabular}
\LABEL{MIN::RELOCATE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}%
    \begin{tabular}[t]{@{}l@{}}
    \verb| ( min::gen * out, min::unsptr n,| \\
    \verb|   min::attr_pointer ap )| \\
    \end{tabular}
\LABEL{MIN::GET_OF_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}%
    \verb| ( min::attr_pointer ap )|
\LABEL{MIN::GET1_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}%
    \begin{tabular}[t]{@{}l@{}}
    \verb| ( min::gen * out, unsigned n,| \\
    \verb|   min::attr_pointer ap )| \\
    \end{tabular}
\LABEL{MIN::GET_FLAGS_OF_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb| ( min::attr_pointer wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|  min::unsptr flag_count;|\ARGBREAK
    \verb|  min::unsptr reverse_attr_count;|\ARGBREAK
    \verb|};|
\ttmindex{name}{in {\tt min::attr\_info}}
\ttmindex{value\_count}{in {\tt min::attr\_info}}
\ttmindex{flag\_count}{in {\tt min::attr\_info}}
\ttmindex{reverse\_attr\_count}{in {\tt min::attr\_info}}
\LABEL{MIN::ATTR_INFO} \\
\verb|typedef | & \verb|min::packed_vec<...,attr_info>| \ARGBREAK
                       \verb|min::|\MINKEY{attr\_info\_vec}
\LABEL{MIN::ATTR_INFO_VEC} \\
\verb|min::attr_info_vec | & 
                       \verb|min::|\MINKEY{attr\_info\_vec\_type}
\LABEL{MIN::ATTR_INFO_VEC_TYPE} \\
\verb|typedef | & \verb|min::attr_info_vec::pointer| \ARGBREAK
                       \verb|min::|\MINKEY{attr\_info\_pointer}
\LABEL{MIN::ATTR_INFO_POINTER} \\
\verb|min::gen min::| & \MINKEY{get\_attrs}\ARGBREAK
    \verb| ( min::attr_pointer ap )|
\LABEL{MIN::GET_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_attr\_info} \verb|( min::gen v )|
\LABEL{MIN::SORT_ATTR_INFO} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|struct min::| & \MINKEY{reverse\_attr\_info}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  min::gen    name;|\ARGBREAK
    \verb|  min::unsptr value_count;|\ARGBREAK
    \verb|};|
\ttmindex{name}{in {\tt min::reverse\_attr\_info}}
\ttmindex{value\_count}{in {\tt min::reverse\_attr\_info}}
\LABEL{MIN::REVERSE_ATTR_INFO} \\
\verb|typedef | & \verb|min::packed_vec<...,reverse_attr_info>| \ARGBREAK
                       \verb|min::|\MINKEY{reverse\_attr\_info\_vec}
\LABEL{MIN::REVERSE_ATTR_INFO_VEC} \\
\verb|min::reverse_attr_info_vec | & 
                       \verb|min::|\MINKEY{reverse\_attr\_info\_vec\_type}
\LABEL{MIN::REVERSE_ATTR_INFO_VEC_TYPE} \\
\verb|typedef | & \verb|min::reverse_attr_info_vec::pointer| \ARGBREAK
                       \verb|min::|\MINKEY{reverse\_attr\_info\_pointer}
\LABEL{MIN::REVERSE_ATTR_INFO_POINTER} \\
\verb|min::gen min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
    \verb| ( min::attr_pointer ap )|
\LABEL{MIN::GET_REVERSE_ATTRS} \\
\verb|void min::| & \MINKEY{sort\_reverse\_attr\_info} \verb|( min::gen v )|
\LABEL{MIN::SORT_REVERSE_ATTR_INFO} \\
\end{tabular}\end{indpar}

Attribute pointers are tied to an object, which is specified by
giving a vector pointer to the object to the constructor of the
attribute pointer.

\ikey{Locator functions}{locator function}
find attributes within an object and set the current
attribute name and reverse attribute name of an attribute pointer.
The {\tt min::\EOL locate} function sets the attribute name of the pointer.
If the `{\tt length}' argument is \underline{not} given, {\tt min::\EOL locate}
uses the complete attribute name.
The {\tt min::\EOL locatei} function does the
same thing as {\tt min::\EOL locate}
but is optimized for the case where the attribute
name has a single component that is an integer.\footnote{
In some implementations {\tt min::gen} is defined to be {\tt min::uns64},
and in these implementations {\tt int} and {\tt min::unsptr} are
incorrectly convertible to the
{\tt min::gen} type by a C++ implicit conversion.  As a consequence of this
the {\tt min::\EOL locatei} function must have a different name from the
{\tt min::\EOL locate} function.}

The form of the {\tt min::\EOL locate} function that takes a `{\tt length}'
argument exists only if the
{\tt MIN\_\EOL ALLOW\_\EOL PARTIAL\_\EOL ATTR\_\EOL LABELS}
(\pagref{MIN_ALLOW_PARTIAL_ATTR_LABELS}) macro is set to {\tt 1}.
This form of {\tt min::\EOL locate} uses the longest initial segment of the
attribute name that locates an attribute that has a non-empty
multiset of values.  The
length of this initial segment is returned in the `\verb|length|'
argument.  If \verb|0| is returned in `\verb|length|',
no initial segment having a non-empty multiset of values was found.

The {\tt min::\EOL locate\_reverse} function sets the reverse attribute name of
a pointer.  This can take the special value {\tt min::NONE} or
{\tt min::ANY}, as noted above.  A call to {\tt min::\EOL locate} or
{\tt min::\EOL locatei} sets the
reverse attribute name to {\tt min::NONE}.

Both the {\tt min::\EOL locate} and {\tt min::\EOL locate\_reverse}
functions take name
arguments that are labels (\secref{LABELS}).  If an atom (number or
string) is given instead, this is treated as the equivalent of
a label whose only element is the atom.

If ab object is reorganized by the \verb|min::publish| function or
relocated by use of an insertable pointer to set attribute values or
flags, every attribute pointer to the object other than the insertable
pointer used to set values or flags will become invalid.
When an attribute pointer becomes invalid, it may be restored to
validity by calling the {\tt min::\EOL relocate} function, without
changing the pointer's attribute and reverse attribute names.  Alternatively,
the {\tt min::\EOL locate} and if necessary {\tt min::\EOL locate\_reverse}
functions may be called for the pointer to reset or change
the pointer's attribute and reverse attribute names.

\ikey{Accessor functions}{accessor function}
can be used for reading attribute values and flags.
For the purposes of describing these functions,
an attribute pointer is considered to point at the attribute
named by the pointer's attribute name, and the reverse attribute
pointed at by the pointer's attribute and reverse attribute names,
unless the latter are \verb|min::NONE| or \verb|min::ANY|.
If these names have never been set it is an error to call an accessor
function for the pointer.

The value multiset pointed at by a pointer is that of the attribute pointed
at if the reverse attribute name is \verb|min::NONE|, or is that of
the reverse attribute pointed at if the reverse attribute name is not
\verb|min::NONE| or \verb|min::ANY|.
If the reverse attribute name is \verb|min::ANY| the value multiset is
the set of all values associated with any reverse attribute name, but
this \verb||min::ANY|
value set can only be read by the 3-argument \verb|min::get|
function, and made empty by the \verb|min::set| function with 0 new values.
It is an error to attempt any other access to this \verb|min::ANY| value set.

The flag set pointed at by a pointer is that of the attribute pointed
at regardless of the setting of the reverse attribute name.
If there are $N$ control codes in a flag set, $N${\tt *VSIZE} flags are
represented by the set, and any flag with number $\geq N${\tt *VSIZE} is
read as zero.  `High order' control codes may contain all zero flags,
and such zero high order control code may be removed when an object
is reorganized.

Attributes whose value and flag sets have never been set are treated
as if they have empty value multisets and flag control code lists.
Similarly reverse attributes
whose value multisets have never been set are treated as having empty value
multisets.

The 3-argument {\tt min::\EOL get} function gets the values in the value
multiset pointed at and stores them in the `{\tt out}' vector.
The total number of values in the value
multiset is returned (regardless of the value of {\tt n}).
The argument {\tt n}, the length of `{\tt out}',
the maximum number of values that may be returned in `{\tt out}'.
If there are more then {\tt n} values, only the first {\tt n}
are returned in `{\tt out}'.
If {\tt n==0} the function just returns
the number of values in the value multiset.

The 1-argument {\tt min::\EOL get} function assumes that there is exactly
one value in the value multiset
and returns that value, or returns the special value
\verb|min::NONE| (\pagref{MIN::NONE}) if the value multiset is empty,
or returns the special value
\verb|min::MULTI_VALUED| (\pagref{MIN::MULTI_VALUED}) if the value multiset
has more than one value.

The {\tt min::\EOL get\_\EOL flags}
function returns the control codes in the flag set pointed at and stores
these in the \verb|min::gen| vector `{\tt out}'.
The total number of control codes in the flag set is returned
(regardless of the value of {\tt n}).
The argument {\tt n}, the length of `{\tt out}',
the maximum number of control codes that may be returned in `{\tt out}'.
If there are more then {\tt n} control codes, only the first {\tt n}
are returned in `{\tt out}'.
If {\tt n==0} the function just returns
the number of control codes in the flag set.

In all of this, high order zero control codes are treated as if
they did not exist (control codes are stored lowest order first
in `{\tt out}').  If there are no non-zero flags, no control codes
are stored in `{\tt out}', and {\tt 0} is returned as the number of
control codes.

In the `{\tt out}' vector, flag $N$ is the bit selected by mask $2^K$
in the vector element with index $I$, where $K=N~\mbox{mod}~\mbox{\tt VSIZE}$
and $I=\mbox{floor}(N/\mbox{\tt VSIZE})$.
If there are $J$ control codes
in the flag set, and $N\geq J*\mbox{\tt VSIZE}$, then
flag $N$ is zero.

The {\tt min::\EOL test\_\EOL flag} function returns the value
of flag {\tt n}.

The attribute names for an object form a list ordered in an implementation
dependent fashion.  
The {\tt min::\EOL get\_\EOL attrs} function gets information about each
attribute in this list.  The information about an attribute is stored in a
{\tt min::\EOL attr\_\EOL info} structure and includes the attribute
name in the {\tt name} member,
the number of values in the attribute value multiset in the {\tt value\_count}
member, the number of control codes in the attribute flag set in
the {\tt flag\_count} member, and the number of associated
reverse attribute names which have non-empty value multisets in the
{\tt reverse\_attr\_count} member.
If a name as only one component that is an {\em atom}, the name is returned
as that {\em atom}; all other names are returned as {\em labels}.
At least one of the three counts must be
non-zero for an attribute, or else the attribute is treated as if it
were not in the list of all attribute names.  In computing
{\tt flag\_count}, high order zero control codes are treated as if they
did not exist, and the value of {\tt flag\_count} is the
same as the value that would be returned by {\tt min::\EOL get\_\EOL flags}.

The {\tt min::\EOL attr\_\EOL info} structs are stored in a packed vector
returned by the {\tt min::\EOL get\_\EOL attrs} function
as a \verb|min::gen| value.  This can be accessed by a read-only
packed vector pointer (\pagref{MIN::PACKED_VEC_POINTER_OF_GEN})
of {\tt min::\EOL attr\_\EOL info\_\EOL pointer} type.
Sample usage is:
\begin{indpar}\begin{verbatim}
min::gen airv = min::get_attrs ( ... );
min::attr_info_pointer aip ( airv );
for ( min::unsptr i = 0; i < aip->length; ++ i )
{
    min::attr_info ai = aip[i];
    . . . . . . . . . . . . . .
}
\end{verbatim}\end{indpar}\label{ATTR-INFO-POINTER-EXAMPLE}

The implementation dependent order of the \verb|attr_info|
values returned by {\tt min::\EOL get\_\EOL attrs} may change if attribute
values are added to or removed from the object or
attribute flags are set or cleared, or if the object is reorganized.
The {\tt min::\EOL sort\_\EOL attr\_\EOL info} function can be used
to sort by attribute name
the packed vector returned by {\tt min::\EOL get\_\EOL attrs}.
A {\tt min::\EOL attr\_\EOL info} packed vector can be manipulated in other
ways using its packed vector type information in
{\tt min::\EOL attr\_\EOL info\_\EOL vec}
and {\tt min::\EOL attr\_\EOL info\_\EOL vec\_\EOL type}:
see Section~\secref{PACKED-STRUCTURES-AND-VECTORS}.

The {\tt min::\EOL get\_\EOL reverse\_\EOL attrs}
function is analogous but involves the list of
reverse attribute names associated
with a particular object and attribute name stored in the attribute
pointer.  In this case there is a {\tt min::\EOL reverse\_\EOL
attr\_\EOL info} struct for each reverse attribute name, and there is only
one count member in this, the {\tt value\_count} member that is the number
of values in the value multiset of the reverse attribute pointed at.
A reverse attribute name with an empty value multiset is treated as if it
were not in the list of reverse attribute names.

Updatable attribute pointers can set existing values as well as perform
the operations of read-only attribute pointers.
The functions for using a
{\tt min::\EOL updatable\_\EOL attr\_\EOL pointer}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|MUP::|
	& \MUPKEY{updatable\_attr\_pointer} \verb|ap|\ARGBREAK
	  \verb| ( min::updatable_vec_pointer & vp )|
\LABEL{MUP::UPDATABLE_ATTR_OF_UPDATABLE_VEC_POINTER} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::updatable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_UPDATABLE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::updatable_attr_pointer & ap,|\ARGBREAK
	  \verb|   int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_UPDATABLE_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::updatable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_UPDATABLE_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::updatable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_UPDATABLE_ATTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb| ( min::updatable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_UPDATABLE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb| ( min::updatable_attr_pointer & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_UPDATABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|   min::updatable_attr_pointer ap )|
\LABEL{MIN::GET_OF_UPDATABLE_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::updatable_attr_pointer ap )|
\LABEL{MIN::GET1_OF_UPDATABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb| ( min::gen * out, unsigned n,|\ARGBREAK
    \verb|   min::updatable_attr_pointer ap )|
\LABEL{MIN::GET_FLAGS_OF_UPDATABLE_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb| ( min::updatable_attr_pointer wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_UPDATABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{get\_attrs}\ARGBREAK
    \verb| ( min::updatable_attr_pointer ap )|
\LABEL{MIN::GET_ATTRS_OF_UPDATABLE} \\
\verb|min::gen min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
    \verb| ( min::updatable_attr_pointer ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_UPDATABLE} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb| ( min::updatable_attr_pointer wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::UPDATE_OF_UPDATABLE_ATTR} \\
\end{tabular}\end{indpar}

Functions defined for read-only attribute pointers are also
applicable to updatable list pointers with the
same results.  However, updatable list pointers
can\underline{not} be converted to be read-only list pointers
(unlike the situation with vector pointers).

The {\tt min::\EOL update} function requires that the current
value multiset have a single value and that it be the value multiset
of an attribute, and not a reverse attribute.
This function replaces the single value, returning the previous value.
It is an error if the value multiset is empty or has more than one
value, or if the attribute pointer
reverse attribute name is not \verb|min::NONE|.

Insertable attribute pointers can remove and insert values and
set and clear flags,
as well as perform the operations of updatable attribute pointers.
The functions for using a
{\tt min::\EOL insertable\_\EOL attr\_\EOL pointer}
are:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|MUP::|
	& \MUPKEY{insertable\_attr\_pointer} \verb|ap|\ARGBREAK
	  \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MUP::INSERTABLE_ATTR_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::insertable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::gen name )|
\LABEL{MIN::LOCATE_ATTR_OF_INSERTABLE_ATTR} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::insertable_attr_pointer & ap,|\ARGBREAK
	  \verb|   int name )|
\LABEL{MIN::LOCATEI_ATTR_OF_INSERTABLE_ATTR_OF_INT} \\
\verb|void min::|
	& \MINKEY{locatei}\ARGBREAK
	  \verb| ( min::insertable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::unsptr name )|
\LABEL{MIN::LOCATEI_ATTR_OF_INSERTABLE_ATTR_OF_UNSPTR} \\
\verb|void min::|
	& \MINKEY{locate}\ARGBREAK
	  \verb| ( min::insertable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::unsptr & length, min::gen name )|
\LABEL{MIN::LOCATE_PARTIAL_OF_INSERTABLE_ATTR} \\
\verb|void min::|
	& \MINKEY{locate\_reverse}\ARGBREAK
	  \verb| ( min::insertable_attr_pointer & ap,|\ARGBREAK
	  \verb|   min::gen reverse_name )|
\LABEL{MIN::LOCATE_REVERSE_OF_INSERTABLE_ATTR} \\
\verb|void min::|
	& \MINKEY{relocate}\ARGBREAK
	  \verb| ( min::insertable_attr_pointer & ap )|
\LABEL{MIN::RELOCATE_ATTR_OF_INSERTABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::gen * out, min::unsptr n,|\ARGBREAK 
    \verb|   min::insertable_attr_pointer ap )|
\LABEL{MIN::GET_OF_INSERTABLE_ATTR} \\
\verb|min::gen min::| & \MINKEY{get}\ARGBREAK
    \verb| ( min::insertable_attr_pointer ap )|
\LABEL{MIN::GET1_OF_INSERTABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|unsigned min::| & \MINKEY{get\_flags}\ARGBREAK
    \verb| ( min::gen * out, unsigned n,|\ARGBREAK
    \verb|   min::insertable_attr_pointer ap )|
\LABEL{MIN::GET_FLAGS_OF_INSERTABLE_ATTR} \\
\verb|bool min::| & \MINKEY{test\_flag}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::TEST_FLAG_OF_INSERTABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{get\_attrs}\ARGBREAK
    \verb| ( min::insertable_attr_pointer ap )|
\LABEL{MIN::GET_ATTRS_OF_INSERTABLE} \\
\verb|min::gen min::| & \MINKEY{get\_reverse\_attrs}\ARGBREAK
    \verb| ( min::insertable_attr_pointer ap )|
\LABEL{MIN::GET_REVERSE_ATTRS_OF_INSERTABLE} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen min::| & \MINKEY{update}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::UPDATE_OF_INSERTABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::SET_OF_INSERTABLE_ATTR} \\
\verb|void min::| & \MINKEY{set\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::SET1_OF_INSERTABLE_ATTR} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{add\_to\_set\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_set\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::ADD1_TO_SET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::ADD_TO_MULTISET} \\
\verb|void min::| & \MINKEY{add\_to\_multiset\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::ADD1_TO_MULTISET} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ONE} \\
\verb|min::unsptr min::| & \MINKEY{remove\_one}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::REMOVE_ONE1} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, min::unsptr n )|
\LABEL{MIN::REMOVE_ALL} \\
\verb|min::unsptr min::| & \MINKEY{remove\_all}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   min::gen v )|
\LABEL{MIN::REMOVE_ALL1} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::| & \MINKEY{set\_flags\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::SET_FLAGS_OF_INSERTABLE} \\
\verb|void min::| & \MINKEY{set\_some\_flags\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::SET_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{clear\_some\_flags\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::CLEAR_SOME_FLAGS} \\
\verb|void min::| & \MINKEY{flip\_some\_flags\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   const min::gen * in, unsigned n )|
\LABEL{MIN::FLIP_SOME_FLAGS} \\
\end{tabular}\end{indpar}

\begin{indpar}\begin{tabular}{r@{}l}
\verb|bool min::| & \MINKEY{set\_flag\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::SET_FLAG} \\
\verb|bool min::| & \MINKEY{clear\_flag\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::CLEAR_FLAG} \\
\verb|bool min::| & \MINKEY{flip\_flag\REL}\ARGBREAK
    \verb| ( min::insertable_attr_pointer wap,|\ARGBREAK
    \verb|   unsigned n )|
\LABEL{MIN::FLIP_FLAG} \\
\end{tabular}\end{indpar}

Functions defined for updatable attribute pointers are also
applicable to insertable list pointers with the
same results.  However, insertable list pointers
can\underline{not} be converted to be updatable or read-only list pointers
(unlike the situation with vector pointers).

The {\tt min::\EOL set}
function sets all the values in the value multiset the
attribute pointer is pointing at, deleting any previous values.
For 3-argument {\tt min::\EOL set}
the new values are given in the `{\tt in}' vector, and
the number of values is given in {\tt n}.  If {\tt n} is zero, all
values are deleted.
For 2-argument {\tt min::\EOL set} there is one new value given as an
argument, unless {\tt v} is \verb|min::NONE|,
in which case there are no new values and all previous values are simply
deleted.

For the {\tt min::\EOL set} function the
pointer's reverse attribute name can be \verb|min::NONE|
but cannot be \verb|min::ANY|, which the exception of the case
where all values are being deleted.  If the reverse attribute name
is \verb|min:ANY| and the {\tt min::\EOL set} function is called to
delete all previous values,
all double arrows with the current attribute name and any
reverse attribute name are deleted.

The {\tt min::\EOL add\_\EOL to\_\EOL set} function
adds values to the multiset set of values,
but adds each value if and only if the value is not already in the multiset,
using {\tt ==} to compare values for equality.
The {\tt min::\EOL add\_\EOL to\_\EOL multiset} function
adds values even if they are already in the multiset.
Both functions have a 3-argument version with a vector of new values,
and a 2-argument version with a single new value.  In the latter case
if {\tt v} is \verb|min::NONE| there is no new value and the function
is a no-operation.
For these functions the pointer's reverse attribute name
can be \verb|min::NONE|
but cannot be \verb|min::ANY|.

The {\tt min::\EOL remove\_\EOL one} function
removes values from the multiset set of values, removing only one copy of
each value,
using {\tt ==} to compare values for equality.
The {\tt min::\EOL remove\_\EOL all} function
removes all copies of each value  
from the multiset of values (it may be less efficient if
the multiset is actually a set).
Both functions have a 3-argument version with a vector of values to remove,
and a 2-argument version with a single value to remove.  In the latter case
if {\tt v} is \verb|min::NONE| there is no value to remove and the function
is a no-operation.  These functions return the number of values actually
removed from the multiset of values.
For these functions the pointer's reverse attribute name
can be \verb|min::NONE| but cannot be \verb|min::ANY|.

Note that attribute values cannot be control codes, and reverse attribute
values must be pointers to objects.

If the attribute pointer is pointing at a multiset of values
associated with a reverse attribute name,
the values represent double arrows.
In this case, let the object being pointed at by the attribute pointer be $O_1$,
the pointer attribute name be $N$, and the pointer reverse
attribute name be $R$.
If a double arrow value pointing at object $O_2$ is set or removed, the value
pointing at $O_1$ will also be set or removed from the attribute named
$R$ with
reverse attribute name $N$ of the object $O_2$.  That is, the other end of
the double arrow will also be set or removed.
In the unusual special case where $O_1=O_2$ and also $N=R$, only one value
pointing at $O_1=O_2$ is put in the reverse attribute multiset; that
is, this value is \underline{not} duplicated.

The {\tt min::\EOL set\_\EOL flags} function sets the control codes
of the flag set the attribute pointer points at.
The new control codes are given in the `{\tt in}' vector which
has length {\tt n}: see the discussion of
{\tt min::\EOL get\_\EOL flags} on \pagref{MIN::GET_FLAGS_OF_ATTR}
for the format of this vector.
If the previous flag set had more control codes that the new flag
set, the extra control codes will be retained but will be zeroed.
If {\tt n} is zero, all existing control codes are zeroed.
When the object is reorganized, high order zero control codes will
be deleted.

The {\tt min::\EOL set\_\EOL some\_\EOL flags},
{\tt min::\EOL clear\_\EOL some\_\EOL flags},
and {\tt min::\EOL flip\_\EOL some\_\EOL flags}
functions can be used to alter flags.  If the bit corresponding
to the flag is on in the `{\tt in}' vector, it is set, cleared,
or flipped, respectively.

The {\tt min::\EOL set\_\EOL flag},
{\tt min::\EOL clear\_\EOL flag},
and {\tt min::\EOL flip\_\EOL flag}
functions can be used to alter a single flag whose number is
given as the argument {\tt n}.  The flag is set, cleared,
or flipped, respectively.  The previous value of the flag is
returned.

TBD: The `{\tt min::\EOL publish\REL}' function.\label{MIN::PUBLISH}

TBD: resize functions\label{MIN::RESIZE_OF_ATTR}.

\subsection{Packed Structures and Vectors}
\label{PACKED-STRUCTURES-AND-VECTORS}

\newcommand{\BRACKETED}[1]{{\tt \LESSTHAN #1\GREATERTHAN}}
\newcommand{\SARG}{\BRACKETED{S}}
\newcommand{\HEARG}{\BRACKETED{H,E}}

A \key{packed structure} is a C datum, usually a `struct', stored in a body.
A \key{packed vector} is such a datum, called the \key{packed vector header},
at the beginning of a body, followed in the body by
a variable sized vector whose elements are also C data but are normally
of a different C type from the header.

The C type of a packed structure, packed vector header, or packed
vector elements must be a C type whose data can be initialized by setting
their bytes to all zeros and can be copied by \verb|memcpy|.
The C type of a packed structure or packed vector header must be a
C \verb|struct| whose first member is
\begin{center}
\verb|const min::uns32 type;|
\end{center}
This first member holds type information and flags.
\verb|min::gen| and \verb|min::stub *| values are permitted as members
of \verb|struct|s or as vector element types by themselves.
C++ classes are not permitted, as the types must \underline{not}
have constructors or destructors and must be copyable with
a simple `{\tt =}' operator or with the \verb|memcpy| function.

There are also special pointer-to-packed-struct types:
\begin{indpar}
\verb|min::packed_struct<S>::ptr| \\
\verb|min::packed_struct<S>::updptr|
\end{indpar}
and pointer-to-packed-vector types:
\begin{indpar}
\verb|min::packed_vec<H,E>::ptr| \\
\verb|min::packed_vec<H,E>::updptr| \\
\verb|min::packed_vec<H,E>::insptr|
\end{indpar}
These are like the type `\verb|const min::stub *|' but with with extra
clothes.
Members of these types can also be included in C packed structures
and packed vectors.

The C type of a packed structure is described by a
{\tt min::packed\_\EOL struct\SARG} C++ static object, where
\verb|S| is the C type of the structure.  The {\tt new\_gen}
member function of this C++ static object can be
used to create new packed structures of that type.
There are two kinds of pointers that can be used to
access members of packed structures.
A read-only {\tt min::\EOL packed\_\EOL struct\SARG::\EOL ptr}
pointer permits read-only access to packed structure members.
An {\tt min::\EOL packed\_\EOL struct\SARG::\EOL updptr}
updatable pointer
permits read-write access to packed structure members.

The situation is similar for a packed vector, whose C type is
described by a
{\tt min::packed\_\EOL vec\HEARG} C++ static object, where
\verb|H| is the C type of the packed vector header and \verb|E| is the C type
of the packed vector element.  The read-only and updatable pointers
permit access to both the header members and vector elements.
There is also a third kind of pointer,
the {\tt min::\EOL packed\_\EOL struct\HEARG::\EOL
insptr} insertable pointer,
that permits read-write access to packed vector header members and
vector elements and also permits pushing and popping vector elements
and resizing the vector.

More explicitly, to create a new type of \key{packed structure}
named \verb|pstype| use

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\SARG} \verb|pstype| \ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * stub_ptr_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT} \\
\verb|min::uns32 min::| & \MINNBKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINNBKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen |
	& \verb|pstype.|\TTKEY{new\_gen} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\verb|const char * const |
	& \verb|pstype.|\TTMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const |
	& \verb|pstype.|\TTMKEY{gen\_disp}
	                       {in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pstype.|\TTMKEY{stub\_ptr\_disp}
	                       {in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_PTR_DISPLACEMENTS} \\
\end{tabular}\end{indpar}

where

\begin{indpar}[1in]
\begin{itemize}

\item[{\tt S}]
The C type of the body of packed structures of the type being
declared.  This C type must be a C \verb|struct| whose first
member is
\begin{center}
\verb|const min::uns32 type;|
\end{center}
This member holds a code effectively
points at \verb|pstype|, and also holds some flags.
This member is initialized by \verb|new_gen| and must not
be changed by the user.

\item[\ttmkey{name}{in {\tt min::packed\_struct}}]
A name unique to the \verb|pstype| datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed structure type when a packed structure is
output.

\item[\ttmkey{gen\_disp}{in {\tt min::packed\_struct}}]
This C vector is a list of the displacements (in bytes) of all
the \verb|min::gen| members of \verb|S|,
terminated by the value {\tt min::DISP\_END}\minindex{DISP\_END}.
The displacement of member \verb|m| in structure type \verb|S| should
be computed by {\tt min::\EOL DISP~(~\&~S::m~)}.

This displacements vector should not
be given (its address should be \verb|NULL|) if there are no \verb|min::gen|
values in \verb|S|.  But if there are \verb|min::gen| members, this
displacements vector must be given for garbage collection purposes.

\verb|const min::gen| members are treated like \verb|min::gen|
members for these purposes.

\item[\ttmkey{stub\_ptr\_disp}{in {\tt min::packed\_struct}}]
Ditto but for \verb|min::stub *| members of \verb|S|
instead of \verb|min::gen| members.

Pointer-to-packed-struct and pointer-to-packed-vector
members, such as {\tt min::\EOL packed\_struct\SARG::\EOL pointer} members,
are treated like `{\tt const min::stub~*}' values in that they
must be listed in {\tt stub\_\EOL ptr\_\EOL disp}.

`\verb|const min::stub *|', `\verb|min::stub const *|', and
`{\tt const min::stub \EOL const~*}' members are treated like
`{\tt min::stub~*}' members for these purposes.

\end{itemize}
\end{indpar}

The \verb|pstype.new_gen| function creates a new packed structure
datum of the C type described by \verb|pstype| and returns a
\verb|min::gen| value pointing at it.  The new packed structure
is set to all zeros.

The function call {\tt min::\EOL DISP~(~\&~S::m~)} will return the
displacement in bytes of the member \verb|m| of a structure
of \verb|struct| type \verb|S|.  This should be used instead of
assuming that \verb|struct| layouts are tightly packed, as often
they are not.  The type of the \verb|S::m| member must be one of
the types mentioned above: \verb|min::gen|, `{\tt const min::stub~*}',
{\tt min::\EOL packed\_\EOL struct\SARG::\EOL ptr}, etc.

\verb|pstype.name|, {\tt pstype.gen\_\EOL disp},
and {\tt pstype.stub\_\EOL ptr\_\EOL disp}
can be used to retrieve the name and displacement
information associated with \verb|pstype|.

There are two kinds of pointers that can be used to access
a packed structure, and these have the usage:

\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( const min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_ptr\SARG} \verb|psp|
	  \verb| ( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_ptr|{\tt \SARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::ptr}
\LABEL{MIN::PACKED_STRUCT_PTR_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}l@{}l}
 \verb|min::packed_struct<S>::ptr & |
	& \TTKEY{operator =}\ARGBREAK
	  \verb| ( min::packed_struct<S>|\ARGBREAK
	  \verb|      ::ptr & psp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_GEN} \\
\verb|min::packed_struct<S>::ptr & |
	& \TTKEY{operator =}\ARGBREAK
	  \verb| ( min::packed_struct<S>|\ARGBREAK
	  \verb|      ::ptr & psp,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_PTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|const min::stub * |
	& \TTKEY{operator const min::stub *} \ARGBREAK
          \verb| ( const min::packed_struct<S>::ptr & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_TO_MIN_STUB} \\
\verb|const * S | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_struct<S>::ptr & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_CONVERSION} \\
\verb|const & S | & \TTKEY{operator *} \ARGBREAK
	  \verb| ( min::packed_struct<S>::ptr & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_DEREFERENCE} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup| \ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updptr\SARG} \verb|psup|
	               \verb|( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_updptr|{\tt \SARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::updptr}
\LABEL{MIN::PACKED_STRUCT_UPDPTR_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{@{}l@{}l}
 \verb|min::packed_struct<S>::updptr & |
	& \TTKEY{operator =}\ARGBREAK
	  \verb| ( min::packed_struct<S>|\ARGBREAK
	  \verb|       ::updptr & psup,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_GEN} \\
\verb|min::packed_struct<S>::updptr & |
	& \TTKEY{operator =}\ARGBREAK
	  \verb| ( min::packed_struct<S>|\ARGBREAK
	  \verb|      ::updptr & psup,|\ARGBREAK
	  \verb|   const min::stub * s )|
\LABEL{MIN::=_PACKED_STRUCT_UPDPTR_OF_STUB} \\
\end{tabular}\end{indpar}
\begin{indpar}[0.1in]\begin{tabular}{r@{}l}
\verb|const min::stub * |
	& \TTKEY{operator const min::stub *} \ARGBREAK
          \verb| ( const min::packed_struct<S>::updptr & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_TO_MIN_STUB} \\
\verb|* S | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_struct<S>::updptr & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_CONVERSION} \\
\verb|& S | & \TTKEY{operator *} \ARGBREAK
	  \verb| ( min::packed_struct<S>::updptr & psup )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_DEREFERENCE} \\
\verb|const min::stub * | & \MINNBKEY{NULL\_STUB}
\LABEL{MIN::NULL_STUB} \\
\end{tabular}\end{indpar}

A {\tt min::\EOL packed\_\EOL struct\SARG::\EOL ptr} value is just
a `{\tt const min::stub~*}' value in fancy clothes,
and similarly a {\tt min::\EOL packed\_\EOL struct\SARG::\EOL updptr} value.
Both pointer values may be converted to/from
`{\tt const min::stub~*}' values.

A {\tt min::\EOL packed\_\EOL struct\SARG::\EOL ptr} value is internally
also a `\verb|const ** S|' value that is made to behave externally like a
also a `\verb|const * S|' value with respect to the \verb|->| and
unary \verb|*| operators.  Thus looking ahead at the example below,
if \verb|upv| is a
{\tt min::\EOL packed\_\EOL struct\SARG::\EOL ptr} value
and \verb|S| has a member \verb|i|, then \verb|upv->i| is the \verb|i|
member of the \verb|S| struct pointed at by \verb|upv|.
Similarly a {\tt min::\EOL packed\_\EOL struct\SARG::\EOL updptr} value
is internally also a `\verb|** S|' value that is made to behave
externally like a also a `\verb|* S|' value with respect to the \verb|->| and
unary \verb|*| operators.

The names {\tt min::\EOL packed\_\EOL struct<S>::\EOL ptr} and
{\tt min::\EOL packed\_\EOL struct<S>::\EOL updptr} are
usually used for pointer types (see example below).  However, in certain
circumstances, such as inside a {\tt template} class, these will not
work, due either to problems with the C++ standard or its implementation,
so you may have to use the less attractive
{\tt min::\EOL packed\_\EOL struct\_\EOL ptr<S>} and
{\tt min::\EOL packed\_\EOL struct\_\EOL updptr<S>} in
these circumstances.

For the constructors and the {\tt =} assignment operator \verb|v| or
\verb|s| must point at packed structure, or \verb|s| must equal
\verb|min::NULL_STUB|, which is just the standard C language \verb|NULL|
cast to the `\verb|const min::stub *|' type.  This cast is necessary
as \verb|NULL| by inself can be converted to either a `\verb|min::stub *|'
or \verb|min::gen| type and is thus ambiguous when used in a constructor
or on the right side of \verb|=|.

If constructors for {\tt min::\EOL packed\_\EOL struct<S>::\EOL ptr} or
{\tt min::\EOL packed\_\EOL struct<S>::\EOL updptr} are
not given an argument, these pointers are set to
\verb|min::NULL_STUB|.  Such pointers give undefined results if
used, though most frequently the result will be a memory fault.

An example use of a packed structure is:
\begin{indpar}\begin{verbatim}
struct ps;
typedef min::packed_struct<ps> pst;
struct ps {
    min::uns32 type;
    min::uns32 i;
    min::uns32 j;
    min::gen g;
    pst::ptr pv;
    min::stub * s;
};

static min::uns32 ps_gen_disp[2] =
    { min::DISP(&ps::g), min::DISP_END };
static min::uns32 ps_stub_ptr_disp[2] =
    { min::DISP(&ps::s), min::DISP(&ps::pv), min::DISP_END };

static pst pstype
    ( "pstype", ps_gen_disp, ps_stub_ptr_disp );

main ( ... )
{
    . . . . . . .
    min::gen v1 = pstype.new_gen();
    pst::updptr upv ( v1 );
    upv->i = 55;
    upv->j = 99;
    upv->g = min::new_str_gen ( "Hello" );

    pst::ptr pv = upv;
    // Upv is converted to a `const min::stub *' value
    // that is used to set pv.

    upv->pv = pv;
    upv = pstype.new_gen();
    // Now upv->i == 0, pv->i == 55, pv->pv->i == 55,
    //     upv->pv == min::NULL_STUB

    . . . . . . .
}
\end{verbatim}\end{indpar}

A packed vector is like a packed structure but with an added vector.
More explicitly, to create a new type of \key{packed vector}
named \verb|pvtype| use

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\HEARG} \verb|pvtype| \ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * element_stub_ptr_disp| \ARGBREAK
	  \verb|                            = NULL,| \ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL )|
\LABEL{MIN::PACKED_VEC} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::gen |
	& \verb|pvtype.|\TTKEY{new\_gen} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|min::gen |
	& \verb|pvtype.|\TTKEY{new\_gen} \ARGBREAK
	  \verb| ( min::uns32 max_length,| \ARGBREAK
	  \verb|   min::uns32 length = 0,| \ARGBREAK
	  \verb|   const E * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const char * const |
	& \verb|pvtype.|\TTMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{header\_gen\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{header\_stub\_ptr\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_PTR_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{element\_gen\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{element\_stub\_ptr\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_PTR_DISPLACEMENTS} \\[1ex]
\verb|min::uns32 |
	& \verb|pvtype.|\TTMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 |
	& \verb|pvtype.|\TTMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 |
	& \verb|pvtype.|\TTMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{tabular}\end{indpar}

where

\begin{indpar}[0.5in]
\begin{itemize}

\item[{\tt H}]\label{PACKED_VEC_HEADER_TYPE}
The C \verb|struct| type of the header data at the beginning of the
bodies of packed vectors of the type being
declared.  The first member of this \verb|struct| type must be
\begin{indpar}
\verb|const min::uns32 type;|
\end{indpar}
and the \verb|struct| type must also have the two members
\begin{indpar}
\verb|const min::uns32 length;| \\
\verb|const min::uns32 max_length;|
\end{indpar}
These members are initialized by \verb|new_gen| and must not
be changed by the user.

\item[{\tt E}]\label{PACKED_VEC_ELEMENT_TYPE}
The C type of the elements in the vector part of the
bodies of packed vectors of the type being
declared.  This need not be a \verb|struct| type; it can
be \verb|min::gen|, \verb|min::stub *| or any numeric type.

\item[\ttmkey{name}{in {\tt min::packed\_vec}}]
A name unique to the \verb|pvtype| datum, typically the
fully qualified name of this datum.  This character string may
be output to identify the packed vector type when a packed vector is
output.

\end{itemize}
\end{indpar}

\begin{indpar}[1.7in]
\begin{itemize}

\item[\ttmkey{header\_gen\_disp}{in {\tt min::packed\_vec}}]
This C vector is a list of the displacements (in bytes) of all
the \verb|min::gen| members of \verb|H|,
terminated by the value {\tt min::DISP\_\EOL END}\minindex{DISP\_END}.
This displacements vector should not
be given (its address should be \verb|NULL|) if there are no \verb|min::gen|
values in \verb|H|.  But if there are \verb|min::gen| members, this
displacements vector must be given for garbage collection purposes.

\item[\ttmkey{header\_stub\_ptr\_disp}{in {\tt min::packed\_vec}}]
Ditto but for \verb|min::stub *| members of \verb|H|.

\item[\ttmkey{element\_stub\_ptr\_disp}{in {\tt min::packed\_vec}}]
Ditto but for \verb|min::gen| members of \verb|E|.

\item[\ttmkey{element\_stub\_ptr\_disp}{in {\tt min::packed\_vec}}]
Ditto but for \verb|min::stub *| members of \verb|E|.

\end{itemize}
\end{indpar}

\verb|pvtype.name|,~~
{\tt pvtype.header\_\EOL gen\_\EOL disp},
{\tt pvtype.header\_\EOL stub\_\EOL ptr\_\EOL disp},
~~{\tt pvtype.ele\-\EOL ment\_\EOL gen\_\EOL disp},
and {\tt pvtype.ele\-\EOL ment\_\EOL stub\_\EOL ptr\_\EOL disp}
can be used to retrieve the name and displacement
information associated with \verb|pvtype|.
In addition the parameters
{\tt pvtype.ini\-tial\_\EOL max\_\EOL length},
{\tt pvtype.increment\_\EOL ratio}, and
{\tt pvtype.max\_\EOL increment}
may be set by the user:

\begin{indpar}[1.4in]
\begin{itemize}

\item[\ttmkey{initial\_max\_length}{in {\tt min::packed\_vec}}]
The maximum length of a packed vector newly created by calling the
\verb|pvtype.new_gen| function with no arguments.  Defaults to \verb|1000|.

\item[\ttmkey{increment\_ratio}{in {\tt min::packed\_vec}}]
The \verb|min::reserve| function multiplies the old maximum length by
this ratio to get the maximum length increment: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \verb|0.5|.

\item[\ttmkey{max\_increment}{in {\tt min::packed\_vec}}]
The maximum increment of the maximum length computable by the
\verb|min::reserve| function: see formula on
\pagref{PACKED-VEC-EXPANSION-FORMULA}.  Defaults to \verb|1000|.

\end{itemize}
\end{indpar}

The \verb|pvtype.new_gen| function creates a new packed vector
datum of the C type described by \verb|pvtype| and returns a
\verb|min::gen| value pointing at it.  A packed vector has a
\mkey{length}{of packed vector} which is the number of elements
currently in the packed vector.  It also has a
\mkey{maximum length}{of packed vector} which is the maximum length
allowed before the packed vector must be reallocated.
The \verb|pvtype.new_gen| function may be given the maximum length
and length and a vector of length type \verb|E| elements that is copied
to the initial value of the packed vector.
If the vector \verb|vp| of initial elements is given as \verb|NULL|,
the initial elements will be zeros.
If no parameters are given to
\verb|pvtype.new_gen|,
the length defaults to \verb|0| and
the maximum length defaults to {\tt pvtype.initial\_\EOL max\_\EOL length}.

There are three kinds of pointers that can be used to access
a packed vector, and these have the usage:

\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_pointer\HEARG} \verb|pvp| \ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_pointer\HEARG} \verb|pvp| \ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_pointer\HEARG} \verb|pvp|
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_POINTER_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_pointer|{\tt \HEARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\HEARG::pointer}
\LABEL{MIN::PACKED_VEC_POINTER_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp )|
\LABEL{MIN::DEINITIALIZE_PACKED_VEC_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updatable\_pointer\HEARG} \verb|pvup|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updatable\_pointer\HEARG} \verb|pvup|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updatable\_pointer\HEARG} \verb|pvup| \ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_updatable_pointer|{\tt \HEARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\HEARG::updatable\_pointer}
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_UPDATABLE_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_UPDATABLE_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup )|
\LABEL{MIN::DEINITIALIZE_PACKED_VEC_UPDATABLE_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insertable\_pointer\HEARG} \verb|pvip|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insertable\_pointer\HEARG} \verb|pvip|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insertable\_pointer\HEARG} \verb|pvip| \ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_insertable_pointer|{\tt \HEARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\HEARG::insertable\_pointer}
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_TYPEDEF} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_INSERTABLE_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_INSERTABLE_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip )|
\LABEL{MIN::DEINITIALIZE_PACKED_VEC_INSERTABLE_POINTER} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const H * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp )|
\LABEL{MIN::PACKED_VEC_POINTER_CONVERSION} \\
\verb|H * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_CONVERSION} \\
\verb|H * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_CONVERSION} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 | & \verb|pvp->length|
\LABEL{MIN::PACKED_VEC_POINTER_LENGTH} \\
\verb|const min::uns32 | & \verb|pvup->length|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_LENGTH} \\
\verb|const min::uns32 | & \verb|pvip->length|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_LENGTH} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const min::uns32 | & \verb|pvp->max_length|
\LABEL{MIN::PACKED_VEC_POINTER_MAX_LENGTH} \\
\verb|const min::uns32 | & \verb|pvup->max_length|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_MAX_LENGTH} \\
\verb|const min::uns32 | & \verb|pvip->max_length|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_MAX_LENGTH} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|const E | & \verb|pvp[i]|
\LABEL{MIN::PACKED_VEC_POINTER_ELEMENT} \\
\verb|E | & \verb|pvup[i]|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_ELEMENT} \\
\verb|E | & \verb|pvip[i]|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_ELEMENT} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{push} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   const E & v )|
\LABEL{MIN::PACKED_VEC_PUSH} \\
\verb|void min::|
	& \MINKEY{push} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 n, const E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|E min::|
	& \MINKEY{pop} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{r@{}l}
\verb|void min::|
	& \MINKEY{resize} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{tabular}\end{indpar}

As for packed structures, packed vector pointers used as the left
operand of \verb|->| are converted to
`\verb|const H *|' or
`\verb|H *|'.  This can be used to access the `\verb|length|'
and \verb|max_length| members of the header.

In addition subscripting packed vector
pointers gives access to the elements of the vector.  The subscripting
operator \verb|[]| checks the index \verb|i| against the current length
of the vector to ensure the access is legal (e.g., \verb|pvp[i]|
checks \verb|0|$\leq$\verb|i|$<$\verb|pvp->length|).
The vector elements in a
packed vector are organized as a C language vector so that
\begin{center}
\verb|(& pvp[0])[i]| is the same as \verb|pvp[i]|
\end{center}
but the vector elements are stored in body whose address can change
if a relocating function is called, so saving C pointers to packed vector
elements is generally a bad idea.  However, temporary use within a single
statement is all right if the statement does not call a relocating
function.  For example, \verb|memcpy| can be used as follows to copy
from or to the vector:
\begin{indpar}\begin{verbatim}
memcpy ( ..., & pvp[0], sizeof ( E ) * pvp->length );
memcpy ( & pvup[0], ..., sizeof ( E ) * pvp->length );
\end{verbatim}\end{indpar}

Insertable packed vector pointers permit the current length and maximum
length of the vector to be changed.
The current vector length is \verb|pvp->length| and the maximum
length is \verb|pvp->max_length| (see description of \verb|H| on
\pagref{PACKED_VEC_HEADER_TYPE}).
The current length can be changed by {\tt min::\EOL push} and
{\tt min::\EOL pop} functions and the maximum length can be changed
by {\tt min::\EOL resize} and {\tt min::\EOL reserve} functions.  If
{\tt min::\EOL push} needs more space it automatically calls
{\tt min::reserve}.

The \verb|min::push| function adds elements
to the end of the packed vector
by incrementing the current vector length, and if this would
exceed the maximum length, first calls the \verb|min::reserve| function
with the number of elements to be pushed.
A single element \verb|v|
or a vector \verb|vp| of \verb|n| elements may be pushed.  In the
latter case new elements are placed within the packed vector in the same
memory order as they appear in the \verb|vp| vector.
Also, if \verb|vp| is \verb|NULL|, \verb|n| zeros are pushed.

The \verb|min::pop| function removes elements from the end of the
packed vector, decrementing the current vector length (which is checked
to be sure it is large enough).   A single element may be removed and
returned, or \verb|n| elements may be removed and returned in the
\verb|vp| vector.  In the latter case removed elements are placed in
\verb|vp| in the same memory order as they appeared in the packed vector.
Also,
if \verb|vp| is \verb|NULL|, the removed elements are simply discarded
instead of being copied.

The \verb|min::resize| function resets the maximum length.  If
the current length would be larger than the new maximum length,
the current length is reset to the new maximum length.

The \verb|min::reserve| function checks that
the current length plus the \verb|reserve_length| is
at most the maximum length, and if this check fails,
resets the maximum length according to the formula:
\begin{indpar}\begin{verbatim}
new_maximum_length = max ( length + reserve_length,
                           old_maximum_length
                           +
                           min ( pvtype.max_increment,
                                   pvtype.increment_ratio
                                 * old_maximum_length ) )
\end{verbatim}\end{indpar}\label{PACKED-VEC-EXPANSION-FORMULA}

An example use of a packed vector is:
\begin{indpar}\begin{verbatim}
struct pvh {
    const min::uns32 type;
          min::uns32 i;
    const min::uns32 length;
    const min::uns32 max_length;
};

struct pve {
    min::gen g;
    min::stub * s;
    min::uns8 j;
};

static min::uns32 pve_gen_disp[2] =
    { 0, min::DISP_END };
static min::uns32 pve_stub_ptr_disp[2] =
    { 0 + sizeof ( min::gen ), min::DISP_END };

typedef min::packed_vec<pvh,pve> pvt;
static pvt pvtype
    ( "pvtype", NULL, NULL,
      pve_gen_disp, pve_stub_ptr_disp );

main ( ... )
{
    min::gen v = pvtype.new_gen ( 5 );
    pvt::insertable_pointer pvip ( v );
        // pvip->max_length == 5
        // pvip->length == 0
    pve e1 = { min::MISSING, NULL, 88 };
    min::push ( pvip, e1 );
    pvt::pointer pvp ( v );
        // pvip->length == 1
        // pvp[1].j == 11

    pve e2[3] = { { min::MISSING, NULL, 11 },
                  { min::MISSING, NULL, 22 },
                  { min::MISSING, NULL, 33 } };
    min::push ( pvip, 3, e2 );
        // pvp[1].j == 11
        // pvp[2].j == 22
        // pvp[3].j == 33

    min::resize ( pvip, 10 );
        // pvp->max_length == 10

    pve e3, e4[3];
    e3 = min::pop ( pvip );
        // e3[0].j == 33
        // pvp->length == 3
    min::pop ( pvip, 2, e4 );
        // e4[0].j == 11
        // e4[1].j == 22
    e3 = min::pop ( pvip );
        // 3e.j == 88
}
\end{verbatim}\end{indpar}

Packed structure and vector pointers do no caching and
there is \underline{no need} for
a refresh function analogous to the {\tt min::\EOL \ldots\_\EOL refresh}
functions for list pointers (\pagref{LIST-POINTER-CACHE}).


\section{Code and Execution}

\subsection{Execution Flags}
\label{EXECUTION-FLAGS}

TBD: relocation flag

\section{TBD Implementation Ideas}


\subsection{Stack and not Ephemeral}

Instead of ephemeral, we use stack objects.  A stack stub is a stub that
is only reachable from pointers in the stack.   When a stack stub
pointer (as a general value) is stored in a non-stack object, the price
of tracing what it points at to make its target non-stack is paid.
This is a logical time to pay this cost.

\section{To Do}

\clearpage

\appendix

\centerline{\Large \bf Appendices}

\section{C/C++ Interface}
\label{C/C++-Interface}

{
\renewcommand{\LABEL}[1]{\dotfill~\pagref{#1}}
\renewcommand{\TTKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\TTNBKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MINKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MINNBKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\MUPKEY}[1]{{\tt ~~#1~~}}
\renewcommand{\ttkey}[1]{{\tt ~~#1~~}}
\renewcommand{\ARGBREAK}{\\&{\tt ~~~~}}
\newcommand{\INDEXHEADER}[1]{{\bf #1}:\vspace{1ex}}
\newlength{\TABULARLEN}
\newenvironment{TABULAR}[1]%
  {\setlength{\TABULARLEN}{6.2in}
   \addtolength{\TABULARLEN}{-#1}
   \begin{tabular}{@{}r@{}l@{}}
   \hspace*{#1} & \hspace*{\TABULARLEN} \\[-4ex]}%
  {\end{tabular}}

Unless otherwise noted, this interface is defined by \verb|min.h|.

\INDEXHEADER{Abbreviations}

These are to be included in user's code, and are \underline{not}
in \verb|min|\ldots\verb|.h| files.

\begin{indpar}[0.2in]
\begin{tabular}{@{}p{6.2in}@{}}
\verb|#define MUP  min::unprotected|
\LABEL{MUP} \\
\verb|#define MOS  min::os|
\LABEL{MOS} \\
\verb|#define MACC min::acc|
\LABEL{MACC} \\
\verb|#define MINT min::internal|
\LABEL{MINT} \\
\end{tabular}
\end{indpar}

\INDEXHEADER{Compilation Macros}

These are in \verb|min_parameters.h|.

\begin{indpar}[0.2in]

\begin{tabular}{@{}p{6.2in}@{}}
\TTNBKEY{MIN\_IS\_COMPACT}
\LABEL{MIN_IS_COMPACT} \\
\TTNBKEY{MIN\_MAX\_EPHEMERAL\_LEVELS}
\LABEL{MIN_MAX_EPHEMERAL_LEVELS} \\
\TTNBKEY{MIN\_IS\_LOOSE}
\LABEL{MIN_IS_LOOSE}	 \\
\TTNBKEY{MIN\_MAX\_NUMBER\_OF\_STUBS}
\LABEL{MIN_MAX_NUMBER_OF_STUBS} \\
\TTNBKEY{MIN\_STUB\_BASE}
\LABEL{MIN_STUB_BASE} \\
\TTNBKEY{MIN\_MAX\_RELATIVE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_RELATIVE_STUB_ADDRESS} \\
\TTNBKEY{MIN\_MAX\_ABSOLUTE\_STUB\_ADDRESS}
\LABEL{MIN_MAX_ABSOLUTE_STUB_ADDRESS} \\
\TTNBKEY{MIN\_PROTECT}
\LABEL{MIN_PROTECT} \\
\TTNBKEY{MIN\_ASSERT($e$)}
\LABEL{MIN_ASSERT} \\
\TTNBKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\TTNBKEY{MIN\_ALLOW\_PARTIAL\_ATTR\_LABELS}
\LABEL{MIN_ALLOW_PARTIAL_ATTR_LABELS} \\
\end{tabular}

\end{indpar}

\newpage

\INDEXHEADER{Types}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{uns8}
\LABEL{MIN::UNS8} \\
\verb|min::| & \MINKEY{int8}
\LABEL{MIN::INT8} \\
\verb|min::| & \MINKEY{uns16}
\LABEL{MIN::UNS16} \\
\verb|min::| & \MINKEY{int16}
\LABEL{MIN::INT16} \\
\verb|min::| & \MINKEY{uns32}
\LABEL{MIN::UNS32} \\
\verb|min::| & \MINKEY{int32}
\LABEL{MIN::INT32} \\
\verb|min::| & \MINKEY{float32}
\LABEL{MIN::FLOAT32} \\
\verb|min::| & \MINKEY{uns64}
\LABEL{MIN::UNS64} \\
\verb|min::| & \MINKEY{int64}
\LABEL{MIN::INT64} \\
\verb|min::| & \MINKEY{float64}
\LABEL{MIN::FLOAT64} \\
\verb|min::| & \MINKEY{unsptr}
\LABEL{MIN::UNSPTR} \\
\verb|min::| & \MINKEY{intptr}
\LABEL{MIN::INTPTR} \\
\verb|min::| & \MINKEY{unsgen}
\LABEL{MIN::UNSGEN} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|min::| & \MINKEY{stub}
\LABEL{MIN::STUB} \\
\verb|min::| & \MINKEY{gen}
\LABEL{MIN::GEN} \\
\verb|min::| & \MINKEY{unsgen}
\LABEL{MIN::UNSGEN}
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Constants}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|const unsigned min::| & \MINKEY{TSIZE}
\LABEL{MIN::TSIZE} \\
\verb|const unsigned min::| & \MINKEY{VSIZE}
\LABEL{MIN::VSIZE}
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Stub Type Codes}\label{STUB-TYPE-CODE-LIST}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
\verb|const int min::| & \MINKEY{DEALLOCATED}
\LABEL{MIN::DEALLOCATED} \\
\verb|const int min::| & \MINKEY{NUMBER}
\LABEL{MIN::NUMBER} \\
\verb|const int min::| & \MINKEY{SHORT\_STR}
\LABEL{MIN::SHORT_STR} \\
\verb|const int min::| & \MINKEY{LONG\_STR}
\LABEL{MIN::LONG_STR} \\
\verb|const int min::| & \MINKEY{LABEL}
\LABEL{MIN::LABEL} \\
\verb|const int min::| & \MINKEY{SHORT\_OBJ}
\LABEL{MIN::SHORT_OBJ} \\
\verb|const int min::| & \MINKEY{LONG\_OBJ}
\LABEL{MIN::LONG_OBJ} \\
\verb|const int min::| & \MINKEY{LIST\_AUX}
\LABEL{MIN::LIST_AUX} \\
\verb|const int min::| & \MINKEY{SUBLIST\_AUX}
\LABEL{MIN::SUBLIST_AUX} \\
\end{TABULAR}
\end{indpar}

\newpage

\INDEXHEADER{Stub Related Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|int min::| & \MINKEY{type\_of}\verb| ( const min::stub * s )|
\LABEL{MIN::TYPE_OF} \\[1ex]
\verb|bool min::| & \MINKEY{is\_collectible}\verb| ( int type )|
\LABEL{MIN::IS_COLLECTIBLE} \\[1ex]
\verb|bool min::| & \MINKEY{relocated\_flag}\verb| ( void )|
\LABEL{MIN::RELOCATED_FLAG} \\
\verb|bool min::| & \MINKEY{set\_relocated\_flag}\verb| ( bool value )|
\LABEL{MIN::SET_RELOCATED_FLAG} \\
\verb|class min::| & \MINKEY{relocated}
\LABEL{MIN::RELOCATED} \\
\verb|void min::| & \MINKEY{interrupt\REL}\verb| ( void )|
\LABEL{MIN::INTERRUPT} \\
\verb|void min::| & \MINKEY{deallocate\REL}\verb| ( min::stub * s )|
\LABEL{MIN::DEALLOCATE} \\
\verb|bool min::| & \MINKEY{is\_deallocated}\verb| ( const min::stub * s )|
\LABEL{MIN::IS_DEALLOCATED} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_stub}\verb| ( min::gen v )|
\LABEL{MIN::IS_STUB} \\
\verb|bool min::| & \MINKEY{is\_direct\_float\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_FLOAT} \\
\verb|bool min::| & \MINKEY{is\_direct\_int\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_INT} \\
\verb|bool min::| & \MINKEY{is\_direct\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_DIRECT_STR} \\
\verb|bool min::| & \MINKEY{is\_index}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDEX} \\
\verb|bool min::| & \MINKEY{is\_control\_code}\verb| ( min::gen v )|
\LABEL{MIN::IS_CONTROL_CODE} \\
\verb|bool min::| & \MINKEY{is\_special}\verb| ( min::gen v )|
\LABEL{MIN::IS_SPECIAL_CODE} \\
\verb|bool min::| & \MINKEY{is\_list\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_sublist\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST_AUX} \\
\verb|bool min::| & \MINKEY{is\_indirect\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_INDIRECT_AUX} \\
\verb|bool min::| & \MINKEY{is\_aux}\verb| ( min::gen v )|
\LABEL{MIN::IS_AUX} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{2.4in}
\verb|const min::stub * min::| & \MINKEY{stub\_of}\ARGBREAK
                        \verb| ( min::gen v )|
\LABEL{MIN::STUB_OF} \\
\verb|min::float64 min::|
    & \MINKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_FLOAT_OF} \\
\verb|min::int32 min::| & \MINKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_INT_OF} \\
\verb|min::uns64 min::| & \MINKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MIN::DIRECT_STR_OF} \\
\verb|min::unsgen min::| & \MINKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MIN::CONTROL_CODE_OF} \\
\verb|min::unsgen min::| & \MINKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MIN::SPECIAL_INDEX_OF} \\
\verb|min::unsgen min::| & \MINKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::LIST_AUX_OF} \\
\verb|min::unsgen min::| & \MINKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::SUBLIST_AUX_OF} \\
\verb|min::unsgen min::|
    & \MINKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MIN::INDIRECT_AUX_OF} \\[1ex]
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen min::| & \MINKEY{new\_gen}\verb| ( min::stub * s )|
\LABEL{MIN::NEW_GEN_OF_STUB} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_float\_gen\LOOSE}\verb| ( min::float64 v )|
\LABEL{MIN::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_direct\_int\_gen}\verb| ( int v )|
\LABEL{MIN::NEW_DIRECT_INT_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen\COMPACT}\verb| ( const char * p )|
\LABEL{MIN::NEW_DIRECT_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen min::| & \MINKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_INDEX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MIN::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MIN::NEW_SPECIAL_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_LIST_AUX_GEN} \\
\verb|min::gen min::| & \MINKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MIN::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int min::| & \MINKEY{gen\_subtype\_of}\verb| ( min::gen v )|
\LABEL{MIN::GEN_SUBTYPE_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::gen v )|
\LABEL{MUP::STUB_OF} \\
\verb|min::float64 MUP::|
    & \MUPKEY{direct\_float\_of\LOOSE}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_FLOAT_OF} \\
\verb|min::int32 MUP::|
    & \MUPKEY{direct\_int\_of\COMPACT}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_INT_OF} \\
\verb|min::uns64 MUP::| & \MUPKEY{direct\_str\_of}\verb| ( min::gen v )|
\LABEL{MUP::DIRECT_STR_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{index\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{control\_code\_of}\verb| ( min::gen v )|
\LABEL{MUP::CONTROL_CODE_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{special\_index\_of}\verb| ( min::gen v )|
\LABEL{MUP::SPECIAL_INDEX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{list\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::LIST_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{sublist\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::SUBLIST_AUX_OF} \\
\verb|min::unsgen MUP::|
    & \MUPKEY{indirect\_aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::INDIRECT_AUX_OF} \\
\verb|min::unsgen MUP::| & \MUPKEY{aux\_of}\verb| ( min::gen v )|
\LABEL{MUP::AUX_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::| & \MUPKEY{new\_gen}\verb| ( min::stub * s )|
\LABEL{MUP::NEW_GEN_OF_STUB} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_float\_gen\LOOSE}\verb| ( min::float64 v )|
\LABEL{MUP::NEW_DIRECT_FLOAT_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_int\_gen\COMPACT}\verb| ( int v )|
\LABEL{MUP::NEW_DIRECT_INT_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_direct\_str\_gen}\verb| ( const char * p )|
\LABEL{MUP::NEW_DIRECT_STR_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_direct\_str\_gen}\ARGBREAK
      \verb| ( const char * p, min::unsptr n )|
\LABEL{MUP::NEW_DIRECT_STR_GEN_WITH_N} \\
\verb|min::gen MUP::| & \MUPKEY{new\_index\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_INDEX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_control\_code\_gen}\verb| ( min::unsgen c )|
\LABEL{MUP::NEW_CONTROL_CODE_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_special\_gen}\verb| ( min::unsgen i )|
\LABEL{MUP::NEW_SPECIAL_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_list\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_LIST_AUX_GEN} \\
\verb|min::gen MUP::| & \MUPKEY{new\_sublist\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_SUBLIST_AUX_GEN} \\
\verb|min::gen MUP::|
    & \MUPKEY{new\_indirect\_aux\_gen}\verb| ( min::unsgen p )|
\LABEL{MUP::NEW_INDIRECT_AUX_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::gen MUP::|
    & \MUPKEY{renew\_gen}\verb| ( min::gen v, min::unsgen p )|
\LABEL{MUP::RENEW_GEN} \\

\end{TABULAR}

\end{indpar}

\INDEXHEADER{Gen Value Subtype Codes}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_INT}
\LABEL{MIN::GEN_DIRECT_INT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_FLOAT}
\LABEL{MIN::GEN_DIRECT_FLOAT} \\
\verb|const unsigned min::| & \MINKEY{GEN\_DIRECT\_STR}
\LABEL{MIN::GEN_DIRECT_STR} \\
\verb|const unsigned min::| & \MINKEY{GEN\_STUB}
\LABEL{MIN::GEN_STUB} \\
\verb|const unsigned min::| & \MINKEY{GEN\_LIST\_AUX}
\LABEL{MIN::GEN_LIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SUBLIST\_AUX}
\LABEL{MIN::GEN_SUBLIST_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDIRECT\_AUX}
\LABEL{MIN::GEN_INDIRECT_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_PACKED\_AUX}
\LABEL{MIN::GEN_PACKED_AUX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_INDEX}
\LABEL{MIN::GEN_INDEX} \\
\verb|const unsigned min::| & \MINKEY{GEN\_CONTROL\_CODE}
\LABEL{MIN::GEN_CONTROL_CODE} \\
\verb|const unsigned min::| & \MINKEY{GEN\_SPECIAL}
\LABEL{MIN::GEN_SPECIAL} \\
\verb|const unsigned min::| & \MINKEY{GEN\_ILLEGAL}
\LABEL{MIN::GEN_ILLEGAL} \\
\end{TABULAR}

\end{indpar}

\newpage

\INDEXHEADER{Special Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{MISSING}
\LABEL{MIN::MISSING} \\
\verb|min::gen min::| & \MINKEY{NONE}
\LABEL{MIN::NONE} \\
\verb|min::gen min::| & \MINKEY{ANY}
\LABEL{MIN::ANY} \\
\verb|min::gen min::| & \MINKEY{MULTI\_VALUED}
\LABEL{MIN::MULTI_VALUED} \\
\verb|min::gen min::| & \MINKEY{UNDEFINED}
\LABEL{MIN::UNDEFINED} \\
\verb|min::gen min::| & \MINKEY{SUCCESS}
\LABEL{MIN::SUCCESS} \\
\verb|min::gen min::| & \MINKEY{FAILURE}
\LABEL{MIN::FAILURE} \\
\verb|(macro) min::gen|
	& \TTNBKEY{MIN\_NEW\_SPECIAL\_GEN}\verb| ( i )|
\LABEL{MIN_NEW_SPECIAL_GEN} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{new\_acc\_stub}\verb| ( void )|
\LABEL{MUP::NEW_ACC_STUB} \\
\verb|min::stub * MUP::| & \MUPKEY{new\_aux\_stub}\verb| ( void )|
\LABEL{MUP::NEW_AUX_STUB} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Read/Write Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{value\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::VALUE_OF} \\
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::FLOAT_OF} \\
\verb|min::gen MUP::| & \MUPKEY{gen\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::GEN_OF} \\
\verb|void * MUP::| & \MUPKEY{pointer\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::POINTER_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_value\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 v )|
\LABEL{MUP::SET_VALUE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_float\_of}\ARGBREAK
      \verb| ( min::stub * s, min::float64 f )|
\LABEL{MUP::SET_FLOAT_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_gen\_of}\ARGBREAK
      \verb| ( min::stub * s, min::gen v )|
\LABEL{MUP::SET_GEN_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_pointer\_of}\ARGBREAK
      \verb| ( min::stub * s, void * p )|
\LABEL{MUP::SET_POINTER_OF} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Stub Control Functions}

\begin{indpar}[0.2in]


\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::| & \MUPKEY{control\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::CONTROL_OF} \\
\verb|bool MUP::|
    & \MUPKEY{test\_flags\_of}\ARGBREAK
      \verb| ( const min::stub * s, min::uns64 flags )|
\LABEL{MUP::TEST_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{set\_control\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 c )|
\LABEL{MUP::SET_CONTROL_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_type\_of}\ARGBREAK
      \verb| ( min::stub * s, int type )|
\LABEL{MUP::SET_TYPE_OF} \\
\verb|void MUP::|
    & \MUPKEY{set\_flags\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::SET_FLAGS_OF} \\
\verb|void MUP::|
    & \MUPKEY{clear\_flags\_of}\ARGBREAK
      \verb| ( min::stub * s, min::uns64 flags )|
\LABEL{MUP::CLEAR_FLAGS_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control} \\
    & \verb|    ( int type_code, min::uns64 v,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_OF_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_type} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_CONTROL_WITH_TYPE_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_control\_with\_locator} \\
    & \verb|    ( int locator, const min::stub * s )|
\LABEL{MUP::NEW_CONTROL_WITH_LOCATOR_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_locator}\ARGBREAK
      \verb| ( min::uns64 c, int locator )|
\LABEL{MUP::RENEW_CONTROL_LOCATOR} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_value}\ARGBREAK
      \verb| ( min::uns64 c, min::uns64 v )|
\LABEL{MUP::RENEW_CONTROL_VALUE} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_stub}\ARGBREAK
      \verb| ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_CONTROL_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|int MUP::| & \MUPKEY{locator\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::LOCATOR_OF_CONTROL} \\
\verb|min::uns64 MUP::| & \MUPKEY{value\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::VALUE_OF_CONTROL} \\
\verb|min::stub * MUP::| & \MUPKEY{stub\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_CONTROL} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::uns64 MUP::|
    & \MUPKEY{new\_acc\_control} \\
    & \verb|    ( int type_code, const min::stub * s,|\ARGBREAK
      \verb|      min::uns64 flags = 0 )|
\LABEL{MUP::NEW_ACC_CONTROL_OF_STUB} \\
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_acc\_control\_stub}\ARGBREAK
      \verb| ( min::uns64 c, const min::stub * s )|
\LABEL{MUP::RENEW_ACC_CONTROL_STUB} \\
\verb|min::stub * MUP::|
    & \MUPKEY{stub\_of\_acc\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::STUB_OF_ACC_CONTROL} \\
[1ex]
\verb|min::uns64 MUP::|
    & \MUPKEY{renew\_control\_type}\ARGBREAK
      \verb| ( min::uns64 c, int type )|
\LABEL{MUP::RENEW_CONTROL_TYPE} \\
\verb|int MUP::| & \MUPKEY{type\_of\_control}\verb| ( min::uns64 c )|
\LABEL{MUP::TYPE_OF_CONTROL} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Control Flags}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.0in}
\verb|const min::uns64 MUP::| & \MUPKEY{STUB\_ADDRESS}
\LABEL{MIN::STUB_ADDRESS}\\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Body Allocation Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|void MUP::|
    & \MUPKEY{new\_body}\verb| ( min::stub * s, min::unsptr n )|
\LABEL{MUP::NEW_BODY} \\
\verb|void MUP::|
    & \MUPKEY{deallocate\_body}\ARGBREAK
      \verb|    ( min::stub * s, min::unsptr n )|
\LABEL{MUP::DEALLOCATE_BODY} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr MUP::|
    & \MUPKEY{body\_size\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::BODY_SIZE_OF} \\
\verb|void * & MUP::| & \MUPKEY{pointer\_ref\_of}%
	     \verb| ( min::stub * s )| 
\LABEL{MUP::POINTER_REF_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|(constructor) MUP::| & \MUPKEY{resize\_body} \verb|rb|\ARGBREAK
    \verb|    ( min::stub * s,|\ARGBREAK
    \verb|      min::unsptr new_size,|\ARGBREAK
    \verb|      min::unsptr old_size )|
\LABEL{MUP::RESIZE_BODY} \\
\verb|void * & MUP::| & \MUPKEY{new\_body\_pointer\_ref}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::NEW_BODY_POINTER_REF} \\
\verb|void MUP::| & \MUPKEY{abort\_resize\_body}\ARGBREAK
	     \verb|    ( MUP::resize_body & rb )| 
\LABEL{MUP::ABORT_RESIZE_BODY} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 min::|
    & \MINKEY{float\_of\COMPACT}\verb| ( const min::stub * s )|
\LABEL{MIN::FLOAT_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_num}\verb| ( min::gen v )|
\LABEL{MIN::IS_NUM} \\[1ex]
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( int v )|
\LABEL{MIN::NEW_NUM_GEN_OF_INT} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::unsptr v )|
\LABEL{MIN::NEW_NUM_GEN_OF_UNSPTR} \\
\verb|min::gen min::|
    & \MINKEY{new\_num\_gen\REL} \verb| ( min::float64 v )|
\LABEL{MIN::NEW_NUM_GEN_OF_FLOAT64} \\[1ex]
\verb|int min::| & \MINKEY{int\_of}\verb| ( min::gen v )|
\LABEL{MIN::INT_OF_GEN} \\
\verb|min::float64 min::| & \MINKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MIN::FLOAT_OF_GEN} \\[1ex]
\verb|min::uns32 min::| & \MINKEY{numhash}\verb| ( min::gen v )|
\LABEL{MIN::NUMHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{floathash}\verb| ( min::float64 f )|
\LABEL{MIN::FLOATHASH} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Number Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::float64 MUP::| & \MUPKEY{float\_of}\verb| ( min::gen v )|
\LABEL{MUP::FLOAT_OF_GEN} \\
\end{TABULAR}

\end{indpar}


\INDEXHEADER{String Protected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL} \verb| ( const char * p )|
\LABEL{MIN::NEW_STR_GEN} \\
\verb|min::gen min::|
    & \MINKEY{new\_str\_gen\REL}\ARGBREAK
      \verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::NEW_STR_GEN_WITH_N} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|int min::| & \MINKEY{is\_str}\verb| ( min::gen v )|
\LABEL{MIN::IS_STR_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::gen v )|
\LABEL{MIN::STRLEN_OF_GEN} \\
\verb|min:uns32 min::| & \MINKEY{strhash}\verb| ( min::gen v )|
\LABEL{MIN::STRHASH_OF_GEN} \\
\verb|char * min::| & \MINKEY{strcpy}\verb| ( char * p, min::gen v )|
\LABEL{MIN::STRCPY_OF_GEN} \\
\verb|char * min::| & \MINKEY{strncpy}\ARGBREAK
                      \verb| ( char * p,|\ARGBREAK
		      \verb|   min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_GEN} \\
\verb|int min::| & \MINKEY{strcmp}\verb| ( const char * p, min::gen v )|
\LABEL{MIN::STRCMP_OF_GEN} \\
\verb|int min::| & \MINKEY{strncmp}\ARGBREAK
                   \verb| ( const char * p,|\ARGBREAK
		   \verb|   min::gen v, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( const char * p )|
\LABEL{MIN::STRHASH} \\
\verb|min::uns32 min::|
    & \MINKEY{strnhash}\verb| ( const char * p, min::unsptr n )|
\LABEL{MIN::STRNHASH} \\
\end{TABULAR}

\end{indpar}

\newpage

\INDEXHEADER{String Pointers}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{str\_pointer}\verb| sp ( min::gen v )|
\LABEL{MIN::STR_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}\ARGBREAK
      \verb| ( min::str_pointer & sp, min::gen v )|
\LABEL{MIN::INIT_OF_STR_POINTER} \\[1ex]
\verb|min::unsptr min::| & \MINKEY{strlen}\verb| ( min::str_pointer & sp )|
\LABEL{MIN::STRLEN_OF_STR_POINTER} \\
\verb|min::uns32 min::| & \MINKEY{strhash}\verb| ( min::str_pointer & sp )|
\LABEL{MIN::STRHASH_OF_STR_POINTER} \\[1ex]
\verb|char * min::| & \MINKEY{strcpy}\ARGBREAK
      \verb| ( char * p, min::str_pointer & sp )|
\LABEL{MIN::STRCPY_OF_STR_POINTER} \\
\verb|char * min::|
    & \MINKEY{strncpy}\ARGBREAK
      \verb| ( char * p,|\ARGBREAK
      \verb|   min::str_pointer & sp, min::unsptr n )|
\LABEL{MIN::STRNCPY_OF_STR_POINTER} \\[1ex]
\verb|int min::|
    & \MINKEY{strcmp}\ARGBREAK
      \verb| ( const char * p,|\ARGBREAK
      \verb|   min::str_pointer & sp )|
\LABEL{MIN::STRCMP_OF_STR_POINTER} \\
\verb|int min::|
    & \MINKEY{strncmp}\ARGBREAK
      \verb|( const char * p,|\ARGBREAK
      \verb|  min::str_pointer & sp, min::unsptr n )|
\LABEL{MIN::STRNCMP_OF_STR_POINTER} \\[1ex]
\verb|const char      |
    & \ttkey{operator [ ]}\ARGBREAK
      \verb| ( min::str_pointer & sp, int index )|
\LABEL{MUP::[]_OF_STR_POINTER} \\
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( min::str_pointer & sp )|
\LABEL{MUP::STR_OF_STR_POINTER} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{String Unprotected Functions}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) MUP::| & \MUPKEY{str\_pointer}\verb| sp ( min::gen v )|
\LABEL{MUP::STR_POINTER_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns64 MUP::|
    & \MUPKEY{short\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::SHORT_STR_OF} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|MUP::long_str * MUP::|
    & \MUPKEY{long\_str\_of}\verb| ( const min::stub * s )|
\LABEL{MUP::LONG_STR_OF} \\
\verb|const char * MUP::| & \MUPKEY{str\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::STR_OF_LONG_STR} \\
\verb|min::unsptr MUP::| & \MUPKEY{length\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::LENGTH_OF_LONG_STR} \\
\verb|min::uns32 MUP::| & \MUPKEY{hash\_of}\verb| ( MUP::long_str * str )|
\LABEL{MUP::HASH_OF_LONG_STR} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Labels}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
(constructor)~\verb|min::|
	& \MINKEY{lab\_pointer}%
	  \verb| labp ( min::gen v )|
\LABEL{MIN::LAB_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_pointer}%
	  \verb| labp ( min::stub * s )|
\LABEL{MIN::LAB_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{lab\_pointer}%
	  \verb| labp ( void )|
\LABEL{MIN::LAB_POINTER_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::lab_pointer & labp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_LAB_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::lab_pointer & labp,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_LAB_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::lab_pointer & labp )|
\LABEL{MIN::DEINITIALIZE_LAB_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|const T & min::|
	& \ttkey{operator [ ]}\ARGBREAK
	  \verb| ( min::lab_pointer & labp,|\ARGBREAK
	  \verb|   min::uns32 i )|
\LABEL{MIN::LAB_POINTER[]} \\
\verb|min::uns32 min::|
	& \MINKEY{length\_of}\ARGBREAK
	  \verb| ( min::lab_pointer & labp )|
\LABEL{MIN::LENGTH_OF_LAB_POINTER} \\
\verb|min::uns32 min::|
	& \MINKEY{hash\_of}\ARGBREAK
	  \verb| ( min::lab_pointer & labp )|
\LABEL{MIN::HASH_OF_LAB_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( const min::stub * s )|
\LABEL{MIN::LABLEN} \\
\verb|min::uns32 min::| & \MINKEY{lablen}\verb| ( min::gen v )|
\LABEL{MIN::LABLEN_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( const min::stub * s )|
\LABEL{MIN::LABHASH} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\verb| ( min::gen v )|
\LABEL{MIN::LABHASH_OF_GEN} \\
\verb|min::uns32 min::| & \MINKEY{labhash}\ARGBREAK
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::LABHASH_OF_GEN_VECTOR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   const min::stub * s )|
	  \end{tabular}
\LABEL{MIN::LAB_OF} \\
\verb|min::uns32 min::| & \MINKEY{lab\_of}%
	  \begin{tabular}[t]{@{}l@{}}
	  \verb| ( min::gen * p, min::uns32 n,| \\
	  \verb|   min::gen v )|
	  \end{tabular}
\LABEL{MIN::LAB_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::gen min::| & \MINKEY{new\_lab\_gen}\ARGBREAK
    \verb| ( const min::gen * p, min::uns32 n )|
\LABEL{MIN::NEW_LAB_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|bool min::| & \MINKEY{is\_lab}\verb| ( min::gen v )|
\LABEL{MIN::IS_LAB_OF_GEN} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_pointer}%
	  \verb| labp ( min::gen v )|
\LABEL{MUP::LAB_POINTER_OF_GEN} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_pointer}%
	  \verb| labp ( min::stub * s )|
\LABEL{MUP::LAB_POINTER_OF_STUB} \\
(constructor)~\verb|MUP::|
	& \MUPKEY{lab\_pointer}%
	  \verb| labp ( void )|
\LABEL{MUP::LAB_POINTER_OF_VOID} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Names}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.6in}
\verb|bool min::| & \MINKEY{is\_name}\verb| ( min::gen v )|
\LABEL{MIN::IS_NAME} \\
\verb|min::uns32 min::| & \MINKEY{hash}\verb| ( min::gen v )|
\LABEL{MIN::HASH} \\
\verb|int min::| & \MINKEY{compare}\verb| ( min::gen v1, min::gen v2 )|
\LABEL{MIN::COMPARE} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Printing General Values}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{pr}\\&{\tt ~~}
    \verb| ( min::gen v,|\\&{\tt ~~}
    \verb|   min::pr_format & f =|\ARGBREAK
    \verb|        min::default_pr_format )|
\LABEL{MIN::PR} \\
\verb|std::ostream & |
    & \TTKEY{operator \LESSTHAN\LESSTHAN}\\&{\tt ~~}
      \verb| ( std ostream & out, min::pr & prv )|
\LABEL{OPERATOR<<_OF_PR} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|struct min::| & \MINKEY{pr\_format}\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  const char * number_format;|\ARGBREAK
    \verb|  const char * str_prefix;|\ARGBREAK
    \verb|  const char * str_postfix;|\ARGBREAK
    \verb|  const char * lab_prefix;|\ARGBREAK
    \verb|  const char * lab_postfix;|\ARGBREAK
    \verb|  const char * special_prefix;|\ARGBREAK
    \verb|  const char * special_postfix;|\ARGBREAK
    \verb|  std::ostream & ( * pr_stub )|\ARGBREAK
    \verb|       ( std::ostream & out,|\ARGBREAK
    \verb|         const min::stub * s );|\ARGBREAK
    \verb|};|
\LABEL{MIN::PR_FORMAT} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|struct min::| & \MINKEY{default\_pr\_format}\verb| =|\ARGBREAK
    \verb|{|\ARGBREAK
    \verb|  "%.15g",     // number_format|\ARGBREAK
    \verb|  "`","'",     // str_prefix/postfix|\ARGBREAK
    \verb|  "[","]",     // lab_prefix/postfix|\ARGBREAK
    \verb|  "","",       // special_prefix/postfix|\ARGBREAK
    \verb|  NULL         // pr_stub|\ARGBREAK
    \verb|};|
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Objects}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.5in}
\verb|min::unsptr min::|
    & \MINKEY{obj\_var\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_VAR_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_hash\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_HASH_SIZE} \\
\verb|min::unsptr min::|
    & \MINKEY{obj\_total\_size}\verb| ( min::unsptr u )|
\LABEL{MIN::OBJ_TOTAL_SIZE} \\
\end{TABULAR}

\end{indpar}

\medskip

\begin{indpar}[0.2in]

\begin{TABULAR}{1.2in}
\verb|min::gen min::| & \MINKEY{new\_obj\_gen\REL}\ARGBREAK
    \verb| ( min::unsptr unused_size,|\ARGBREAK
    \verb|   min::unsptr hash_size = 0,|\ARGBREAK
    \verb|   min::unsptr variables_size = 0 )|
\LABEL{MIN::NEW_OBJ_GEN} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Protected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|(constructor) min::| & \MINKEY{vec\_pointer}\verb| vp ( min::gen v )|
\LABEL{MIN::VEC_POINTER_OF_GEN} \\
\verb|(constructor) min::| & \MINKEY{vec\_pointer}%
       \verb| vp ( const min::stub * s )|
\LABEL{MIN::VEC_POINTER_OF_STUB} \\
\verb|(constructor) min::| & \MINKEY{vec\_pointer}%
       \verb| vp ( void )|
\LABEL{MIN::VEC_POINTER_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|void min::|
    & \MINKEY{initialize}\ARGBREAK
      \verb| ( min::vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen v )|
\LABEL{MIN::INIT_OF_VEC_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}\ARGBREAK
      \verb| ( min::vec_pointer & vp,|\ARGBREAK
      \verb|   const min::stub * s )|
\LABEL{MIN::INIT_OF_VEC_POINTER_OF_STUB} \\
\verb|void min::|
    & \MINKEY{deinitialize} \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::DEINIT_OF_VEC_POINTER_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{2.0in}
\verb|const min::stub * min::| & \MINKEY{stub\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::STUB_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{var\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::VAR_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{hash\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::HASH_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{attr\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::ATTR_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{unused\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::UNUSED_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{aux\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::AUX_SIZE_OF_VEC_POINTER} \\
\verb|min::unsptr min::| & \MINKEY{total\_size\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::TOTAL_SIZE_OF_VEC_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|min::gen | & \MINKEY{var}\ARGBREAK
    \verb| ( min::vec_pointer & vp,|\ARGBREAK
    \verb|   min::unsptr index )|
\LABEL{MIN::VAR_OF_VEC_POINTER} \\
\verb|min::gen | & \MINKEY{hash}\ARGBREAK
    \verb| ( min::vec_pointer & vp,|\ARGBREAK
    \verb|   min::unsptr index )|
\LABEL{MIN::HASH_OF_VEC_POINTER} \\
\verb|min::gen | & \MINKEY{attr}\ARGBREAK
    \verb| ( min::vec_pointer & vp,|\ARGBREAK
    \verb|   min::unsptr index )|
\LABEL{MIN::ATTR_OF_VEC_POINTER} \\
\verb|min::gen | & \MINKEY{aux}\ARGBREAK
    \verb| ( min::vec_pointer & vp,|\ARGBREAK
    \verb|   min::unsptr aux_pointer )|
\LABEL{MIN::AUX_OF_VEC_POINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|(constructor) min::|
    & \MINKEY{updatable\_vec\_pointer} \verb|vp|\ARGBREAK
    \verb| ( min::gen v )|
\LABEL{MIN::UPDATABLE_VEC_POINTER_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{updatable\_vec\_pointer} \verb|vp|\ARGBREAK%
    \verb| ( min::stub * s )|
\LABEL{MIN::UPDATABLE_VEC_POINTER_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{updatable\_vec\_pointer} \verb|vp|\ARGBREAK%
    \verb| ( void )|
\LABEL{MIN::UPDATABLE_VEC_POINTER_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{initialize}\ARGBREAK
      \verb| ( min::updatable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen v )|
\LABEL{MIN::INIT_OF_UPDATABLE_VEC_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}\ARGBREAK
      \verb| ( min::updatable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::stub * s )|
\LABEL{MIN::INIT_OF_UPDATABLE_VEC_POINTER_OF_STUB} \\
\verb|void min::|
    & \MINKEY{deinitialize}\ARGBREAK
      \verb| ( min::updatable_vec_pointer & vp )|
\LABEL{MIN::DEINIT_OF_UPDATABLE_VEC_POINTER_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{set\_var}\ARGBREAK
      \verb| ( min::updatable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::unsptr index,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_VAR_OF_UPDATABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{set\_hash}\ARGBREAK
      \verb| ( min::updatable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::unsptr index,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_HASH_OF_UPDATABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{set\_attr}\ARGBREAK
      \verb| ( min::updatable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::unsptr index,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_ATTR_OF_UPDATABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{set\_aux}\ARGBREAK
      \verb| ( min::updatable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::unsptr aux_pointer,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::SET_AUX_OF_UPDATABLE_VEC_POINTER} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.8in}
\verb|(constructor) min::|
    & \MINKEY{insertable\_vec\_pointer} \verb|vp|\ARGBREAK
    \verb| ( min::gen v )|
\LABEL{MIN::INSERTABLE_VEC_POINTER_OF_GEN} \\
\verb|(constructor) min::|
    & \MINKEY{insertable\_vec\_pointer} \verb|vp|\ARGBREAK%
    \verb| ( min::stub * s )|
\LABEL{MIN::INSERTABLE_VEC_POINTER_OF_STUB} \\
\verb|(constructor) min::|
    & \MINKEY{insertable\_vec\_pointer} \verb|vp|\ARGBREAK%
    \verb| ( void )|
\LABEL{MIN::INSERTABLE_VEC_POINTER_OF_VOID} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
    & \MINKEY{initialize}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen v )|
\LABEL{MIN::INIT_OF_INSERTABLE_VEC_POINTER_OF_GEN} \\
\verb|void min::|
    & \MINKEY{initialize}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::stub * s )|
\LABEL{MIN::INIT_OF_INSERTABLE_VEC_POINTER_OF_STUB} \\
\verb|void min::|
    & \MINKEY{deinitialize}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MIN::DEINIT_OF_INSERTABLE_VEC_POINTER_OF_STUB} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::ATTR_PUSH_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{attr\_push}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MIN::ATTR_PUSH_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\

\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen value )|
\LABEL{MIN::AUX_PUSH_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{aux\_push}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   const min::gen * p, min::unsptr n )|
\LABEL{MIN::AUX_PUSH_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen & value )|
\LABEL{MIN::ATTR_POP_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{attr\_pop}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::ATTR_POP_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\

\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen & value )|
\LABEL{MIN::AUX_POP_OF_INSERTABLE_VEC_POINTER} \\
\verb|void min::| & \MINKEY{aux\_pop}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::AUX_POP_MULTIPLE_OF_INSERTABLE_VEC_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|bool min::| & \MINKEY{resize\REL}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::unsptr unused_size )|
\LABEL{MIN::RESIZE_UNUSED_OF_INSERTABLE_VEC_POINTER} \\
\verb|bool min::| & \MINKEY{resize\REL}\ARGBREAK
      \verb| ( min::insertable_vec_pointer & vp,|\ARGBREAK
      \verb|   min::unsptr unused_size,|\ARGBREAK
      \verb|   min::unsptr var_size )|
\LABEL{MIN::RESIZE_UNUSED_AND_VAR_OF_INSERTABLE_VEC_POINTER} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Unprotected Object Vector Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
\verb|const min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb| ( min::vec_pointer & v )|
\LABEL{MUP::BASE_OF_VEC_POINTER} \\
\verb|min::gen * & MUP::| & \MUPKEY{base}\ARGBREAK
    \verb| ( min::updatable_vec_pointer & v )|
\LABEL{MUP::BASE_OF_UPDATABLE_VEC_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::stub * MUP::| & \MUPKEY{stub\_of}\verb| ( min::vec_pointer & vp )|
\LABEL{MUP::STUB_OF_VEC_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|min::unsptr MUP::| & \MUPKEY{var\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::VAR_OFFSET_OF_VEC_POINTER} \\
\verb|min::unsptr MUP::| & \MUPKEY{attr\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::ATTR_OFFSET_OF_VEC_POINTER} \\
\verb|min::unsptr MUP::| & \MUPKEY{unused\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_VEC_POINTER} \\
\verb|min::unsptr MUP::| & \MUPKEY{aux\_offset\_of}%
    \verb| ( min::vec_pointer & vp )|
\LABEL{MUP::AUX_OFFSET_OF_VEC_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.8in}
\verb|min::unsptr & MUP::| & \MUPKEY{unused\_offset\_of}\ARGBREAK
    \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MUP::UNUSED_OFFSET_OF_INSERTABLE_VEC_POINTER} \\
\verb|min::unsptr & MUP::| & \MUPKEY{aux\_offset\_of}\ARGBREAK
    \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MUP::AUX_OFFSET_OF_INSERTABLE_VEC_POINTER} \\
\end{TABULAR}

\end{indpar}

\INDEXHEADER{Object List Level}

\begin{indpar}[0.2in]
\begin{TABULAR}{1.8in}
(macro) & \TTNBKEY{MIN\_USE\_OBJ\_AUX\_STUBS}
\LABEL{MIN_USE_OBJ_AUX_STUBS} \\
\verb|bool min::|
	& \MINKEY{use\_obj\_aux\_stubs}
\LABEL{MIN::USE_OBJ_AUX_STUBS} \\
\end{TABULAR}
\end{indpar}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\verb|const min::gen min::| & \MINKEY{LIST\_END}
\LABEL{MIN::LIST_END} \\
\verb|const min::gen min::|
    & \MINKEY{EMPTY\_SUBLIST}
\LABEL{MIN::EMPTY_SUBLIST} \\
\end{TABULAR}

\end{indpar}

\begin{indpar}[0.2in]

\begin{TABULAR}{2.2in}
(constructor)~\verb|min::|
	& \MINKEY{list\_pointer} \verb|lp|\ARGBREAK
	  \verb| ( min::vec_pointer & vp )|
\LABEL{MIN::LIST_POINTER_OF_VEC_POINTER} \\
\verb|min::vec_pointer & min::|
	& \MINKEY{vec\_pointer\_of}\ARGBREAK
	  \verb| ( min::list_pointer & lp )|
\LABEL{MIN::VEC_POINTER_OF_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_HASH} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_ATTR} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_COPY_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_COPY_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_COPY_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_SUBLIST_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_LIST_POINTER_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::START_SUBLIST_OF_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{next}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::NEXT_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{peek}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::PEEK_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{current}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::CURRENT_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::HASH_SIZE_OF_LIST_POINTER} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\verb| ( min::list_pointer & lp )|
\LABEL{MIN::ATTR_SIZE_OF_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|bool min::|
	& \MINKEY{is\_list\_end}\verb| ( min::gen v )|
\LABEL{MIN::IS_LIST_END} \\
\verb|bool min::|
	& \MINKEY{is\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_SUBLIST} \\
\verb|bool min::|
	& \MINKEY{is\_empty\_sublist}\verb| ( min::gen v )|
\LABEL{MIN::IS_EMPTY_SUBLIST} \\
\end{TABULAR}

\bigskip

\begin{TABULAR}{1.6in}
(constructor)~\verb|min::|
	& \MINKEY{updatable\_list\_pointer} \verb|lp|\ARGBREAK
	  \verb| ( min::updatable_vec_pointer & vp )|
\LABEL{MIN::UPDATABLE_LIST_POINTER_OF_UPDATABLE_VEC_POINTER} \\
\multicolumn{2}{@{}l}{\tt min::updatable\_vec\_pointer \&} \\
\verb|min::|
	& \MINKEY{vec\_pointer\_of}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::VEC_POINTER_OF_UPDATABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_HASH_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_UPDATABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_COPY_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_COPY_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_SUBLIST_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_UPDATABLE_LIST_POINTER_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::START_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::NEXT_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::PEEK_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp )|
\LABEL{MIN::CURRENT_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb|    ( min::updatable_list_pointer & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb|    ( min::updatable_list_pointer & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_UPDATABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb|    ( min::updatable_list_pointer & lp )|
\LABEL{MIN::HASH_SIZE_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb|    ( min::updatable_list_pointer & lp )|
\LABEL{MIN::ATTR_SIZE_OF_UPDATABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb| ( min::updatable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::gen value )|
\LABEL{MIN::UPDATE_OF_UPDATABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{insertable\_list\_pointer} \verb|lp|\ARGBREAK
	  \verb| ( min::insertable_vec_pointer & vp )|
\LABEL{MIN::INSERTABLE_LIST_POINTER_OF_INSERTABLE_VEC_POINTER} \\
\multicolumn{2}{@{}l}{\tt min::insertable\_vec\_pointer \&} \\
\verb|min::|
	& \MINKEY{vec\_pointer\_of}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::VEC_POINTER_OF_INSERTABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.3in}
\verb|min::gen min::|
	& \MINKEY{start\_hash}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_HASH_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_attr}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr index )|
\LABEL{MIN::START_ATTR_OF_INSERTABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.2in}
\verb|min::gen min::|
	& \MINKEY{start\_copy}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_COPY_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_SUBLIST_OF_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::updatable_list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_SUBLIST_OF_UPDATABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   const min::insertable_list_pointer & lp2 )|
\LABEL{MIN::START_INSERTABLE_LIST_POINTER_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::START_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.6in}
\verb|min::unsptr min::|
	& \MINKEY{hash\_size\_of}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::HASH_SIZE_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::unsptr min::|
	& \MINKEY{attr\_size\_of}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::ATTR_SIZE_OF_INSERTABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.4in}
\verb|min::gen min::|
	& \MINKEY{next}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::NEXT_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{peek}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::PEEK_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{start\_sublist}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::START_SUBLIST_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{current}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::CURRENT_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{update\_refresh}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::UPDATE_REFRESH_OF_INSERTABLE_LIST_POINTER} \\
\verb|min::gen min::|
	& \MINKEY{insert\_refresh}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp )|
\LABEL{MIN::INSERT_REFRESH_OF_INSERTABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|void min::|
	& \MINKEY{update}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::gen value )|
\LABEL{MIN::UPDATE_OF_INSERTABLE_LIST_POINTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|bool min::|
	& \MINKEY{insert\_reserve\REL}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr insertions,|\ARGBREAK
	  \verb|   min::unsptr elements = 0,|\ARGBREAK
	  \verb|   bool use_obj_aux_stubs =|\ARGBREAK
	  \verb|       min::use_obj_aux_stubs )|
\LABEL{MIN::INSERT_RESERVE} \\
\verb|void min::|
	& \MINKEY{insert\_before}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_BEFORE} \\
\verb|void min::|
	& \MINKEY{insert\_after}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::gen * p, min::unsptr n )|
\LABEL{MIN::INSERT_AFTER} \\
\end{TABULAR}

\medskip

\begin{TABULAR}{1.8in}
\verb|min::unsptr min::|
	& \MINKEY{remove}\ARGBREAK
	  \verb| ( min::insertable_list_pointer & lp,|\ARGBREAK
	  \verb|   min::unsptr n = 1 )|
\LABEL{MIN::REMOVE_FROM_INSERTABLE_LIST} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Object Attribute Level}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.8in}
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Structures}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\SARG} \verb|pstype| \ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * stub_ptr_disp = NULL )|
\LABEL{MIN::PACKED_STRUCT} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::uns32 min::| & \MINNBKEY{DISP} \verb|( & |$S$\verb|::|$m$\verb| )|
\LABEL{MIN::DISP} \\
\verb|min::uns32 min::| & \MINNBKEY{DISP\_END}
\LABEL{MIN::DISP_END} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::gen |
	& \verb|pstype.|\TTKEY{new\_gen} \verb|( void )|
\LABEL{PACKED_STRUCT_NEW_GEN} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const char * const |
	& \verb|pstype.|\TTMKEY{name}{in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_NAME} \\
\verb|const min::uns32 * const |
	& \verb|pstype.|\TTMKEY{gen\_disp}
	                       {in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_GEN_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pstype.|\TTMKEY{stub\_ptr\_disp}
	                       {in {\tt min::packed\_struct}}
\LABEL{PACKED_STRUCT_STUB_PTR_DISPLACEMENTS} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_pointer\SARG} \verb|psp|
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_pointer\SARG} \verb|psp|
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_pointer\SARG} \verb|psp|
	  \verb| ( void )|
\LABEL{MIN::PACKED_STRUCT_PTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_pointer|{\tt \SARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::pointer}
\LABEL{MIN::PACKED_STRUCT_PTR_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\end{TABULAR}

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updatable\_pointer\SARG} \verb|psup| \ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updatable\_pointer\SARG} \verb|psup| \ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_struct\_updatable\_pointer\SARG} \verb|psup| \ARGBREAK
	               \verb| ( void )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_struct_updatable_pointer|{\tt \SARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_struct\SARG::updatable\_pointer}
\LABEL{MIN::PACKED_STRUCT_UPDPTR_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|const S * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_struct<S>::pointer & psp )|
\LABEL{MIN::PACKED_STRUCT_PTR_CONVERSION} \\
\verb|S * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_struct<S>|\ARGBREAK
	  \verb|      ::updatable_pointer & psp )|
\LABEL{MIN::PACKED_STRUCT_UPDPTR_CONVERSION} \\
\end{TABULAR}

\end{indpar}

\bigskip

\INDEXHEADER{Packed Vectors}

\begin{indpar}[0.2in]

\begin{TABULAR}{1.4in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\HEARG} \verb|pvtype| \ARGBREAK
	  \verb| ( const char * name,|\ARGBREAK
	  \verb|   const min::uns32 * element_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * element_stub_ptr_disp| \ARGBREAK
	  \verb|                            = NULL,| \ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL,|\ARGBREAK
	  \verb|   const min::uns32 * header_gen_disp = NULL )|
\LABEL{MIN::PACKED_VEC} \\
\end{TABULAR}

\begin{TABULAR}{1.4in}
\verb|min::gen |
	& \verb|pvtype.|\TTKEY{new\_gen} \verb|( void )|
\LABEL{PACKED_VEC_NEW_GEN_VOID} \\
\verb|min::gen |
	& \verb|pvtype.|\TTKEY{new\_gen} \ARGBREAK
	  \verb| ( min::uns32 max_length,| \ARGBREAK
	  \verb|   min::uns32 length = 0,| \ARGBREAK
	  \verb|   const E * vp = NULL )|
\LABEL{PACKED_VEC_NEW_GEN_MAX_LENGTH} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|const char * const |
	& \verb|pvtype.|\TTMKEY{name}{in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_NAME} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{header\_gen\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_GEN_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{header\_stub\_ptr\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_HEADER_STUB_PTR_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{element\_gen\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_GEN_DISPLACEMENTS} \\
\verb|const min::uns32 * const |
	& \verb|pvtype.|\TTMKEY{element\_stub\_ptr\_disp}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_ELEMENT_STUB_PTR_DISPLACEMENTS} \\
\end{TABULAR}

\begin{TABULAR}{2.4in}
\verb|min::uns32 |
	& \verb|pvtype.|\TTMKEY{initial\_max\_length}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INITIAL_MAX_LENGTH} \\
\verb|min::float64 |
	& \verb|pvtype.|\TTMKEY{increment\_ratio}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_INCREMENT_RATIO} \\
\verb|min::uns32 |
	& \verb|pvtype.|\TTMKEY{max\_increment}
	                       {in {\tt min::packed\_vec}}
\LABEL{PACKED_VEC_MAX_INCREMENT} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_pointer\HEARG} \verb|pvp| \ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_pointer\HEARG} \verb|pvp| \ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_pointer\HEARG} \verb|pvp|
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_POINTER_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_pointer|{\tt \HEARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\HEARG::pointer}
\LABEL{MIN::PACKED_VEC_POINTER_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp )|
\LABEL{MIN::DEINITIALIZE_PACKED_VEC_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updatable\_pointer\HEARG} \verb|pvup|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updatable\_pointer\HEARG} \verb|pvup|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_updatable\_pointer\HEARG} \verb|pvup| \ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_updatable_pointer|{\tt \HEARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\HEARG::updatable\_pointer}
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_UPDATABLE_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_UPDATABLE_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup )|
\LABEL{MIN::DEINITIALIZE_PACKED_VEC_UPDATABLE_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insertable\_pointer\HEARG} \verb|pvip|\ARGBREAK
	  \verb| ( min::gen v )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_OF_GEN} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insertable\_pointer\HEARG} \verb|pvip|\ARGBREAK
	  \verb| ( min::stub * s )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_OF_STUB} \\
(constructor)~\verb|min::|
	& \MINKEY{packed\_vec\_insertable\_pointer\HEARG} \verb|pvip| \ARGBREAK
	               \verb|( void )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_OF_VOID} \\
\verb|typedef |
	& \verb|min::packed_vec_insertable_pointer|{\tt \HEARG} \ARGBREAK
	  \verb|min::|\MINKEY{packed\_vec\HEARG::insertable\_pointer}
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_TYPEDEF} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip,|\ARGBREAK
	  \verb|   min::gen v )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_INSERTABLE_POINTER_OF_GEN} \\
\verb|void min::|
	& \MINKEY{initialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip,|\ARGBREAK
	  \verb|   min::stub * s )|
\LABEL{MIN::INITIALIZE_PACKED_VEC_INSERTABLE_POINTER_OF_STUB} \\
\verb|void min::|
	& \MINKEY{deinitialize}\ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip )|
\LABEL{MIN::DEINITIALIZE_PACKED_VEC_INSERTABLE_POINTER} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|const H * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_vec<H,E>::pointer & pvp )|
\LABEL{MIN::PACKED_VEC_POINTER_CONVERSION} \\
\verb|H * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::updatable_pointer & pvup )|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_CONVERSION} \\
\verb|H * | & \TTKEY{operator -\GREATERTHAN} \ARGBREAK
	  \verb| ( min::packed_vec<H,E>|\ARGBREAK
	  \verb|      ::insertable_pointer & pvip )|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_CONVERSION} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|const min::uns32 | & \verb|pvp->length|
\LABEL{MIN::PACKED_VEC_POINTER_LENGTH} \\
\verb|const min::uns32 | & \verb|pvup->length|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_LENGTH} \\
\verb|const min::uns32 | & \verb|pvip->length|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_LENGTH} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|const min::uns32 | & \verb|pvp->max_length|
\LABEL{MIN::PACKED_VEC_POINTER_MAX_LENGTH} \\
\verb|const min::uns32 | & \verb|pvup->max_length|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_MAX_LENGTH} \\
\verb|const min::uns32 | & \verb|pvip->max_length|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_MAX_LENGTH} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|const E | & \verb|pvp[i]|
\LABEL{MIN::PACKED_VEC_POINTER_ELEMENT} \\
\verb|E | & \verb|pvup[i]|
\LABEL{MIN::PACKED_VEC_UPDATABLE_POINTER_ELEMENT} \\
\verb|E | & \verb|pvip[i]|
\LABEL{MIN::PACKED_VEC_INSERTABLE_POINTER_ELEMENT} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\verb|void min::|
	& \MINKEY{push} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   const E & v )|
\LABEL{MIN::PACKED_VEC_PUSH} \\
\verb|void min::|
	& \MINKEY{push} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 n, const E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_PUSH_N} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|E min::|
	& \MINKEY{pop} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip )|
\LABEL{MIN::PACKED_VEC_POP} \\
\verb|void min::|
	& \MINKEY{pop} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 n, E * vp = NULL )|
\LABEL{MIN::PACKED_VEC_POP_N} \\
\end{TABULAR}

\begin{TABULAR}{1.2in}
\verb|void min::|
	& \MINKEY{resize} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 max_length )|
\LABEL{MIN::PACKED_VEC_RESIZE} \\
\verb|void min::|
	& \MINKEY{reserve} \ARGBREAK
	  \verb| ( packed_vec<H,E>::insertable_pointer pvip,| \ARGBREAK
	  \verb|   min::uns32 reserve_length )|
\LABEL{MIN::PACKED_VEC_RESERVE} \\
\end{TABULAR}

\begin{TABULAR}{1.6in}
\end{TABULAR}

\end{indpar}


} % end of renewcommand for \LABEL, \{TT,MIN,MUP}KEY.

\section{Operating System Interface}
\label{OPERATING-SYSTEM-INTERFACE}

The interface between MIN implementation code and the operating system
consists of standard C++/C functions available on all operating
systems, such as \verb|iostreams|, plus \ttkey{min::os}
namespace interface functions that are
declared in \verb|min_os.h| and defined in \verb|src/min_os.cc|.
This code division is intended to make it easy to port MIN to different
operating systems by placing all the code that must be
changed in the small \verb|src/min_os.cc| file.
\verb|min::os| is commonly abbreviated to
`\ttnbmkey{MOS}{abbreviates {\tt min::os}}'\label{MOS}
by including the following definition in code that accesses
the interface:

\begin{center}
\verb|#define  MOS  min::os|
\end{center}

Details of the \verb|min::os| interface are in \verb|min_os.h|.  The
following is an overview.

\subsection{Configuration Parameters}
\label{CONFIGURATION-PARAMETERS}

In UNIX the \ttnbkey{MIN\_CONFIG} environment variable value consists
of whitespace separated entries of the form `{\em name}\verb|=|{\em value}'
that specify configuration parameters, most of which control the
Allocator/Collector/Compactor.

\subsection{Memory Pools}

A memory pool is a contiguous block of pages of \underline{virtual}
memory.  Memory pools may be allocated, and it is possible to
specify that a pool being allocated has its starting address in
a particular range (e.g., so stub addresses can be limited to
44 bits).  Segments of memory pools may be freed, may be made
into inaccessible virtual memory, and may be made reaccessible.
Segments of memory pools may be moved by copying page table entries,
which is faster than copying bytes.

\section{Allocator/Collector/Compactor}
\label{ALLOCATOR/COLLECTOR/COMPACTOR}\label{ACC}

The \key{Allocator/Collector/Compactor}, or \ttnbkey{acc}, 
is a replaceable component of the MIN code, which should not
normally be accessed directly.  It can be controlled by parameters
passed to the program (see Configuration Parameters,
\pagref{CONFIGURATION-PARAMETERS}), or by defaults for these
provided at compile time in \verb|min_acc_parameters.h|.
Documentation for these parameters is in this last file.
The acc code is in the 
\verb|min::acc| namespace which is abbreviated to
`\ttnbmkey{MACC}{abbreviates {\tt min::acc}}'\label{MACC}
by including the following definition in acc code:

\begin{center}
\verb|#define  MACC  min::acc|
\end{center}

Details of the acc code are in \verb|min_acc.h|.  The
following is an overview.

TBD

\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}
