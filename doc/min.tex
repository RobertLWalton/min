% Minimal Descriptive Programming Language
%
% File:         min.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}{ p\pageref{#1}}}
\newcommand{\Secref}[1]{\ref{#1}{(p\pageref{#1})}}
\newcommand{\stepref}[1]{\ref{#1}{(p\pageref{#1})}}
\newcommand{\appref}[1]{\ref{#1}{ p\pageref{#1}}}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Minimal\\Descriptive and Programming\\Language\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{Copyright 2004 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by my son's efforts at game design.}}

\date{August 1, 2004}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MIN, the Minimal Descriptive and Programming
Language.

The main goal of MIN is to make it easy to describe objects,
and to write small pieces of program code that change object descriptions
in response to external inputs.  MIN has a geometry engine that translates
object descriptions into a geometrical data, video and audio engines
that translate the geometry and object data into visual and
audio displays, and a view engine that translates between object descriptions
and textual displays such as spreadsheets.

MIN is intended to be the smallest, simplest language that can perform
these tasks well.


\section{Remarks}


\section{Overview}


\section{Lexemes}

MIN descriptions are representable by strings of characters that
can be stored in files.  When a MIN program reads these, it
scans the characters from left to right to produce a sequence
of \skey{lexeme}s.  There are five kinds of lexemes: words, numbers,
brackets, marks, and quoted strings.

A \key{word} is a string of letters.  E.g., {\tt fie}.  The underline
character (\ttmkey{\UNDERLINE}{letter}) is a letter.
A period (\ttmkey{.}{letter})
is a letter if it is followed by a letter; similarly an exclamation
mark (\ttmkey{!}{letter}) is a letter if it is followed by a letter,
and an appostrophe (\ttmkey{'}{letter}) is a letter if it
is followed by a letter.
E.g., \verb|.separator|, \verb|!set|, and \verb|it's| are words.

A \key{number} is a string of digits plus an optional \key{decimal point}.
E.g., {\tt 5.2}.  Any decimal point must be followed by a digit.

A \key{bracket} is a single bracket character.  E.g., \verb|[| and \verb|]|.
The \key{bracket characters} are parentheses
(\ttmkey{(}{bracket character} and \ttmkey{)}{bracket character}),
square brackets (\ttmkey{[}{bracket character} and
\ttmkey{]}{bracket character}),
curly brackets (\ttmkey{\LEFTBRACKET}{bracket character} and
\ttmkey{\RIGHTBRACKET}{bracket character}),
and single quotes (\ttmkey{`}{bracket character} and
\ttmkey{'}{bracket character}).  The close quote (\verb|'|) is
a letter, and not a bracket, if it is followed by a letter.

A \key{mark} is a string of mark characters, which are just characters
that are not letters or digits or decimal points or brackets or quotes.
E.g., \verb|+| and \verb|::|.  The \key{mark characters} are
comma (\ttmkey{,}{mark character}),
semi-colon (\ttmkey{;}{mark character}),
colon (\ttmkey{:}{mark character}),
period (\ttmkey{.}{mark character}) when not followed by a digit or
letter,
exclamation mark (\ttmkey{!}{mark character}) when not followed by a
letter,
at sign ({\tt @}\index{"@@{\tt "@}!mark character}),
pound sign (\ttmkey{\#}{mark character}),
dollar sign (\ttmkey{\$}{mark character}),
percent sign (\ttmkey{\%}{mark character}),
circumflex (\ttmkey{\CIRCUMFLEX}{mark character}),
ampersand (\ttmkey{\&}{mark character}),
asterix (\ttmkey{*}{mark character}),
minus sign (\ttmkey{-}{mark character}),
plus sign (\ttmkey{+}{mark character}),
equal sign (\ttmkey{=}{mark character}),
vertical bar (\ttmkey{\BAR}{mark character}),
back-slash (\ttmkey{\BACKSLASH}{mark character}),
less-than (\ttmkey{\LESSTHAN}{mark character}),
greater-than (\ttmkey{\GREATERTHAN}{mark character}),
slash (\ttmkey{/}{mark character}),
and
tilde (\ttmkey{\TILDE}{mark character}).


A \key{quoted string} is a string of characters that begins and ends with
a \verb|"| \key{quote character}.  The string of characters may include
spaces and escape sequences.  See~\secref{QUOTED-STRINGS} for details on
quoted strings.

Words, marks, and quoted strings are all \skey{symbol}s, which are just
character strings that can be used like words or marks.  A quoted string
may be just an alternate representation of a word or a mark.  Thus
{\tt hello} and {\tt "hello"} represent the same thing, the same symbol.
Similarly {\tt :} and {\tt ":"} represent the same symbol.  However
{\tt 0.123} is a number which is not a symbol, and {\tt "0.123"} is a symbol
which is not a number.

There are special rules for some characters.

An underline (\ttmkey{\UNDERLINE}{letter}) is a letter.

A \ttmkey{.}{letter}\index{.@{\tt .}!decimal point}
is a decimal point if followed by a digit, a letter if followed
by another letter, and a mark character otherwise.  E.g., {\tt 0.123} is
a number with a decimal pointer, {\tt .terminator} is a word beginning with
a letter, and {\tt `Hello.'} contains the word {\tt Hello}
followed by the \verb|.| mark.

Users of MIN should not create words that begin with
\ttmkey{.}{reserved use}; such words
are reserved for use by the designers of MIN.

An exclamation mark ({\tt !}\index{"!@{\tt "!}!letter}%
\index{"!@{\tt "!}!mark character})
is a letter if followed by another letter, and a mark character
otherwise.  E.g., {\tt !set} is a word and {\tt `Hello!'} contains the
word {\tt Hello} followed by the \verb|!| mark.

Similarly the close quote (\ttmkey{'}{letter}) is a letter if followed
by a letter, as in \verb|it's|, and a closing bracket otherwise.

The double quote ({\tt "}\index{""@{\tt ""}}) is used to begin and end
quoted strings.

A \ttkey{\BACKSLASH} is a mark character if it occurs outside quoted
strings, and is an \key{escape character} if it occurs inside quoted strings.
As an escape character it is used to begin a sequence of characters called
an escape sequence that denotes a single character.
See~\pagref{ESCAPE-SEQUENCES} for details on escape sequences.

White-space characters, the \key{space character}, the \key{tab character},
the \key{new line character}, the \key{form feed character}, and the
\key{vertical tab} character are used to separate lexemes.  The space
character can be used to represent a single space inside quoted strings.
The tab character is always equivalent to one or more space characters,
with tabs set every 8 columns.
The other whitespace characters have special interpretation inside quoted
strings, see~\secref{QUOTED-STRINGS}.

\subsection{Quoted Strings}
\label{QUOTED-STRINGS}

TBD
\label{ESCAPE-SEQUENCES}

\section{Data}

A \key{datum} in MIN is either an atom, an object, or an arrow.

An \key{atom} is either a symbol (word, mark, or quoted string) or a
number.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it has nothing else.

However, as a place in memory, an object has a name.  Objects are assigned
\skey{raw object name}s
of the form `\ttmkey{\#\#}{in raw object name}$I$' where $I$
is an integer that starts
with {\tt 1} for the first object created and continues in sequence as
more objects are created.  E.g., the first three objects created have the
raw object names \verb|##1|, \verb|##2|, and \verb|##3|. 

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a label, which is a sequence of zero or
more atoms.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.

An \key{arrow label} is a sequence of zero or more atoms.
Two arrows leaving the same object may not have the same label.  Thus
arrows can be named by giving an object which is the source of the arrow
and a label which is the label of a single arrow or the label in the
direction leaving the object of a double arrow.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In most of this document
arrows are called attributes, arrow labels are called attribute names,
and arrow targets are called attribute values.

\subsection{Raw Representations}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set must be used
in the file.  The simplest representation is the raw representation,
which we now describe.

The format of a \key{raw representation} is:

\begin{center}
\begin{tabular}{l}
\key{raw-representation} ::= {\em raw-object-representation} \ldots
\\[1ex]
\key{raw-object-representation} ::=
    \begin{tabular}[t]{@{}l@{}}
    {\em raw-object-name} \ttmkey{::}{in {\em raw-object-representation}} \\
    {\em raw-arrow-representation} \ldots
    \end{tabular}
\\[1ex]
\key{raw-arrow-representation}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-single-arrow-representation} \\
    $|$ & {\em raw-double-arrow-representation}
    \end{tabular}
\\[1ex]
\key{raw-single-arrow-representation} ::=
	{\em arrow-label}\ttmkey{:}{in {\em raw-single-arrow-representation}}
	{\em single-arrow-target}
	\ttmkey{;;}{in {\em raw-single-arrow-representation}}
\\[1ex]
\key{single-arrow-target} ::= {\em atom} $|$ {\em raw-object-name}
\\[1ex]
\key{raw-double-arrow-representation} ::=
	{\em arrow-label}\ttmkey{:}{in {\em raw-double-arrow-representation}}
	{\em double-arrow-target}
	{\tt :}{\em arrow-label}
	\ttmkey{;;}{in {\em raw-double-arrow-representation}}
\\[1ex]
\key{double-arrow-target} ::= {\em raw-object-name}
\\[1ex]
\key{raw-object-name} ::=
	\ttmkey{\#\#}{in {\em raw-object-name}}{\em integer-above-zero}
\\[1ex]
\key{arrow-label} ::= {\em atom} \ldots

\end{tabular}
\end{center}%
\index{label!arrow}%
\index{source!arrow}%
\index{target!arrow}

A simple example of the raw representation of a set of objects is:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##1::|\\
\verb|    type: woman;;|\\
\verb|    name: Jill;;|\\
\verb|    husband: ##2 :wife;;|\\
\verb|##2::|\\
\verb|    type: man;;|\\
\verb|    name: Jack;;|\\
\verb|    wife: ##1 :husband;;|
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt \#\#1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt \#\#2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

This represents two objects.
There are two single arrows from object \verb|##1|,
one arrow labeled {\tt type} whose target is the atom {\tt woman},
and one arrow labeled {\tt name} whose target is the atom {\tt Jill}.
There are two similar single arrows from object \verb|##2|.
There is a double arrow between the two objects which has the
label {\tt husband} when going from \verb|##1| to \verb|##2|
and the label {\tt wife} when going in the reverse direction.

In order to permit \verb|:| to be used in an arrow label, the following
\key{quote representation rule} is applied to representations.
A quoted symbol cannot be recognized as an atom that has special
meaning in a representation, such as the \verb|::|, \verb|:|,
\verb|##|, or \verb|;;| atoms in raw representations.  Thus if any
of these atoms are to be part of an arrow label or target, they should
be represented by \verb|"::"|, \verb|":"|, \verb|"##"|, or \verb|";;"|.
Other than this rule, there is no
distinction between quoted and unquoted representations of typically
unquoted atoms.

The double-semi-colons (\verb|;;|) at the ends of arrow representations
may be omitted according to the \key{double-semi-colon representation rule}.
This rule says that the \ttmkey{;;}{omitting} at the end of an arrow
representation may be omitted provided the next line is not
indented with respect to the first non-whitespace character of the
arrow representation with the omitted \verb|;;|, or alternatively if the end of
text (e.g., end of file) immediately follows.
Thus the \verb|;;|'s in the example just given may be omitted.

We can say that \verb|##1| is the source of an arrow labeled \verb|type|
with target \verb|woman|, but instead we will usually say that
\verb|##1| has an attribute named \verb|type| with value \verb|woman|.
Thus in our example \verb|##1| has attributes named \verb|type|,
\verb|name|, and \verb|husband| that have values, respectively,
\verb|woman|, \verb|Jill|, and \verb|##2|.

In the rest of this document we use the terminolgy of attributes,
attribute name, and attribute values, in place of
arrows, arrow labels, and arrow targets.
An \key{attribute} of an object is just a single arrow sourced at the object,
or a double arrow viewed in the direction going away from the object.
The \key{attribute name}\index{name!attribute} is just the label of this arrow.
The \key{attribute value}\index{value!attribute} is just the target
of this arrow.

\subsection{Cooked Representations}

In contrast to the raw representation of a set of objects there is the
cooked representation, that is much easier to read and write, but a bit more
long winded to explain.

One rule of cooked representations is that some attributes may be
grouped together to form a list attribute, and the list attribute may
be represented more compactly.  The attributes that are grouped to
form the list are called element attributes.

For example, the element attributes

\begin{indpar}\begin{verbatim}
relatives 1: ##4
relatives 2: ##7
relatives 3: ##2
relatives 4: ##9
\end{verbatim}\end{indpar}

may be grouped to form the list attribute

\begin{indpar}\begin{verbatim}
relatives: ##4 ##7 ##2 ##9
\end{verbatim}\end{indpar}

while the element attributes

\begin{indpar}\begin{verbatim}
outline 1 1: straight
outline 1 2 : 3.2
outline 2 1: left
outline 3 1: straight
outline 3 2: 9.6
outline 4 1: left
outline 5 1: straight
outline 5 2: 3.2
outline 6 1: left
outline 7 1: straight
outline 7 2: 3.8
outline 8 1: door
outline 8 2: 2.0
outline 9 1: straight
outline 9 2: 3.8
outline 10 1: close
outline .separator: ","
\end{verbatim}\end{indpar}

may be grouped to form the list attribute

\begin{indpar}\begin{verbatim}
outline: straight 3.2, left, straight 9.6, left,
         straight 3.2, left, straight 3.8, door 2.0,
         straight 3.8, close
\end{verbatim}\end{indpar}

and the element attributes

\begin{indpar}\begin{verbatim}
text 1 1 1: The
text 1 1 2: orange
text 1 1 3: idea
text 1 1 4: is
text 1 1 5: peeping
text 1 2 1: furiously
text 1 .separator: ","
text 1 .terminator: "."
text 2 1: It's
text 2 2: fallen
text 2 3: for
text 2 4: the
text 2 5: purple
text 2 6: syllogism
text 2 .terminator: "!"
\end{verbatim}\end{indpar}

may be grouped to form the list attribute

\begin{indpar}\begin{verbatim}
text: The orange idea is peeping, furiously.  It's
      fallen for the purple syllogism!
\end{verbatim}\end{indpar}

Also curly brackets (\verb|{ }|) may be used to change
the format to a format suitable for code.  Thus the element
attributes

\begin{indpar}\begin{verbatim}
text 1 1 1: The
text 1 1 2: orange
text 1 1 3: idea
text 1 1 4: is
text 1 1 5: peeping
text 1 2 1: furiously
text 1 .separator: ","
text 1 .terminator: "."
text 2 1: It's
text 2 2: fallen
text 2 3: for
text 2 4: the
text 2 5: purple
text 2 6: syllogism
text 2 .terminator: "!"
\end{verbatim}\end{indpar}

may be grouped to form the list attribute

\begin{indpar}\begin{verbatim}
min: (x,y) {
     if x > y:
         return y;
     else:
         return x;
     }
\end{verbatim}\end{indpar}

\section{code}

Consider the following description of a room:

\begin{indpar}\begin{verbatim}
##523::
    type: standard room type
    outline: straight width, left, straight length, left,
             straight width, left,
             doored wall width,
             close
    width: 3.2
    length: 9.6
    doored wall: function ( length ) {
                     d = (length - door width) / 2
                     straight d
                     door (door width)
                     straight d }
    door : standard room door
    label: under(over), color(green)
    over: ##598
\end{verbatim}\end{indpar}

It turns out that most the attribute values for this room
object are pieces of executable code.

The \verb|type| attribute value, `{\tt standard room type}', names
a global variable whose value is an object that describes the type of
this object.

The \verb|outline| attribute value is a program to draw the outline of the
room.  This program is written from the point of view of a robot moving
around the outline of the room building walls.  The robot follows a sequence
of commands that are separated by commas.  A possible command is
`{\tt straight 3.2}', meaning the robot is to go straight \verb|3.2| units.
But in the example \verb|3.2| is replaced by
{\tt width}, which names an attribute of the object whose value in turn
is \verb|3.2|.  Here \verb|width| is an argument to the \verb|straight|
command.  If the argument is more than a single atom, it can be enclosed
in parentheses, as is the single argument to \verb|straight| in

\begin{center}
\verb|doored wall (door width )|
\end{center}

\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}


