% Minimal Descriptive Programming Language
%
% File:         min.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}{ p\pageref{#1}}}
\newcommand{\Secref}[1]{\ref{#1}{(p\pageref{#1})}}
\newcommand{\stepref}[1]{\ref{#1}{(p\pageref{#1})}}
\newcommand{\appref}[1]{\ref{#1}{ p\pageref{#1}}}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Minimal\\Descriptive Programming\\Language\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{Copyright 2004 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by my son's efforts at game design.}}

\date{August 21, 2004}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MIN, the Minimal Descriptive Programming
Language.

The main goal of MIN is to make it easy to describe objects,
and to write small pieces of program code that change object descriptions
in response to external inputs.  MIN has a geometry engine that translates
object descriptions into a geometrical data, video and audio engines
that translate the geometry and object data into visual and
audio displays, and a view engine that translates between object descriptions
and textual displays such as spreadsheets.

MIN is intended to be the smallest, simplest language that can perform
these tasks well.


\section{Remarks}


\section{Overview}


\section{Lexemes}
\label{LEXEMES}

MIN descriptions are representable by strings of characters that
can be stored in files.  When a MIN program reads these, it
scans the characters from left to right to produce a sequence
of \skey{lexeme}s.  There are five kinds of lexemes: words, numbers,
brackets, marks, and quoted strings.

A \key{word} is a string of letters.  E.g., {\tt fie}.  The underline
character (\ttmkey{\UNDERLINE}{letter}) is a letter.
A period (\ttmkey{.}{letter})
is a letter if it is followed by a letter; similarly an exclamation
mark (\ttmkey{!}{letter}) is a letter if it is followed by a letter,
and an appostrophe (\ttmkey{'}{letter}) is a letter if it
is followed by a letter.
E.g., \verb|.separator|, \verb|!set|, and \verb|it's| are words.

A \key{number} is a string of digits plus an optional \key{decimal point}.
E.g., {\tt 5.2}.  Any decimal point must be followed by a digit.

A \key{bracket} is a single bracket character.  E.g., \verb|[| and \verb|]|.
The \key{bracket characters} are parentheses
(\ttmkey{(}{bracket character} and \ttmkey{)}{bracket character}),
square brackets (\ttmkey{[}{bracket character} and
\ttmkey{]}{bracket character}),
curly brackets (\ttmkey{\LEFTBRACKET}{bracket character} and
\ttmkey{\RIGHTBRACKET}{bracket character}),
and single quotes (\ttmkey{`}{bracket character} and
\ttmkey{'}{bracket character}).  The close quote (\verb|'|) is
a letter, and not a bracket, if it is followed by a letter.

A \key{mark} is a string of mark characters, which are just characters
that are not letters or digits or decimal points or brackets or quotes.
E.g., \verb|+| and \verb|::|.  The \key{mark characters} are
comma (\ttmkey{,}{mark character}),
semi-colon (\ttmkey{;}{mark character}),
colon (\ttmkey{:}{mark character}),
period (\ttmkey{.}{mark character}) when not followed by a digit or
letter,
exclamation mark (\ttmkey{!}{mark character}) when not followed by a
letter,
at sign ({\tt @}\index{"@@{\tt "@}!mark character}),
pound sign (\ttmkey{\#}{mark character}),
dollar sign (\ttmkey{\$}{mark character}),
percent sign (\ttmkey{\%}{mark character}),
circumflex (\ttmkey{\CIRCUMFLEX}{mark character}),
ampersand (\ttmkey{\&}{mark character}),
asterix (\ttmkey{*}{mark character}),
minus sign (\ttmkey{-}{mark character}),
plus sign (\ttmkey{+}{mark character}),
equal sign (\ttmkey{=}{mark character}),
vertical bar (\ttmkey{\BAR}{mark character}),
back-slash (\ttmkey{\BACKSLASH}{mark character}),
less-than (\ttmkey{\LESSTHAN}{mark character}),
greater-than (\ttmkey{\GREATERTHAN}{mark character}),
slash (\ttmkey{/}{mark character}),
and
tilde (\ttmkey{\TILDE}{mark character}).


A \key{quoted string} is a string of characters that begins and ends with
a \verb|"| \key{quote character}.  The string of characters may include
spaces and escape sequences.  See~\secref{QUOTED-STRINGS} for details on
quoted strings.

Words, marks, and quoted strings are all \skey{symbol}s, which are just
character strings that can be used like words or marks.  A quoted string
may be just an alternate representation of a word or a mark.  Thus
{\tt hello} and {\tt "hello"} represent the same thing, the same symbol.
Similarly {\tt :} and {\tt ":"} represent the same symbol.  However
{\tt 0.123} is a number which is not a symbol, and {\tt "0.123"} is a symbol
which is not a number.

There are special rules for some characters.

An underline (\ttmkey{\UNDERLINE}{letter}) is a letter.

A \ttmkey{.}{letter}\index{.@{\tt .}!decimal point}
is a decimal point if followed by a digit, a letter if followed
by another letter, and a mark character otherwise.  E.g., {\tt 0.123} is
a number with a decimal pointer, {\tt .terminator} is a word beginning with
a letter, and {\tt `Hello.'} contains the word {\tt Hello}
followed by the \verb|.| mark.

Users of MIN should not create words that begin with
\ttmkey{.}{reserved use}; such words
are reserved for use by the designers of MIN.

An exclamation mark ({\tt !}\index{"!@{\tt "!}!letter}%
\index{"!@{\tt "!}!mark character})
is a letter if followed by another letter, and a mark character
otherwise.  E.g., {\tt !set} is a word and {\tt `Hello!'} contains the
word {\tt Hello} followed by the \verb|!| mark.

Similarly the close quote (\ttmkey{'}{letter}) is a letter if followed
by a letter, as in \verb|it's|, and a closing bracket otherwise.

The double quote ({\tt "}\index{""@{\tt ""}}) is used to begin and end
quoted strings.

A \ttkey{\BACKSLASH} is a mark character if it occurs outside quoted
strings, and is an \key{escape character} if it occurs inside quoted strings.
As an escape character it is used to begin a sequence of characters called
an escape sequence that denotes a single character.
See~\pagref{ESCAPE-SEQUENCES} for details on escape sequences.

White-space characters, the \key{space character}, the \key{tab character},
the \key{new line character}, the \key{form feed character}, and the
\key{vertical tab} character are used to separate lexemes.  The space
character can be used to represent a single space inside quoted strings.
The tab character is always equivalent to one or more space characters,
with tabs set every 8 columns.
The other whitespace characters have special interpretation inside quoted
strings, see~\secref{QUOTED-STRINGS}.

\subsection{Quoted Strings}
\label{QUOTED-STRINGS}

TBD
\label{ESCAPE-SEQUENCES}

\section{Data}

A \key{datum} in MIN is either an atom, an object, or an arrow.

An \key{atom} is either a symbol (word, mark, or quoted string) or a
number.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it has nothing else.

However, as a place in memory, an object has a name.  Objects are assigned
\skey{raw object name}s
of the form `\ttmkey{\#\#}{in raw object name}$I$' where $I$
is an integer that starts
with {\tt 1} for the first object created and continues in sequence as
more objects are created.  E.g., the first three objects created have the
raw object names \verb|##1|, \verb|##2|, and \verb|##3|. 

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a label, which is a sequence of zero or
more atoms.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.

An \key{arrow label} is a sequence of zero or more atoms.
Two arrows leaving the same object may not have the same label.  Thus
arrows can be named by giving an object which is the source of the arrow
and a label which is the label of a single arrow or the label in the
direction leaving the object of a double arrow.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In most of this document
arrows are called attributes, arrow labels are called attribute names,
and arrow targets are called attribute values.

\subsection{Raw Representations}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set must be used
in the file.  The simplest representation is the raw representation,
which we now describe.

The format of a \key{raw representation} is:

\begin{center}
\begin{tabular}{l}
\key{raw-representation} ::= {\em raw-object-representation} \ldots
\\[1ex]
\key{raw-object-representation} ::=
    {\em raw-object-header}
    {\em raw-arrow-representation} \ldots
\\[1ex]
\key{raw-object-header}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-object-name} \ttmkey{::}{in {\em raw-object-header}} \\
    $|$ & {\em raw-object-name} \ttmkey{:>>:}{in {\em raw-object-header}} \\
    \end{tabular}
\\[1ex]
\key{raw-arrow-representation}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-single-arrow-representation} \\
    $|$ & {\em raw-double-arrow-representation}
    \end{tabular}
\\[1ex]
\key{raw-single-arrow-representation} ::=
	{\em arrow-label}\ttmkey{:}{in {\em raw-single-arrow-representation}}
	{\em single-arrow-target}
	\ttmkey{;;}{in {\em raw-single-arrow-representation}}
\\[1ex]
\key{single-arrow-target} ::= {\em atom} $|$ {\em raw-object-name}
\\[1ex]
\key{raw-double-arrow-representation} ::=
	{\em arrow-label}\ttmkey{:}{in {\em raw-double-arrow-representation}}
	{\em double-arrow-target}
	{\tt :}{\em arrow-label}
	\ttmkey{;;}{in {\em raw-double-arrow-representation}}
\\[1ex]
\key{double-arrow-target} ::= {\em raw-object-name}
\\[1ex]
\key{raw-object-name} ::=
	\ttmkey{\#\#}{in {\em raw-object-name}}{\em non-negative-integer}
\\[1ex]
\key{arrow-label} ::= {\em atom} \ldots
\\[1ex]
\key{atom} ::= {\em non-special-lexeme} \ldots
\\[1ex]
\key{special-lexeme} ::= \verb|##| $|$ \verb|::| $|$ \verb|:>>:|
		$|$ \verb|:| $|$ \verb|;;|

\end{tabular}
\end{center}%
\index{label!arrow}%
\index{source!arrow}%
\index{target!arrow}

A simple example of the raw representation of a set of objects is:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##1::|\\
\verb|    type: woman;;|\\
\verb|    name: Jill;;|\\
\verb|    husband: ##2 :wife;;|\\
\verb|##2::|\\
\verb|    type: man;;|\\
\verb|    name: Jack;;|\\
\verb|    wife: ##1 :husband;;|
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt \#\#1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt \#\#2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

This represents two objects.
There are two single arrows from object \verb|##1|,
one arrow labeled {\tt type} whose target is the atom {\tt woman},
and one arrow labeled {\tt name} whose target is the atom {\tt Jill}.
There are two similar single arrows from object \verb|##2|.
There is a double arrow between the two objects which has the
label {\tt husband} when going from \verb|##1| to \verb|##2|
and the label {\tt wife} when going in the reverse direction.

In order to permit \verb|:| to be used in an arrow label, the following
\key{quote representation rule} is applied to representations.
A quoted symbol cannot be recognized as an atom that has special
meaning in a representation, such as the \verb|::|, \verb|:|,
\verb|##|, or \verb|;;| atoms in raw representations.  Thus if any
of these atoms are to be part of an arrow label or target, they should
be represented by \verb|"::"|, \verb|":"|, \verb|"##"|, or \verb|";;"|.
Other than this rule, there is no
distinction between quoted and unquoted representations of typically
unquoted atoms.

The double-semi-colons (\verb|;;|) at the ends of arrow representations
may be omitted according to the \key{double-semi-colon representation rule}.
This rule says that the \ttmkey{;;}{omitting} at the end of an arrow
representation may be omitted provided the next line is not
indented with respect to the first non-whitespace character of the
arrow representation with the omitted \verb|;;|, or alternatively if the end of
text (e.g., end of file) immediately follows.
Thus the \verb|;;|'s in the example just given may be omitted.

We can say that \verb|##1| is the source of an arrow labeled \verb|type|
with target \verb|woman|, but instead we will usually say that
\verb|##1| has an attribute named \verb|type| with value \verb|woman|.
Thus in our example \verb|##1| has attributes named \verb|type|,
\verb|name|, and \verb|husband| that have values, respectively,
\verb|woman|, \verb|Jill|, and \verb|##2|.

In the rest of this document we use the terminolgy of attributes,
attribute name, and attribute values, in place of
arrows, arrow labels, and arrow targets.
An \key{attribute} of an object is just a single arrow sourced at the object,
or a double arrow viewed in the direction going away from the object.
The \key{attribute name}\index{name!attribute} is just the label of this arrow.
The \key{attribute value}\index{value!attribute} is just the target
of this arrow.

The difference between \ttkey{::} and \ttkey{:>>:} is that the former
indicates that the object should not previously
exist, while the later indicates that the attributes are to be added to
any existing object, though if the object does not exist it will be
created.  It is an error to add to an existing object an attribute with the
same name as an existing attribute of that object.


Object \ttkey{\#\#0} is special: it is the \ttkey{.GLOBAL} object, and
its attributes are called \skey{global variables}.  One of the global
variables is named {\tt .GLOBAL} and has as its value the {\tt .GLOBAL}
object, a situation which can be achieved by the data representation:



\begin{indpar}\begin{verbatim}
##0:>>:
    .GLOBAL: ##0
\end{verbatim}\end{indpar}



\subsection{Cooked Representations}

In contrast to the raw representation of a set of objects there is the
cooked representation, that is much easier to read and write, but a bit more
long winded to explain.

The main thing that the cooked representation does is take certain objects
that are organized like lists and represent them as lists.

For example,

\begin{indpar}\begin{verbatim}
##93:: This is a sentence.
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{indpar}\begin{verbatim}
##93::
    1: this
    2: is
    3: a
    4: sentence
    .terminator: "."
    .initiator: capital
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
##46:: straight 3.2, left, straight (y + 9.4)
\end{verbatim}\end{indpar}

is the cooked representation of the set of objects

\begin{indpar}\begin{verbatim}
##42:: 
    1: straight
    2: 3.2
##43:: 
    1: "+"
    .initiator: "`"
    .terminator: "'"
##44:: 
    1: .sum
    2: y
    3: ##43
    4: 9.4
    .initiator: "("
    .terminator: ")"
##45:: 
    1: straight
    2: ##44
##46::
    1: ##42
    2: left
    3: ##45
    .separator: ","
\end{verbatim}\end{indpar}

Also curly brackets (\verb|{ }|) are used to change to
a format suitable for code.  Thus

\begin{indpar}\begin{verbatim}
##138:: function (x,y)
        {
           if (x > y):
               return y
           else:
               return x
        }
\end{verbatim}\end{indpar}

is the cooked representation of

\begin{indpar}\begin{verbatim}
##130::
    1: x
    2: y
    .separator: ","
    .initiator: "("
    .terminator: ")"
##131::
    1: ">"
    .initiator: "`"
    .terminator: "'"
##132::
    1: .compare
    2: x
    3: ##131
    4: y
##133::
    1: return
    2: y
    .initiator: ":"
##134::
    1: if
    2: ##132
    3: ##133
##135::
    1: return
    2: x
    .initiator: ":"
##136::
    1: else
    2: ##135
##137::
    1: ##134
    2: ##136
    .initiator: "{"
    .terminator: "}"
##138::
    1: function
    2: ##130
    2: ##137
\end{verbatim}\end{indpar}

Cooked representations may replace raw object names in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
##291:: text: This is a sentence.
        outline: straight 3.2, left, straight (y + 9.4)
        min: function (x,y)
             {
                if (x > y):
                    return y
                else:
                    return x
             }
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{indpar}\begin{verbatim}
##291::
    text: ##93
    outline: ##46
    min: ##138
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
##291:: text A: This is a sentence.
        text B: This is a sentence.
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
##291::
    text A: ##93
    text B: ##93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
##291::
    text A: ##93
    text B: ##521
\end{verbatim}\end{indpar}

where object \verb|##521| happens to have the same structure as
object \verb|##93|.  The default is to make both \verb|text A|
and \verb|text B| be the same object, \verb|##93|, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object names in the cooked representations of other
objects.

A couple of generalizations about certain attribute names are in
order.  First, the strictly positive integers \verb|1|, \verb|2|,
\verb|3|, \ldots are used to name the elements of a list.  Second,
some attribute names beginning with `\verb|.|' have special
meaning for object representation.  Examples above are
\verb|.separator|, \verb|.initiator|, and \verb|.terminator|.
Recall that words beginning with `\verb|.|' are reserved for
use by the MIN system, and should not be defined by MIN users.

In the following sections we describe cooked representations
precisely.

\subsection{Syntax}

\begin{boxedfigure}

\begin{center}

Ad Hoc Special Lexemes

\bigskip

\begin{tabular}{ll@{\hspace*{5em}}ll}
\ttkey{::} & object assignment &
\ttkey{:>>:} & object addition \\
\ttkey{:} & attribute assignment &
\ttkey{:} & code indicator \\
\end{tabular}

\bigskip

Brackets

\bigskip

\begin{tabular}{ll@{\hspace*{5em}}ll}

\ttkey{(}~~~\ttkey{)}	& parentheses. &
\ttkey{[}~~~\ttkey{]}	& square brackets \\
\ttkey{\CurlyBra}~~~\ttkey{\CurlyKet}	& curly brackets &
\ttkey{`}~~~\ttkey{'}	& single quotes \\
\end{tabular}

\bigskip

Standard Operators

\bigskip

\begin{tabular}{rl@{\hspace*{2em}}l@{\hspace*{2em}}l}

	 & implied \\
priority & prefix	& operators	& meaning 
\\[2ex]
-5000 & {\em special} &  \ttkey{.} ~~~ \ttkey{!} ~~~ \ttkey{?}	& sentence terminators \\
-4000 & {\em special} &  \ttkey{;} & subsentence separator \\
-3000 & {\em special} &  \ttkey{,} & phrase separator \\
+0000 & \ttkey{.CONDITIONAL} &  \ttkey{if} ~~~ \ttkey{then} ~~~ \ttkey{else}
	& conditionals \\
+1000 & \ttkey{.LOGICAL} &  \ttkey{and} ~~~ \ttkey{or} ~~~ \ttkey{not}
	& logical AND, OR, NOT \\
+2000 & \ttkey{.COMPARE} &  \ttkey{=} ~~~ \ttkey{/=} ~~~
        \ttkey{!=} 			& equal, not equal, ditto \\
      &		      & \ttkey{<} ~~~ \ttkey{<=} ~~~ \ttkey{=<}
      & less than, less than or equal, \\
      &		      &		&
      ditto \\
      &		      & \ttkey{>} ~~~ \ttkey{>=} ~~~ \ttkey{=>}
      & greater than, greater than or \\
      &		      &		&
      equal, ditto \\
+3000 & \ttkey{.SUM} &  \ttkey{+} ~~~ \ttkey{-}
	& addition, subtraction \\
+3100 & \ttkey{.PRODUCT} &  \ttkey{*} ~~~ \ttkey{/} 
	& multiplication, division \\
+9999 & \ttkey{.OBJNAME} &  \ttkey{\#\#}
	& object name \\
\end{tabular}

\end{center}

\caption{Special Lexemes}
\label{SPECIAL-LEXEMES}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{l}
\key{data-representation} ::= {\em object-representation} \ldots
\\[1ex]
\key{object-representation} ::=
    {\em object-header}
    {\em attribute-representation} \ldots
\\[1ex]
\key{object-header}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em object-name} \ttmkey{::}{in {\em object-header}} \\
    $|$ & {\em object-name} \ttmkey{:>>:}{in {\em object-header}} \\
    \end{tabular}
\\[1ex]
\key{attribute-representation}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em cooked-attribute-representation} \\
    $|$ & {\em double-arrow-attribute-representation}
    \end{tabular}
\\[1ex]
\key{cooked-attribute-representation} ::=
	{\em attribute-label}\ttmkey{:}{in {\em cooked-attribute-representation}}
	{\em expression}
	\ttmkey{;;}{in {\em cooked-attribute-representation}}
\\[1ex]
\key{double-arrow-attribute-representation} ::=
\\\hspace*{1in}
	{\em attribute-label}\ttmkey{:}{in
		{\em double-arrow-attribute-}!{\em representation}}
	{\em double-arrow-target}
	{\tt :}{\em attribute-label}
	\ttmkey{;;}{in {\em double-arrow-attribute-}!{\em representation}}
\\[1ex]
\key{double-arrow-target} ::= {\em object-name}
\\[1ex]
\key{object-name} ::=
	\ttmkey{\#\#}{in {\em object-name}}{\em non-negative-integer}
\\[1ex]
\key{attribute-label} ::= {\em atom} \ldots
\\[1ex]
\key{atom} ::= non-special lexeme: see Table~\ref{SPECIAL-LEXEMES}
\\[1ex]
\key{expression} ::= {\em expression(-9999)}
\\[1ex]
{\em expression($N$)} ::=
	\{ {\em expression($N+1$)} $|$ {\em operator($N$)} \}\ldots
\\[1ex]
\key{operator}{\em ($N$)} ::= operator of priority $N$:
			      see Table~\ref{SPECIAL-LEXEMES}
\\[1ex]
{\em expression(10000)} ::= {\em atom} $|$ {\em bracketted-expression}
\\[1ex]
\key{bracketted-expression} \begin{tabular}[t]{@{}rl@{}}
			    ::= & \verb|(| {\em expression} \verb|)| \\
			    $|$ & \verb|[| {\em expression} \verb|]| \\
			    $|$ & \verb|{| {\em expression} \verb|}| \\
			    $|$ & \verb|`| {\em expression} \verb|'| \\
			    \end{tabular}

\end{tabular}
\end{center}%
\index{label!attribute}%
\index{name!object}

\caption{Data Representation Syntax}
\label{DATA-REPRESENTATION-SYNTAX}
\end{boxedfigure}


A cooked data representation has the syntax given
in Table~\ref{DATA-REPRESENTATION-SYNTAX} and is based on the
special lexemes given in Table~\ref{SPECIAL-LEXEMES}.

\section{Evaluation}

Consider the following description of a room:

\begin{indpar}\begin{verbatim}
##523::
    type: standard room
    outline: straight width, left, straight length, left,
             straight width, left,
             doored wall width,
             close
    width: 3.2
    length: 9.6
    doored wall: function ( length ) {
                     d = (length - door width) / 2
                     straight d
                     door (door width)
                     straight d }
    door : standard room door
    label: color green, under over, noun room
    over: ##598
\end{verbatim}\end{indpar}

The information in this description is not immediately useful for
producing output, such as a video picture of the room, or text naming
the room.  Instead, parts of the description must be evaluated to produce
the picture or the name.

The goal of an evaluation is to produce \key{derived information} which is
frequently stored in a derived attribute of an object.  A \key{derived
attribute} is just any attribute that stores derived information.  Derived
attributes are often also \skey{hidden attribute}s, which are just
attributes whose names begin with `\ttmkey{.}{hidden attribute}', and which
are not normally output when the object is saved.

For example, a very important derived attribute of any object is its
inheritance list, which is the value of the object's \verb|.ancestors|
attribute, and which is a list of other objects from which the current
object inherits attributes.  In our example, the \verb|type| attribute
names another object, `{\tt standard room}', from which the room object
inherits attributes.  This means that when an evaluation searches for the
name of an attribute in the room object, if that name is not found, the
evaluation will next search the `{\tt standard room}' object.

To compute the \verb|.ancestors| attribute an the \verb|type| object
is evaluated `in global context'.  This last implies that the only
names the evaluator can use are global variable names, and `{\tt standard
room}' in fact names a global variable whose value is the object
which is the sole immediate ancestor of our room.

The \verb|outline| attribute value is used to compute a derived attribute
named \verb|.video| which describes how the object is to be displayed
graphically.
The \verb|outline| attribue value is a program is written from the point
of view of a robot moving around the outline of the room building walls.
The robot follows a sequence of commands that are separated by commas.

In order to show how evaluation works, we will explain in detail some
of the evaluation of \verb|outline|.

Evaluation of the \verb|outline| attribute of object \verb|##523|
is triggered when the value
of the \verb|.video| attribute of this object is needed.  Computation
of the \verb|.video| attribute is be done by a function
named {\tt .make .video}, which in this case is defined by {\tt standard
room} which is an ancestor of \verb|##523|.
If this function did not exist, compuation would done by the function
named {\tt .make}, which is globally defined, and which would attempt
to evaluate the {\tt video} attribute (without the `\verb|.|') of
\verb|##523| to produce this object's \verb|.video| attribute
(with the `\verb|.|').  In any case, computation of an attribute AA
can be done in a fashion taylored to what is being computed by defining a
`\verb|.make| AA' function in an object or one of its ancestors.

In our case the \verb|.make .video| function evaluates
the \verb|outline| attribute of \verb|##523| to produce
a value for the \verb|.video| attribute of \verb|##523|.
First the function establishes
a context, which is a list of objects that will be searched when an
attribute name is to be located.  The context for the evaluation of
an object's attribute value usually begins with the object and ends with
a special object called `\verb|.GLOBAL|'.  A global variable is by definition
just an attribute of the \verb|.GLOBAL| object.  An function evaluating
an {\tt outline} attribute is likely to include in the context an object
that defines functions named `{\tt straight}' and `{\tt left}' which will
evaluate parts of the {\tt outline} attribute.

Besides establishing a context, the \verb|.make| function establishes an
execution frame.  The execution frame may contain output
channels, which are places to put output.  In this case the value of
\verb|.video| becomes an output channel into which functions like
`{\tt straight}' will write new commands written in a video language
that can be processed by the video engine to produce a picture.

Since functions such as `{\tt straight}' and `{\tt left}' are written
from the point of view of a robot moving around the outline of a room,
the execution frame also contains the current location and direction
of the robot.

After establishing a context and frame, the evaluating function starts reading
the \verb|outline| attribute value which is to be evaluated.  In this
case the it finds a comma separated list of commands, and evaluates
each command separately.

The first command is `{\tt straight width}'.   When `{\tt straight}' is 
read, a search is made in the current context for an attribute with a name
beginning with the word `{\tt straight}'.  One will be found whose total
name is just the single word `{\tt straight}', and the value of that
attribute will be taken.  We have not shown that attribute, but it will
exist and have a value of the form

\begin{center}
\verb|function ( w ) { |\ldots\verb|}|
\end{center}

This value means the expression we are reading should have next, after the
word `{\tt straight}', a single argument.  An argument
is either a single lexeme or a bracketted string of lexemes.  The argument
must be read, and perhaps evaluated and replaced by its value, which becomes
the value of the \verb|w| argument of the `{\tt straight}' function.
Then this function is evaluated.

In our case `{\tt width}' follows `{\tt straight}'.  This is an unbracketted
single lexeme argument, and as such must be evaluated and replaced by
its value.  A search is made for an attribute whose name begins with
`{\tt width}'.  The `{\tt width}' attribute of \verb|##523| is found,
and as its value is a number,
\verb|3.2|, that is the final value of the `{\tt width}' argument.
Thus the command `{\tt straigth width}' has become `{\tt straight 3.2}',
and this is then evaluated by executing the `{\tt straight}' function
with \verb|w| equal to \verb|3.2|.  The result will be some command
written into the {\tt .video} attribute of \verb|##523|.

The other commands in the {\tt outline} attribute are similar, except
for the `{\tt doored wall width}' command.  This invokes the `{\tt doored wall}'
function we have defined as an attribute of \verb|##523| (but it would
make more sense to define it as an attribute of the {\tt standard room}
object whose attributes are inherited by \verb|##523|).   Again
`{\tt width}' is the argument which evaluates to \verb|3.2| and becomes
the value of the `{\tt length}' argument in the `{\tt doored wall}'
function.  Evaluation of the `{\tt doored wall}' function is next,
and as a function,
its evaluation context begins with an object called the function frame
that has an attribute named `{\tt length}' whose value is the corresponding
argument value, in this case \verb|3.2|.

A special feature of the MIN language is are dependency lists which
can be used to figure out when to re-compute attribute values, such as
the \verb|.video| attribute of \verb|##523|.  Each attribute X can have
a dependency list which specifies all the other attibutes Y, Z, \ldots
whose values depend upon the value of X.  When the value of X is changed,
the values of Y, Z, \ldots are marked `obsolete', which identifies them
as needing to be recomputed.  Thus in the current case the \verb|width|
attribute of \verb|##523| has a dependency list that includes the
\verb|.video| attribute of \verb|##523|.  Not all attributes will have
dependency lists: the \verb|.ancestors| attribute of an object would
have a very long dependency list, if it existed, that included all the
attributes ever computed from the object, and for this reason the
\verb|.ancestors| attribute has no dependency list, so changing it does
not mark other values obsolete.

We also need to explain
the meaning of the `{\tt label}' and `{\tt over}' attribute values
of \verb|##523|.  It is necessary to produce a name
for \verb|##523| in an arbitrary natural language, such as English or
French or Japanese, and this is what the `{\tt label}' attribute value does
when it is evaluated.  This value is also a sequence of commands that
provide desriptive information about the object which the natural language
engine can process to produce the desired text.  The `{\tt color green}'
command invokes the `{\tt color}' function with an argument that is
some object which is the value of the `{\tt green}' variable to
produce some internal notation that tells the natural language engine
that \verb|##523| has the color green.  Similarly `{\tt over under}'
invokes the `{\tt over}' function with an the `{\tt under}' argument that
just names an attribute of \verb|##523| with value \verb|##598|.  This
says that \verb|##523| is under \verb|##598|.  Lastly, `{\tt noun room}'
says that \verb|##523| is a room.

If the label of \verb|##598| is

\begin{center}
\verb|label: adjective main, noun dungeon|
\end{center}

then the English natural language engine might generate the text

\begin{center}
\verb|the green room under the main dungeon|
\end{center}

in order to specify \verb|##523|.

\subsection{The Evaluation Algorithm}


\begin{indpar}\begin{verbatim}

    evaluate ( expression, context ):
        if expression is a single number atom:
            return atom
        if expression is `...' bracketted:
            return expression without the `'s
        search ( expression, context )

    search ( expression, context ):
        foreach object in context:
            search (expression, context, object )
        search ( expression, context, .GLOBAL object )

    search ( expression, context, object ):
       if expression is empty and object is not a function with
          no arguments or an object with an attribute with the
          empty label:
           return object
       if object is function definition:
           execute ( expression, context, object )

       match names of object attributes to beginning of expression
       if several match:
           pick the longest match
           set r = expression with matched portion removed
           set v = value of matched attribute
           search ( r, context, v )
       else for each ancestor of object:
           search ( expression, context, ancestor )
       error

    execute ( expression, context, function ):
        make a new function frame F
        for each argument name N in function:
            let A be the next atom or bracketted
                subexpression of expression
            remove A from expression
            let V = evaluate ( A, context )
            make an attribute of F with name N and
                 value V
        let B be the body of the function
        let C be the context list with F prepended
        let V = evaluate ( B, C )
        search ( expression, context, V )

\end{verbatim}\end{indpar}



\subsection{Expressions and Subexpressions}

An \key{expression} is just a list of atoms and bracketted
subexpressions:


\subsection{Search}

\ikey{Search}{search} is part of the evaluation process.

Search is invoked with a \key{context}, which is just a list of
objects, and an expression, which is just a list of atoms.
The goal of search is to find an attribute whose name begins the expression.


\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}


