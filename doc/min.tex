% Minimal Descriptive Programming Language
%
% File:         min.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Minimal\\Descriptive Programming\\Language\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{Copyright 2005 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by my son's budding career as a game designer.}}

\date{February 16, 2005}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MIN, the Minimal Descriptive Programming
Language.

The main goal of MIN is to make it easy to describe objects,
and to write small pieces of program code that change object descriptions
in response to external inputs.  MIN has a geometry engine that translates
object descriptions into a geometrical data, video and audio engines
that translate the geometry and object data into visual and
audio displays, and a view engine that translates between object descriptions
and textual displays such as spreadsheets.

MIN is intended to be the smallest, simplest language that can perform
these tasks well.


\section{Remarks}


\section{Overview}


\section{Lexemes}
\label{LEXEMES}

MIN descriptions are representable by strings of characters that
can be stored in files.  When a MIN program reads these, it
scans the characters from left to right to produce a sequence
of \skey{lexeme}s.  There are five kinds of lexemes: words, numbers,
brackets, marks, and quoted strings.

A \key{word} is a string of letters.  E.g., {\tt fie}.  The underline
character (\ttmkey{\UNDERLINE}{letter}) is a letter.
A period (\ttmkey{.}{letter})
is a letter if it is followed by a letter; similarly an exclamation
mark (\ttmkey{!}{letter}) is a letter if it is followed by a letter,
and an apostrophe (\ttmkey{'}{letter}) is a letter if it
is followed by a letter.
E.g., \verb|.separator|, \verb|!set|, and \verb|it's| are words.

A \key{number} is a string of digits plus an optional \key{decimal point}.
E.g., {\tt 5.2}.  Any decimal point must be followed by a digit.

A \key{bracket} is a single bracket character.  E.g., \verb|[| and \verb|]|.
The \key{bracket characters} are parentheses
(\ttmkey{(}{bracket character} and \ttmkey{)}{bracket character}),
square brackets (\ttmkey{[}{bracket character} and
\ttmkey{]}{bracket character}),
curly brackets (\ttmkey{\LEFTBRACKET}{bracket character} and
\ttmkey{\RIGHTBRACKET}{bracket character}),
and single quotes (\ttmkey{`}{bracket character} and
\ttmkey{'}{bracket character}).  The close quote (\verb|'|) is
a letter, and not a bracket, if it is followed by a letter.

A \key{mark} is a string of mark characters, which are just characters
that are not letters or digits or decimal points or brackets or quotes.
E.g., \verb|+| and \verb|::|.  The \key{mark characters} are
comma (\ttmkey{,}{mark character}),
semi-colon (\ttmkey{;}{mark character}),
colon (\ttmkey{:}{mark character}),
period (\ttmkey{.}{mark character}) when not followed by a digit or
letter,
exclamation mark (\ttmkey{!}{mark character}) when not followed by a
letter,
at sign ({\tt @}\index{"@@{\tt "@}!mark character}),
pound sign (\ttmkey{\#}{mark character}),
dollar sign (\ttmkey{\$}{mark character}),
percent sign (\ttmkey{\%}{mark character}),
circumflex (\ttmkey{\CIRCUMFLEX}{mark character}),
ampersand (\ttmkey{\&}{mark character}),
asterisk (\ttmkey{*}{mark character}),
minus sign (\ttmkey{-}{mark character}),
plus sign (\ttmkey{+}{mark character}),
equal sign (\ttmkey{=}{mark character}),
vertical bar (\ttmkey{\BAR}{mark character}),
back-slash (\ttmkey{\BACKSLASH}{mark character}),
less-than (\ttmkey{\LESSTHAN}{mark character}),
greater-than (\ttmkey{\GREATERTHAN}{mark character}),
slash (\ttmkey{/}{mark character}),
and
tilde (\ttmkey{\TILDE}{mark character}).


A \key{quoted string} is a string of characters that begins and ends with
a \verb|"| \key{quote character}.  The string of characters may include
spaces and escape sequences.  See~\secref{QUOTED-STRINGS} for details on
quoted strings.

Words, marks, and quoted strings are all \skey{symbol}s, which are just
character strings that can be used like words or marks.  A quoted string
may be just an alternate representation of a word or a mark.  Thus
{\tt hello} and {\tt "hello"} represent the same thing, the same symbol.
Similarly {\tt :} and {\tt ":"} represent the same symbol.  However
{\tt 0.123} is a number which is not a symbol, and {\tt "0.123"} is a symbol
which is not a number.

There are special rules for some characters.

An underline (\ttmkey{\UNDERLINE}{letter}) is a letter.

A \ttmkey{.}{letter}\index{.@{\tt .}!decimal point}
is a decimal point if followed by a digit, a letter if followed
by another letter, and a mark character otherwise.  E.g., {\tt 0.123} is
a number with a decimal point, {\tt .terminator} is a word beginning with
a letter, and {\tt `Hello.'} contains the word {\tt Hello}
followed by the \verb|.| mark.

Users of MIN should not create words that begin with
\ttmkey{.}{reserved use}; such words
are reserved for use by the designers of MIN.

An exclamation mark ({\tt !}\index{"!@{\tt "!}!letter}%
\index{"!@{\tt "!}!mark character})
is a letter if followed by another letter, and a mark character
otherwise.  E.g., {\tt !set} is a word and {\tt `Hello!'} contains the
word {\tt Hello} followed by the \verb|!| mark.

Similarly the close quote (\ttmkey{'}{letter}) is a letter if followed
by a letter, as in \verb|it's|, and a closing bracket otherwise.

The double quote ({\tt "}\index{""@{\tt ""}}) is used to begin and end
quoted strings.

A \ttkey{\BACKSLASH} is a mark character if it occurs outside quoted
strings, and is an \key{escape character} if it occurs inside quoted strings.
As an escape character it is used to begin a sequence of characters called
an escape sequence that denotes a single character.
See~\pagref{ESCAPE-SEQUENCES} for details on escape sequences.

White-space characters, the \key{space character}, the \key{tab character},
the \key{new line character}, the \key{form feed character}, and the
\key{vertical tab} character, are used to separate lexemes.  The space
character can be used to represent a single space inside quoted strings.
The tab character is always equivalent to one or more space characters,
with tabs set every 8 columns.
The other whitespace characters have special interpretation inside quoted
strings, see~\secref{QUOTED-STRINGS}.

\subsection{Quoted Strings}
\label{QUOTED-STRINGS}

A \key{quoted string} is an alternative representation of a symbol, the
other representations being words and marks.  The quoted string \verb|"::"|
and the mark \verb|::| represent the same thing.  Quoted strings can
represent symbols that have characters in them which cannot be in words
or marks.

There is one difference between a quoted string and its corresponding
word or mark, e.g.~between \verb|"+"| and \verb|+|.  This is that the
quoted string cannot be interpreted as an operator during parsing, while
the word or mark, if it is an operator, can be so interpreted.
See \secref{STANDARD-REPRESENTATIONS}.

A quoted string consists of a sequence of
\skey{character representative}s
surrounded by double quotes (\verb|"|\index{""@{\tt ""}}).  A non-whitespace
character other than quote (\verb|"|) or backslash (\verb|\|)
can be used to represent itself.  The single space character can be used
to represent itself.  Any sequence of line feeds and carriage returns
containing at least one line feed represents a single line feed.
The other character representatives are called \skey{escape sequence}s,
and consist of a backslash (\verb|\|\index{\\@{\tt \BACKSLASH}})
followed by other characters.  The possible escape sequences are:

\begin{center}
\begin{tabular}{lp{4in}}
\verb|\n| & new line \\
\verb|\r| & carriage return \\
\verb|\t| & horizontal tab \\
\verb|\b| & backspace \\
\verb|\f| & form feed \\
\verb|\v| & vertical tab \\
\verb|\\| & \verb|\| \\
\verb|\"| & \verb|"| \\[1ex]
\verb|\x|$hh$ & character with ASCII code $hh$ as a 2 digit
		hexadecimal number \\[1ex]
\verb|\|$ooo$ & character with ASCII code $ooo$ as a
		3 digit octal number \\[1ex]
\verb|\|{\em new-line} {\em white-space}
		& the backslash, new line, and all following white space
		  characters are replaced by a space character \\[1ex]
\verb|\+|{\em new-line} {\em white-space}
		& the backslash, {\tt +}, new line, and all following
		  white space characters are deleted \\
\end{tabular}
\end{center}%
\label{ESCAPE-SEQUENCES}%
\index{n@{\tt \BACKSLASH n}}%
\index{r@{\tt \BACKSLASH r}}%
\index{t@{\tt \BACKSLASH t}}%
\index{b@{\tt \BACKSLASH b}}%
\index{f@{\tt \BACKSLASH f}}%
\index{v@{\tt \BACKSLASH v}}%
\index{\\2@{\BACKSLASH\BACKSLASH}}%
\index{""2@{\tt \BACKSLASH""}}%
\index{space character 2@{\BACKSLASH{\em space}}}%
\index{x@{\tt \BACKSLASH x}$hh$}%
\index{digit@{\BACKSLASH{\em digit}}}%
\index{new line 2@{\BACKSLASH{\em new-line} {\em white-space}}}
\index{+@{\BACKSLASH{\tt +} {\em new-line} {\em white-space}}}

Single space characters after a quoted string new line representative
are removed up through the column containing the initial quote (\verb|"|)
of the quoted string.  Thus

\begin{indpar}\begin{verbatim}
some text "This is a line.
           And another line."
\end{verbatim}\end{indpar}

contains a quoted string that represents two lines, the first beginning
with `\verb|This|' and second beginning with `\verb|And|'.  There is no
whitespace at the beginning of the second represented line, as the whitespace
at the beginning of its representing quoted string line is removed.
The last removed whitespace column is that of the \verb|"| beginning the
quoted string.

Tab characters in are always equivalent to one or more space characters,
with tabs set every 8 columns.  Columns are counted with respect to the
beginning of the line, and \underline{not} the beginning of any quoted string.

Form feed and vertical tabs cannot appear inside a quoted string.  Carriage
returns cannot appear inside or outside a quoted string
except in a sequence containing a line feed.
Non-whitespace control characters cannot appear inside or outside a quoted
string.  All these characters can be represented by escape sequences inside
a quoted string.



\section{Data}

A \key{datum} in MIN is either an atom, an object, or an arrow.

An \key{atom} is either a symbol (word, mark, or quoted string) or a
number.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it is nothing more.

However, as a place in memory, an object has a name.  Objects are assigned
\skey{raw object name}s
of the form `\ttmnbkey{\#\#}{in raw object name}$I$' where $I$
is an integer.  Raw object names of this form are assigned only to objects
that must be named in an output stream (e.g., printed output).
The first object named in output stream is assigned the name
\verb|##1|, the second object named in output the name \verb|##2|,
and so forth.  The same object may be assigned different names in different
output streams.\footnote{A possible implementation is to give objects that
have been assigned names in an output stream a hidden system defined output
stream specific attribute equal to the object's name integer.}

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a label, which is a sequence of zero or
more atoms.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.

An \key{arrow label} is a sequence of zero or more atoms.
Two arrows leaving the same object may not have the same label.  Thus
arrows can be named by giving an object which is the source of the arrow
and a label which is the label of a single arrow or the label in the
direction leaving the object of a double arrow.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In most of this document
arrows are called attributes, arrow labels are called attribute names,
and arrow targets are called attribute values.

\subsection{Raw Representations}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set must be used
in the file.  The simplest representation is the raw representation,
which we now describe.

The format of a \key{raw representation} is:

\begin{center}
\begin{tabular}{l}
\key{raw-representation} ::= {\em raw-object-representation} \ldots
\\[1ex]
\key{raw-object-representation} ::=
    {\em raw-object-header}
    {\em raw-arrow-representation} \ldots
\\[1ex]
\key{raw-object-header}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-object-name} \ttmkey{::}{in {\em raw-object-header}} \\
    $|$ & {\em raw-object-name} \ttmnbkey{:>>:}{in {\em raw-object-header}} \\
    \end{tabular}
\\[1ex]
\key{raw-arrow-representation}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-single-arrow-representation} \\
    $|$ & {\em raw-double-arrow-representation}
    \end{tabular}
\\[1ex]
\key{raw-single-arrow-representation} ::=
	{\em arrow-label}\ttmkey{:}{in {\em raw-single-arrow-representation}}
	{\em single-arrow-target}
	\ttmkey{;;}{in {\em raw-single-arrow-representation}}
\\[1ex]
\key{single-arrow-target} ::= {\em atom} $|$ {\em raw-object-name}
\\[1ex]
\key{raw-double-arrow-representation} ::=
\\\hspace*{1in}
	{\em arrow-label}\ttmkey{:}{in {\em raw-double-arrow-representation}}
	{\em double-arrow-target}
	{\tt :}{\em arrow-label}
	\ttmkey{;;}{in {\em raw-double-arrow-representation}}
\\[1ex]
\key{double-arrow-target} ::= {\em raw-object-name}
\\[1ex]
\key{raw-object-name} ::=
	\ttmkey{\#\#}{in {\em raw-object-name}}{\em non-negative-integer}
\\[1ex]
\key{arrow-label} ::= {\em atom} \ldots
\\[1ex]
\key{atom} ::= {\em non-special-lexeme} \ldots
\\[1ex]
\key{special-lexeme} ::= \verb|##| $|$ \verb|::| $|$ \verb|:>>:|
		$|$ \verb|:| $|$ \verb|;;|

\end{tabular}
\end{center}%
\index{label!arrow}%
\index{source!arrow}%
\index{target!arrow}

A simple example of the raw representation of a set of objects is:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##1::|\\
\verb|    type: woman;;|\\
\verb|    name: Jill;;|\\
\verb|    husband: ##2 :wife;;|\\
\verb|##2::|\\
\verb|    type: man;;|\\
\verb|    name: Jack;;|\\
\verb|    wife: ##1 :husband;;|
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt \#\#1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt \#\#2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

This represents two objects.
There are two single arrows from object \verb|##1|,
one arrow labeled {\tt type} whose target is the atom {\tt woman},
and one arrow labeled {\tt name} whose target is the atom {\tt Jill}.
There are two similar single arrows from object \verb|##2|.
There is a double arrow between the two objects which has the
label {\tt husband} when going from \verb|##1| to \verb|##2|
and the label {\tt wife} when going in the reverse direction.

In order to permit \verb|:| to be used in an arrow label, the following
\key{quote representation rule} is applied to representations.
A quoted symbol cannot be recognized as an atom that has special
meaning in a representation, such as the \verb|::|, \verb|:|,
\verb|##|, or \verb|;;| atoms in raw representations.  Thus if any
of these atoms are to be part of an arrow label or target, they should
be represented by \verb|"::"|, \verb|":"|, \verb|"##"|, or \verb|";;"|.
Other than this rule, there is no
distinction between quoted and unquoted representations of typically
unquoted atoms.

The double-semi-colons (\verb|;;|) at the ends of arrow representations
may be omitted according to the \key{double-semi-colon representation rule}.
This rule says that the \ttmkey{;;}{omitting} at the end of an arrow
representation may be omitted provided the next line is not
indented with respect to the first non-whitespace character of the
arrow representation with the omitted \verb|;;|, or alternatively if the end of
text (e.g., end of file) immediately follows.
Thus the \verb|;;|'s in the example just given may be omitted.

We can say that \verb|##1| is the source of an arrow labeled \verb|type|
with target \verb|woman|, but instead we will usually say that
\verb|##1| has an attribute named \verb|type| with value \verb|woman|.
Thus in our example \verb|##1| has attributes named \verb|type|,
\verb|name|, and \verb|husband| that have values, respectively,
\verb|woman|, \verb|Jill|, and \verb|##2|.

In the rest of this document we use the terminology of attributes,
attribute name, and attribute values, in place of
arrows, arrow labels, and arrow targets.
An \key{attribute} of an object is just a single arrow sourced at the object,
or a double arrow viewed in the direction going away from the object.
The \key{attribute name}\index{name!attribute} is just the label of this arrow.
The \key{attribute value}\index{value!attribute} is just the target
of this arrow.

The difference between \ttkey{::} and \ttnbkey{:>>:} is that the former
indicates that the object should not previously
exist, while the later indicates that the attributes are to be added to
any existing object, though if the object does not exist it will be
created.  It is an error to add to an existing object an attribute with the
same name as an existing attribute of that object.


Object \ttnbkey{\#\#0} is special: it is the \ttkey{.GLOBAL} object, and
its attributes are called \skey{global variables}.  One of the global
variables is named {\tt .GLOBAL} and has as its value the {\tt .GLOBAL}
object, a situation which can be achieved by the data representation:



\begin{indpar}\begin{verbatim}
##0:>>:
    .GLOBAL: ##0
\end{verbatim}\end{indpar}



\subsection{Cooked Representations}

In contrast to the raw representation of a set of objects there is the
cooked representation, that is much easier to read and write, but more
long winded to explain.

The main thing that the cooked representation does is take certain objects
that are organized like lists and represent them as lists.

For example,

\begin{indpar}\begin{verbatim}
##93:: This is a sentence.
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{indpar}\begin{verbatim}
##93::
    1: this
    2: is
    3: a
    4: sentence
    .terminator: "."
    .initiator: capital
\end{verbatim}\end{indpar}

The following is a second example in which
curly brackets (\verb|{ }|) are used to permit
operators such as \verb|+| to be recognized, so that

\begin{indpar}\begin{verbatim}
##46:: { straight 3.2; left; straight (y + 9.4) }
\end{verbatim}\end{indpar}

is the cooked representation of the objects

\begin{indpar}\begin{verbatim}
##42:: 
    1: straight
    2: 3.2
##43:: 
    1: "+"
    2: y
    3: 9.4
    initiator: "("
    terminator: ")"
##44:: 
    1: straight
    2: ##43
##45::
    1: ##42
    2: left
    3: ##44
    .separator: ";"
    .initiator: "{"
    .terminator: "}"
\end{verbatim}\end{indpar}

The following is a third example in which
curly brackets (\verb|{ }|) are used with multiple
lines and indentation to represent code, so that

\begin{indpar}\begin{verbatim}
##138:: function (x,y)
        {
           if (x > y):
               return y
           else:
               return x
        }
\end{verbatim}\end{indpar}

is the cooked representation of

\begin{indpar}\begin{verbatim}
##130::
    1: x
    2: y
    .separator: ","
    .initiator: "("
    .terminator: ")"
##131::
    1: ">"
    2: x
    3: y
    .initiator: "("
    .terminator: ")"
##132::
    1: return
    2: y
    .initiator: ":"
##133::
    1: if
    2: ##131
    3: ##132
##134::
    1: return
    2: x
    .initiator: ":"
##135::
    1: else
    2: ##134
##136::
    1: ##133
    2: ##135
    .initiator: "{"
    .terminator: "}"
##137::
    1: function
    2: ##130
    2: ##136
\end{verbatim}\end{indpar}

Cooked representations may replace raw object names in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
##291:: text: This is a sentence.
        outline: { straight 3.2, left, straight (y + 9.4) }
        min: function (x,y)
             {
                if (x > y):
                    return y
                else:
                    return x
             }
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{indpar}\begin{verbatim}
##291::
    text: ##93
    outline: ##45
    min: ##137
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
##291:: text A: This is a sentence.
        text B: This is a sentence.
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
##291::
    text A: ##93
    text B: ##93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
##291::
    text A: ##93
    text B: ##999
\end{verbatim}\end{indpar}

where object \verb|##999| happens to have the same structure as
object \verb|##93|.  The default is to make both \verb|text A|
and \verb|text B| be the same object, \verb|##93|, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object names in the cooked representations of other
objects.

The following are generalizations about certain attribute names.
First, the strictly positive integers \verb|1|, \verb|2|,
\verb|3|, \ldots are used to name the elements of a list.  Second,
some attribute names beginning with `\verb|.|' have special
meaning for object representation.  Examples above are
\verb|.separator|, \verb|.initiator|, and \verb|.terminator|.
Recall that words beginning with `\verb|.|' are reserved for
use by the MIN system, and should not be defined by MIN users.

In the following sections we describe cooked representations
precisely.

\subsection{Syntax}

A cooked data representation has the syntax given
in Figure~\figref{DATA-REPRESENTATION-SYNTAX} and is based on the
special lexemes given in Figure~\figref{SPECIAL-LEXEMES}.

The difference between cooked data and raw data is the presence
of expressions.  An expression is parsed to produce an atom or
an object which is called the \key{parsed expression}.
If the expression is part of a
{\em cooked-attribute-representation}, the atom or object becomes
the value of the attribute.  For example, the cooked representation

\begin{indpar}\begin{verbatim}
##401::
    text A: This is a sentence.
    expression B: [ x + 8 ]
\end{verbatim}\end{indpar}

is equivalent to the raw representation

\begin{indpar}\begin{verbatim}
##401::
    text A: ##402
    expression B: ##403
##402::
    1: this
    2: is
    3: a
    4: sentence
    .initiator: capital
    .terminator: "."
##403::
    1: "+"
    2: x
    3: 8
    .initiator: "["
    .terminator: "]"
\end{verbatim}\end{indpar}

If the expression immediately follows
an {\em object-header}, and is before any {\em attribute-representa\-tions}
in the {\em object-representation}, then if the parsed expression is
an object, the attributes of the object produced are copied to become
attributes of the object represented, and if parsed expression is
an atom, the atom becomes the value of the represented object attribute
named `\ttmkey{1}{defined in cooked representation}'.  For example,
the cooked representation

\begin{indpar}\begin{verbatim}
##410:: This is a sentence.
        x: 5
\end{verbatim}\end{indpar}

is equivalent to the raw representation

\begin{indpar}\begin{verbatim}
##410::
    1: this
    2: is
    3: a
    4: sentence
    .initiator: capital
    .terminator: "."
    x: 5
\end{verbatim}\end{indpar}

and the cooked representation

\begin{indpar}\begin{verbatim}
##411:: hi
        x: 5
\end{verbatim}\end{indpar}

is equivalent to the raw representation

\begin{indpar}\begin{verbatim}
##411::
    1: hi
    x: 5
\end{verbatim}\end{indpar}

The precise algorithm used in parsing is described below in
\secref{PARSING}.

\begin{boxedfigure}[b!]

\begin{center}

Ad Hoc Special Lexemes

\bigskip

\begin{tabular}{ll@{\hspace*{5em}}ll}
\ttkey{::} & object assignment &
\ttnbkey{:>>:} & object addition \\
\ttkey{:} & attribute assignment &
\ttkey{:} & code indicator \\
\end{tabular}

\bigskip

Brackets

\bigskip

\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
macro	&	brackets	& meaning	& parsing mode
\\[1ex]
\ttkey{.ROUND}	& \ttnbkey{(}~~~\ttnbkey{)}	& parentheses	& no change \\
\ttkey{.SQUARE}	& \ttnbkey{[}~~~\ttnbkey{]}	& square brackets
						& expression \\
\ttkey{.CURLY}	& \ttnbkey{\CurlyBra}~~~\ttnbkey{\CurlyKet}
						& curly brackets & code \\
\ttkey{.QUOTE}	& \ttnbkey{`}~~~\ttnbkey{'}	& single quotes & text \\
\end{tabular}

\bigskip

Standard Operators

\bigskip

\begin{tabular}{rl@{\hspace*{2em}}l@{\hspace*{2em}}l}

priority & macro	& operators	& meaning 
\\[2ex]
-5000 & \ttkey{.SENTENCE} &  \ttnbkey{.} ~~~ \ttnbkey{!} ~~~ \ttnbkey{?}
	& sentence terminators \\
-4000 & \ttkey{.SUBSENTENCE} &  \ttnbkey{;} & subsentence separator \\
-3000 & \ttkey{.PHRASE} &  \ttnbkey{,} & phrase separator \\
+0000 & \ttkey{.CONDITIONAL} &  \ttkey{if} ~~~ \ttkey{then} ~~~ \ttkey{else}
	& conditionals \\
+1000 & \ttkey{.LOGICAL} &  \ttkey{and} ~~~ \ttkey{or} ~~~ \ttkey{not}
	& logical AND, OR, NOT \\
+2000 & \ttkey{.COMPARE} &  \ttnbkey{=} ~~~ \ttnbkey{/=} ~~~
        \ttnbkey{!=} 			& equal, not equal, ditto \\
      &		      & \ttnbkey{<} ~~~ \ttnbkey{<=} ~~~ \ttnbkey{=<}
      & less than, less than or \\
      &		      &		&
      equal, ditto \\
      &		      & \ttnbkey{>} ~~~ \ttnbkey{>=} ~~~ \ttnbkey{=>}
      & greater than, greater \\
      &		      &		&
      than or equal, ditto \\
+3000 & \ttkey{.SUM} &  \ttnbkey{+} ~~~ \ttnbkey{-}
	& addition, subtraction \\
+3100 & \ttkey{.PRODUCT} &  \ttnbkey{*} ~~~ \ttnbkey{/} 
	& multiplication, division \\
+9999 & \ttkey{.OBJNAME} &  \ttnbkey{\#\#}
	& object name \\
\end{tabular}

\end{center}

\caption{Special Lexemes}
\label{SPECIAL-LEXEMES}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{l}
\key{data-representation} ::= {\em object-representation} \ldots
\\[1ex]
\key{object-representation} ::=
\\\hspace*{1in}
    \begin{tabular}[t]{@{}rl@{}}
        & {\em object-header} {\em attribute-representation} \ldots \\
    $|$ & {\em object-header} {\em expression}
	  \ttmkey{;;}{in {\em object-representation}}
    	  {\em attribute-representation} \ldots \\[1ex]
    \end{tabular}
\\[1ex]
\key{object-header}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em object-name} \ttmkey{::}{in {\em object-header}} \\
    $|$ & {\em object-name} \ttmnbkey{:>>:}{in {\em object-header}} \\[1ex]
    \end{tabular}
\\[1ex]
\key{attribute-representation}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em cooked-attribute-representation} \\
    $|$ & {\em double-arrow-attribute-representation} \\[1ex]
    \end{tabular}
\\[1ex]
\key{cooked-attribute-representation} ::=
	{\em attribute-label}\ttmkey{:}{in {\em cooked-attribute-representation}}
	{\em expression}
	\ttmkey{;;}{in {\em cooked-attribute-representation}}
\\[1ex]
\key{double-arrow-attribute-representation} ::=
\\\hspace*{1in}
	{\em attribute-label}\ttmkey{:}{in
		{\em double-arrow-attribute-}!{\em representation}}
	{\em double-arrow-target}
	{\tt :}{\em attribute-label}
	\ttmkey{;;}{in {\em double-arrow-attribute-}!{\em representation}}
\\[1ex]
\key{double-arrow-target} ::= {\em object-name}
\\[1ex]
\key{object-name} ::=
	\ttmkey{\#\#}{in {\em object-name}}{\em non-negative-integer}
\\[1ex]
\key{attribute-label} ::= {\em atom} \ldots
\\[1ex]
\key{atom} ::= non-special lexeme: see Figure~\figref{SPECIAL-LEXEMES}
\\[1ex]
\key{expression} ::= {\em expression(-9999)}
\\[1ex]
{\em expression($N$)} ::=
	\{ {\em expression($N+1$)} $|$ {\em operator($N$)} \}\ldots
\\[1ex]
\key{operator}{\em ($N$)} ::= operator of priority $N$:
			      see Figure~\figref{SPECIAL-LEXEMES}
\\[1ex]
{\em expression(10000)} ::= {\em atom} $|$ {\em bracketed-expression}
\\[1ex]
\key{bracketed-expression} \begin{tabular}[t]{@{}rl@{}}
			    ::= & \verb|(| {\em expression} \verb|)| \\
			    $|$ & \verb|[| {\em expression} \verb|]| \\
			    $|$ & \verb|{| {\em code-block} \verb|}| \\
			    $|$ & \verb|`| {\em expression} \verb|'| \\[1ex]
			    \end{tabular}
\\[1ex]
{\em code-block} ::= see~\secref{PARSING-MODES}

\end{tabular}
\end{center}%
\index{label!attribute}%
\index{name!object}

\caption{Data Representation Syntax}
\label{DATA-REPRESENTATION-SYNTAX}
\end{boxedfigure}


\subsection{Parsing Modes}
\label{PARSING-MODES}

There are three \skey{parsing mode}s: text, expression, and code.
The parsing mode of any lexeme is determined by the innermost
brackets containing the lexeme, according to Figure~\figref{SPECIAL-LEXEMES}.
Thus if the innermost brackets are \verb|` '| the parsing mode is `text',
if they are \verb|[ ]| the mode is `expression', and if they are \verb|{ }|
the mode is `code'.  The \verb|( )| brackets are not considered in
determining mode.  Thus it is as if \verb|` '| changes to text mode,
\verb|[ ]| to expression mode, and \verb|{ }| to code mode, but \verb|( )|
does not change the mode.

In \key{text mode} only operators with negative priority are recognized,
line feeds and indentation are treated like any other whitespace, and
`\verb|:|' is not recognized as a code indicator.

In \key{expression mode} all operators are recognized,
line feeds and indentation are treated like any other whitespace, and
`\verb|:|' is not recognized as a code indicator.

In \key{code mode} all operators are recognized,
while line feeds, indentation, and the code indicator `\verb|:|' are
used to sequence statements within the code block and to indicate
code subblocks, according to the following rules:

\begin{enumerate}
\item
The column of the first non-whitespace character inside \verb|{}| brackets
defines the initial column of the \key{code block} enclosed by the
brackets.

\item No line in a code block may be indented by less than its initial column.

\item A code block is organized as a sequence of statements such that
each non-whitespace character in the code block initial column begins a new
statement, and statements so begun are the only statements in the code block.

\item
If a statement contains a `\verb|:|' \key{code indicator} mark as the last
lexeme of a line, the first column of the next lexeme in the statement
begins a \key{code subblock} that includes the rest of the statement.  The
first column of that next lexeme is the initial column of the code
subblock.  The subblock obeys rules 2 and 3 just given for code blocks.

\item
A code block and its surrounding \verb|{ }| brackets represent a list of
zero or more statements with
list \verb|.initiator| \verb|"{"| and list \verb|.terminator| \verb|"}"|.

\item
A code subblock and its preceding code indicator `\verb|:|'
represents a list of zero or more statements with
list \verb|.initiator| \verb|":"| and no list \verb|.terminator|.

\end{enumerate}



\subsection{Standard Representations}
\label{STANDARD-REPRESENTATIONS}

In this section we describe how standard operators parse.
Subsequent sections describe how to introduce user defined
operators or change standard parsing.

We first introduce some terminology by giving some examples.

Consider the expression

\begin{center}
\verb|- x + 5 * y|
\end{center}

The first step in parsing an expression is to insert implied
parentheses using operator priority.  In our example, the
operators \verb|-| and \verb|+| have priority +3000, while
the operator \verb|*| has the higher priority +3100.  The
result is

\begin{center}
\verb/- x + (| 5 * y |)/
\end{center}

where \verb/(| |)/ represent implied parentheses.

The next step is to identify the macros associated with the different
priority levels.  In this case the macro \verb|.SUM| is associated with
+3000, and the macro \verb|.PRODUCT| is associated with +3100.
A macro parses expressions containing the operators at the level of the
macro.  Expressions not containing an operator are left as is.
Parsing proceeds from the innermost expression to the outermost.
Thus in our example, first \verb|.PRODUCT| is called with
`\verb|5 * y|' as its argument, and this returns `\verb|* 5 y|' as
its parsed result.  Then \verb|.SUM| is called with
`\verb/- x + (| * 5 y |)/' as its argument, and it returns
`\verb/+ (| - x |) (| * 5 y |)/' as parsed result.
This final returned result
is the same as the objects represented by the raw data

\begin{indpar}
\verb|##500::|\\
\verb|    1: "-"|\\
\verb|    2: x|\\
\verb|##501::|\\
\verb|    1: "*"|\\
\verb|    2: 5|\\
\verb|    3: y|\\
\verb|##502::|\\
\verb|    1: "+"|\\
\verb|    2: ##500|\\
\verb|    3: ##501|
\end{indpar}

except, of course, the actual object numbers might be different when
the expression was actually parsed.

Now consider the expression

\begin{center}
\verb|The "." is a terminator.|
\end{center}

In this the second \verb|.| is an operator, the only operator in the
expression, and its associated macro \verb|.SENTENCE| is called with the
argument

\begin{center}
\verb/(| The "." is a terminator |)./
\end{center}

to expand the expression and produce a parsed expression that could be
described by the raw data

\begin{indpar}\begin{verbatim}
##520::
    1: the
    2: "."
    3: is
    4: a
    5: terminator
    .initiator: capital
    .terminator: "."
\end{verbatim}\end{indpar}

where the object number \verb|520| would probably be different in any
actual parse.  The \verb|.SENTENCE| macro rearranged what it was given
into a single list in which the first word is lower case,
the \verb|.initiator| is `\verb|capital|' to indicate the first word
should be capitalized, and the \verb|.terminator| is the `\verb|.|'
that was originally the operator.  Changing the case of the first
word and adding the \verb|.initiator| is done by a
`de-capitalization algorithm', \secref{DECAPITALIZATION}.

In most cases, a parsed atom is just the atom itself.  However, when a quoted
atom is parsed, the quotes are removed, a process called \key{de-quoting}.
Thus in the above example, the atom \verb|"."| when parsed is de-quoted to
produce the single character atom `\verb|.|'.  This in turn, when represented
in raw data, is represented by \verb|"."|, on the grounds that
readers of raw data often also read cooked data, and distinguish between
raw and cooked by the presence of operators, so in raw data potential
cooked operators should be protected by quoting them.

With the terminology we have just introduced in mind, the following are
the parsed values produced by standard operator definitions.

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{parsing}}
\newcommand{\NBOP}[1]{\ttmnbkey{#1}{parsing}}
\newcommand{\MAC}[2]{\hfill #1, \ttmkey{#2}{parsing macro}}

\bigskip

\NBOP{(} ~~~ \NBOP{)} \MAC{parentheses}{.ROUND} \\
\NBOP{[} ~~~ \NBOP{]} \MAC{square brackets}{.SQUARE} \\
\NBOP{\CurlyBra} ~~~ \NBOP{\CurlyKet} \MAC{curly brackets}{.CURLY} \\
\NBOP{`} ~~~ \NBOP{'} \MAC{quotes}{.QUOTE}

\begin{indpar}[0.5em]
The bracketed subexpression is parsed and the result
is converted if necessary to a list without either a \verb|.initiator|
or a \verb|.terminator| attribute.
Then an \ttmkey{.initiator}{produced by parsing} attribute equal to
the opening bracket (\verb|"("|, \verb|"["|, \verb|"{"|, or \verb|"`"|)
and a \ttmkey{.terminator}{produced by parsing} attribute equal to
the closing bracket (\verb|")"|, \verb|"]"|, \verb|"}"|, or \verb|"'"|)
are added to this list,
and the list becomes the result of parsing the parenthesized expression.
\end{indpar}

\bigskip

\NBOP{.} ~~~ \NBOP{!} ~~~ \NBOP{?} \MAC{terminators}{.SENTENCE}

\begin{indpar}[0.5em]
Terminators may not be consecutive, may not begin an expression,
and must end an expression.  Thus each between-terminator subexpression
is non-empty and is followed by a terminator.
Each between-terminator subexpression is parsed and converted if necessary
to a list.  Then a \ttmkey{.terminator}{produced by parsing}
attribute is added to this list whose value is the terminator following the
subexpression.  If there is only one subexpression, the list it produces
is the parse result.  Otherwise the result is the list of all the subexpression
lists.
\end{indpar}

\bigskip

\NBOP{;} \MAC{subsentence separator}{.SUBSENTENCE} \\
\NBOP{,} \MAC{phrase separator}{.PHRASE}

\begin{indpar}[0.5em]
Here `\verb|;|' or `\verb|,|' is the \key{separator}.
Each between-separator subexpression (which may be empty) is parsed.
If empty, a subexpression parses to the empty object
(an object with no attributes).
There will be at least two subexpressions: one following
the last separator and one preceding the first separator.
A list of all the subexpression
parses is made, is given a \ttmkey{.separate}{produced by parsing}
attribute with value of the separator (\verb|";"| or \verb|","|,
and is returned as the result of the parse.
\end{indpar}

\bigskip

\OP{if} ~~~ \OP{then} ~~~ \OP{else} \MAC{conditional operators}{.CONDITIONAL}

\begin{indpar}[0.5em]
Expressions with conditional operators must have the syntax:

\begin{indpar}[0.5em]
\key{conditional-expression} ::=
    \begin{tabular}[t]{@{}l@{}}
    \ttmkey{if}{in {\em conditional-expression}}
	{\em subexpression}
        \ttmkey{then}{in {\em conditional-expression}}
        {\em subexpression}
    \\
    \{ {\tt \bf else if}
	{\em subexpression}
        \ttmkey{then}{in {\em conditional-expression}}
        {\em subexpression}
    \}\ldots \\
    \ttmkey{else}{in {\em conditional-expression}}
	{\em subexpression}
    \end{tabular}
\end{indpar}

where any {\em subexpression} may be empty.

\end{indpar}

\bigskip

\NBOP{+} ~~~ \NBOP{-} \MAC{addition operators}{.SUM}

\begin{indpar}[0.5em]
Addition operators may not be consecutive and may not end an expression.
Between operator subexpressions are parsed, and the results rewritten using
the multi-argument summation function \verb|+| and the unary negation function
\verb|-|.

\begin{indpar}[0.5em]
\verb|- x + y + z - w| ~~~ $\Longrightarrow$ ~~~
\verb|+ (- x) y z (- w)|
\end{indpar}
\end{indpar}

\bigskip

\NBOP{*} ~~~ \NBOP{/} \MAC{multiplication operators}{.PRODUCT}

\begin{indpar}[0.5em]
The two different multiplication operators may not be mixed in the same
expression.
Multiplication operators may not be consecutive and may neither begin
nor end an expression.  The division operator \verb|/| must have exactly
two operands.
Between operator subexpressions are parsed, and the results rewritten using
the multi-argument multiplication function \verb|*| or the binary
division function \verb|/|.  E.g.:

\begin{indpar}[0.5em]
\verb|x * y * z| ~~~ $\Longrightarrow$ ~~~ \verb|* x y z| \\
\verb|x / y| ~~~ $\Longrightarrow$ ~~~ \verb|/ x y|

\end{indpar}
\end{indpar}


\end{indpar}


\subsection{Parsing}
\label{PARSING}

\section{Evaluation}

Consider the following description of a room:

\begin{indpar}\begin{verbatim}
##523::
    type: standard room
    outline: straight width, left, straight length, left,
             straight width, left,
             doored wall width,
             close
    width: 3.2
    length: 9.6
    doored wall: function ( length ) {
                     d = (length - door width) / 2
                     straight d
                     door (door width)
                     straight d }
    door : standard room door
    label: color green, under over, noun room
    over: ##598
\end{verbatim}\end{indpar}

The information in this description is not immediately useful for
producing output, such as a video picture of the room, or text naming
the room.  Instead, parts of the description must be evaluated to produce
the picture or the name.

The goal of an evaluation is to produce \key{derived information} which is
frequently stored in a derived attribute of an object.  A \key{derived
attribute} is just any attribute that stores derived information.  Derived
attributes are often also \skey{hidden attribute}s, which are just
attributes whose names begin with `\ttmkey{.}{hidden attribute}', and which
are not normally output when the object is saved.

For example, a very important derived attribute of any object is its
inheritance list, which is the value of the object's \verb|.ancestors|
attribute, and which is a list of other objects from which the current
object inherits attributes.  In our example, the \verb|type| attribute
names another object, `{\tt standard room}', from which the room object
inherits attributes.  This means that when an evaluation searches for the
name of an attribute in the room object, if that name is not found, the
evaluation will next search the `{\tt standard room}' object.

To compute the \verb|.ancestors| attribute an the \verb|type| object
is evaluated `in global context'.  This last implies that the only
names the evaluator can use are global variable names, and `{\tt standard
room}' in fact names a global variable whose value is the object
which is the sole immediate ancestor of our room.

The \verb|outline| attribute value is used to compute a derived attribute
named \verb|.video| which describes how the object is to be displayed
graphically.
The \verb|outline| attribute value is a program is written from the point
of view of a robot moving around the outline of the room building walls.
The robot follows a sequence of commands that are separated by commas.

In order to show how evaluation works, we will explain in detail some
of the evaluation of \verb|outline|.

Evaluation of the \verb|outline| attribute of object \verb|##523|
is triggered when the value
of the \verb|.video| attribute of this object is needed.  Computation
of the \verb|.video| attribute is be done by a function
named {\tt .make .video}, which in this case is defined by {\tt standard
room} which is an ancestor of \verb|##523|.
If this function did not exist, computation would done by the function
named {\tt .make}, which is globally defined, and which would attempt
to evaluate the {\tt video} attribute (without the `\verb|.|') of
\verb|##523| to produce this object's \verb|.video| attribute
(with the `\verb|.|').  In any case, computation of an attribute AA
can be done in a fashion tailored to what is being computed by defining a
`\verb|.make| AA' function in an object or one of its ancestors.

In our case the \verb|.make .video| function evaluates
the \verb|outline| attribute of \verb|##523| to produce
a value for the \verb|.video| attribute of \verb|##523|.
First the function establishes
a context, which is a list of objects that will be searched when an
attribute name is to be located.  The context for the evaluation of
an object's attribute value usually begins with the object and ends with
a special object called `\verb|.GLOBAL|'.  A global variable is by definition
just an attribute of the \verb|.GLOBAL| object.  An function evaluating
an {\tt outline} attribute is likely to include in the context an object
that defines functions named `{\tt straight}' and `{\tt left}' which will
evaluate parts of the {\tt outline} attribute.

Besides establishing a context, the \verb|.make| function establishes an
execution frame.  The execution frame may contain output
channels, which are places to put output.  In this case the value of
\verb|.video| becomes an output channel into which functions like
`{\tt straight}' will write new commands written in a video language
that can be processed by the video engine to produce a picture.

Since functions such as `{\tt straight}' and `{\tt left}' are written
from the point of view of a robot moving around the outline of a room,
the execution frame also contains the current location and direction
of the robot.

After establishing a context and frame, the evaluating function starts reading
the \verb|outline| attribute value which is to be evaluated.  In this
case the it finds a comma separated list of commands, and evaluates
each command separately.

The first command is `{\tt straight width}'.   When `{\tt straight}' is 
read, a search is made in the current context for an attribute with a name
beginning with the word `{\tt straight}'.  One will be found whose total
name is just the single word `{\tt straight}', and the value of that
attribute will be taken.  We have not shown that attribute, but it will
exist and have a value of the form

\begin{center}
\verb|function ( w ) { |\ldots\verb|}|
\end{center}

This value means the expression we are reading should have next, after the
word `{\tt straight}', a single argument.  An argument
is either a single lexeme or a bracketed string of lexemes.  The argument
must be read, and perhaps evaluated and replaced by its value, which becomes
the value of the \verb|w| argument of the `{\tt straight}' function.
Then this function is evaluated.

In our case `{\tt width}' follows `{\tt straight}'.  This is an unbracketed
single lexeme argument, and as such must be evaluated and replaced by
its value.  A search is made for an attribute whose name begins with
`{\tt width}'.  The `{\tt width}' attribute of \verb|##523| is found,
and as its value is a number,
\verb|3.2|, that is the final value of the `{\tt width}' argument.
Thus the command `{\tt straight width}' has become `{\tt straight 3.2}',
and this is then evaluated by executing the `{\tt straight}' function
with \verb|w| equal to \verb|3.2|.  The result will be some command
written into the {\tt .video} attribute of \verb|##523|.

The other commands in the {\tt outline} attribute are similar, except
for the `{\tt doored wall width}' command.  This invokes the `{\tt doored wall}'
function we have defined as an attribute of \verb|##523| (but it would
make more sense to define it as an attribute of the {\tt standard room}
object whose attributes are inherited by \verb|##523|).   Again
`{\tt width}' is the argument which evaluates to \verb|3.2| and becomes
the value of the `{\tt length}' argument in the `{\tt doored wall}'
function.  Evaluation of the `{\tt doored wall}' function is next,
and as a function,
its evaluation context begins with an object called the function frame
that has an attribute named `{\tt length}' whose value is the corresponding
argument value, in this case \verb|3.2|.

A special feature of the MIN language is are dependency lists which
can be used to figure out when to re-compute attribute values, such as
the \verb|.video| attribute of \verb|##523|.  Each attribute X can have
a dependency list which specifies all the other attributes Y, Z, \ldots
whose values depend upon the value of X.  When the value of X is changed,
the values of Y, Z, \ldots are marked `obsolete', which identifies them
as needing to be recomputed.  Thus in the current case the \verb|width|
attribute of \verb|##523| has a dependency list that includes the
\verb|.video| attribute of \verb|##523|.  Not all attributes will have
dependency lists: the \verb|.ancestors| attribute of an object would
have a very long dependency list, if it existed, that included all the
attributes ever computed from the object, and for this reason the
\verb|.ancestors| attribute has no dependency list, so changing it does
not mark other values obsolete.

We also need to explain
the meaning of the `{\tt label}' and `{\tt over}' attribute values
of \verb|##523|.  It is necessary to produce a name
for \verb|##523| in an arbitrary natural language, such as English or
French or Japanese, and this is what the `{\tt label}' attribute value does
when it is evaluated.  This value is also a sequence of commands that
provide descriptive information about the object which the natural language
engine can process to produce the desired text.  The `{\tt color green}'
command invokes the `{\tt color}' function with an argument that is
some object which is the value of the `{\tt green}' variable to
produce some internal notation that tells the natural language engine
that \verb|##523| has the color green.  Similarly `{\tt over under}'
invokes the `{\tt over}' function with an the `{\tt under}' argument that
just names an attribute of \verb|##523| with value \verb|##598|.  This
says that \verb|##523| is under \verb|##598|.  Lastly, `{\tt noun room}'
says that \verb|##523| is a room.

If the label of \verb|##598| is

\begin{center}
\verb|label: adjective main, noun dungeon|
\end{center}

then the English natural language engine might generate the text

\begin{center}
\verb|the green room under the main dungeon|
\end{center}

in order to specify \verb|##523|.

\subsection{The Evaluation Algorithm}

A CONTEXT is:

\begin{indpar}\begin{verbatim}
FRAME
OBJECT
STATEMENT
ITEM in STATEMENT
STATE, and integer containing the following flags:
    FAILURE-FLAG    (set when if condition is false)
    REPEAT-FLAG    (set to repeat current statement)
PREVIOUS-CONTEXT (contexts are like CONS cells)
\end{verbatim}\end{indpar}

A FRAME is:

\begin{indpar}\begin{verbatim}
... temporary variables like object attrubutes ...
OBJECT
PREVIOUS-FRAME (frames are like CONS cells)
\end{verbatim}\end{indpar}

\begin{indpar}\begin{verbatim}

    push ( CONTEXT ):
        C = copy of CONTEXT
        C.PREVIOUS-CONTEXT = CONTEXT
        return C

    evaluate ( CONTEXT )
        E = next item read from CONTEXT
	return evaluate ( E, CONTEXT )

    evaluate ( EXPRESSION, CONTEXT ):
        if EXPRESSION is a single number atom:
            return EXPRESSION
        else if EXPRESSION is `...' bracketed list:
            return quoted ( EXPRESSION, CONTEXT, 1 )
        else if EXPRESSION is {...} bracketed list:
            return code ( EXPRESSION, CONTEXT )
        else:
            return search ( EXPRESSION, CONTEXT )

    quoted ( EXPRESSION, CONTEXT, DEPTH ):
        `Handles depth, e.g., `foo `fum [[x]] [y]'''
        RESULT = EXPRESSION with 0 list items
                 (but same .initiator, etc.)
        foreach ITEM in EXPRESSION:
            if ITEM is not sublist:
                append ITEM to RESULT
                continue
            if ITEM is [...] bracketed:
                if DEPTH > 1:
                    append quote ( ITEM, CONTEXT, DEPTH - 1 )
                           to end of RESULT
                else:
                    concatenate evaluate ( ITEM, CONTEXT, 0 )
                                at end of RESULT
            else if ITEM is `...' quoted:
                append quote ( ITEM, CONTEXT, DEPTH + 1 )
                       to end of RESULT
            else:
                append quote ( ITEM, CONTEXT, DEPTH )
                       to end of RESULT
        return RESULT

    code ( EXPRESSION, CONTEXT ):
        `EXPRESSION is {...} bracketed'
        foreach STATEMENT in EXPRESSION:
	    C = push CONTEXT
	    C.STATEMENT = STATEMENT
	    C.ITEM = first item of STATEMENT
	    C.STATE = REPEAT-FLAG
            while C.REPEAT-FLAG:
	        C.REPEAT-FLAG = 0
                V = evaluate ( CONTEXT )
                if V is RETURN(OB): return OB
		CONTEXT.OBJECT = V
	return NULL

    search ( EXPRESSION, CONTEXT ):
        V = search ( EXPRESSION, CONTEXT, CONTEXT.FRAME )
	if V != FAILURE: return V
        return search ( EXPRESSION, CONTEXT, CONTEXT.FRAME.OBJECT )

    search ( EXPRESSION, CONTEXT, OBJECT ):
       if EXPRESSION is empty and OBJECT is not a function with
          no arguments or an object with an attribute with the
          empty label:
           return OBJECT
       if OBJECT is function definition:
           return execute ( EXPRESSION, CONTEXT, OBJECT )

       match names of OBJECT's attributes to beginning of EXPRESSION
       if several match:
           pick the longest match
           let R = EXPRESSION with matched portion removed
           let V = value of matched attribute
           return search ( R, CONTEXT, V )
       else for each ANCESTOR of OBJECT:
           return search ( EXPRESSION, CONTEXT, ANCESTOR )
       else error

    execute ( EXPRESSION, CONTEXT, FUNCTION ):
        make a new function frame F
        for each argument name N in FUNCTION:
            let A be the next atom or bracketed
                subexpression of EXPRESSION
            remove A from beginning of EXPRESSION
            let V = evaluate ( A, CONTEXT )
            make an attribute of F with name N and
                 value V
        let B be the body of FUNCTION
        let C be CONTEXT with F prepended
        let V = evaluate ( B, C )
        return search ( EXPRESSION, CONTEXT, V )

\end{verbatim}\end{indpar}



\subsection{Expressions and Subexpressions}

An \key{expression} is just a list of atoms and bracketed
subexpressions:


\subsection{Search}

\ikey{Search}{search} is part of the evaluation process.

Search is invoked with a \key{context}, which is just a list of
objects, and an expression, which is just a list of atoms.
The goal of search is to find an attribute whose name begins the expression.


\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}


