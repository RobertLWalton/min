% Minimal Descriptive Programming Language
%
% File:         min.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:        	See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Minimal\\Descriptive Programming\\Language\\[2ex]MIN\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{Copyright 2005 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by my son's budding career as a game designer.}}

\date{March 5, 2007}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MIN, the Minimal Descriptive Programming
Language.

The main goal of MIN is to make it easy to describe objects,
and to write small pieces of program code that change object descriptions
in response to external inputs.  MIN has a geometry engine that translates
object descriptions into a geometrical data, video and audio engines
that translate the geometry and object data into visual and
audio displays, and a view engine that translates between object descriptions
and textual displays such as spreadsheets.

MIN is intended to be the smallest, simplest language that can perform
these tasks well.


\section{Remarks}

TBD

\section{Overview}

TBD

\section{Lexemes}
\label{LEXEMES}

MIN descriptions are representable by strings of characters that
can be stored in files.  When a MIN program reads these, it
scans the characters from left to right to produce a sequence
of \skey{lexeme}s.  There are six kinds of lexemes: words, numbers,
brackets, separators, marks, and quoted strings.

A \key{word} is a string of \skey{word character}s.
A \mkey{letter}{word character} is a word character, as is
the underline character (\ttmkey{\UNDERLINE}{word character}).
A period (\ttmkey{.}{word character}) is a word character when
it is followed by a letter.  For example, {\tt fie} and {\tt .terminator}
are words.

A \key{number} is a string of digits plus an optional \key{decimal point}.
E.g., {\tt 5.2}.  Any decimal point must be followed by a digit.
Note that `{\tt X1}' is a string of \underline{two} lexemes, and is the
same as `{\tt X 1}'.

A \key{mark} is a string of mark characters, which are just characters
that are not word characters
or digits or decimal points or brackets or separators
or quotes or white-space characters.  E.g., \verb|+| and \verb|::| are marks.
The \skey{mark character}s are:
colon (\ttmkey{:}{mark character}),
period (\ttmkey{.}{mark character}) when not followed by a digit or letter,
exclamation mark (\ttmkey{!}{mark character}),
question mark (\ttmkey{?}{mark character}),
apostrophe (\ttmkey{'}{mark character}) when followed by a letter,
digit, or non-apostrophe mark character,
at sign ({\tt @}\index{"@@{\tt "@}!mark character}),
pound sign (\ttmkey{\#}{mark character}),
dollar sign (\ttmkey{\$}{mark character}),
percent sign (\ttmkey{\%}{mark character}),
circumflex (\ttmkey{\CIRCUMFLEX}{mark character}),
ampersand (\ttmkey{\&}{mark character}),
asterisk (\ttmkey{*}{mark character}),
minus sign (\ttmkey{-}{mark character}),
plus sign (\ttmkey{+}{mark character}),
equal sign (\ttmkey{=}{mark character}),
vertical bar (\ttmkey{\BAR}{mark character}),
back-slash (\ttmkey{\BACKSLASH}{mark character}),
less-than (\ttmkey{\LESSTHAN}{mark character}),
greater-than (\ttmkey{\GREATERTHAN}{mark character}),
slash (\ttmkey{/}{mark character}),
and
tilde (\ttmkey{\TILDE}{mark character}).

A \key{separator} is a single separator character.  The separator
characters are
comma (\ttmkey{,}{mark character}) and
semi-colon (\ttmkey{;}{mark character}).

A \key{bracket} is a single bracket character.  E.g., \verb|[| and \verb|]|.
The \key{bracket characters} are parentheses,
\ttmkey{(}{bracket character} and \ttmkey{)}{bracket character},
square brackets, \ttmkey{[}{bracket character} and
\ttmkey{]}{bracket character},
curly brackets, \ttmkey{\LEFTBRACKET}{bracket character} and
\ttmkey{\RIGHTBRACKET}{bracket character},
and single quotes, \ttmkey{`}{bracket character} and
\ttmkey{'}{bracket character}.  The close quote, or apostrophe, (\verb|'|) is
a mark, and not a bracket, if it is followed by a
mark other than another apostrophe, or followed by a letter,
or followed by a digit.

A \key{quoted string} is a string of characters that begins and ends with
a \verb|"| \key{quote character}.  The string of characters may include
spaces and escape sequences.  See~\secref{QUOTED-STRINGS} for details on
quoted strings.  The quote character may only be used in quoted strings.

Words, marks, separators, and quoted strings
are all \skey{symbol}s, which are just
character strings that can be used in similar ways.  A quoted string
may be just an alternate representation of a word, mark, or separator.  Thus
{\tt hello} and {\tt "hello"} represent the same word,
{\tt :} and {\tt ":"} represent the same mark, and
{\tt ;} and {\tt ";"} represent the same separator.  However
{\tt 0.123} is a number which is not a symbol, and {\tt "0.123"} is a symbol
which is not a number.

Periods and apostrophes have special rules.  For example
{\tt 0.123} is a number with a decimal point, {\tt .terminator} is a
mark ({\tt .}) followed by a word ({\tt terminator}), and
and {\tt `Hello.'} contains the word {\tt Hello}
followed by the \verb|.| mark all surrounded by the {\tt ` '} brackets.

A \ttkey{\BACKSLASH} is a mark character if it occurs outside quoted
strings, and is an \key{escape character} if it occurs inside quoted strings.
As an escape character it is used to begin a sequence of characters called
an escape sequence that denotes a single character (or in one case,
that denotes zero characters).
See~\pagref{ESCAPE-SEQUENCES} for details on escape sequences.

\ikey{White-space characters}{white-space character} ---
the \key{space character}, the \key{tab character},
the \key{new line character}, \key{carriage return character},
the \key{form feed character}, and the
\key{vertical tab} character --- are used to separate lexemes.  The space
character can be used to represent a single space inside quoted strings.
The tab character is always equivalent to one or more space characters,
with tabs set every 8 columns.
Carriage returns can only occur adjacent to
new line characters, and are effectively deleted from the input (ignored).
Form feeds and vertical tabs can only occur in a line by themselves
outside quoted strings.

\subsection{Quoted Strings}
\label{QUOTED-STRINGS}

A \key{quoted string} is an alternative representation of a symbol, the
other representations being words, marks, and separators.
The quoted string \verb|"::"|
and the mark \verb|::| represent the same thing.  Quoted strings can
represent symbols that have characters in them which cannot be in words,
marks, or separators.

A quoted string (e.g., \verb|"+"| or \verb|"x"|) and its corresponding
word, mark, or separator (e.g., \verb|+| or \verb|x|)
many be treated differently during parsing (\secref{PARSER-EXPANSION}).
The unquoted word, mark, or separator may be treated as an operator
or variable name, while the quoted string will be treated as naming
a constant.  Except for parsing, there is no difference between
a quoted string and any corresponding word, mark, or separator.

A quoted string consists of a sequence of
\skey{character representative}s
surrounded by double quotes (\verb|"|\index{""@{\tt ""}}).  A non-white-space
character other than quote (\verb|"|) or backslash (\verb|\|)
can be used to represent itself.  The single space character can be used
to represent itself.  Line feeds represent themselves;
carriage returns are ignored.
The other character representatives are called
\skey{escape sequence}s,\label{ESCAPE-SEQUENCES}
and consist of a backslash (\verb|\|\index{\\@{\tt \BACKSLASH}})
followed by other characters.  Each escape sequence represents exactly
one character, except for the \verb|\|{\em white-space}\verb|\|
sequence that represents zero characters.  The possible escape sequences and
the character they represent are:

\begin{center}
\begin{tabular}{lp{4in}}
\verb|\n| & new line \\
\verb|\r| & carriage return \\
\verb|\t| & horizontal tab \\
\verb|\b| & backspace \\
\verb|\f| & form feed \\
\verb|\v| & vertical tab \\
\verb|\\| & \verb|\| \\
\verb|\"| & \verb|"| \\[1ex]
\verb|\x|$hh$ & character with ASCII code $hh$ as a 2 digit
		hexadecimal number \\[1ex]
\verb|\|$ooo$ & character with ASCII code $ooo$ as a
		3 digit octal number \\[1ex]
\verb|\|{\em white-space}\verb|\|
		& the backslash, white space, and second backslash
		  are deleted; this allows continuation across
		  line ends
\end{tabular}
\end{center}%
\index{n@{\tt \BACKSLASH n}}%
\index{r@{\tt \BACKSLASH r}}%
\index{t@{\tt \BACKSLASH t}}%
\index{b@{\tt \BACKSLASH b}}%
\index{f@{\tt \BACKSLASH f}}%
\index{v@{\tt \BACKSLASH v}}%
\index{\\2@{\BACKSLASH\BACKSLASH}}%
\index{""2@{\tt \BACKSLASH""}}%
\index{space character 2@{\BACKSLASH{\em space}}}%
\index{x@{\tt \BACKSLASH x}$hh$}%
\index{digit@{\BACKSLASH{\em digit}}}%
\index{whitespace@{\BACKSLASH{\em white-space}\BACKSLASH}}

Single space characters after a newline in a quoted string
are removed up through the column containing the initial quote (\verb|"|)
of the quoted string.  Thus

\begin{indpar}\begin{verbatim}
some text "This is a line.
           And another line."
\end{verbatim}\end{indpar}

contains a quoted string that represents two lines, the first beginning
with `\verb|This|' and second beginning with `\verb|And|'.  There is no
white-space at the beginning of the second represented line, as the white-space
at the beginning of its representing quoted string line is removed.
The last removed white-space column is that of the \verb|"| beginning the
quoted string.

Tab characters are always equivalent to one or more space characters,
with tabs set every 8 columns.  Columns are counted with respect to the
beginning of the line, and \underline{not} the beginning of any quoted string.

Form feeds and vertical tabs cannot appear inside a quoted string.
Carriage returns can only appear adjacent to
new line characters, and are effectively deleted from the input (ignored).
Non-white-space control characters cannot appear inside or outside a quoted
string.  All these characters can be represented by escape sequences inside
a quoted string.



\section{Data}

A \key{datum} in MIN is either an atom, an object, or an arrow.

An \key{atom} is either a symbol (word, mark, separator, or quoted string) or a
number.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it is nothing more.

However, as a place in memory, an object has a name.  Objects are assigned
\skey{raw object name}s
of the form `\ttmnbkey{\#\#}{in raw object name}$I$' where $I$
is an integer.  Raw object names of this form are assigned only to objects
that must be named in an output stream (e.g., printed output).
The first object named in output stream is assigned the name
\verb|##1|, the second object named in output the name \verb|##2|,
and so forth.  The same object may be assigned different names in different
output streams.\footnote{A possible implementation is to give objects that
have been assigned names in an output stream a hidden system defined output
stream specific attribute (\pagref{ATTRIBUTE})
equal to the object's name integer.  Another implementation uses a
hash table per stream.}

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a label, which is a sequence of zero or
more atoms.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.
The difference between a double arrow and a pair of single arrows is that
it is possible to delete only one direction of a pair of single arrows, but 
when deleting a double arrow, both directions are deleted.

An \key{arrow label} is a sequence of zero or more atoms.
Two arrows leaving the same object may have the same label.  Thus
an object and an arrow label together name
a set of arrows sourced at the object.

\ikey{Arrow flags}{arrow flag} may be attached to arrow labels.
More precisely, a set of arrow flags is defined for each object
and each arrow label, and these flags apply to all arrows sourced at the
object that have the given label.
The standard flags are the \key{dot flag} (\ttmkey{.}{dot flag}),
and the \key{maybe flag} (\ttmkey{?}{maybe flag}).
Arrows with a dot flagged label are not to be output when their source
is output.
Targets of arrows with a maybe flagged label may be garbage collected
(made to disappear automatically, see \secref{GARBAGE-COLLECTION})
if they cannot be reached except by traversing arrows whose labels
have maybe flags.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In the rest of this document
arrows are called \skey{attribute}s,\label{ATTRIBUTE} arrow labels are called
\skey{attribute name}s, arrow flags are called \skey{attribute flag}s,
and arrow targets are called \skey{attribute value}s.
Also `\ikey{attribute L of object O}{attribute!of an object}'
denotes the set of all values (arrow targets) of attributes
of object O (arrows sourced at O) which have the attribute label
(arrow label) L.

A double arrow is called a \key{double attribute}.  When viewed from
an object at one end of the double arrow, the double arrow is an
attribute of that object, the label of the arrow directed away from that object
is the \mkey{attribute label}{of double attribute} of the double attribute,
and the label of the arrow directed toward the object is the
\mkey{reverse attribute label}{of double attribute} of the double attribute.


\subsection{Raw Representations}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set is used
in the file.  The simplest representation is the raw representation,
which we now describe.

The format of a \key{raw representation} is:

\begin{indpar}
\begin{tabular}{l}
\emkey{raw-representation} ::= {\em raw-object-representation} \ldots
\end{tabular}

\begin{tabular}{l}
\emkey{raw-object-representation} ::=
    {\em raw-object-header}
    {\em raw-attribute-representation} \ldots
\end{tabular}

\begin{tabular}{l}
\emkey{raw-object-header}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em object-name} \ttmkey{::}{in {\em raw-object-header}} \\
    $|$ & {\em object-name} \verb|>|{\tt \bf :}%
          \ttmindex{>:}{in {\em raw-object-header}} \\
    $|$ & {\em object-name} \verb|>>|{\tt \bf :}%
          \ttmindex{>>:}{in {\em raw-object-header}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-attribute-representation}\label{RAW-ATTRIBUTE-REPRESENTATION}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-single-attribute-representation} \\
    $|$ & {\em raw-double-attribute-representation}
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-single-attribute-representation} ::=
\\\hspace*{1in}
	{\em attribute-label} {\em attribute-label-terminator}
	{\em single-attribute-value}
	\ttmkey{;;}{in {\em raw-single-attribute}!{\em -representation}}
\end{tabular}%
\index{value!attribute}

\begin{tabular}{l}
\emkey{single-attribute-value} ::= {\em atom} $|$ {\em object-name}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-double-attribute-representation} ::=
\\\hspace*{1in}
	{\em attribute-label} {\em attribute-label-terminator}
	{\em double-attribute-value}
\\\hspace*{1in}
	{\em attribute-label-initiator} {\em reverse-attribute-label}
	\ttmkey{;;}{in {\em raw-double-attribute-representation}}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-value} ::= {\em object-name}
\end{tabular}

\begin{tabular}{l}
\emkey{object-name} ::=
	\ttmnbkey{\#\#}{in {\em object-name}} {\em non-negative-integer}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-label} ::= {\em atom} \ldots
\end{tabular}%
\index{label!attribute}

\begin{tabular}{l}
\emkey{reverse-attribute-label} ::= {\em attribute-label}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-label-terminator} ::=
	{\em flag-character}\ldots{\tt \bf :}%
	\index{:flag-character@{\em flag-character}\ldots{\tt :}!
	attribute-label-terminator}~~~~~(a mark)
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-label-initiator} ::=
	{\tt \bf :}{\em flag-character}\ldots%
	\index{:flag-character@{\tt :}{\em flag-character}\ldots!
	attribute-label-initiator}~~~~~(a mark)
\end{tabular}

\begin{tabular}{l}
\emkey{flag-character} ::= {\em mark-character}
		except \verb|:|, \verb|<|, or \verb|>|
\end{tabular}

\begin{tabular}{l}
\emkey{atom} ::= {\em non-special-lexeme}
\end{tabular}

\begin{tabular}{l}
\emkey{special-lexeme}
    \begin{tabular}[t]{@{}r@{~}l@{}}
    ::= & \verb|##| $|$ \verb|::| $|$ \verb|>:| $|$ \verb|>>:| $|$ \verb|;;| \\
    $|$ & {\em attribute-label-terminator} $|$ {\em attribute-label-initiator}
    \end{tabular}
\end{tabular}
\end{indpar}

A simple example of the raw representation of a set of objects is:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##1::|\\
\verb|    type: woman;;|\\
\verb|    name: Jill;;|\\
\verb|    husband: ##2 :wife;;|\\
\verb|##2::|\\
\verb|    type: man;;|\\
\verb|    name: Jack;;|\\
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt \#\#1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt \#\#2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

This represents two objects.
There are two single attributes of object \verb|##1| (arrows sourced
at \verb|##1|),
one attribute labeled {\tt type} whose value (target) is the atom {\tt woman},
and one attribute labeled {\tt name} whose value is the atom {\tt Jill}.
There are two similar single attributes from object \verb|##2|.
There is a double attribute (double arrow)
between the two objects which has the
label {\tt husband} when going from \verb|##1| to \verb|##2|
and the label {\tt wife} when going in the reverse direction.

In order to permit \verb|:| to be used in an attribute label, the following
\key{quote representation rule} is applied to representations.
A quoted symbol cannot be recognized as an atom that has special
meaning in a representation, such as the \verb|::|, \verb|:|,
\verb|##|, or \verb|;;| atoms in raw representations.  Thus if any
of these atoms are to be part of an attribute label or value, they should
be represented by \verb|"::"|, \verb|":"|, \verb|"##"|, or \verb|";;"|.
Other than this rule, there is no
distinction between quoted and unquoted representations of unquoted atoms.

The double-semi-colons (\verb|;;|) at the ends of attribute representations
may be omitted according to the \key{double-semi-colon representation rule}.
This rule says that the \ttmkey{;;}{omitting} at the end of an attribute
representation may be omitted provided the next non-blank line is not
indented with respect to the first non-white-space character of the
attribute representation with the omitted \verb|;;|,
or alternatively if there are no following non-blank lines in the text
(e.g., in the file).
Thus the \verb|;;|'s in the example just given may be omitted.
To detect errors, if a line of an attribute representation is indented by
just one column with respect to the first non-white-space character of the
attribute representation, the line is considered to be in error.
Thus indentations must be by at least two columns.

It is possible to place \skey{attribute flag}s on attribute labels
by putting flag characters
before or after the \verb|:| that follows or precedes an attribute label.
The following is the same as the above example except that flags
have been added to some of the attributes:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##1::|\\
\verb|    type: woman;;|\\
\verb|    name-: Jill;;|\\
\verb|    husband@: ##2 :@wife;;|\\
\verb|##2::|\\
\verb|    type: man;;|\\
\verb|    name+: Jack;;|\\
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt \#\#1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt -}}$}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt \#\#2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt +}}$}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){{\tt husband}$^{\mbox{\tt @}}$}}
\put(1.5,1.00){\makebox(0,0){{\tt wife}$^{\mbox{\tt @}}$}}
\end{picture}
\end{center}

In the picture the attribute flags have been added as superscripts on the
attribute labels, and in the text the flags have been added before or after the
\verb|:| that follows or precedes the attribute label.

Several attributes of the same object (arrows sourced at the object)
may have the same attribute
label.  An example of this, in which object \verb|##1| has two
attributes labeled \verb|child|, is:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##1::|\\
\verb|    child: ##2 :parent;;|\\
\verb|    child: ##3 :parent;;|\\
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(2.4,0.3){\tt \#\#1}}
\put(1.5,1.15){\oval(2.4,0.3)}
\put(0.65,1.00){\vector(0,-1){0.6}}
\put(0.60,0.80){\makebox(0,0)[r]{\tt child}}
\put(0.75,0.40){\vector(0,1){0.6}}
\put(0.80,0.55){\makebox(0,0)[l]{\tt parent}}
\put(2.25,1.00){\vector(0,-1){0.6}}
\put(2.20,0.80){\makebox(0,0)[r]{\tt child}}
\put(2.35,0.40){\vector(0,1){0.6}}
\put(2.40,0.55){\makebox(0,0)[l]{\tt parent}}
\put(0.3,0.10){\makebox(0.8,0.3){\tt \#\#2}}
\put(0.7,0.25){\oval(0.8,0.3)}
\put(1.9,0.10){\makebox(0.8,0.3){\tt \#\#3}}
\put(2.3,0.25){\oval(0.8,0.3)}
\end{picture}
\end{center}

We say that the value of the \verb|child| attribute of \verb|##1| is
the set to two elements, \verb|##2| and \verb|##3|.

Differences between \ttnbkey{::}, \ttnbkey{>:}, are \ttnbkey{>>:} relate
to what is done when an object or attribute label previously exists.

\verb|::| indicates that the object being represented should not previously
exist, or if it does exist, must not have been defined by any previous
object representation (it may have been defined as the value of an
attribute).  Second, any attribute label represented in the object
representation, if it previously exists, must be represented with exactly
the same flags as it already has.

At the other extreme, \verb|>>:| adds to existing objects.
The object being represented can previously exist.  Any attribute
representation in the object representation creates a new attribute value.
Any flags on an attribute label are added to the flags of the label if
that label already exists.

\verb|>:| is like \verb|>>:| except that the object representation cannot
add new values to previously existing attributes of the object represented.
More precisely, the attribute label of any attribute representation in
the object representation must not have previously (before the object
representation is read) been an attribute label of the represented object.
Thus \verb|>:| is used to introduce new attributes to an existing object.
Note that reverse attribute labels are not attribute labels in the sense
of this paragraph.

Double attributes must have only one representation.  If they
are given two representations, one for each end of the attribute
(double headed arrow),
\underline{two} identical double attributes (two double headed arrows with the
same end points and labels) will be created.
Usually one end of a double attribute is
thought of as the primary end, and its object representation is used to
include the sole representation of the double attribute.

The {\em object-name} \ttnbkey{\#\#0} is special; it always names
a particular object, the \ttkey{.GLOBAL} object,
whose its attributes are called \skey{global variables}.  One of the global
variables is named {\tt .GLOBAL} and has as its value the {\tt .GLOBAL}
object itself, a situation which can be achieved by the data representation:

\begin{indpar}\begin{verbatim}
##0>:
    .GLOBAL: ##0
\end{verbatim}\end{indpar}

Words beginning with `\ttkey{.}' are reserved for use by
the MIN system, and should not be defined by MIN users.  {\tt .GLOBAL}
is an example of such a word.



\subsection{Cooked Representations}

In contrast to the raw representation of a set of objects there is the
cooked representation, that is much easier to read and write, but more
long winded to explain.

The main thing that the cooked representation does is take certain objects
that are organized like lists and represent them as lists.

For example,

\begin{indpar}\begin{verbatim}
##93:: This is a sentence.
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##93::|\\
\verb|    1: this|\\
\verb|    2: is|\\
\verb|    3: a|\\
\verb|    4: sentence|\\
\verb|    .terminator: "."|\\
\verb|    .initiator: capital|\\
\end{tabular}
~~~~~
\begin{picture}(4.1,1.5)
\put(0,0){\framebox(4.1,1.5){}}
\put(0.3,1.00){\makebox(3.4,0.3){\tt \#\#93}}
\put(2.0,1.15){\oval(3.4,0.3)}
\put(1.00,1.00){\vector(0,-1){0.4}}
\put(0.95,0.85){\makebox(0,0)[r]{\tt .initiator}}
\put(1.00,0.50){\makebox(0,0)[c]{\tt capital}}
\put(1.50,1.00){\vector(0,-1){0.6}}
\put(1.45,0.85){\makebox(0,0)[r]{\tt 1}}
\put(1.50,0.30){\makebox(0,0)[c]{\tt this}}
\put(1.85,1.00){\vector(0,-1){0.6}}
\put(1.80,0.85){\makebox(0,0)[r]{\tt 2}}
\put(1.85,0.30){\makebox(0,0)[c]{\tt is}}
\put(2.10,1.00){\vector(0,-1){0.6}}
\put(2.05,0.85){\makebox(0,0)[r]{\tt 3}}
\put(2.10,0.30){\makebox(0,0)[c]{\tt a}}
\put(2.60,1.00){\vector(0,-1){0.6}}
\put(2.55,0.85){\makebox(0,0)[r]{\tt 4}}
\put(2.60,0.30){\makebox(0,0)[c]{\tt sentence}}
\put(3.00,1.00){\vector(0,-1){0.4}}
\put(3.00,0.50){\makebox(0,0)[c]{\tt "."}}
\put(3.05,0.85){\makebox(0,0)[l]{\tt .terminator}}
\end{picture}
\end{center}

The following is a second example in which parentheses \verb|( )|
are used to permit the operator \verb|+| to be recognized, so that

\begin{indpar}\begin{verbatim}
##45:: straight 3.2; left; straight (y + 9.4)
\end{verbatim}\end{indpar}

is the cooked representation of the objects

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|##42::|\\
\verb|    1: straight|\\
\verb|    2: 3.2|\\
\verb|##43::|\\
\verb|    1: "+"|\\
\verb|    2: y|\\
\verb|    3: 9.4|\\
\verb|    initiator: "("|\\
\verb|    terminator: ")"|\\
\verb|##44:: |\\
\verb|    1: straight|\\
\verb|    2: ##43|\\
\verb|##45::|\\
\verb|    1: ##42|\\
\verb|    2: left|\\
\verb|    3: ##44|\\
\verb|    .separator: ";"|\\
\end{tabular}
~~~~~
\begin{picture}(4.1,3.2)
\put(0,0){\framebox(4.1,3.2){}}
\put(1.4,0.0){
\put(0.0,0.90){\makebox(2.0,0.3){\tt \#\#43}}
\put(1.0,1.05){\oval(2.0,0.3)}
\put(0.40,0.90){\vector(0,-1){0.4}}
\put(0.35,0.75){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.40){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.90){\vector(0,-1){0.6}}
\put(0.65,0.75){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.20){\makebox(0,0)[c]{\tt "+"}}
\put(1.00,0.90){\vector(0,-1){0.6}}
\put(0.95,0.75){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.20){\makebox(0,0)[c]{\tt y}}
\put(1.30,0.90){\vector(0,-1){0.6}}
\put(1.25,0.75){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.20){\makebox(0,0)[c]{\tt 9.4}}
\put(1.60,0.90){\vector(0,-1){0.4}}
\put(1.60,0.40){\makebox(0,0)[c]{\tt ")"}}
\put(1.65,0.75){\makebox(0,0)[l]{\tt .terminator}}
}
\put(0.2,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt \#\#42}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.3}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.10){\makebox(0,0)[c]{\tt 3.2}}
}
\put(2.2,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt \#\#44}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.6}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
}
\put(0.2,2.2){
\put(0.0,0.50){\makebox(3.2,0.3){\tt \#\#45}}
\put(1.60,0.65){\oval(3.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.6}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(1.30,0.50){\vector(0,-1){0.3}}
\put(1.25,0.35){\makebox(0,0)[r]{\tt 2}}
\put(1.30,0.10){\makebox(0,0)[c]{\tt left}}
\put(2.30,0.50){\vector(0,-1){0.6}}
\put(2.25,0.35){\makebox(0,0)[r]{\tt 3}}
\put(2.80,0.50){\vector(0,-1){0.3}}
\put(2.85,0.35){\makebox(0,0)[l]{\tt .separator}}
\put(2.80,0.10){\makebox(0,0)[c]{\tt ";"}}
}
\end{picture}
\end{center}

Next is a third example in which
curly brackets (\verb|{ }|) are used with multiple
lines and indentation to represent code, so that

\begin{indpar}\begin{verbatim}
##138:: function (x,y)
        {
           if (x > y):
               return y
           else:
               return x
        }
\end{verbatim}\end{indpar}

is the cooked representation of the object in
Figure~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION}.


\begin{boxedfigure}

\begin{center}
\begin{tabular}[t]{@{}l@{}}
\verb|##130::|\\
\verb|    1: x|\\
\verb|    2: y|\\
\verb|    .separator: ","|\\
\verb|    .initiator: "("|\\
\verb|    .terminator: ")"|\\
\verb|##131::|\\
\verb|    1: ">"|\\
\verb|    2: x|\\
\verb|    3: y|\\
\verb|    .initiator: "("|\\
\verb|    .terminator: ")"|\\
\verb|##132::|\\
\verb|    1: return|\\
\verb|    2: y|\\
\verb|    .initiator: ":"|\\
\verb|##133::|\\
\verb|    1: if|\\
\verb|    2: ##131|\\
\verb|    3: ##132|\\
\verb|##134::|\\
\verb|    1: return|\\
\verb|    2: x|\\
\verb|    .initiator: ":"|\\
\verb|##135::|\\
\verb|    1: else|\\
\verb|    2: ##134|\\
\verb|##136::|\\
\verb|    1: ##133|\\
\verb|    2: ##135|\\
\verb|    .initiator: "{"|\\
\verb|    .terminator: "}"|\\
\end{tabular}
~~~~~
\begin{tabular}[t]{@{}l@{}}
\verb|##137::|\\
\verb|    1: function|\\
\verb|    2: ##130|\\
\verb|    3: ##136|\\[2ex]
\begin{picture}(4.0,5.5)
\put(0,0){\framebox(4.0,5.5){}}
\put(0.6,0.0){
\put(0.0,0.50){\makebox(2.0,0.3){\tt \#\#131}}
\put(1.0,0.65){\oval(2.0,0.3)}
\put(0.40,0.50){\vector(0,-1){0.25}}
\put(0.35,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.15){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt ">"}}
\put(1.00,0.50){\vector(0,-1){0.25}}
\put(0.95,0.40){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.15){\makebox(0,0)[c]{\tt x}}
\put(1.30,0.50){\vector(0,-1){0.25}}
\put(1.25,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.15){\makebox(0,0)[c]{\tt y}}
\put(1.60,0.50){\vector(0,-1){0.25}}
\put(1.65,0.40){\makebox(0,0)[l]{\tt .terminator}}
\put(1.60,0.15){\makebox(0,0)[c]{\tt ")"}}
}
\put(1.4,1.4){
\put(0.0,0.50){\makebox(1.3,0.3){\tt \#\#132}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.10,0.50){\vector(0,-1){0.25}}
\put(1.05,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.10,0.15){\makebox(0,0)[c]{\tt y}}
}
\put(2.6,0.7){
\put(0.0,0.50){\makebox(1.3,0.3){\tt \#\#134}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.10,0.50){\vector(0,-1){0.25}}
\put(1.05,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.10,0.15){\makebox(0,0)[c]{\tt x}}
}
\put(0.2,2.0){
\put(0.0,0.50){\makebox(1.2,0.3){\tt \#\#133}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt if}}
\put(0.60,0.50){\line(0,-1){0.45}}
\put(0.50,0.05){\oval(0.2,0.2)[br]}
\put(0.50,-0.05){\line(-1,0){0.40}}
\put(0.10,-0.15){\oval(0.2,0.2)[tl]}
\put(0.00,-0.15){\line(0,-1){1.10}}
\put(0.10,-1.25){\oval(0.2,0.2)[bl]}
\put(0.10,-1.35){\vector(1,0){0.30}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.50){\line(0,-1){0.35}}
\put(1.00,0.15){\oval(0.2,0.2)[bl]}
\put(1.00,0.05){\vector(1,0){0.2}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 3}}
}
\put(2.8,2.0){
\put(0.0,0.50){\makebox(0.8,0.3){\tt \#\#135}}
\put(0.40,0.65){\oval(0.8,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt else}}
\put(0.60,0.50){\vector(0,-1){1.0}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
}
\put(1.5,2.4){
\put(0.2,1.00){\makebox(1.3,0.3){\tt \#\#136}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt "\LEFTBRACKET"}}
\put(0.70,1.00){\line(0,-1){0.65}}
\put(0.60,0.35){\oval(0.2,0.2)[br]}
\put(0.60,0.25){\vector(-1,0){0.70}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(1.00,1.00){\line(0,-1){0.65}}
\put(1.10,0.35){\oval(0.2,0.2)[bl]}
\put(1.10,0.25){\vector(1,0){0.20}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.30,1.00){\vector(0,-1){0.25}}
\put(1.35,0.90){\makebox(0,0)[l]{\tt .terminator}}
\put(1.30,0.65){\makebox(0,0)[c]{\tt "\RIGHTBRACKET"}}
}
\put(0.6,3.2){
\put(0.2,1.00){\makebox(1.3,0.3){\tt \#\#130}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt "("}}
\put(0.70,1.00){\vector(0,-1){0.25}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.65){\makebox(0,0)[c]{\tt x}}
\put(1.00,1.00){\vector(0,-1){0.25}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.65){\makebox(0,0)[c]{\tt y}}
\put(1.30,1.00){\vector(0,-1){0.25}}
\put(1.35,0.90){\makebox(0,0)[l]{\tt .terminator}}
\put(1.30,0.65){\makebox(0,0)[c]{\tt ")"}}
\put(1.50,1.15){\vector(1,0){1.0}}
\put(1.55,1.20){\makebox(0,0)[l]{\tt .separator}}
\put(2.55,1.15){\makebox(0,0)[l]{\tt ","}}
}
\put(0.2,4.5){
\put(0.0,0.50){\makebox(3.6,0.30){\tt \#\#137}}
\put(1.80,0.65){\oval(3.6,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt function}}
\put(1.25,0.50){\vector(0,-1){0.5}}
\put(1.20,0.40){\makebox(0,0)[r]{\tt 2}}
\put(3.40,0.50){\line(0,-1){1.35}}
\put(3.30,-0.85){\oval(0.2,0.2)[br]}
\put(3.30,-0.95){\vector(-1,0){0.5}}
\put(3.35,0.40){\makebox(0,0)[r]{\tt 3}}
}
\end{picture}
\end{tabular}
\end{center}

\caption{Example Code Object Representation}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION}
\end{boxedfigure}

Cooked representations may replace raw object names in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
##291:: text: This is a sentence.
        outline: straight 3.2, left, straight (y + 9.4)
        min: function (x,y)
             {
                if (x > y):
                    return y
                else:
                    return x
             }
\end{verbatim}\end{indpar}

which is the cooked representation of the object

\begin{indpar}\begin{verbatim}
##291::
    text: ##93
    outline: ##45
    min: ##137
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
##291:: text A: This is a sentence.
        text B: This is a sentence.
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
##291::
    text A: ##93
    text B: ##93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
##291::
    text A: ##93
    text B: ##999
\end{verbatim}\end{indpar}

where object \verb|##999| happens to have the same structure as
object \verb|##93|.  The default is to make both \verb|text A|
and \verb|text B| be the same object, \verb|##93|, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object names in the cooked representations of other
objects.

The following are generalizations about certain attribute names.
First, the strictly positive integers \verb|1|, \verb|2|,
\verb|3|, \ldots are used to name the elements of a list.  Second,
some attribute names beginning with `\verb|.|' have special
meaning for object representation.  Examples above are
\verb|.separator|, \verb|.initiator|, and \verb|.terminator|.
Recall that words beginning with `\verb|.|' are reserved for
use by the MIN system, and should not be defined by MIN users.

In the following sections we describe cooked representations
precisely.

\subsection{Syntax}

A cooked data representation has the syntax given
in Figure~\figref{DATA-REPRESENTATION-SYNTAX} and is based on the
special lexemes given in Figure~\figref{SPECIAL-LEXEMES}.

\begin{boxedfigure}

\begin{center}

Ad Hoc Special Lexemes

\bigskip

\begin{tabular}{ll@{\hspace*{5em}}ll}
\ttkey{::} & object assignment &
\ttnbkey{>:} & object addition \\
\ttkey{:} & attribute assignment &
\ttkey{:} & code indicator \\
\end{tabular}

\bigskip

Brackets

\bigskip

\begin{tabular}{l@{~~~~~}l@{~~~~~}l}
brackets	& meaning	& parsing mode
\\[1ex]
\ttnbkey{(}~~~\ttnbkey{)}	& parentheses		& expression \\
\ttnbkey{[}~~~\ttnbkey{]}	& square brackets	& expression \\
\ttnbkey{\CurlyBra}~~~\ttnbkey{\CurlyKet}
				& curly brackets	& code \\
\ttnbkey{`}~~~\ttnbkey{'}	& single quotes		& text \\
\end{tabular}

\bigskip

Standard Operators

\bigskip

\begin{tabular}{rl@{\hspace*{2em}}l@{\hspace*{2em}}l}

priority & parser	& operators	& meaning 
\\[2ex]
-5000 & \ttkey{sentence} &  \ttnbkey{.} ~~~ \ttnbkey{!} ~~~ \ttnbkey{?}
	& sentence terminators \\
-4000 & \ttkey{subsentence} &  \ttnbkey{;} & subsentence separator \\
-3000 & \ttkey{phrase} &  \ttnbkey{,} & phrase separator \\
+0000 & \ttkey{assign} &  \ttnbkey{<-} ~~~ \ttkey{BECOMES} & assignment \\
+1000 & \ttkey{logical} &  \ttkey{AND} ~~~ \ttkey{OR} ~~~ \ttkey{NOT}
	& logical and, or, not \\
+2000 & \ttkey{compare} &  \ttnbkey{=} ~~~ \ttnbkey{/=} ~~~
        \ttnbkey{!=} 			& equal, not equal, ditto \\
      &		      & \ttnbkey{<} ~~~ \ttnbkey{<=} ~~~ \ttnbkey{=<}
      & less than, less than or \\
      &		      &		&
      equal, ditto \\
      &		      & \ttnbkey{>} ~~~ \ttnbkey{>=} ~~~ \ttnbkey{=>}
      & greater than, greater \\
      &		      &		&
      than or equal, ditto \\
+3000 & \ttkey{sum} &  \ttnbkey{+} ~~~ \ttnbkey{-}
	& addition, subtraction \\
+3100 & \ttkey{product} &  \ttnbkey{*} ~~~ \ttnbkey{/} 
	& multiplication, division \\
+9999 & \ttkey{objname} &  \ttnbkey{\#\#}
	& object name \\
\end{tabular}

\end{center}

\caption{Special Lexemes}
\label{SPECIAL-LEXEMES}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{l}
\key{data-representation} ::= {\em object-representation} \ldots
\\[1ex]
\key{object-representation} ::=
\\\hspace*{1in}
    \begin{tabular}[t]{@{}r@{~}l@{}}
        & {\em object-header} {\em attribute-representation} \ldots \\
    $|$ & {\em object-header} {\em text-expression}
	  \ttmkey{;;}{in {\em object-representation}}
    	  {\em attribute-representation} \ldots \\[1ex]
    \end{tabular}
\\[1ex]
\key{object-header}
    \begin{tabular}[t]{@{}r@{~}l@{}}
    ::= & {\em object-name} \ttmkey{::}{in {\em object-header}} \\
    $|$ & {\em object-name} \ttmnbkey{>:}{in {\em object-header}} \\
    $|$ & {\em object-name} \ttmnbkey{>>:}{in {\em object-header}} \\[1ex]
    \end{tabular}
\\[1ex]
\key{attribute-representation}
    \begin{tabular}[t]{@{}r@{~}l@{}}
    ::= & {\em raw-attribute-representation} \\
    $|$ & {\em cooked-single-attribute-representation} \\
    $|$ & {\em cooked-double-attribute-representation} \\[1ex]
    \end{tabular}
\\[1ex]
\key{cooked-single-attribute-representation} ::=
\\\hspace*{1in}
	{\em attribute-label} {\em attribute-label-terminator}
	{\em text-expression}
	\ttmkey{;;}{in {\em cooked-single-attribute}!{\em -representation}}
\\[1ex]
\key{cooked-double-attribute-representation} ::=
\\\hspace*{1in}
	{\em attribute-label} {\em attribute-label-terminator}
\\\hspace*{1in}
	{\em double-attribute-value}
	{\em double-attribute-value}\ldots
\\\hspace*{1in}
	{\em attribute-label-initiator} {\em attribute-label}
	\ttmkey{;;}{in {\em raw-double-attribute-representation}}
\\[1ex]
\key{text-expression} ::= {\em expression} in text mode
\\[1ex]
\key{expression} ::= {\em expression(-9999)}
\\[1ex]
\key{expression}{\em ($N$)} ::=
	\{ {\em expression($N+1$)} $|$ {\em operator($N$)} \}\ldots
\\[1ex]
\key{operator}{\em ($N$)} ::= operator of priority $N$:
			      see Figure~\figref{SPECIAL-LEXEMES}
\\[1ex]
\key{expression}{\em (10000)} ::= {\em atom} $|$ {\em bracketed-expression}
\\[1ex]
\key{bracketed-expression} \begin{tabular}[t]{@{}r@{~}l@{}}
			    ::= & \verb|(| {\em expression} \verb|)| \\
			    $|$ & \verb|[| {\em expression} \verb|]| \\
			    $|$ & \verb|{| {\em code-block} \verb|}| \\
			    $|$ & \verb|`| {\em text-expression} \verb|'| \\[1ex]
			    \end{tabular}
\\[1ex]
\key{code-block} ::= {\em expression} in code mode
\\[1ex]
See \pagref{RAW-ATTRIBUTE-REPRESENTATION} for rest of equations
(e.g., for {\em raw-attribute-representation}).
\end{tabular}
\end{center}%
\index{label!attribute}%
\index{name!object}

\caption{Data Representation Syntax}
\label{DATA-REPRESENTATION-SYNTAX}
\end{boxedfigure}

The difference between cooked data and raw data is the presence
of expressions.  An expression is parsed to produce an atom or
an object which is called the \key{parsed expression}.
If the expression is part of a
{\em cooked-attribute-representation}, the atom or object becomes
a value of the attribute.  For example, the cooked representation

\begin{indpar}\begin{verbatim}
##401::
    text A: This is a sentence.
    expression B: ( x + 8 )
\end{verbatim}\end{indpar}

is equivalent to the raw representation

\begin{indpar}\begin{verbatim}
##401::
    text A: ##402
    expression B: ##403
##402::
    1: this
    2: is
    3: a
    4: sentence
    .initiator: capital
    .terminator: "."
##403::
    1: "+"
    2: x
    3: 8
    .initiator: ")"
    .terminator: "("
\end{verbatim}\end{indpar}

If the expression immediately follows
an {\em object-header}, and is before any {\em attribute-representa\-tions}
in the {\em object-representation}, then if the parsed expression is
an object, the attributes of the object produced are copied to become
attributes of the object represented, and if the parsed expression is
an atom, the atom becomes the value of the represented object attribute
named `\ttmkey{1}{defined in cooked representation}'.  For example,
the cooked representation

\begin{indpar}\begin{verbatim}
##410:: This is a sentence.
        x: 5
\end{verbatim}\end{indpar}

is equivalent to the raw representation

\begin{indpar}\begin{verbatim}
##410::
    1: this
    2: is
    3: a
    4: sentence
    .initiator: capital
    .terminator: "."
    x: 5
\end{verbatim}\end{indpar}

and the cooked representation

\begin{indpar}\begin{verbatim}
##411:: hi
        x: 5
\end{verbatim}\end{indpar}

is equivalent to the raw representation

\begin{indpar}\begin{verbatim}
##411::
    1: hi
    x: 5
\end{verbatim}\end{indpar}

The precise algorithm used in parsing is described below in
\secref{PARSING}.


\subsection{Parsing Modes}
\label{PARSING-MODES}

There are three \skey{parsing mode}s: text, expression, and code.
The parsing mode of any lexeme is determined by the innermost
brackets containing the lexeme, according to Figure~\figref{SPECIAL-LEXEMES}.
Thus if there are no innermost brackets,
or if the innermost brackets are \verb|` '|, the parsing mode is `text'.
If the innermost brackets are \verb|( )| or \verb|[ ]|
the mode is `expression'.  If the innermost brackets are \verb|{ }|
the mode is `code'.  Thus it is as if \verb|` '| changes to text mode,
\verb|( )| and \verb|[ ]| to expression mode, and \verb|{ }| to code mode.

In \key{expression mode}\label{EXPRESSION-MODE} all operators are recognized,
line feeds and indentation are treated like any other white-space, and
`\verb|:|' is not recognized as a code indicator.

\ikey{Text mode}{text mode} is the same as expression mode except that
only some operators are recognized.  Operators with zero or negative
priority are recognized.  Operators of positive priority are only recognized
within subexpressions of operators of zero priority.

Thus if the lexeme sequence `\verb|move 5 * y, x <- x + 1|' is parsed in
text mode, the \verb|+| is recognized as an operator because it is in a
subexpression of the zero priority \verb|<-| operator, while the
\verb|*| is not recognized as an operator
because it is not in such a subexpression.  To recognize the \verb|*| as
an operator, one should put \verb|5 * y| in parentheses, as in
`\verb|move ( 5 * y ), x <- x + 1|'.

In \key{code mode}\label{CODE-MODE} all operators are recognized,
while line feeds, indentation, and the code indicator `\verb|:|' are
used to sequence statements within the code block and to indicate
code subblocks, according to the following rules:

\begin{enumerate}
\item
The column of the first non-white-space character inside \verb|{}| brackets
defines the initial column of the \key{code block} enclosed by the
brackets.

\item No line inside a code block may be indented by less than its
initial column.
Any line indented by more than the initial column must be indented by at
least 2 columns more than the initial column.

If the code block
terminating \verb|}| is the first lexeme on its line, its line is
\underline{not} considered to be inside the code block.  If the
terminating \verb|}| is \underline{not} the first lexeme on its line, 
its line is considered to be inside the code block.

\item A code block is organized as a sequence of statements such that
each non-white-space character in the code block initial column begins a new
statement, and statements so begun are the only statements in the code block.

\item
If a statement contains a `\verb|:|' \key{code indicator}\label{CODE-INDICATOR}
mark as the last
lexeme of a line, the first column of the next lexeme in the statement
begins a \key{code subblock} that includes the rest of the statement.  The
first column of that next lexeme is the initial column of the code
subblock.  The subblock obeys rules 2 and 3 just given for code blocks.

\item
A code block and its surrounding \verb|{ }| brackets represent a list of
zero or more statements with
list \verb|.initiator| \verb|"{"| and list \verb|.terminator| \verb|"}"|.

\item
A code subblock and its preceding code indicator `\verb|:|'
represents a list of zero or more statements with
list \verb|.initiator| \verb|":"| and no list \verb|.terminator|.

\end{enumerate}


\subsection{Parsing}
\label{PARSING}

Parsing a sequence of lexemes is done in four phases:

\begin{list}{}{}
\item[(1)] \ikey{Lexeme Scanning}{lexeme scanning}%
				 \index{scanning!lexeme}~~~~
The sequence of lexemes is represented as an object
that is a list whose elements (values of the attributes
named {\tt 1}, {\tt 2}, {\tt 3}, \ldots) are atoms that are lexemes
and objects representing bracketed sublists of lexemes.  Quoted
atoms are specially represented by a list with one element and the
{\tt .initiator} attribute value `{\tt quoted}'.

\item[(2)] \ikey{Operator Scanning}{operator scanning}%
				   \index{scanning!operator}~~~~
The object representation is scanned for operators
and modified by replacing subsequences of elements representing
subexpressions with implied parentheses with sublists, and by
adding {\tt .parser} attribute values to some of the list objects.

\item[(3)] \ikey{Parser Expansion}{parser expansion}%
				  \index{expansion!parser}~~~~
The object representation is evaluated by calling the parsers.

\end{list}

\subsubsection{Lexeme Scanning}
\label{LEXEME-SCANNING}

The \key{lexeme scanning} algorithm inputs a sequence of lexemes
and outputs an object representing the sequence.  The object has
list elements which are attributes labeled {\tt 1}, {\tt 2}, \ldots.
The object may have an {\tt .initiator} and/or {\tt .terminator}
attribute.

The rules for computing the object from the lexeme sequence are:

\begin{enumerate}

\item The lexeme sequence is examined to identify matching brackets.
It is an error if there are unmatched brackets (bracket characters
in quoted strings do not count as brackets).

Then the first of the following rules which can be applied is applied,
unless no rule can be applied.

\begin{enumerate}

\item If the lexeme sequence begins and ends with matching brackets, these
are removed from the sequence, and become the {\tt .initiator} and
{\tt .terminator} attributes of the object being computed.

\item If the lexeme sequence begins with a `\verb|:|' code indicator mark
(\pagref{CODE-INDICATOR}), this
is removed from the sequence, and becomes the {\tt .initiator}
attribute of the object being computed.

\end{enumerate}

\item The remaining
lexeme sequence is then scanned from right to left to produce
the list elements of the object being computed (these become the
values of the attributes named {\tt 1}, {\tt 2}, {\tt 3}, \ldots).
At each stage of the
scan, lexemes are input and another list element is produced according
to the first of the following rules that can be applied.

\begin{enumerate}

\item If the next lexeme is the beginning of a statement within a code
block (\pagref{CODE-MODE}),
the subsequence of lexemes that is the statement (including any
subblocks) becomes the input,
the lexical scanning algorithm is called recursively with this subsequence,
and the object output by the recursive call becomes the next list element.

\item If the next lexeme is an opening bracket (\verb|{|, \verb|(|,
\verb|[|, or \verb|`|), the subsequence of lexemes beginning
with the bracket and ending with the matching bracket becomes the input,
the lexical scanning algorithm is called recursively with this subsequence,
and the object output by the recursive call becomes the next list element.

\item If the next lexeme is a `\verb|:|' code indicator mark
(\pagref{CODE-INDICATOR}), the subsequence of lexemes consisting of
the code indicator mark and the following subblock becomes the input,
the lexical scanning algorithm is called recursively with this subsequence,
and the object output by the recursive call becomes the next list element.

\item If the next lexeme is a quoted string, the lexeme by itself
becomes the input, and the next list element is an
object whose only attributes are an attribute named {\tt 1} whose value
is the quoted string atom
and an {\tt .initiator} attribute whose value is the atom `{\tt quoted}'.

\item If the next lexeme is a word, mark, separator, or number,
the lexeme by itself becomes the input, and the word, mark, separator,
or number becomes the next list element.

\end{enumerate}

\end{enumerate}

For example, given the input

\begin{center}
\verb|`The "+" in (x + 5 * y) is an operator.'|
\end{center}

the lexical scanning algorithm outputs object \verb|##1| in the
following:\label{LEXICAL-SCANNING-EXAMPLE-OUTPUT}

\begin{indpar}\begin{verbatim}
##1::
    1 : The
    2 : ##2
    3 : in
    4 : ##3
    5 : is
    6 : an
    7 : operator
    8 : .
    .initiator: "`"
    .terminator: "'"
##2::
    1: "+"
    .initiator: quoted
##3::
    1 : x
    2 : "+"
    3 : 5
    4 : "*"
    5 : y
    .initiator: "("
    .terminator: ")"
\end{verbatim}\end{indpar}

Recall that within objects there is no difference between
a quoted string representation of a mark and the mark, as both are
the same atom, but in textual representations of objects the quoted
string representation of marks that can be operators is used
to keep the marks from being misread as operators.
Thus \verb|"+"| is used in the textual
object representation above to denote the 1 character atom \verb|+|,
and \verb|"*"|, \verb|"("|, \verb|"`"|, \verb|")"|, and \verb|"'"| 
also denote 1 character atoms.

Differences between expression mode (\pagref{EXPRESSION-MODE})
and code mode (\pagref{CODE-MODE}) are all
handled during lexical scanning, and thereafter these two modes behave
the same.

\subsubsection{Operator Scanning}
\label{OPERATOR-SCANNING}

The \key{operator scanning} algorithm inputs an object output
by the lexical scanning algorithm and rearranges its contents according
to the operators it contains.
Specifically, subsequences of list elements between operators
are regrouped into sublists to represent subexpressions,
and {\tt .parser} attributes are added to
objects in preparation for expansion.

The operator scanning algorithm takes as input both an object and a parsing
mode.  The parsing mode is either text or expression (\pagref{PARSING-MODES}).
Code mode is handled elsewhere, during lexical scanning, and is treated as
equivalent to expression mode during operator scanning.  The output of
the algorithm is the input object which may be modified.
The operator scanning algorithm applies the following actions to the
object:

\begin{enumerate}

\item If the object has an 
an {\tt .initiator} attribute equal to `{\tt quoted}', the
scanning algorithm terminates without modifying the object.

\item
If the object has an {\tt .initiator} attribute,
the parsing mode argument to the algorithm is changed as follows:

\begin{center}
\begin{tabular}{lll}
\tt .initiator	& \tt .terminator	& new parsing mode \\[1ex]
\tt `		& \tt '			& text \\
\tt (		& \tt )			& expression \\
\tt [		& \tt ]			& expression \\
\LEFTBRACKET	& \RIGHTBRACKET		& expression \\
\tt :		& 			& expression \\
\end{tabular}
\end{center}
	
\item The object list elements are inspected to see if any are operators.
An operator is an atom equal to an operator that is recognized according
to the current parsing mode (see \pagref{PARSING-MODES},
Figure~\figref{SPECIAL-LEXEMES}, and Section~\secref{OPERATOR-DECLARATION}).

If there are operators among the list elements, those with the lowest
priority L are selected.  Then any non-empty sequences of list elements between
selected operators are replaced by a single object listing the replaced
elements.  However sequences with only one element are not replaced.
Then, the current object is given a {\tt .parser}
attribute equal to the parser associated with priority level L
(see Figure~\figref{SPECIAL-LEXEMES} and Section~\secref{OPERATOR-DECLARATION}).

Lastly, if the current parsing mode is text and L equals zero, the parsing
mode is changed to expression.

\item
The operator scanning algorithm is called recursively on each element
of the current object's list that is an object and not an atom.  In making
this recursive call, the current parsing mode is passed as an argument
to the recursive algorithm execution.


\end{enumerate}

Given the the lexical scanning output on
\pagref{LEXICAL-SCANNING-EXAMPLE-OUTPUT},
which was derived from the lexeme sequence,

\begin{center}
\verb|`The "+" in (x + 5 * y) is an operator.'|
\end{center}

operator scanning returns:

\begin{indpar}\begin{verbatim}
##1::
    1 : ##4
    2 : .
    .initiator: "`"
    .terminator: "'"
    .parser: sentence
##4::
    1 : The
    2 : ##2
    3 : in
    4 : ##3
    5 : is
    6 : an
    7 : operator
##2::
    1: "+"
    .initiator: quoted
##3::
    1 : x
    2 : "+"
    3 : ##5
    .initiator: "("
    .terminator: ")"
    .parser: sum
##5::
    1 : 5
    2 : "*"
    3 : y
    .parser: product
\end{verbatim}\end{indpar}

Note that classical programming language prefix and postfix operators are
not supported by MIN.  Examples are given with descriptions of parsers
in the next section.\footnote{Classical prefix and postfix operators could be
supported by MIN, but seem to the author to be no more intuitive than
the MIN approach.  In particular, `{\tt x<y~AND NOT~y<z}' fails classically
but works in MIN.}

\subsubsection{Parser Expansion}
\label{PARSER-EXPANSION}

The \key{parser expansion} algorithm inputs an object output
by the operator scanning algorithm and outputs an
expanded object that replaces the input object.
The parser expansion algorithm goes through its input
looking for objects with a {\tt .parser} attribute, and for each
such object, calls its {\tt .parser} attribute value as a function with
the object as input and the function output as the expansion of the input
object.  The expansion algorithm works only on the top level: when the
algorithm calls the {\tt .parser} attribute function of an expression,
the algorithm leaves it up to that function to call the {\tt .parser}
attribute functions of subexpressions.  The standard parsers do this
first, thus effecting a bottom up algorithm, similar to expression
evaluation.

A {\tt .parser} attribute value is known as a \key{parser}, and is associated
with an operator priority level
(see Figure \figref{SPECIAL-LEXEMES} and \secref{OPERATOR-DECLARATION}).
Immediately below are the standard parsers and their effects.

In describing effects, we use notation such as

\begin{center}
\verb|x <- y <- z + w| ~~~ $\Longrightarrow$ ~~~
\verb|<- x (<- y (+ x w))|
\end{center}

Here $\Longrightarrow$ means `is rewritten as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implicit},
which means that the lists they bracket have \underline{no}
\verb|.initiator| or \verb|.terminator|, and the parentheses are
merely written here to indicate sublists in the expression structure.

\newpage

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{parsing}}
\newcommand{\NBOP}[1]{\ttmnbkey{#1}{parsing}}
\newcommand{\MAC}[2]{\hfill #1, \ttmkey{#2}{parsing macro}}

\bigskip

\ttmkey{sentence}{parser} \hfill
	\skey{terminator}s: \NBOP{.} ~ \NBOP{!} ~ \NBOP{?}

\begin{indpar}[0.5em]
Terminators may not be consecutive, may not begin an expression,
and must end an expression.  Thus each between-terminator subexpression
is non-empty and is followed by a terminator.
Each between-terminator subexpression is converted if necessary
to a list.  Then a \ttmkey{.terminator}{produced by parsing}
attribute is added to this list whose value is the terminator following the
subexpression.  If there is only one subexpression, the list it produces
is the parse result.  Otherwise the result is the list of all the subexpression
lists.
\end{indpar}

\bigskip


\ttmkey{subsentence}{parser} \hfill
	\key{subsentence separator}: \NBOP{;} \\
\ttmkey{phrase}{parser} \hfill
	\key{phrase separator}: \NBOP{,}

\begin{indpar}[0.5em]
Here `\verb|;|' or `\verb|,|' is the \key{separator}.  These have different
priority levels and different parsers, and so cannot appear together
in the same expression.

A list of all between-separator subexpressions is made, with empty
between-separator subexpressions being represented by objects with
no attributes.  There will be at least two subexpressions: one following
the last separator and one preceding the first separator.
The list of subexpressions is given a
\ttmkey{.separator}{produced by parsing}
attribute with value of the separator (\verb|";"| or \verb|","|),
and is returned as the result of the parse.
\end{indpar}

\bigskip

\ttmkey{assign}{parser} \hfill
	\skey{assign operator}s: \NBOP{<-} ~ \OP{BECOMES}

\begin{indpar}[0.5em]
Assign operators may not be consecutive and may not begin or end an expression.
The two different kinds of assignment operator, \verb|<-| and \verb|BECOMES|,
may not be mixed in the same expression.
The results are rewritten using the two-argument assignment function \verb|<-|,
making multiple assignments from right to left.

\begin{indpar}[0.5em]
\verb|x <- y <- z + w| ~~~ $\Longrightarrow$ ~~~
\verb|<- x (<- y (+ x w))| \\
\verb|x BECOMES y BECOMES z + w| ~~~ $\Longrightarrow$ ~~~
\verb|<- x (<- y (+ x w))|
\end{indpar}
\end{indpar}

\bigskip

\ttmkey{logical}{parser} \hfill
	\skey{logical operator}s: \OP{AND} ~ \OP{OR} ~ \OP{NOT}

\begin{indpar}[0.5em]
One expression cannot have both {\tt AND} and {\tt OR} operators
outside explicitly bracketed subexpressions.  The {\tt NOT} operator
can only occur at the beginning of an expression or just after {\tt AND}
or {\tt OR}.  Subexpressions cannot be empty, except for the subexpressions
before a {\tt NOT}, which must always be empty.

The expression is rewritten using a multi-argument {\tt AND}
or {\tt OR} function and a single argument {\tt NOT} function.

\begin{indpar}[0.5em]
\verb|NOT x = 8| ~~~ $\Longrightarrow$ \verb|NOT (x = 8)| \\
\verb|NOT x AND NOT y AND z AND w| ~~~ $\Longrightarrow$ ~~~
\verb|AND (NOT x) (NOT y) z w| \\
\verb|NOT x = 8 OR NOT y < 9 OR z = 0| ~~~ $\Longrightarrow$
\\\hspace*{1in}
\verb|OR (NOT (x = 8)) (NOT (y < 9)) (z = 0)|
\end{indpar}

Note that {\tt NOT} is not a classical prefix operator, which would have
higher priority than \verb|=| or \verb|<|.  Also note that {\tt AND}
and {\tt OR} may not be used in the same logical expression without using
explicit parentheses.
\end{indpar}

\bigskip

\ttmkey{compare}{parser} \hfill
	\skey{compare operator}s:
	\NBOP{=} ~ \NBOP{<} ~ \NBOP{>} ~
	\NBOP{/=} ~ \NBOP{!=} ~
	\NBOP{=>} ~ \NBOP{>=} ~
	\NBOP{=<} ~ \NBOP{<=}

\begin{indpar}[0.5em]
Subexpressions cannot be empty, and a compare operator may not
begin or end an expression.
The expression is rewritten using a multi-argument {\tt AND}
function and two-argument compare functions.  Temporary variables
(\secref{TEMPORARY-VARIABLES})
are used to name intermediate expression values to
avoid recomputing arguments.

\begin{indpar}[0.5em]
\verb|x < y < z| ~~~ $\Longrightarrow$ ~~~
\verb|AND (< x (<- (.tmp 56) y)) (< (.tmp 56) z))| \\
\verb|x = y + z != w/2 <= x| ~~~ $\Longrightarrow$
\\\hspace*{1in}\begin{tabular}{@{}ll@{}}
	       \verb|AND| & \verb|(= x (<- (.tmp 57) (+ y z)))| \\
			  & \verb|(!= (.tmp 57) (<- (.tmp 58) (/w 2)))| \\
			  & \verb|(<= (.tmp 58) x)| \\
	       \end{tabular}
\end{indpar}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \verb|x<y<z| means \verb|x<y AND y<z| and \underline{not}
\verb|(x<y)<z|.
\end{indpar}

\bigskip

\ttmkey{sum}{parser} \hfill
	\skey{addition operator}s: \NBOP{+} ~ \NBOP{-}

\begin{indpar}[0.5em]
Addition operators may not be consecutive and may not end an expression.
The results are rewritten using the multi-argument summation function \verb|+|
and the unary negation function \verb|-|.

\begin{indpar}[0.5em]
\verb|- x + y + z - w| ~~~ $\Longrightarrow$ ~~~
\verb|+ (- x) y z (- w)|
\end{indpar}
\end{indpar}

\bigskip

\ttmkey{product}{parser} \hfill
	\skey{multiplication operator}s: \NBOP{*} ~ \NBOP{/}

\begin{indpar}[0.5em]
The two different kinds of multiplication operators, \verb|*| and \verb|/|,
cannot be mixed in the same expression.
Multiplication operators may not be consecutive and may neither begin
nor end an expression.  The division operator \verb|/| must have exactly
two operands.  The results are rewritten using
the multi-argument multiplication function \verb|*| or the binary
division function \verb|/|.  E.g.:

\begin{indpar}[0.5em]
\verb|x * y * z| ~~~ $\Longrightarrow$ ~~~ \verb|* x y z| \\
\verb|x / y| ~~~ $\Longrightarrow$ ~~~ \verb|/ x y|

\end{indpar}
\end{indpar}


\end{indpar}


\section{Evaluation}
\label{EVALUATION}

A MIN expression is an atom or a list
(see Figure~\figref{DATA-REPRESENTATION-SYNTAX})
that can be evaluated.  Evaluation is done by an object,
which may be a function frame (see below).  The attributes of the
object constitute the local variables accessible during evaluation.
If a variable cannot be found locally, it is found by searching
the ancestors of the object.  The first ancestor searched is called
the lexical parent of the object, and plays a special role in
compilation.

Evaluation is done in an evaluation context.  This context includes
the object currently evaluating expressions, a pointer indicating
the next part of the expression to be evaluated, and other information.
The object evaluating the expression may change during evaluation of
the expression, as when the first part of an expression designates
another object that is to evaluate the rest of the expression.
The evaluation context includes an initial object that is to be used
as the first object to evaluate any subexpression.

The code that does evaluation for a particular object is compiled.
Associated with each evaluation context is a lexical context
which contains the information available at the time this code is
compiled.  Code may be compiled as soon as the lexical context in
which it is run is defined.
The lexical context includes incomplete information about which attributes
are defined for an object that performs evaluations of expressions.
This information is available from the lexical context of the code that
creates the object.
The lexical context also includes the lexical context of the lexical
parent of the object.

In effect, the `type' of an object is the lexical context in which
the object is created.  All objects created with the same lexical
context can share the same code.  To make this work properly, the
lexical parent of an object is determined by the lexical context
in which the object is created.

\section{Evaluation Context}
\label{EVALUATION-CONTEXT}

Expressions are evaluated in an \key{evaluation context}.  Evaluation
contexts are organized in a tree, with subcontexts and parent contexts.
Each evaluation context contains the following:

\bigskip

\key{current expression}

\begin{indpar}[0.5em]
This is the expression being evaluated.  It is not used during
evaluation (see `remaining argument list' below), but is available for
debugging and error messages.
\end{indpar}

\key{remaining argument list}

\begin{indpar}[0.5em]
This is initialized to the list of elements of the current expression.
These elements are call \skey{argument}s.
If the expression is a single atom, it is treated as a list
of one atom.

As the expression is evaluated, arguments are removed from
the beginning of the remaining argument list.  When an argument is
removed, it may or may not be evaluated, as determined by the
current evaluator (see below).
\end{indpar}

\bigskip

\key{current evaluator}\\
\key{initial evaluator}

\begin{indpar}[0.5em]
The current evaluator is the object that is currently evaluating the
expression.  Often this object is a function frame created when a
function is called.  But this object is also frequently a non-frame
object whose attributes are to be read or written.

The initial evaluator is used to initialize the current evaluator in
any newly created evaluation subcontext.
When an argument is to be evaluated, a new evaluation subcontext
is created for evaluating the argument, and the initial evaluator
becomes both the initial and current evaluator in the subcontext.
\end{indpar}

\bigskip

\key{input list}\\
\key{output list}

\begin{indpar}[0.5em]
The input list is a list of values, or is missing, and similarly
the output list is a list of values, or is missing.  Missing and
empty lists are \underline{not} the same.

The input values are values to be written somewhere.  The output
values are values read from somewhere.  Write and read operations
are controlled by these lists and other parts of the context.

\end{indpar}

\bigskip

\key{memory type}

\begin{indpar}[0.5em]
Reads and writes come in three kinds: \key{single value},
\key{set value} and \key{multiset value}.

In the single value case, the thing being read or written is
viewed as having a single value.  A read should return this value
(in th output list), a write should overwrite
(from the input list) any existing value, or create a new value if
none exists, and a delete should delete the thing being read or
written.

In the set value case, the thing begin read or written is
viewed as having a set of \underline{unequal} values.
A read should return the values of this set (in the output list),
a write should add to this set any values (from the input list)
not already in the set, and a delete should remove designated values
(from the input list).

The multiset case is just like the case except that values may be
replicated, and need not all be unequal.  Adding a value that already
exists merely increments the values replication count, and deleting
the value deletes the count.  The count may not be negative.

\end{indpar}

\bigskip

\key{search type}

\begin{indpar}[0.5em]
TBD: local, non-local.
\end{indpar}




\begin{enumerate}

\item
An expression is treated as a list of subexpressions called
`\skey{argument}s' that are read
from left to right under the control of a `\key{current value}'.
The current value at the beginning of the expression is the
`\key{initial value}' of the expression.
The initial value of an expression completely defines the
context in which the expression is evaluated.
It is typically a function frame for the function
whose code contains the expression.

Arguments are read without being evaluated.  They can then
be evaluated at any time using the same initial value as the expression
that contained the argument.  Thus arguments may be immediately
evaluated, never evaluated, or evaluated later.  Sometimes parts of
an unevaluated argument can be treated as separate arguments, as when
an argument is a comma separated list whose elements can be evaluted
separately.

The list of unread arguments remaining in the expression is called the
`\key{remaining argument list}'.

\item
An expression evaluation may have a list of input
values and/or a a list of output values.
The input values may be thought of as values to be stored,
and the output values may be thought of as values read or
returned from a function.  Either list may be missing.

A missing value list and an empty value list are not the same thing;
e.g., a missing input list means nothing is to be stored, and an empty
input list means the empty list is to be stored.

\item
An expression evaluation also has as both input and output
a condition code containing some flag bits that control evaluation.
In the context of evaluating a block (a sequence of expressions to
be evaluated one after another), one bit may be set to repeat the
current expression, another to indicate that any immediately following
`\verb|else|' or `\verb|else if|' expression should be skipped, and
so forth.

\item
The current value reads zero or more arguments, performs some computation,
and modifies the input and output value lists, the current value, the
condition code, and the remaining argument list.  Usually the only
modification is to remove arguments as they are read from the
remaining argument list, and either set the current value if there
are remaining arguments or the output argument list otherwise.

Current values that return a single value when the input value
list is missing and the remaining argument list is empty usually will
make the value they would have returned the new current value
if the remaining argument list is not empty.

\item
When a function is called, a function frame is allocated to a stack
in order to hold the local variables of the function.
Function frames are just like
objects, except that no object can point at a function frame, and
no function frame X can point at another function frame Y unless
X and Y are in the same stack and Y is allocated after X is allocated and
freed before X is freed.

\item
When the current value of an expression is an object or frame, the next
arguments are used as the name of an attribute which is searched for
starting with the current value.
Objects and function frames have a list of ancestors from which they
inherit attributes.  Ancestors are themselved objects or frames.
If the search does not find an attribute in an
object or frame, the ancestors of the object or frame are searched for
the attribute, recursively depth first.

Note that because only frames may point at frames, a frame may not be
an ancestor of an object, and frame X may be an ancestor of frame Y only
if X and Y are in the same stack and Y is allocated after X is allocated
and freed before X is freed.

The last ancestor in the list of ancestors of an object or frame is called
the \key{lexical parent} of the object or frame, and plays the role of
identifying the lexical container of the object or frame.

\item

There are two kinds of functions.

\ikey{Methods}{method} are functions whose code is the value of
an object or frame attribute.
When called, a new frame is created to hold the local variables
of the function execution, and that frame is given as its lexical parent
the object or frame whose attribute is the function code.

\ikey{Abstractions}{abstraction} are functions created by a function execution.
An abstraction consists of a pair, one element being the code of the
function, and the other element being a pointer to the frame of the function
execution that created the abstraction.  When the abstraction is called,
a new frame is created to hold the local variables of the function
execution, and that frame is given as its lexical parent the
frame pointed at by the frame element of the abstraction, which is the
frame of the function execution that created the abstraction.

An abstraction can only be called by a function execution X that runs
during the function execution Y that created the abstraction.
Similarly a method of the frame of a function execution Y can only
be called by a function execution X that runs during Y.  X and Y can be
the same function execution in either case.

\begin{quote}
Some languages permit the lexical parent of an object to be a frame,
but MIN does not.

Specifically, in languages with object types, whenever a function or
object type definition X is created
within a function execution whose frame is Y,
definition X is associated with frame Y.
Then any function call or object
creation using the definition X yields a function frame or object whose
lexical parent is Y.  Also, if a definition X of a function or object type
occurs within an object type definition Z,
then effectively X is not available except within an object Y of type Z,
and Y becomes the lexical parent of any function execution or
object created from definition X.

Because object types may be defined by function code (in languages other
than MIN), objects may have function frames as lexical parents.
The adverse consequence is that either these objects must be deallocated
when their lexical parent's function execution terminates,
or their lexical parent must persist after its function execution terminates.
MIN does not support this,
and therefore does not support objects whose lexical parents are frames
(or in general, objects that point at frames in any way).

\end{quote}


\end{enumerate}

\subsection{Evaluation Examples}

Consider the following description of a room:

\begin{indpar}\begin{verbatim}
##523::
    type: standard room
    outline: straight width, left, straight length, left,
             straight width, left,
             doored wall width,
             close
    width: 3.2
    length: 9.6
    doored wall: function ( length ) {
                     d <- (length - door width) / 2
                     straight d
                     door (door width)
                     straight d }
    door : standard room door
    label: color green, under over, noun room
    over: ##598
\end{verbatim}\end{indpar}

The information in this description is not immediately useful for
producing output, such as a video picture of the room, or text naming
the room.  Instead, parts of the description must be evaluated to produce
the picture or the name.

Another example is the \ttmkey{type}{of object} attribute of an object,
which is implicitly evaluated to produce the \ttdmkey{ancestors} attribute
of the object.  This last is a list of other objects from which the current
object inherits attributes.  In our example, the \verb|type| attribute
names another object, `{\tt standard room}', from which the room object
inherits attributes.  This means that when an evaluation searches for the
name of an attribute in the room object, if that name is not found, the
evaluation will next search the `{\tt standard room}' object.

To compute the \verb|.ancestors| attribute the \verb|type| object
is evaluated `in global context'.  This last implies that the only
names the evaluator can use are global variable names, and `{\tt standard
room}' in fact names a global variable whose value is the object
which is the sole immediate ancestor of our room.

In our example, the \verb|outline| attribute value is used to compute
a video output that describes how the object is to be displayed
graphically.
The \verb|outline| attribute value is a program is written from the point
of view of a robot moving around the outline of the room building walls.
The robot follows a sequence of commands that are separated by commas.

In order to show how evaluation works, we will explain in detail some
of the evaluation of \verb|outline|.

Evaluation of the \verb|outline| attribute of object \verb|##523|
is triggered when a video description of how to display this object
is needed.  This evaluation is done by the
\ttdmkey{display}{function of object} attribute of the object to be
displayed.  In this case this {\tt .display} attribute
is defined by {\tt standard room} which is an ancestor of \verb|##523|.

In our case the \verb|.display| function evaluates
the \verb|outline| attribute of \verb|##523| to produce the video output.
First the function establishes
a context, which is a list of objects that will be searched when an
attribute name is to be located.  The context for the evaluation of
an object's attribute value usually begins with the object and ends with
a special object called `\verb|.GLOBAL|'.  A global variable is by definition
just an attribute of the \verb|.GLOBAL| object.  An function evaluating
an {\tt outline} attribute is likely to include in the context an object
that defines functions named `{\tt straight}' and `{\tt left}' which will
evaluate parts of the {\tt outline} attribute.

Besides establishing a context, the \verb|.display| function establishes an
execution frame.  The execution frame contains a video output channel into
which functions like `{\tt straight}' write new commands written in
a video language that can be processed by the video engine to produce
a picture.

Since functions such as `{\tt straight}' and `{\tt left}' are written
from the point of view of a robot moving around the outline of a room,
the execution frame also contains the current location and direction
of the robot.

After establishing a context and frame, the evaluating function starts reading
the \verb|outline| attribute value which is to be evaluated.  In this
case the it finds a comma separated list of commands, and evaluates
each command separately.

The first command is `{\tt straight width}'.   When `{\tt straight}' is 
read, a search is made in the current context for an attribute with a name
beginning with the word `{\tt straight}'.  One will be found whose total
name is just the single word `{\tt straight}', and the value of that
attribute will be taken.  We have not shown that attribute, but it will
exist and have a value of the form

\begin{center}
\verb|function ( w ) { |\ldots\verb|}|
\end{center}

This value means the expression we are reading should have next, after the
word `{\tt straight}', a single argument.  An argument
is either a single lexeme or a bracketed string of lexemes.  The argument
must be read, and perhaps evaluated and replaced by its value, which becomes
the value of the \verb|w| argument of the `{\tt straight}' function.
Then this function is evaluated.

In our case `{\tt width}' follows `{\tt straight}'.  This is an unbracketed
single lexeme argument, and as such must be evaluated and replaced by
its value.  A search is made for an attribute whose name begins with
`{\tt width}'.  The `{\tt width}' attribute of \verb|##523| is found,
and as its value is a number,
\verb|3.2|, that is the final value of the `{\tt width}' argument.
Thus the command `{\tt straight width}' has become `{\tt straight 3.2}',
and this is then evaluated by executing the `{\tt straight}' function
with \verb|w| equal to \verb|3.2|.  The result will be video commands
written into the video output channel.

The other commands in the {\tt outline} attribute are similar, except
for the `{\tt doored wall width}' command.  This invokes the `{\tt doored wall}'
function we have defined as an attribute of \verb|##523| (but it would
make more sense to define it as an attribute of the {\tt standard room}
object whose attributes are inherited by \verb|##523|).   Again
`{\tt width}' is the argument which evaluates to \verb|3.2| and becomes
the value of the `{\tt length}' argument in the `{\tt doored wall}'
function.  Evaluation of the `{\tt doored wall}' function is next,
and as a function,
its evaluation context begins with an object called the function frame
that has an attribute named `{\tt length}' whose value is the corresponding
argument value, in this case \verb|3.2|.

We also need to explain
the meaning of the `{\tt label}' and `{\tt over}' attribute values
of \verb|##523|.  It is necessary to produce a name
for \verb|##523| in an arbitrary natural language, such as English or
French or Japanese, and this is what the `{\tt label}' attribute value does
when it is evaluated.  This value is also a sequence of commands that
provide descriptive information about the object which the natural language
engine can process to produce the desired text.  The `{\tt color green}'
command invokes the `{\tt color}' function with an argument that is
some object which is the value of the `{\tt green}' variable to
produce some internal notation that tells the natural language engine
that \verb|##523| has the color green.  Similarly `{\tt over under}'
invokes the `{\tt over}' function with an the `{\tt under}' argument that
just names an attribute of \verb|##523| with value \verb|##598|.  This
says that \verb|##523| is under \verb|##598|.  Lastly, `{\tt noun room}'
says that \verb|##523| is a room.

If the label of \verb|##598| is

\begin{center}
\verb|label: adjective main, noun dungeon|
\end{center}

then the English natural language engine might generate the text

\begin{center}
\verb|the green room under the main dungeon|
\end{center}

in order to specify \verb|##523|.

\subsection{The Evaluation Algorithm}

An object or frame has an `\ttdkey{ancestors}' attribute that is a
list of all the ancestors of the object or frame.
Ancestors of objects must be other objects, while ancestors
of frames can be objects or frames.  Frame X can be an ancestor of
frame Y only if X and Y are in the same stack and Y is allocated after
X is allocated and freed before X is freed.

The context of an expression being evaluated is provided by an
`\key{evaluation context}' datum.  This is typically not a MIN datum,
but instead a C++ datum, allocated in the C++ stack to the C++ frame
of a C++ expression evaluator function.  Evaluation contexts
are allocated to their own `\key{evaluation stack}', which may be
just the C++ stack (and may contain other things besides evaluation
contexts).

One may think of evaluation of an expression as being
done by a particular frame or object, called the \key{current evaluator}.

An evaluation context has the following components:

\begin{indpar}[0.1in]
\begin{tabular}{@{}p{1.2in}p{1.5in}p{3.1in}@{}}

\begin{tabular}[t]{@{}l@{}}
\tt \bf current \\
\tt \bf evaluator \\
\end{tabular}\ttmindex{current evaluator}{of evaluation context}
    & \begin{tabular}[t]{@{}l@{}}object or frame\\name\end{tabular}
    & One should think of expression evaluation as being done by an object
      or frame called the current evaluator.
\\[0.5ex]
\begin{tabular}[t]{@{}l@{}}
\tt \bf initial \\
\tt \bf evaluator \\
\end{tabular}\ttmindex{initial evaluator}{of evaluation context}
    & \begin{tabular}[t]{@{}l@{}}object or frame\\name\end{tabular}
    & Initial value for the current evaluator when a new context is
      created to evaluate a subexpression.  \underline{Both} the current
      and initial evaluator of the new context are set to the
      initial evaluator of the previous context in the evaluation stack.
\end{tabular}
\end{indpar}

\bigskip

\begin{indpar}[0.1in]
\begin{tabular}{@{}p{1.2in}p{1.5in}p{3.1in}@{}}

\ttmkey{expression}{of evaluation context} & MIN expression
    & Expression being evaluated.
\\[2ex]
\ttmkey{next}{of evaluation context}
    & \begin{tabular}[t]{@{}l@{}}non-negative\\integer\end{tabular}
    & The \skey{remaining argument}s
      are all the elements of the `{\tt expression}'
      list from the element whose index is `{\tt next}'
      to the end of the list.  {\tt 0} is the index of the first element.
      If the expression is not a list, it is treated as if it were
      a list of one element.

\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\begin{tabular}{@{}p{1.2in}p{1.5in}p{3.1in}@{}}

\ttmkey{caller}{of evaluation context} & evaluation context
    & Evaluation context of the expression which called the function
      execution of which the current evaluation context is a part.
      When the function wants to read another argument, it invokes
      this evaluation context to read or to read and evaluate the
      next function argument.
      This is also the context that resumes execution when a function
      returns.

\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\begin{tabular}{@{}p{1.2in}p{1.5in}p{3.1in}@{}}

\ttmkey{input values}{of evaluation context} & MIN list or MISSING
    & The possibly empty list of input values, or the special MISSING
      value (the MISSING value need not be a MIN value, and
      may be the C++ NULL value).
      \\[0.5ex]
    &
    & Expressions of the form `$X$ \verb|<-| $Y$' cause values
      generated by evaluating $Y$ to become input values to the
      evaluation of $X$.
\\[0.5ex]
\ttmkey{output values}{of evaluation context} & MIN list or MISSING
    & Ditto but for output values instead of input values.
      Expressions that return values do so in this output values list.

\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\begin{tabular}{@{}p{1.2in}p{1.5in}p{3.1in}@{}}

\begin{tabular}[t]{@{}l@{}}
\tt \bf evaluation \\
\tt \bf flags \\
\end{tabular}\ttmindex{evaluation flags}{of evaluation context}
    & 32 bits
    & Contains flags that control expression evaluation.  The low order
      16 bits are reserved to the MIN system, and the high order bits
      may be used by applications programs.  See below.

\end{tabular}
\end{indpar}

The MIN system \skey{evaluation flag}s are:

\begin{indpar}
\begin{list}{}{}

\item[\ttakey{repeat}{evaluation flag}]~\\
    If on at the end of evaluating a statement in a block,
    this flag is turned off and the statement is repeated.

\item[\ttakey{skip else}{evaluation flag}]~\\
    If on at the beginning of an {\tt else} statement being
    evaluated in a block, the {\tt else} statement is skipped
    and this flag is turned off.

    If on at the beginning of an `{\tt else if}' statement
    being evaluated in a block, the `{\tt else if}' statement is
    skipped and this flag is left on.

    If on at the beginning of any other statement in a block,
    this flag is turned off.

\item[\ttakey{throw}{evaluation flag}]~\\
    Set when a {\tt throw} statement is executed during a
    {\tt try} statement.

    If \underline{off} at the beginning of a {\tt catch} or `{\tt catch if}'
    statement being evaluated in a block, the {\tt catch} or
    `{\tt catch if}' statement is skipped.

\item[\ttakey{return}{evaluation flag}]~\\
    If on at the end of evaluating a statement in a block,
    a return to the last caller is executed.  Any output
    values, current value changes, etc.~of the caller must
    be done by the expression that sets the return flag.

\end{list}
\end{indpar}

\subsection{Evaluation Steps}

An evaluation step performs some operation on the
top evaluation context in the evaluation stack.
The top level program executor creates a non-empty
evaluation stack and executes evaluation steps until the
stack becomes empty.  Some builtin operators push an
evaluation context into the evaluation stack and then execute
evaluation steps until that context terminates; that is,
until the context is popped from the stack.  When a context
terminates, information from that context, such as its output
value list and evaluation flag setting, is passed to the
builtin operator.

An \key{evaluation step} is just the execution of the first
of the following which applies:

\begin{enumerate}

\item
The remaining arguments are a non-empty string of
atoms that name an attribute of the current object,
and the input list is empty.

\begin{indpar}[0.5em]
Add all the values of the current object attribute to
the output list and terminate evaluation of the current
evaluation context.  The attribute may have zero or more values.
\end{indpar}

\item
The remaining arguments are a non-empty string of
atoms that name an attribute of an ancestor of the current
object, and do so for at most one ancestor,
and the input list is empty.

\begin{indpar}[0.5em]
Add all the values of the ancestor's attribute to
the output list and terminate evaluation of the current
evaluation context.  The attribute may have zero or more values.
\end{indpar}

\item
The remaining arguments begin with a non-empty string of
atoms that name an attribute of the current object,
this string is the longest such string in case there are
several that name attributes of the current object,
this string does \underline{not} include all of the
remaining arguments, the input list is empty, and the
named current object attribute has a single value that
is an object.

\begin{indpar}[0.5em]
Remove the attribute name from the beginning of the
remaining arguments (by incrementing the {\tt next}
value in the current context), and make the current
object attribute value the new current object.
\end{indpar}

\item
The remaining arguments begin with a non-empty string of
atoms that name an attribute of an ancestor of the current object,
this string is the longest such string in case there are
several that name attributes of ancestors of the current object,
at most one ancestor of the current object has an attribute named
by this string,
this string does \underline{not} include all of the
remaining arguments, the input list is empty, and the
named ancestor has a single value that
is an object.

\begin{indpar}[0.5em]
Remove the attribute name from the beginning of the
remaining arguments (by incrementing the {\tt next}
value in the current context), and make the ancestor
attribute value the new current object.
\end{indpar}

\item
The remaining arguments begin with a non-empty string of
atoms that name an attribute of the current object,
this string is the longest such string in case there are
several that name attributes of the current object,
and the named current object attribute has a single value that
is a function.

\begin{indpar}[0.5em]
Remove the attribute name from the beginning of the
remaining arguments (by incrementing the {\tt next}
value in the current context), and call the function.

Calling the function consist of pushing a new function evaluation
context into the evaluation stack and pushing a new frame
for the function into the frame stack.  The current context
is the caller context, and the new context is the function context.
The function context has the new frame as its current and initial evaluator,
and that frame has the object whose attribute value is the function was its
only ancestor.  The function context has the body of the function
as its expression to be evaluated.  The function context has the
caller context as its {\tt caller}.

Evaluation steps are then performed until the function context
terminates.  During this the function may read arguments from
its {\tt caller}.

When the function context terminates, further
action depends upon whether there are
remaining arguments in the caller context, and upone
the flags of the function context.  The first of the
following applicable steps are taken:

\begin{indpar}[0.5em]
If the {\tt throw} flag of the function context is on,
the current output value list is replaced by the output value
list of the function context, the {\tt throw} flag of the
caller context is set, and the caller context terminates.
\end{indpar}

\begin{indpar}[0.5em]
If there are no remaining arguments in the caller context,
the output values of the
function context are added to the end of the list of output
values of the caller context, and the caller context terminates.
\end{indpar}

\begin{indpar}[0.5em]
If there are remaining arguments in the caller context,
and the output list of the function context has a single element
that is an object name, that object name becomes the current
evaluator of the caller context.
\end{indpar}

\begin{indpar}[0.5em]
If there are remaining arguments in the caller context,
and the output list of the function context has a single element
that is an abstract function, that function is called from the
caller context.  This is just like the function call above,
except that the ancestors of the new frame are specified by the
abstract function.
\end{indpar}

\end{indpar}

\end{enumerate}

\subsection{The Evaluation Algorithm: OLD}

A CONTEXT is:

\begin{indpar}\begin{verbatim}
FRAME
EXPRESSION
NEXT ITEM INDEX         // of next ITEM in EXPRESSION
STATE, and integer containing the following flags:
    CONDITION CODE:     CC TRUE, CC FALSE, CC NONE
                        // set by current statement
    PREVIOUS CONDITION CODE:    CC TRUE, CC FALSE, CC NONE
                                // as set by previous statement
    SKIP FLAG       // set to skip rest of current statement
    REPEAT FLAG     // set to repeat current statement
    RETURN FLAG     // set to return from current block
    THROW FLAG      // set to throw from current block
PREVIOUS CONTEXT    // contexts are chained like CONS cells
\end{verbatim}\end{indpar}

A FRAME is:

\begin{indpar}\begin{verbatim}
... local variables are like object attributes ...
.object                  // object containing executing code
.caller                  // context of caller of frame
.value                   // assignment rightside argument input
                         // to a function evaluation
PREVIOUS FRAME           // frames are like CONS cells
\end{verbatim}\end{indpar}

Some special values are:

\begin{indpar}\begin{verbatim}
FAILURE                  // Search has failed.
SKIPPED                  // Search, evaluation, etc. has been
                         // skipped because the SKIP flag is
                         // on.
READ-OPERATION           // Read, instead of write, a value.
\end{verbatim}\end{indpar}

\begin{verbatim}

push ( CONTEXT ):
    C = copy of CONTEXT
    C PREVIOUS CONTEXT = CONTEXT
    return C

read ( CONTEXT ):
    if there is no next item in CONTEXT:
        return FAILURE
    V = CONTEXT EXPRESSION ( CONTEXT NEXT ITEM INDEX )
    CONTEXT NEXT ITEM INDEX = CONTEXT NEXT ITEM INDEX + 1
    return V

// In general evaluate returns a VALUE and may change the
// SKIP, REPEAT, RETURN, and THROW flags of the CONTEXT.

// Read the next expression from a context and evaluate that
// expression in the context.
//
evaluate ( CONTEXT ):
    E = read ( CONTEXT )
    return evaluate ( E, CONTEXT )

// Evaluate an expression in a context.
//
evaluate ( EXPRESSION, CONTEXT ):
    if EXPRESSION is a single number atom:
        return EXPRESSION
    else if EXPRESSION is `...' bracketed list:
        return quoted ( EXPRESSION, CONTEXT, 1 )
    else if EXPRESSION is {...} bracketed list:
        return execute block ( EXPRESSION, CONTEXT )
    else:
        C = push CONTEXT
        C EXPRESSION = EXPRESSION
        C NEXT ITEM INDEX = 1
        V = scan ( C, READ-OPERATION )
        CONTEXT STATE = C STATE
        discard C
        return V

quoted ( EXPRESSION, CONTEXT, DEPTH ):
    `Handles depth, e.g., `foo `fum [[x]] [y]'''
    `[[x]] is like LISP ",'," - there is no equivalent of LISP ",,"'
    RESULT = EXPRESSION with list items all removed
             (but same .initiator, etc.)
    foreach ITEM in EXPRESSION:
        if ITEM is not sublist:
            append ITEM to RESULT
            continue
        if ITEM is [...] bracketed:
            D = depth of ITEM [...] brackets
            if DEPTH > D:
                V = quote ( ITEM, CONTEXT, DEPTH - 1 )
                if CONTEXT STATE RETURN FLAG
                   or
                   CONTEXT STATE THROW FLAG
                   or
                   CONTEXT STATE SKIP FLAG
                    return V
                append V to end of RESULT
            else:
                I = ITEM with D-1 square brackets stripped
                V = evaluate ( I, CONTEXT )
                if CONTEXT STATE RETURN FLAG
                   or
                   CONTEXT STATE THROW FLAG
                   or
                   CONTEXT STATE SKIP FLAG
                    return V
                concatenate V at end of RESULT
        else if ITEM is `...' quoted:
            V = quote ( ITEM, CONTEXT, DEPTH + 1 )
            if CONTEXT STATE RETURN FLAG
               or
               CONTEXT STATE THROW FLAG
               or
               CONTEXT STATE SKIP FLAG
                return V
            append V to end of RESULT
        else:
            V = quote ( ITEM, CONTEXT, DEPTH )
            if CONTEXT STATE RETURN FLAG
               or
               CONTEXT STATE THROW FLAG
               or
               CONTEXT STATE SKIP FLAG
                return V
            append V to end of RESULT
    return RESULT

// Evaluate an EXPESSION of the form
//
//	{ STATEMENT ... }
//
// CONTEXT CC and FLAGS are set from last statement
// executed.  Initializes CC to CC NONE and flags are
// to off.
//
execute block ( EXPRESSION, CONTEXT ):
    `EXPRESSION is {...} bracketed'
    `executing {...} clears CC' 
    V = NULL
    CONTEXT STATE CC = CC NONE
    CONTEXT STATE SKIP FLAG = 0
    CONTEXT STATE REPEAT FLAG = 0
    CONTEXT STATE RETURN FLAG = 0
    CONTEXT STATE THROW FLAG = 0
    foreach STATEMENT in EXPRESSION:
        CONTEXT STATE REPEAT FLAG = 1
        while CONTEXT STATE REPEAT FLAG:
            CONTEXT STATE REPEAT FLAG = 0
            CONTEXT STATE PREVIOUS CC = CONTEXT STATE CC
            CONTEXT STATE CC = CC NONE
            V = evaluate ( STATEMENT, CONTEXT )
            CONTEXT STATE SKIP FLAG = 0
            if CONTEXT STATE RETURN FLAG
               or
               CONTEXT STATE THROW FLAG
                break
        CONTEXT STATE REPEAT FLAG = 0
        if CONTEXT STATE RETURN FLAG
           or
           CONTEXT STATE THROW FLAG
            break
    return V

// Scanning reads an attribute name from a context and uses it to
// identify an attribute of a frame or object.  This identification
// process entails searching frames and objects for an attribute
// with the given name.
//
// Then if VALUE is READ-OPERATION, the value of the attribute is
// returned, but if VALUE is something else, the attribute is
// set to VALUE and the VALUE is returned.
//
// If the SKIP flag goes on, SKIPPED is returned.

// Search the frame of a context first, and then search the object
// of that frame.  Return FAILURE if not found.
//
scan ( CONTEXT, VALUE ):
    V = scan object ( CONTEXT, CONTEXT FRAME, VALUE )
    if V != FAILURE: return V
    return scan ( CONTEXT, CONTEXT FRAME .object, VALUE )

// Search an object first, and then the ancestors of the object.
// Return FAILURE if not found.
//
scan ( CONTEXT, OBJECT, VALUE ):
   V = scan object ( CONTEXT, OBJECT, VALUE )
   if V != FAILURE: return V
   for each ANCESTOR of OBJECT:
       V = scan object ( CONTEXT, ANCESTOR, VALUE )
       if V != FAILURE: break
   return V

// Search a particular object.  Return FAILURE if not found.
//
scan object ( CONTEXT, OBJECT, VALUE ):
   if CONTEXT STATE SKIP FLAG:
       return SKIPPED
   if OBJECT has an attribute named `.empty' with value V:
          return scan ( CONTEXT, V, VALUE )
   if CONTEXT NEXT ITEM INDEX > length CONTEXT EXPRESSION:
        if VALUE = READ-OPERATION
            return OBJECT
        else
            return FAILURE

   match names of OBJECT's attributes to next items in
         CONTEXT
   if several match:
      pick the longest match M
      increment CONTEXT NEXT ITEM INDEX to skip matching items
      if VALUE != READ-OPERATION
         and
         CONTEXT NEXT ITEM INDEX > length CONTEXT EXPRESSION:
            set attribute M of OBJECT = VALUE
            return VALUE
      let V = value of matched attribute
      if V is function definition:
           return execute ( CONTEXT, V, OBJECT, VALUE )
      else:
           return scan ( CONTEXT, V, VALUE )
   else if VALUE != READ-OPERATION:
        A = rest of CONTEXT EXPRESSION
        set attribute A of OBJECT = VALUE
        return VALUE
   else:
       return FAILURE

execute ( CONTEXT, FUNCTION, CONTAINER, VALUE ):
    make a new function frame F
    for each argument name N in FUNCTION:
        if N is to be evaluated:
            V = evaluate ( CONTEXT )
        else:
            E = read ( CONTEXT )
            V = (.context. E CONTEXT)
        if CONTEXT STATE THROW SKIP:
                discard F
                return SKIPPED
        if CONTEXT STATE RETURN FLAG
           or
           CONTEXT STATE THROW FLAG:
                discard F
                return V
        make an attribute of F with name N and
             value V
    F .caller = CONTEXT
    F .object = CONTAINER
    F .value = VALUE
    C = push CONTEXT
    C FRAME = F
    if FUNCTION is {...} bracketted list:
        V = execute block ( body of FUNCTION, C )
    else if FUNCTION is internal function:
        V = execute internal FUNCTION ( C )
    C STATE RETURN FLAG = 0
    CONTEXT STATE = C STATE
    discard C,F
    return V

.assign builtin function():
    L = read ( .context )
    V = evaluate ( .context )
    C = push .context
    C EXPRESSION = L
    C NEXT ITEM INDEX = 1
    C STATE = CC NONE and off flags
    V = scan ( C, V )
    discard C
    return V

return builtin function ( V ):
    .context state return flag = 1
    return V

.context. builtin function ( EXPRESSION, CONTEXT ):
    return evaluate ( EXPRESSION, CONTEXT )

try builtin function ():
    V = evaluate ( .context )
    if .context state throw flag:
        .context state throw flag = 0
        return evaluate ( .context )
    else:
        .context state skip flag = 1
        return V

\end{verbatim}



\subsection{Expressions and Subexpressions}

An \key{expression} is just a list of atoms and bracketed
subexpressions:


\subsection{Search}

\ikey{Search}{search} is part of the evaluation process.

Search is invoked with a \key{context}, which is just a list of
objects, and an expression, which is just a list of atoms.
The goal of search is to find an attribute whose name begins the expression.

\section{To Do}
Decapitalization\label{DECAPITALIZATION}

Operator Declaration\label{OPERATOR-DECLARATION}

Temporary Variables\label{TEMPORARY-VARIABLES}

Garbage Collection\label{GARBAGE-COLLECTION}

There must be come way to indicate when a cooked representation is not
immutable.


\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}


